(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 63);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("./vendor");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DOMException = __webpack_require__(29);
var ERR = DOMException;
var isApiWritable = __webpack_require__(42).isApiWritable;

exports.NAMESPACE = {
  HTML: 'http://www.w3.org/1999/xhtml',
  XML: 'http://www.w3.org/XML/1998/namespace',
  XMLNS: 'http://www.w3.org/2000/xmlns/',
  MATHML: 'http://www.w3.org/1998/Math/MathML',
  SVG: 'http://www.w3.org/2000/svg',
  XLINK: 'http://www.w3.org/1999/xlink'
};

//
// Shortcut functions for throwing errors of various types.
//
exports.IndexSizeError = function() { throw new DOMException(ERR.INDEX_SIZE_ERR); };
exports.HierarchyRequestError = function() { throw new DOMException(ERR.HIERARCHY_REQUEST_ERR); };
exports.WrongDocumentError = function() { throw new DOMException(ERR.WRONG_DOCUMENT_ERR); };
exports.InvalidCharacterError = function() { throw new DOMException(ERR.INVALID_CHARACTER_ERR); };
exports.NoModificationAllowedError = function() { throw new DOMException(ERR.NO_MODIFICATION_ALLOWED_ERR); };
exports.NotFoundError = function() { throw new DOMException(ERR.NOT_FOUND_ERR); };
exports.NotSupportedError = function() { throw new DOMException(ERR.NOT_SUPPORTED_ERR); };
exports.InvalidStateError = function() { throw new DOMException(ERR.INVALID_STATE_ERR); };
exports.SyntaxError = function() { throw new DOMException(ERR.SYNTAX_ERR); };
exports.InvalidModificationError = function() { throw new DOMException(ERR.INVALID_MODIFICATION_ERR); };
exports.NamespaceError = function() { throw new DOMException(ERR.NAMESPACE_ERR); };
exports.InvalidAccessError = function() { throw new DOMException(ERR.INVALID_ACCESS_ERR); };
exports.TypeMismatchError = function() { throw new DOMException(ERR.TYPE_MISMATCH_ERR); };
exports.SecurityError = function() { throw new DOMException(ERR.SECURITY_ERR); };
exports.NetworkError = function() { throw new DOMException(ERR.NETWORK_ERR); };
exports.AbortError = function() { throw new DOMException(ERR.ABORT_ERR); };
exports.UrlMismatchError = function() { throw new DOMException(ERR.URL_MISMATCH_ERR); };
exports.QuotaExceededError = function() { throw new DOMException(ERR.QUOTA_EXCEEDED_ERR); };
exports.TimeoutError = function() { throw new DOMException(ERR.TIMEOUT_ERR); };
exports.InvalidNodeTypeError = function() { throw new DOMException(ERR.INVALID_NODE_TYPE_ERR); };
exports.DataCloneError = function() { throw new DOMException(ERR.DATA_CLONE_ERR); };

exports.nyi = function() {
  throw new Error("NotYetImplemented");
};

exports.assert = function(expr, msg) {
  if (!expr) {
    throw new Error("Assertion failed: " + (msg || "") + "\n" + new Error().stack);
  }
};

exports.expose = function(src, c) {
  for (var n in src) {
    Object.defineProperty(c.prototype, n, { value: src[n], writable: isApiWritable });
  }
};

exports.merge = function(a, b) {
  for (var n in b) {
    a[n] = b[n];
  }
};

// Compare two nodes based on their document order. This function is intended
// to be passed to sort(). Assumes that the array being sorted does not
// contain duplicates.  And that all nodes are connected and comparable.
// Clever code by ppk via jeresig.
exports.documentOrder = function(n,m) {
  /* jshint bitwise: false */
  return 3 - (n.compareDocumentPosition(m) & 6);
};

exports.toASCIILowerCase = function(s) {
  return s.replace(/[A-Z]+/g, function(t) { return t.toLowerCase(); });
};


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Node;

var EventTarget = __webpack_require__(32);
var utils = __webpack_require__(1);
var NAMESPACE = utils.NAMESPACE;

// All nodes have a nodeType and an ownerDocument.
// Once inserted, they also have a parentNode.
// This is an abstract class; all nodes in a document are instances
// of a subtype, so all the properties are defined by more specific
// constructors.
function Node() {
}

var ELEMENT_NODE                = Node.ELEMENT_NODE = 1;
var ATTRIBUTE_NODE              = Node.ATTRIBUTE_NODE = 2;
var TEXT_NODE                   = Node.TEXT_NODE = 3;
var CDATA_SECTION_NODE          = Node.CDATA_SECTION_NODE = 4;
var ENTITY_REFERENCE_NODE       = Node.ENTITY_REFERENCE_NODE = 5;
var ENTITY_NODE                 = Node.ENTITY_NODE = 6;
var PROCESSING_INSTRUCTION_NODE = Node.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = Node.COMMENT_NODE = 8;
var DOCUMENT_NODE               = Node.DOCUMENT_NODE = 9;
var DOCUMENT_TYPE_NODE          = Node.DOCUMENT_TYPE_NODE = 10;
var DOCUMENT_FRAGMENT_NODE      = Node.DOCUMENT_FRAGMENT_NODE = 11;
var NOTATION_NODE               = Node.NOTATION_NODE = 12;

var DOCUMENT_POSITION_DISCONNECTED            = Node.DOCUMENT_POSITION_DISCONNECTED = 0x01;
var DOCUMENT_POSITION_PRECEDING               = Node.DOCUMENT_POSITION_PRECEDING = 0x02;
var DOCUMENT_POSITION_FOLLOWING               = Node.DOCUMENT_POSITION_FOLLOWING = 0x04;
var DOCUMENT_POSITION_CONTAINS                = Node.DOCUMENT_POSITION_CONTAINS = 0x08;
var DOCUMENT_POSITION_CONTAINED_BY            = Node.DOCUMENT_POSITION_CONTAINED_BY = 0x10;
var DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;

var hasRawContent = {
  STYLE: true,
  SCRIPT: true,
  XMP: true,
  IFRAME: true,
  NOEMBED: true,
  NOFRAMES: true,
  PLAINTEXT: true
};

var emptyElements = {
  area: true,
  base: true,
  basefont: true,
  bgsound: true,
  br: true,
  col: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

var extraNewLine = {
  /* Removed in https://github.com/whatwg/html/issues/944
  pre: true,
  textarea: true,
  listing: true
  */
};

Node.prototype = Object.create(EventTarget.prototype, {

  // Node that are not inserted into the tree inherit a null parent
  parentNode: { value: null, writable: true },

  // XXX: the baseURI attribute is defined by dom core, but
  // a correct implementation of it requires HTML features, so
  // we'll come back to this later.
  baseURI: { get: utils.nyi },

  parentElement: { get: function() {
    return (this.parentNode && this.parentNode.nodeType===ELEMENT_NODE) ? this.parentNode : null;
  }},

  hasChildNodes: { value: function() {  // Overridden in leaf.js
    return this.childNodes.length > 0;
  }},

  firstChild: { get: function() {
    return this.childNodes.length === 0 ? null : this.childNodes[0];
  }},

  lastChild: { get: function() {
    return this.childNodes.length === 0 ? null : this.childNodes[this.childNodes.length-1];
  }},

  previousSibling: { get: function() {
    if (!this.parentNode) return null;
    var sibs = this.parentNode.childNodes, i = this.index;
    return i === 0 ? null : sibs[i-1];
  }},

  nextSibling: { get: function() {
    if (!this.parentNode) return null;
    var sibs = this.parentNode.childNodes, i = this.index;
    return i+1 === sibs.length ? null : sibs[i+1];
  }},


  _countChildrenOfType: { value: function(type) {
    var sum = 0, nodes = this.childNodes, length = nodes.length, i;
    for (i=0; i<length; i++) {
      if (nodes[i].nodeType === type) sum++;
    }
    return sum;
  }},

  _ensureInsertValid: { value: function _ensureInsertValid(node, child, isPreinsert) {
    var parent = this, i;
    if (!node.nodeType) throw new TypeError('not a node');
    // 1. If parent is not a Document, DocumentFragment, or Element
    // node, throw a HierarchyRequestError.
    switch (parent.nodeType) {
    case DOCUMENT_NODE:
    case DOCUMENT_FRAGMENT_NODE:
    case ELEMENT_NODE:
      break;
    default: utils.HierarchyRequestError();
    }
    // 2. If node is a host-including inclusive ancestor of parent,
    // throw a HierarchyRequestError.
    if (node.isAncestor(parent)) utils.HierarchyRequestError();
    // 3. If child is not null and its parent is not parent, then
    // throw a NotFoundError. (replaceChild omits the 'child is not null'
    // and throws a TypeError here if child is null.)
    if (child !== null || !isPreinsert) {
      if (child.parentNode !== parent) utils.NotFoundError();
    }
    // 4. If node is not a DocumentFragment, DocumentType, Element,
    // Text, ProcessingInstruction, or Comment node, throw a
    // HierarchyRequestError.
    switch (node.nodeType) {
    case DOCUMENT_FRAGMENT_NODE:
    case DOCUMENT_TYPE_NODE:
    case ELEMENT_NODE:
    case TEXT_NODE:
    case PROCESSING_INSTRUCTION_NODE:
    case COMMENT_NODE:
      break;
    default: utils.HierarchyRequestError();
    }
    // 5. If either node is a Text node and parent is a document, or
    // node is a doctype and parent is not a document, throw a
    // HierarchyRequestError.
    // 6. If parent is a document, and any of the statements below, switched
    // on node, are true, throw a HierarchyRequestError.
    if (parent.nodeType === DOCUMENT_NODE) {
      switch (node.nodeType) {
      case TEXT_NODE:
        utils.HierarchyRequestError();
        break;
      case DOCUMENT_FRAGMENT_NODE:
        // 6a1. If node has more than one element child or has a Text
        // node child.
        if (node._countChildrenOfType(TEXT_NODE) > 0)
          utils.HierarchyRequestError();
        switch (node._countChildrenOfType(ELEMENT_NODE)) {
        case 0:
          break;
        case 1:
          // 6a2. Otherwise, if node has one element child and either
          // parent has an element child, child is a doctype, or child
          // is not null and a doctype is following child. [preinsert]
          // 6a2. Otherwise, if node has one element child and either
          // parent has an element child that is not child or a
          // doctype is following child. [replaceWith]
          if (child !== null /* always true here for replaceWith */) {
            if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE)
              utils.HierarchyRequestError();
            for (i=parent.childNodes.length-1; i>=0; i--) {
              if (parent.childNodes[i] === child) break;
              if (parent.childNodes[i].nodeType === DOCUMENT_TYPE_NODE)
                utils.HierarchyRequestError();
            }
          }
          i = parent._countChildrenOfType(ELEMENT_NODE);
          if (isPreinsert) {
            // "parent has an element child"
            if (i > 0)
              utils.HierarchyRequestError();
          } else {
            // "parent has an element child that is not child"
            if (i > 1 || (i === 1 && child.nodeType !== ELEMENT_NODE))
              utils.HierarchyRequestError();
          }
          break;
        default: // 6a1, continued. (more than one Element child)
          utils.HierarchyRequestError();
        }
        break;
      case ELEMENT_NODE:
        // 6b. parent has an element child, child is a doctype, or
        // child is not null and a doctype is following child. [preinsert]
        // 6b. parent has an element child that is not child or a
        // doctype is following child. [replaceWith]
        if (child !== null /* always true here for replaceWith */) {
          if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE)
            utils.HierarchyRequestError();
          for (i=parent.childNodes.length-1; i>=0; i--) {
            if (parent.childNodes[i] === child) break;
            if (parent.childNodes[i].nodeType === DOCUMENT_TYPE_NODE)
              utils.HierarchyRequestError();
          }
        }
        i = parent._countChildrenOfType(ELEMENT_NODE);
        if (isPreinsert) {
          // "parent has an element child"
          if (i > 0)
            utils.HierarchyRequestError();
        } else {
          // "parent has an element child that is not child"
          if (i > 1 || (i === 1 && child.nodeType !== ELEMENT_NODE))
            utils.HierarchyRequestError();
        }
        break;
      case DOCUMENT_TYPE_NODE:
        // 6c. parent has a doctype child, child is non-null and an
        // element is preceding child, or child is null and parent has
        // an element child. [preinsert]
        // 6c. parent has a doctype child that is not child, or an
        // element is preceding child. [replaceWith]
        if (child === null) {
          if (parent._countChildrenOfType(ELEMENT_NODE))
            utils.HierarchyRequestError();
        } else {
          // child is always non-null for [replaceWith] case
          for (i=0; i<parent.childNodes.length; i++) {
            if (parent.childNodes[i] === child) break;
            if (parent.childNodes[i].nodeType === ELEMENT_NODE)
              utils.HierarchyRequestError();
          }
        }
        i = parent._countChildrenOfType(DOCUMENT_TYPE_NODE);
        if (isPreinsert) {
          // "parent has an doctype child"
          if (i > 0)
            utils.HierarchyRequestError();
        } else {
          // "parent has an doctype child that is not child"
          if (i > 1 || (i === 1 && child.nodeType !== DOCUMENT_TYPE_NODE))
            utils.HierarchyRequestError();
        }
        break;
      }
    } else {
      // 5, continued: (parent is not a document)
      if (node.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();
    }
  }},

  insertBefore: { value: function insertBefore(node, child) {
    var parent = this;
    // 1. Ensure pre-insertion validity
    parent._ensureInsertValid(node, child, true);
    // 2. Let reference child be child.
    var refChild = child;
    // 3. If reference child is node, set it to node's next sibling
    if (refChild === node) { refChild = node.nextSibling; }
    // 4. Adopt node into parent's node document.
    parent.doc.adoptNode(node);
    // 5. Insert node into parent before reference child.
    if (refChild === null) {
      parent._appendChild(node);
    } else {
      node.insert(parent, refChild.index);
    }
    // 6. Return node
    return node;
  }},


  appendChild: { value: function(child) {
    // This invokes _appendChild after doing validity checks.
    return this.insertBefore(child, null);
  }},

  _appendChild: { value: function(child) {
    child.insert(this, this.childNodes.length);
    return child;
  }},

  removeChild: { value: function removeChild(child) {
    var parent = this;
    if (!child.nodeType) throw new TypeError('not a node');
    if (child.parentNode !== parent) utils.NotFoundError();
    child.remove();
    return child;
  }},

  // To replace a `child` with `node` within a `parent` (this)
  replaceChild: { value: function replaceChild(node, child) {
    var parent = this;
    // Ensure validity (slight differences from pre-insertion check)
    parent._ensureInsertValid(node, child, false);
    // Adopt node into parent's node document.
    if (node.doc !== parent.doc) {
      // XXX adoptNode has side-effect of removing node from its parent
      // and generating a mutation event, thus causing the _insertOrReplace
      // to generate two deletes and an insert instead of a 'move'
      // event.  It looks like the new MutationObserver stuff avoids
      // this problem, but for now let's only adopt (ie, remove `node`
      // from its parent) here if we need to.
      parent.doc.adoptNode(node);
    }
    // Do the replace.
    node._insertOrReplace(parent, child.index, true);
    return child;
  }},

  // See: http://ejohn.org/blog/comparing-document-position/
  contains: { value: function contains(node) {
    if (node === null) { return false; }
    if (this === node) { return true; /* inclusive descendant */ }
    /* jshint bitwise: false */
    return (this.compareDocumentPosition(node) &
            DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  }},

  compareDocumentPosition: { value: function compareDocumentPosition(that){
    // Basic algorithm for finding the relative position of two nodes.
    // Make a list the ancestors of each node, starting with the
    // document element and proceeding down to the nodes themselves.
    // Then, loop through the lists, looking for the first element
    // that differs.  The order of those two elements give the
    // order of their descendant nodes.  Or, if one list is a prefix
    // of the other one, then that node contains the other.

    if (this === that) return 0;

    // If they're not owned by the same document or if one is rooted
    // and one is not, then they're disconnected.
    if (this.doc !== that.doc ||
      this.rooted !== that.rooted)
      return (DOCUMENT_POSITION_DISCONNECTED +
          DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC);

    // Get arrays of ancestors for this and that
    var these = [], those = [];
    for(var n = this; n !== null; n = n.parentNode) these.push(n);
    for(n = that; n !== null; n = n.parentNode) those.push(n);
    these.reverse();  // So we start with the outermost
    those.reverse();

    if (these[0] !== those[0]) // No common ancestor
      return (DOCUMENT_POSITION_DISCONNECTED +
          DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC);

    n = Math.min(these.length, those.length);
    for(var i = 1; i < n; i++) {
      if (these[i] !== those[i]) {
        // We found two different ancestors, so compare
        // their positions
        if (these[i].index < those[i].index)
          return DOCUMENT_POSITION_FOLLOWING;
        else
          return DOCUMENT_POSITION_PRECEDING;
      }
    }

    // If we get to here, then one of the nodes (the one with the
    // shorter list of ancestors) contains the other one.
    if (these.length < those.length)
      return (DOCUMENT_POSITION_FOLLOWING +
          DOCUMENT_POSITION_CONTAINED_BY);
    else
      return (DOCUMENT_POSITION_PRECEDING +
          DOCUMENT_POSITION_CONTAINS);
  }},

  isSameNode: {value : function isSameNode(node) {
    return this === node;
  }},


  // This method implements the generic parts of node equality testing
  // and defers to the (non-recursive) type-specific isEqual() method
  // defined by subclasses
  isEqualNode: { value: function isEqualNode(node) {
    if (!node) return false;
    if (node.nodeType !== this.nodeType) return false;

    // Check for same number of children
    // Check for children this way because it is more efficient
    // for childless leaf nodes.
    var n; // number of child nodes
    if (!this.firstChild) {
      n = 0;
      if (node.firstChild) return false;
    }
    else {
      n = this.childNodes.length;
      if (node.childNodes.length !== n) return false;
    }

    // Check type-specific properties for equality
    if (!this.isEqual(node)) return false;

    // Now check children for equality
    for(var i = 0; i < n; i++) {
      var c1 = this.childNodes[i], c2 = node.childNodes[i];
      if (!c1.isEqualNode(c2)) return false;
    }

    return true;
  }},

  // This method delegates shallow cloning to a clone() method
  // that each concrete subclass must implement
  cloneNode: { value: function(deep) {
    // Clone this node
    var clone = this.clone();

    // Handle the recursive case if necessary
    if (deep && this.firstChild) {
      for(var i = 0, n = this.childNodes.length; i < n; i++) {
        clone._appendChild(this.childNodes[i].cloneNode(true));
      }
    }

    return clone;
  }},

  lookupPrefix: { value: function lookupPrefix(ns) {
    var e;
    if (ns === '') return null;
    switch(this.nodeType) {
    case ELEMENT_NODE:
      return this.locateNamespacePrefix(ns);
    case DOCUMENT_NODE:
      e = this.documentElement;
      return e ? e.locateNamespacePrefix(ns) : null;
    case DOCUMENT_TYPE_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      return null;
    default:
      e = this.parentElement;
      return e ? e.locateNamespacePrefix(ns) : null;
    }
  }},


  lookupNamespaceURI: {value: function lookupNamespaceURI(prefix) {
    var e;
    switch(this.nodeType) {
    case ELEMENT_NODE:
      return this.locateNamespace(prefix);
    case DOCUMENT_NODE:
      e = this.documentElement;
      return e ? e.locateNamespace(prefix) : null;
    case DOCUMENT_TYPE_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      return null;
    default:
      e = this.parentElement;
      return e ? e.locateNamespace(prefix) : null;
    }
  }},

  isDefaultNamespace: { value: function isDefaultNamespace(ns) {
    var defaultns = this.lookupNamespaceURI(null);
    if (defaultns === null) defaultns = '';
    return ns === defaultns;
  }},

  // Utility methods for nodes.  Not part of the DOM

  // Return the index of this node in its parent.
  // Throw if no parent, or if this node is not a child of its parent
  index: { get: function() {
    utils.assert(this.parentNode);
    var kids = this.parentNode.childNodes;
    if (this._index === undefined || kids[this._index] !== this) {
      // Ensure that we don't have an O(N^2) blowup if none of the
      // kids have defined indices yet and we're traversing via
      // nextSibling or prevSibling
      for (var i=0; i<kids.length; i++) {
        kids[i]._index = i;
      }
      utils.assert(kids[this._index] === this);
    }
    return this._index;
  }},

  // Return true if this node is equal to or is an ancestor of that node
  // Note that nodes are considered to be ancestors of themselves
  isAncestor: { value: function(that) {
    // If they belong to different documents, then they're unrelated.
    if (this.doc !== that.doc) return false;
    // If one is rooted and one isn't then they're not related
    if (this.rooted !== that.rooted) return false;

    // Otherwise check by traversing the parentNode chain
    for(var e = that; e; e = e.parentNode) {
      if (e === this) return true;
    }
    return false;
  }},

  // DOMINO Changed the behavior to conform with the specs. See:
  // https://groups.google.com/d/topic/mozilla.dev.platform/77sIYcpdDmc/discussion
  ensureSameDoc: { value: function(that) {
    if (that.ownerDocument === null) {
      that.ownerDocument = this.doc;
    }
    else if(that.ownerDocument !== this.doc) {
      utils.WrongDocumentError();
    }
  }},

  // Remove all of this node's children.  This is a minor
  // optimization that only calls modify() once.
  removeChildren: { value: function removeChildren() {
    var n = this.childNodes.length;
    if (n) {
      var root = this.rooted ? this.ownerDocument : null;
      for(var i = 0; i < n; i++) {
        if (root) root.mutateRemove(this.childNodes[i]);
        this.childNodes[i].parentNode = null;
      }
      this.childNodes.length = 0; // Forget all children
      this.modify();              // Update last modified type once only
    }
  }},

  // Insert this node as a child of parent at the specified index,
  // firing mutation events as necessary
  insert: { value: function insert(parent, index) {
    this._insertOrReplace(parent, index, false);
  }},

  // Insert this node as a child of parent at the specified index,
  // or replace the specified child with this node, firing mutation events as
  // necessary
  _insertOrReplace: { value: function _insertOrReplace(parent, index, isReplace) {
    var child = this;
    var kids = parent.childNodes;

    if (child.nodeType === DOCUMENT_FRAGMENT_NODE && child.rooted) {
      utils.HierarchyRequestError();
    }

    // If we are already a child of the specified parent, then
    // the index may have to be adjusted.
    if (child.parentNode === parent) {
      var currentIndex = child.index;
      // If we're not moving the node, we're done now
      // XXX: or do DOM mutation events still have to be fired?
      if (currentIndex === index) return;

      // If the child is before the spot it is to be inserted at,
      // then when it is removed, the index of that spot will be
      // reduced.
      if (currentIndex < index) index--;
    }

    // Delete the old child
    if (isReplace) {
      var oldChild = parent.childNodes[index];
      if (oldChild.rooted) oldChild.doc.mutateRemove(oldChild);
      oldChild.parentNode = null;
    }

    // If both the child and the parent are rooted, then we want to
    // transplant the child without uprooting and rerooting it.
    if (child.rooted && parent.rooted) {
      // Remove the child from its current position in the tree
      // without calling remove(), since we don't want to uproot it.
      var curpar = child.parentNode;
      curpar.childNodes.splice(child.index, 1);
      curpar.modify();

      // And insert it as a child of its new parent
      child.parentNode = parent;
      if (isReplace) {
        kids[index] = child;
      } else {
        kids.splice(index, 0, child);
      }
      child._index = index;
      parent.modify();

      // Generate a move mutation event
      parent.doc.mutateMove(child);
    }
    else {
      if (child.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var spliceArgs = [index, isReplace ? 1 : 0];
        var i;
        for (i = 0; i < child.childNodes.length; i++) {
          var fragChild = child.childNodes[i];
          spliceArgs.push(fragChild);
          fragChild.parentNode = parent;
          fragChild._index = index + i;
        }
        // Remove all nodes from the document fragment
        child.childNodes.length = 0;
        // Add all nodes to the new parent, overwriting the old child
        kids.splice.apply(kids, spliceArgs);
        // Call the mutation handlers
        // Use spliceArgs since the original array has been destroyed. The
        // liveness guarantee requires us to clone the array so that
        // references to the childNodes of the DocumentFragment will be empty
        // when the insertion handlers are called.
        if (parent.rooted) {
          parent.modify();
          for (i = 2; i < spliceArgs.length; i++) {
            parent.doc.mutateInsert(spliceArgs[i]);
          }
        }
      }
      else {
        // If the child already has a parent, it needs to be
        // removed from that parent, which may also uproot it
        if (child.parentNode) child.remove();

        // Now insert the child into the parent's array of children
        child.parentNode = parent;
        if (isReplace) {
          kids[index] = child;
        } else {
          kids.splice(index, 0, child);
        }
        child._index = index;

        // And root the child if necessary
        if (parent.rooted) {
          parent.modify();
          parent.doc.mutateInsert(child);
        }
      }
    }
  }},


  // Return the lastModTime value for this node. (For use as a
  // cache invalidation mechanism. If the node does not already
  // have one, initialize it from the owner document's modclock
  // property. (Note that modclock does not return the actual
  // time; it is simply a counter incremented on each document
  // modification)
  lastModTime: { get: function() {
    if (!this._lastModTime) {
      this._lastModTime = this.doc.modclock;
    }
    return this._lastModTime;
  }},

  // Increment the owner document's modclock and use the new
  // value to update the lastModTime value for this node and
  // all of its ancestors. Nodes that have never had their
  // lastModTime value queried do not need to have a
  // lastModTime property set on them since there is no
  // previously queried value to ever compare the new value
  // against, so only update nodes that already have a
  // _lastModTime property.
  modify: { value: function() {
    if (this.doc.modclock) { // Skip while doc.modclock == 0
      var time = ++this.doc.modclock;
      for(var n = this; n; n = n.parentElement) {
        if (n._lastModTime) {
          n._lastModTime = time;
        }
      }
    }
  }},

  // This attribute is not part of the DOM but is quite helpful.
  // It returns the document with which a node is associated.  Usually
  // this is the ownerDocument. But ownerDocument is null for the
  // document object itself, so this is a handy way to get the document
  // regardless of the node type
  doc: { get: function() {
    return this.ownerDocument || this;
  }},


  // If the node has a nid (node id), then it is rooted in a document
  rooted: { get: function() {
    return !!this._nid;
  }},

  normalize: { value: function() {
    for (var i=0; i < this.childNodes.length; i++) {
      var child = this.childNodes[i];

      if (child.normalize) {
        child.normalize();
      }

      if (child.nodeType !== Node.TEXT_NODE) {
        continue;
      }

      if (child.nodeValue === "") {
        this.removeChild(child);
        i--;
        continue;
      }

      if (i) {
        var prevChild = this.childNodes[i-1];

        if (prevChild.nodeType === Node.TEXT_NODE) {
          // remove the child and decrement i
          prevChild.appendData(child.nodeValue);

          this.removeChild(child);
          i--;
        }
      }
    }
  }},

  // Convert the children of a node to an HTML string.
  // This is used by the innerHTML getter
  // The serialization spec is at:
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#serializing-html-fragments
  serialize: { value: function() {
    var s = '';
    for(var i = 0, n = this.childNodes.length; i < n; i++) {
      var kid = this.childNodes[i];
      switch(kid.nodeType) {
      case 1: //ELEMENT_NODE
        var ns = kid.namespaceURI;
        var html = ns === NAMESPACE.HTML;
        var tagname = (html || ns === NAMESPACE.SVG || ns === NAMESPACE.MATHML) ? kid.localName : kid.tagName;

        s += '<' + tagname;

        for(var j = 0, k = kid._numattrs; j < k; j++) {
          var a = kid._attr(j);
          s += ' ' + attrname(a);
          if (a.value !== undefined) s += '="' + escapeAttr(a.value) + '"';
        }
        s += '>';

        if (!(html && emptyElements[tagname])) {
          var ss = kid.serialize();
          if (html && extraNewLine[tagname] && ss.charAt(0)==='\n') s += '\n';
          // Serialize children and add end tag for all others
          s += ss;
          s += '</' + tagname + '>';
        }
        break;
      case 3: //TEXT_NODE
      case 4: //CDATA_SECTION_NODE
        var parenttag;
        if (this.nodeType === ELEMENT_NODE &&
          this.namespaceURI === NAMESPACE.HTML)
          parenttag = this.tagName;
        else
          parenttag = '';

        if (hasRawContent[parenttag] ||
            (parenttag==='NOSCRIPT' && this.ownerDocument._scripting_enabled)) {
          s += kid.data;
        } else {
          s += escape(kid.data);
        }
        break;
      case 8: //COMMENT_NODE
        s += '<!--' + kid.data + '-->';
        break;
      case 7: //PROCESSING_INSTRUCTION_NODE
        s += '<?' + kid.target + ' ' + kid.data + '?>';
        break;
      case 10: //DOCUMENT_TYPE_NODE
        s += '<!DOCTYPE ' + kid.name;

        if (false) {
          // Latest HTML serialization spec omits the public/system ID
          if (kid.publicID) {
            s += ' PUBLIC "' + kid.publicId + '"';
          }

          if (kid.systemId) {
            s += ' "' + kid.systemId + '"';
          }
        }

        s += '>';
        break;
      default:
        utils.InvalidState();
      }
    }

    return s;
  }},

  // mirror node type properties in the prototype, so they are present
  // in instances of Node (and subclasses)
  ELEMENT_NODE:                { value: ELEMENT_NODE },
  ATTRIBUTE_NODE:              { value: ATTRIBUTE_NODE },
  TEXT_NODE:                   { value: TEXT_NODE },
  CDATA_SECTION_NODE:          { value: CDATA_SECTION_NODE },
  ENTITY_REFERENCE_NODE:       { value: ENTITY_REFERENCE_NODE },
  ENTITY_NODE:                 { value: ENTITY_NODE },
  PROCESSING_INSTRUCTION_NODE: { value: PROCESSING_INSTRUCTION_NODE },
  COMMENT_NODE:                { value: COMMENT_NODE },
  DOCUMENT_NODE:               { value: DOCUMENT_NODE },
  DOCUMENT_TYPE_NODE:          { value: DOCUMENT_TYPE_NODE },
  DOCUMENT_FRAGMENT_NODE:      { value: DOCUMENT_FRAGMENT_NODE },
  NOTATION_NODE:               { value: NOTATION_NODE }
});

function escape(s) {
  return s.replace(/[&<>\u00A0]/g, function(c) {
    switch(c) {
    case '&': return '&amp;';
    case '<': return '&lt;';
    case '>': return '&gt;';
    case '\u00A0': return '&nbsp;';
    }
  });
}

function escapeAttr(s) {
  var toEscape = /[&"\u00A0]/g;
  if (!toEscape.test(s)) {
      // nothing to do, fast path
      return s;
  } else {
      return s.replace(toEscape, function(c) {
        switch(c) {
        case '&': return '&amp;';
        case '"': return '&quot;';
        case '\u00A0': return '&nbsp;';
        }
      });
  }
}

function attrname(a) {
  var ns = a.namespaceURI;
  if (!ns)
    return a.localName;
  if (ns === NAMESPACE.XML)
    return 'xml:' + a.localName;
  if (ns === NAMESPACE.XLINK)
    return 'xlink:' + a.localName;

  if (ns === NAMESPACE.XMLNS) {
    if (a.localName === 'xmlns') return 'xmlns';
    else return 'xmlns:' + a.localName;
  }
  return a.name;
}


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(1);

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Element;

var xml = __webpack_require__(20);
var utils = __webpack_require__(1);
var NAMESPACE = utils.NAMESPACE;
var attributes = __webpack_require__(41);
var Node = __webpack_require__(2);
var NodeList = __webpack_require__(9);
var FilteredElementList = __webpack_require__(68);
var DOMTokenList = __webpack_require__(30);
var select = __webpack_require__(19);
var ChildNode = __webpack_require__(12);
var NonDocumentTypeChildNode = __webpack_require__(36);

function Element(doc, localName, namespaceURI, prefix) {
  this.nodeType = Node.ELEMENT_NODE;
  this.ownerDocument = doc;
  this.localName = localName;
  this.namespaceURI = namespaceURI;
  this.prefix = prefix;

  this.tagName = (prefix !== null) ? prefix + ':' + localName : localName;

  if (namespaceURI !== NAMESPACE.HTML || (!namespaceURI && !doc.isHTML)) this.isHTML = false;

  if (this.isHTML) this.tagName = this.tagName.toUpperCase();

  this.childNodes = new NodeList();

  // These properties maintain the set of attributes
  this._attrsByQName = Object.create(null); // The qname->Attr map
  this._attrsByLName = Object.create(null); // The ns|lname->Attr map
  this._attrKeys = [];     // attr index -> ns|lname

  this._index = undefined;
}

function recursiveGetText(node, a) {
  if (node.nodeType === Node.TEXT_NODE) {
    a.push(node._data);
  }
  else {
    for(var i = 0, n = node.childNodes.length;  i < n; i++)
      recursiveGetText(node.childNodes[i], a);
  }
}

Element.prototype = Object.create(Node.prototype, {
  nodeName: { get: function() { return this.tagName; }},
  nodeValue: {
    get: function() {
      return null;
    },
    set: function() {}
  },
  textContent: {
    get: function() {
      var strings = [];
      recursiveGetText(this, strings);
      return strings.join('');
    },
    set: function(newtext) {
      this.removeChildren();
      if (newtext !== null && newtext !== '') {
        this._appendChild(this.ownerDocument.createTextNode(newtext));
      }
    }
  },
  innerHTML: {
    get: function() {
      return this.serialize();
    },
    set: utils.nyi
  },
  outerHTML: {
    get: function() {
      // "the attribute must return the result of running the HTML fragment
      // serialization algorithm on a fictional node whose only child is
      // the context object"
      var fictional = {
        childNodes: [ this ],
        nodeType: 0
      };
      return Node.prototype.serialize.call(fictional);
    },
    set: utils.nyi
  },

  children: { get: function() {
    if (!this._children) {
      this._children = new ChildrenCollection(this);
    }
    return this._children;
  }},

  attributes: { get: function() {
    if (!this._attributes) {
      this._attributes = new AttributesArray(this);
    }
    return this._attributes;
  }},


  firstElementChild: { get: function() {
    var kids = this.childNodes;
    for(var i = 0, n = kids.length; i < n; i++) {
      if (kids[i].nodeType === Node.ELEMENT_NODE) return kids[i];
    }
    return null;
  }},

  lastElementChild: { get: function() {
    var kids = this.childNodes;
    for(var i = kids.length-1; i >= 0; i--) {
      if (kids[i].nodeType === Node.ELEMENT_NODE) return kids[i];
    }
    return null;
  }},

  childElementCount: { get: function() {
    return this.children.length;
  }},


  // Return the next element, in source order, after this one or
  // null if there are no more.  If root element is specified,
  // then don't traverse beyond its subtree.
  //
  // This is not a DOM method, but is convenient for
  // lazy traversals of the tree.
  nextElement: { value: function(root) {
    if (!root) root = this.ownerDocument.documentElement;
    var next = this.firstElementChild;
    if (!next) {
      // don't use sibling if we're at root
      if (this===root) return null;
      next = this.nextElementSibling;
    }
    if (next) return next;

    // If we can't go down or across, then we have to go up
    // and across to the parent sibling or another ancestor's
    // sibling.  Be careful, though: if we reach the root
    // element, or if we reach the documentElement, then
    // the traversal ends.
    for(var parent = this.parentElement;
      parent && parent !== root;
      parent = parent.parentElement) {

      next = parent.nextElementSibling;
      if (next) return next;
    }

    return null;
  }},

  // XXX:
  // Tests are currently failing for this function.
  // Awaiting resolution of:
  // http://lists.w3.org/Archives/Public/www-dom/2011JulSep/0016.html
  getElementsByTagName: { value: function getElementsByTagName(lname) {
    var filter;
    if (!lname) return new NodeList();
    if (lname === '*')
      filter = function() { return true; };
    else if (this.isHTML)
      filter = htmlLocalNameElementFilter(lname);
    else
      filter = localNameElementFilter(lname);

    return new FilteredElementList(this, filter);
  }},

  getElementsByTagNameNS: { value: function getElementsByTagNameNS(ns, lname){
    var filter;
    if (ns === '*' && lname === '*')
      filter = function() { return true; };
    else if (ns === '*')
      filter = localNameElementFilter(lname);
    else if (lname === '*')
      filter = namespaceElementFilter(ns);
    else
      filter = namespaceLocalNameElementFilter(ns, lname);

    return new FilteredElementList(this, filter);
  }},

  getElementsByClassName: { value: function getElementsByClassName(names){
    names = String(names).trim();
    if (names === '') {
      var result = new NodeList(); // Empty node list
      return result;
    }
    names = names.split(/\s+/);  // Split on spaces
    return new FilteredElementList(this, classNamesElementFilter(names));
  }},

  getElementsByName: { value: function getElementsByName(name) {
    return new FilteredElementList(this, elementNameFilter(String(name)));
  }},

  // Overwritten in the constructor if not in the HTML namespace
  isHTML: { value: true, writable: true },

  // Utility methods used by the public API methods above
  clone: { value: function clone() {
    var e;

    // XXX:
    // Modify this to use the constructor directly or
    // avoid error checking in some other way. In case we try
    // to clone an invalid node that the parser inserted.
    //
    if (this.namespaceURI !== NAMESPACE.HTML || this.prefix)
      e = this.ownerDocument.createElementNS(this.namespaceURI,
                           this.tagName);
    else
      e = this.ownerDocument.createElement(this.localName);

    for(var i = 0, n = this._attrKeys.length; i < n; i++) {
      var lname = this._attrKeys[i];
      var a = this._attrsByLName[lname];
      var b = new Attr(e, a.localName, a.prefix, a.namespaceURI);
      b.data = a.data;
      e._attrsByLName[lname] = b;
      e._addQName(b);
    }
    e._attrKeys = this._attrKeys.concat();

    return e;
  }},

  isEqual: { value: function isEqual(that) {
    if (this.localName !== that.localName ||
      this.namespaceURI !== that.namespaceURI ||
      this.prefix !== that.prefix ||
      this._numattrs !== that._numattrs)
      return false;

    // Compare the sets of attributes, ignoring order
    // and ignoring attribute prefixes.
    for(var i = 0, n = this._numattrs; i < n; i++) {
      var a = this._attr(i);
      if (!that.hasAttributeNS(a.namespaceURI, a.localName))
        return false;
      if (that.getAttributeNS(a.namespaceURI,a.localName) !== a.value)
        return false;
    }

    return true;
  }},

  // This is the 'locate a namespace prefix' algorithm from the
  // DOMCore specification.  It is used by Node.lookupPrefix()
  locateNamespacePrefix: { value: function locateNamespacePrefix(ns) {
    if (this.namespaceURI === ns && this.prefix !== null)
      return this.prefix;

    for(var i = 0, n = this._numattrs; i < n; i++) {
      var a = this._attr(i);
      if (a.prefix === 'xmlns' && a.value === ns)
        return a.localName;
    }

    var parent = this.parentElement;
    return parent ? parent.locateNamespacePrefix(ns) : null;
  }},

  // This is the 'locate a namespace' algorithm for Element nodes
  // from the DOM Core spec.  It is used by Node.lookupNamespaceURI
  locateNamespace: { value: function locateNamespace(prefix) {
    if (this.prefix === prefix && this.namespaceURI !== null)
      return this.namespaceURI;

    for(var i = 0, n = this._numattrs; i < n; i++) {
      var a = this._attr(i);
      if ((a.prefix === 'xmlns' && a.localName === prefix) ||
        (a.prefix === null && a.localName === 'xmlns')) {
        return a.value || null;
      }
    }

    var parent = this.parentElement;
    return parent ? parent.locateNamespace(prefix) : null;
  }},

  //
  // Attribute handling methods and utilities
  //

  /*
   * Attributes in the DOM are tricky:
   *
   * - there are the 8 basic get/set/has/removeAttribute{NS} methods
   *
   * - but many HTML attributes are also 'reflected' through IDL
   *   attributes which means that they can be queried and set through
   *   regular properties of the element.  There is just one attribute
   *   value, but two ways to get and set it.
   *
   * - Different HTML element types have different sets of reflected
     attributes.
   *
   * - attributes can also be queried and set through the .attributes
   *   property of an element.  This property behaves like an array of
   *   Attr objects.  The value property of each Attr is writeable, so
   *   this is a third way to read and write attributes.
   *
   * - for efficiency, we really want to store attributes in some kind
   *   of name->attr map.  But the attributes[] array is an array, not a
   *   map, which is kind of unnatural.
   *
   * - When using namespaces and prefixes, and mixing the NS methods
   *   with the non-NS methods, it is apparently actually possible for
   *   an attributes[] array to have more than one attribute with the
   *   same qualified name.  And certain methods must operate on only
   *   the first attribute with such a name.  So for these methods, an
   *   inefficient array-like data structure would be easier to
   *   implement.
   *
   * - The attributes[] array is live, not a snapshot, so changes to the
   *   attributes must be immediately visible through existing arrays.
   *
   * - When attributes are queried and set through IDL properties
   *   (instead of the get/setAttributes() method or the attributes[]
   *   array) they may be subject to type conversions, URL
   *   normalization, etc., so some extra processing is required in that
   *   case.
   *
   * - But access through IDL properties is probably the most common
   *   case, so we'd like that to be as fast as possible.
   *
   * - We can't just store attribute values in their parsed idl form,
   *   because setAttribute() has to return whatever string is passed to
   *   getAttribute even if it is not a legal, parseable value. So
   *   attribute values must be stored in unparsed string form.
   *
   * - We need to be able to send change notifications or mutation
   *   events of some sort to the renderer whenever an attribute value
   *   changes, regardless of the way in which it changes.
   *
   * - Some attributes, such as id and class affect other parts of the
   *   DOM API, like getElementById and getElementsByClassName and so
   *   for efficiency, we need to specially track changes to these
   *   special attributes.
   *
   * - Some attributes like class have different names (className) when
   *   reflected.
   *
   * - Attributes whose names begin with the string 'data-' are treated
     specially.
   *
   * - Reflected attributes that have a boolean type in IDL have special
   *   behavior: setting them to false (in IDL) is the same as removing
   *   them with removeAttribute()
   *
   * - numeric attributes (like HTMLElement.tabIndex) can have default
   *   values that must be returned by the idl getter even if the
   *   content attribute does not exist. (The default tabIndex value
   *   actually varies based on the type of the element, so that is a
   *   tricky one).
   *
   * See
   * http://www.whatwg.org/specs/web-apps/current-work/multipage/urls.html#reflect
   * for rules on how attributes are reflected.
   *
   */

  getAttribute: { value: function getAttribute(qname) {
    if (this.isHTML) qname = utils.toASCIILowerCase(qname);
    var attr = this._attrsByQName[qname];
    if (!attr) return null;

    if (Array.isArray(attr))  // If there is more than one
      attr = attr[0];         // use the first

    return attr.value;
  }},

  getAttributeNS: { value: function getAttributeNS(ns, lname) {
    var attr = this._attrsByLName[(ns === null ? '' : ns) + '|' + lname];
    return attr ? attr.value : null;
  }},

  hasAttribute: { value: function hasAttribute(qname) {
    if (this.isHTML) qname = utils.toASCIILowerCase(qname);
    return this._attrsByQName[qname] !== undefined;
  }},

  hasAttributeNS: { value: function hasAttributeNS(ns, lname) {
    var key = (ns === null ? '' : ns) + '|' + lname;
    return this._attrsByLName[key] !== undefined;
  }},

  // Set the attribute without error checking. The parser uses this.
  _setAttribute: { value: function _setAttribute(qname, value) {
    // XXX: the spec says that this next search should be done
    // on the local name, but I think that is an error.
    // email pending on www-dom about it.
    var attr = this._attrsByQName[qname];
    var isnew;
    if (!attr) {
      attr = this._newattr(qname);
      isnew = true;
    }
    else {
      if (Array.isArray(attr)) attr = attr[0];
    }

    // Now set the attribute value on the new or existing Attr object.
    // The Attr.value setter method handles mutation events, etc.
    attr.value = value;
    if (this._attributes) this._attributes[qname] = attr;
    if (isnew && this._newattrhook) this._newattrhook(qname, value);
  }},

  // Check for errors, and then set the attribute
  setAttribute: { value: function setAttribute(qname, value) {
    if (!xml.isValidName(qname)) utils.InvalidCharacterError();
    if (this.isHTML) qname = utils.toASCIILowerCase(qname);
    if (qname.substring(0, 5) === 'xmlns') utils.NamespaceError();
    this._setAttribute(qname, String(value));
  }},


  // The version with no error checking used by the parser
  _setAttributeNS: { value: function _setAttributeNS(ns, qname, value) {
    var pos = qname.indexOf(':'), prefix, lname;
    if (pos === -1) {
      prefix = null;
      lname = qname;
    }
    else {
      prefix = qname.substring(0, pos);
      lname = qname.substring(pos+1);
    }

    var key = (ns === null ? '' : ns) + '|' + lname;
    if (ns === '') ns = null;

    var attr = this._attrsByLName[key];
    var isnew;
    if (!attr) {
      attr = new Attr(this, lname, prefix, ns);
      isnew = true;
      this._attrsByLName[key] = attr;
      this._attrKeys.push(key);

      // We also have to make the attr searchable by qname.
      // But we have to be careful because there may already
      // be an attr with this qname.
      this._addQName(attr);
    }
    else {
      // Calling setAttributeNS() can change the prefix of an
      // existing attribute!
      if (attr.prefix !== prefix) {
        // Unbind the old qname
        this._removeQName(attr);
        // Update the prefix
        attr.prefix = prefix;
        // Bind the new qname
        this._addQName(attr);

      }

    }
    attr.value = value; // Automatically sends mutation event
    if (isnew && this._newattrhook) this._newattrhook(qname, value);
  }},

  // Do error checking then call _setAttributeNS
  setAttributeNS: { value: function setAttributeNS(ns, qname, value) {
    if (!xml.isValidName(qname)) utils.InvalidCharacterError();
    if (!xml.isValidQName(qname)) utils.NamespaceError();

    var pos = qname.indexOf(':');
    var prefix = (pos === -1) ? null : qname.substring(0, pos);
    if (ns === '') ns = null;

    if ((prefix !== null && ns === null) ||
      (prefix === 'xml' && ns !== NAMESPACE.XML) ||
      ((qname === 'xmlns' || prefix === 'xmlns') &&
       (ns !== NAMESPACE.XMLNS)) ||
      (ns === NAMESPACE.XMLNS &&
       !(qname === 'xmlns' || prefix === 'xmlns')))
      utils.NamespaceError();

    this._setAttributeNS(ns, qname, String(value));
  }},

  removeAttribute: { value: function removeAttribute(qname) {
    if (this.isHTML) qname = utils.toASCIILowerCase(qname);

    var attr = this._attrsByQName[qname];
    if (!attr) return;

    // If there is more than one match for this qname
    // so don't delete the qname mapping, just remove the first
    // element from it.
    if (Array.isArray(attr)) {
      if (attr.length > 2) {
        attr = attr.shift();  // remove it from the array
      }
      else {
        this._attrsByQName[qname] = attr[1];
        attr = attr[0];
      }
    }
    else {
      // only a single match, so remove the qname mapping
      this._attrsByQName[qname] = undefined;
    }

    var ns = attr.namespaceURI;
    // Now attr is the removed attribute.  Figure out its
    // ns+lname key and remove it from the other mapping as well.
    var key = (ns === null ? '' : ns) + '|' + attr.localName;
    this._attrsByLName[key] = undefined;

    var i = this._attrKeys.indexOf(key);
    this._attrKeys.splice(i, 1);

    if (this._attributes)
      this._attributes[qname] = undefined;

    // Onchange handler for the attribute
    if (attr.onchange)
      attr.onchange(this, attr.localName, attr.value, null);

    // Mutation event
    if (this.rooted) this.ownerDocument.mutateRemoveAttr(attr);
  }},

  removeAttributeNS: { value: function removeAttributeNS(ns, lname) {
    var key = (ns === null ? '' : ns) + '|' + lname;
    var attr = this._attrsByLName[key];
    if (!attr) return;

    this._attrsByLName[key] = undefined;

    var i = this._attrKeys.indexOf(key);
    this._attrKeys.splice(i, 1);

    // Now find the same Attr object in the qname mapping and remove it
    // But be careful because there may be more than one match.
    this._removeQName(attr);

    // Onchange handler for the attribute
    if (attr.onchange)
      attr.onchange(this, attr.localName, attr.value, null);
    // Mutation event
    if (this.rooted) this.ownerDocument.mutateRemoveAttr(attr);
  }},

  // This 'raw' version of getAttribute is used by the getter functions
  // of reflected attributes. It skips some error checking and
  // namespace steps
  _getattr: { value: function _getattr(qname) {
    // Assume that qname is already lowercased, so don't do it here.
    // Also don't check whether attr is an array: a qname with no
    // prefix will never have two matching Attr objects (because
    // setAttributeNS doesn't allow a non-null namespace with a
    // null prefix.
    var attr = this._attrsByQName[qname];
    return attr ? attr.value : null;
  }},

  // The raw version of setAttribute for reflected idl attributes.
  _setattr: { value: function _setattr(qname, value) {
    var attr = this._attrsByQName[qname];
    var isnew;
    if (!attr) {
      attr = this._newattr(qname);
      isnew = true;
    }
    attr.value = String(value);
    if (this._attributes) this._attributes[qname] = attr;
    if (isnew && this._newattrhook) this._newattrhook(qname, value);
  }},

  // Create a new Attr object, insert it, and return it.
  // Used by setAttribute() and by set()
  _newattr: { value: function _newattr(qname) {
    var attr = new Attr(this, qname, null, null);
    var key = '|' + qname;
    this._attrsByQName[qname] = attr;
    this._attrsByLName[key] = attr;
    this._attrKeys.push(key);
    return attr;
  }},

  // Add a qname->Attr mapping to the _attrsByQName object, taking into
  // account that there may be more than one attr object with the
  // same qname
  _addQName: { value: function(attr) {
    var qname = attr.name;
    var existing = this._attrsByQName[qname];
    if (!existing) {
      this._attrsByQName[qname] = attr;
    }
    else if (Array.isArray(existing)) {
      existing.push(attr);
    }
    else {
      this._attrsByQName[qname] = [existing, attr];
    }
    if (this._attributes) this._attributes[qname] = attr;
  }},

  // Remove a qname->Attr mapping to the _attrsByQName object, taking into
  // account that there may be more than one attr object with the
  // same qname
  _removeQName: { value: function(attr) {
    var qname = attr.name;
    var target = this._attrsByQName[qname];

    if (Array.isArray(target)) {
      var idx = target.indexOf(attr);
      utils.assert(idx !== -1); // It must be here somewhere
      if (target.length === 2) {
        this._attrsByQName[qname] = target[1-idx];
      }
      else {
        target.splice(idx, 1);
      }
    }
    else {
      utils.assert(target === attr);  // If only one, it must match
      this._attrsByQName[qname] = undefined;
    }
  }},

  // Return the number of attributes
  _numattrs: { get: function() { return this._attrKeys.length; }},
  // Return the nth Attr object
  _attr: { value: function(n) {
    return this._attrsByLName[this._attrKeys[n]];
  }},

  // Define getters and setters for an 'id' property that reflects
  // the content attribute 'id'.
  id: attributes.property({name: 'id'}),

  // Define getters and setters for a 'className' property that reflects
  // the content attribute 'class'.
  className: attributes.property({name: 'class'}),

  classList: { get: function() {
    var self = this;
    if (this._classList) {
      return this._classList;
    }
    var dtlist = new DOMTokenList(
      function() {
        return self.className || "";
      },
      function(v) {
        self.className = v;
      }
    );
    this._classList = dtlist;
    return dtlist;
  }},

  matches: { value: function(selector) {
    return select.matches(this, selector);
  }},

  closest: { value: function(selector) {
    var el = this;
    while (el.matches && !el.matches(selector)) el = el.parentNode;
    return el.matches ? el : null;
  }},

  querySelector: { value: function(selector) {
    return select(selector, this)[0];
  }},

  querySelectorAll: { value: function(selector) {
    var nodes = select(selector, this);
    return nodes.item ? nodes : new NodeList(nodes);
  }}

});

Object.defineProperties(Element.prototype, ChildNode);
Object.defineProperties(Element.prototype, NonDocumentTypeChildNode);

// Register special handling for the id attribute
attributes.registerChangeHandler(Element, 'id',
 function(element, lname, oldval, newval) {
   if (element.rooted) {
     if (oldval) {
       element.ownerDocument.delId(oldval, element);
     }
     if (newval) {
       element.ownerDocument.addId(newval, element);
     }
   }
 }
);


// The Attr class represents a single attribute.  The values in
// _attrsByQName and _attrsByLName are instances of this class.
function Attr(elt, lname, prefix, namespace) {
  // Always remember what element we're associated with.
  // We need this to property handle mutations
  this.ownerElement = elt;

  if (!namespace && !prefix && elt._attributeChangeHandlers[lname])
    this.onchange = elt._attributeChangeHandlers[lname];

  // localName and namespace are constant for any attr object.
  // But value may change.  And so can prefix, and so, therefore can name.
  this.localName = lname;
  this.prefix = (prefix===null || prefix==='') ? null : ('' + prefix);
  this.namespaceURI = (namespace===null || namespace==='') ? null : ('' + namespace);
}

Attr.prototype = {
  get name() {
    return this.prefix ? this.prefix + ':' + this.localName : this.localName;
  },

  get value() {
    return this.data;
  },

  get specified() {
    // Deprecated
    return true;
  },

  set value(value) {
    var oldval = this.data;
    value = (value === undefined) ? '' : value + '';
    if (value === oldval) return;

    this.data = value;

    // Run the onchange hook for the attribute
    // if there is one.
    if (this.onchange)
      this.onchange(this.ownerElement,this.localName, oldval, value);

    // Generate a mutation event if the element is rooted
    if (this.ownerElement.rooted)
      this.ownerElement.ownerDocument.mutateAttr(this, oldval);
  },

  // Legacy aliases (see gh#70 and https://dom.spec.whatwg.org/#interface-attr)
  get nodeName() { return this.name; },
  get nodeValue() { return this.value; },
  get textContent() { return this.value; },
  set nodeValue(v) { this.value = v; },
  set textContent(v) { this.value = v; },
};


// The attributes property of an Element will be an instance of this class.
// This class is really just a dummy, though. It only defines a length
// property and an item() method. The AttrArrayProxy that
// defines the public API just uses the Element object itself.
function AttributesArray(elt) {
  this.element = elt;
  for (var name in elt._attrsByQName) {
    this[name] = elt._attrsByQName[name];
  }
}
AttributesArray.prototype = {
  get length() {
    return this.element._attrKeys.length;
  },
  item: function(n) {
    return this.element._attrsByLName[this.element._attrKeys[n]];
  }
};


// The children property of an Element will be an instance of this class.
// It defines length, item() and namedItem() and will be wrapped by an
// HTMLCollection when exposed through the DOM.
function ChildrenCollection(e) {
  this.element = e;
  this.updateCache();
}

ChildrenCollection.prototype = {
  get length() {
    this.updateCache();
    return this.childrenByNumber.length;
  },
  item: function item(n) {
    this.updateCache();
    return this.childrenByNumber[n] || null;
  },

  namedItem: function namedItem(name) {
    this.updateCache();
    return this.childrenByName[name] || null;
  },

  // This attribute returns the entire name->element map.
  // It is not part of the HTMLCollection API, but we need it in
  // src/HTMLCollectionProxy
  get namedItems() {
    this.updateCache();
    return this.childrenByName;
  },

  updateCache: function updateCache() {
    var namedElts = /^(a|applet|area|embed|form|frame|frameset|iframe|img|object)$/;
    if (this.lastModTime !== this.element.lastModTime) {
      this.lastModTime = this.element.lastModTime;

      var n = this.childrenByNumber && this.childrenByNumber.length || 0;
      for(var i = 0; i < n; i++) {
        this[i] = undefined;
      }

      this.childrenByNumber = [];
      this.childrenByName = Object.create(null);

      for(i = 0, n = this.element.childNodes.length; i < n; i++) {
        var c = this.element.childNodes[i];
        if (c.nodeType === Node.ELEMENT_NODE) {

          this[this.childrenByNumber.length] = c;
          this.childrenByNumber.push(c);

          // XXX Are there any requirements about the namespace
          // of the id property?
          var id = c.getAttribute('id');

          // If there is an id that is not already in use...
          if (id && !this.childrenByName[id])
            this.childrenByName[id] = c;

          // For certain HTML elements we check the name attribute
          var name = c.getAttribute('name');
          if (name &&
            this.element.namespaceURI === NAMESPACE.HTML &&
            namedElts.test(this.element.localName) &&
            !this.childrenByName[name])
            this.childrenByName[id] = c;
        }
      }
    }
  }
};

// These functions return predicates for filtering elements.
// They're used by the Document and Element classes for methods like
// getElementsByTagName and getElementsByClassName

function localNameElementFilter(lname) {
  return function(e) { return e.localName === lname; };
}

function htmlLocalNameElementFilter(lname) {
  var lclname = utils.toASCIILowerCase(lname);
  if (lclname === lname)
    return localNameElementFilter(lname);

  return function(e) {
    return e.isHTML ? e.localName === lclname : e.localName === lname;
  };
}

function namespaceElementFilter(ns) {
  return function(e) { return e.namespaceURI === ns; };
}

function namespaceLocalNameElementFilter(ns, lname) {
  return function(e) {
    return e.namespaceURI === ns && e.localName === lname;
  };
}

// XXX
// Optimize this when I implement classList.
function classNamesElementFilter(names) {
  return function(e) {
    var classAttr = e.getAttribute('class');
    if (!classAttr) return false;
    var classes = classAttr.trim().split(/\s+/);
    return names.every(function(n) {
      return classes.indexOf(n) !== -1;
    });
  };
}

function elementNameFilter(name) {
  return function(e) {
    return e.getAttribute('name') === name;
  };
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Event;

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

function Event(type, dictionary) {
  // Initialize basic event properties
  this.type = '';
  this.target = null;
  this.currentTarget = null;
  this.eventPhase = Event.AT_TARGET;
  this.bubbles = false;
  this.cancelable = false;
  this.isTrusted = false;
  this.defaultPrevented = false;
  this.timeStamp = Date.now();

  // Initialize internal flags
  // XXX: Would it be better to inherit these defaults from the prototype?
  this._propagationStopped = false;
  this._immediatePropagationStopped = false;
  this._initialized = true;
  this._dispatching = false;

  // Now initialize based on the constructor arguments (if any)
  if (type) this.type = type;
  if (dictionary) {
    for(var p in dictionary) {
      this[p] = dictionary[p];
    }
  }
}

Event.prototype = Object.create(Object.prototype, {
  constructor: { value: Event },
  stopPropagation: { value: function stopPropagation() {
    this._propagationStopped = true;
  }},

  stopImmediatePropagation: { value: function stopImmediatePropagation() {
    this._propagationStopped = true;
    this._immediatePropagationStopped = true;
  }},

  preventDefault: { value: function preventDefault() {
    if (this.cancelable) this.defaultPrevented = true;
  }},

  initEvent: { value: function initEvent(type, bubbles, cancelable) {
    this._initialized = true;
    if (this._dispatching) return;

    this._propagationStopped = false;
    this._immediatePropagationStopped = false;
    this.defaultPrevented = false;
    this.isTrusted = false;

    this.target = null;
    this.type = type;
    this.bubbles = bubbles;
    this.cancelable = cancelable;
  }},

});


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = CharacterData;

var Leaf = __webpack_require__(33);
var utils = __webpack_require__(1);
var ChildNode = __webpack_require__(12);
var NonDocumentTypeChildNode = __webpack_require__(36);

function CharacterData() {
}

CharacterData.prototype = Object.create(Leaf.prototype, {
  // DOMString substringData(unsigned long offset,
  //               unsigned long count);
  // The substringData(offset, count) method must run these steps:
  //
  //     If offset is greater than the context object's
  //     length, throw an INDEX_SIZE_ERR exception and
  //     terminate these steps.
  //
  //     If offset+count is greater than the context
  //     object's length, return a DOMString whose value is
  //     the UTF-16 code units from the offsetth UTF-16 code
  //     unit to the end of data.
  //
  //     Return a DOMString whose value is the UTF-16 code
  //     units from the offsetth UTF-16 code unit to the
  //     offset+countth UTF-16 code unit in data.
  substringData: { value: function substringData(offset, count) {
    if (offset > this.data.length || offset < 0 || count < 0) 
      utils.IndexSizeError();
    return this.data.substring(offset, offset+count);
  }},

  // void appendData(DOMString data);
  // The appendData(data) method must append data to the context
  // object's data.
  appendData: { value: function appendData(data) {
    this.data = this.data + data;
  }},

  // void insertData(unsigned long offset, DOMString data);
  // The insertData(offset, data) method must run these steps:
  //
  //     If offset is greater than the context object's
  //     length, throw an INDEX_SIZE_ERR exception and
  //     terminate these steps.
  //
  //     Insert data into the context object's data after
  //     offset UTF-16 code units.
  //
  insertData: { value: function insertData(offset, data) {
    var curtext = this.data;
    if (offset > curtext.length || offset < 0) utils.IndexSizeError();
    var prefix = curtext.substring(0, offset),
    suffix = curtext.substring(offset);
    this.data = prefix + data + suffix;
  }},


  // void deleteData(unsigned long offset, unsigned long count);
  // The deleteData(offset, count) method must run these steps:
  //
  //     If offset is greater than the context object's
  //     length, throw an INDEX_SIZE_ERR exception and
  //     terminate these steps.
  //
  //     If offset+count is greater than the context
  //     object's length var count be length-offset.
  //
  //     Starting from offset UTF-16 code units remove count
  //     UTF-16 code units from the context object's data.
  deleteData: { value: function deleteData(offset, count) {
    var curtext = this.data, len = curtext.length;

    if (offset > len || offset < 0) utils.IndexSizeError();

    if (offset+count > len)
      count = len - offset;

    var prefix = curtext.substring(0, offset),
    suffix = curtext.substring(offset+count);

    this.data = prefix + suffix;
  }},


  // void replaceData(unsigned long offset, unsigned long count,
  //          DOMString data);
  //
  // The replaceData(offset, count, data) method must act as
  // if the deleteData() method is invoked with offset and
  // count as arguments followed by the insertData() method
  // with offset and data as arguments and re-throw any
  // exceptions these methods might have thrown.
  replaceData: { value: function replaceData(offset, count, data) {
    var curtext = this.data, len = curtext.length;

    if (offset > len || offset < 0) utils.IndexSizeError();

    if (offset+count > len)
      count = len - offset;

    var prefix = curtext.substring(0, offset),
    suffix = curtext.substring(offset+count);

    this.data = prefix + data + suffix;
  }},

  // Utility method that Node.isEqualNode() calls to test Text and
  // Comment nodes for equality.  It is okay to put it here, since
  // Node will have already verified that nodeType is equal
  isEqual: { value: function isEqual(n) {
    return this._data === n._data;
  }},

  length: { get: function() { return this.data.length; }}

});

Object.defineProperties(CharacterData.prototype, ChildNode);
Object.defineProperties(CharacterData.prototype, NonDocumentTypeChildNode);


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = DOMImplementation;

var Document = __webpack_require__(13);
var DocumentType = __webpack_require__(14);
var HTMLParser = __webpack_require__(15);
var utils = __webpack_require__(1);
var xml = __webpack_require__(20);

// Each document must have its own instance of the domimplementation object
// Even though these objects have no state
function DOMImplementation() {}


// Feature/version pairs that DOMImplementation.hasFeature() returns
// true for.  It returns false for anything else.
var supportedFeatures = {
  'xml': { '': true, '1.0': true, '2.0': true },   // DOM Core
  'core': { '': true, '2.0': true },               // DOM Core
  'html': { '': true, '1.0': true, '2.0': true} ,  // HTML
  'xhtml': { '': true, '1.0': true, '2.0': true} , // HTML
};

DOMImplementation.prototype = {
  hasFeature: function hasFeature(feature, version) {
    var f = supportedFeatures[(feature || '').toLowerCase()];
    return (f && f[version || '']) || false;
  },

  createDocumentType: function createDocumentType(qualifiedName, publicId, systemId) {
    if (!xml.isValidName(qualifiedName)) utils.InvalidCharacterError();
    if (!xml.isValidQName(qualifiedName)) utils.NamespaceError();

    return new DocumentType(qualifiedName, publicId, systemId);
  },

  createDocument: function createDocument(namespace, qualifiedName, doctype) {
    //
    // Note that the current DOMCore spec makes it impossible to
    // create an HTML document with this function, even if the
    // namespace and doctype are propertly set.  See this thread:
    // http://lists.w3.org/Archives/Public/www-dom/2011AprJun/0132.html
    //
    var d = new Document(false, null);
    var e;

    if (qualifiedName)
      e = d.createElementNS(namespace, qualifiedName);
    else
      e = null;

    if (doctype) {
      if (doctype.ownerDocument) utils.WrongDocumentError();
      d.appendChild(doctype);
    }

    if (e) d.appendChild(e);

    return d;
  },

  createHTMLDocument: function createHTMLDocument(titleText) {
    var d = new Document(true, null);
    d.appendChild(new DocumentType('html'));
    var html = d.createElement('html');
    d.appendChild(html);
    var head = d.createElement('head');
    html.appendChild(head);
    var title = d.createElement('title');
    head.appendChild(title);
    title.appendChild(d.createTextNode(titleText));
    html.appendChild(d.createElement('body'));
    d.modclock = 1; // Start tracking modifications
    return d;
  },

  mozSetOutputMutationHandler: function(doc, handler) {
    doc.mutationHandler = handler;
  },

  mozGetInputMutationHandler: function(doc) {
    utils.nyi();
  },

  mozHTMLParser: HTMLParser,
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var NodeFilter = {
  // Constants for acceptNode()
  FILTER_ACCEPT: 1,
  FILTER_REJECT: 2,
  FILTER_SKIP: 3,

  // Constants for whatToShow
  SHOW_ALL: 0xFFFFFFFF,
  SHOW_ELEMENT: 0x1,
  SHOW_ATTRIBUTE: 0x2, // historical
  SHOW_TEXT: 0x4,
  SHOW_CDATA_SECTION: 0x8, // historical
  SHOW_ENTITY_REFERENCE: 0x10, // historical
  SHOW_ENTITY: 0x20, // historical
  SHOW_PROCESSING_INSTRUCTION: 0x40,
  SHOW_COMMENT: 0x80,
  SHOW_DOCUMENT: 0x100,
  SHOW_DOCUMENT_TYPE: 0x200,
  SHOW_DOCUMENT_FRAGMENT: 0x400,
  SHOW_NOTATION: 0x800 // historical
};

module.exports = (NodeFilter.constructor = NodeFilter.prototype = NodeFilter);


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = NodeList;

function item(i) {
  /* jshint validthis: true */
  return this[i];
}

function NodeList(a) {
  if (!a) a = [];
  a.item = item;
  return a;
}


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(5);

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var parserlib = __webpack_require__(75);

module.exports = CSSStyleDeclaration;

function CSSStyleDeclaration(elt) {
  this._element = elt;
}

// Utility function for parsing style declarations
// Pass in a string like "margin-left: 5px; border-style: solid"
// and this function returns an object like
// {"margin-left":"5px", "border-style":"solid"}
function parseStyles(s) {
  var parser = new parserlib.css.Parser();
  var result = { property: Object.create(null), priority: Object.create(null) };
  parser.addListener("property", function(e) {
    if (e.invalid) return; // Skip errors
    result.property[e.property.text] = e.value.text;
    if (e.important) result.priority[e.property.text] = 'important';
  });
  s = (''+s).replace(/^;/, '');
  parser.parseStyleAttribute(s);
  return result;
}

var NO_CHANGE = {}; // Private marker object

CSSStyleDeclaration.prototype = Object.create(Object.prototype, {

  // Return the parsed form of the element's style attribute.
  // If the element's style attribute has never been parsed
  // or if it has changed since the last parse, then reparse it
  // Note that the styles don't get parsed until they're actually needed
  _parsed: { get: function() {
    if (!this._parsedStyles || this.cssText !== this._lastParsedText) {
      var text = this.cssText;
      this._parsedStyles = parseStyles(text);
      this._lastParsedText = text;
      delete this._names;
    }
    return this._parsedStyles;
  }},

  // Call this method any time the parsed representation of the
  // style changes.  It converts the style properties to a string and
  // sets cssText and the element's style attribute
  _serialize: { value: function() {
    var styles = this._parsed;
    var s = "";

    for(var name in styles.property) {
      if (s) s += " ";
      s += name + ": " + styles.property[name];
      if (styles.priority[name]) {
        s += " !" + styles.priority[name];
      }
      s += ";";
    }

    this.cssText = s;      // also sets the style attribute
    this._lastParsedText = s;  // so we don't reparse
    delete this._names;
  }},

  cssText: {
    get: function() {
      // XXX: this is a CSSStyleDeclaration for an element.
      // A different impl might be necessary for a set of styles
      // associated returned by getComputedStyle(), e.g.
      return this._element.getAttribute("style");
    },
    set: function(value) {
      // XXX: I should parse and serialize the value to
      // normalize it and remove errors. FF and chrome do that.
      this._element.setAttribute("style", value);
    }
  },

  length: { get: function() {
    if (!this._names)
      this._names = Object.getOwnPropertyNames(this._parsed.property);
    return this._names.length;
  }},

  item: { value: function(n) {
    if (!this._names)
      this._names = Object.getOwnPropertyNames(this._parsed.property);
    return this._names[n];
  }},

  getPropertyValue: { value: function(property) {
    property = property.toLowerCase();
    return this._parsed.property[property] || "";
  }},

  getPropertyPriority: { value: function(property) {
    property = property.toLowerCase();
    return this._parsed.priority[property] || "";
  }},

  setProperty: { value: function(property, value, priority) {
    property = property.toLowerCase();
    if (value === null || value === undefined) {
      value = "";
    }
    if (priority === null || priority === undefined) {
      priority = "";
    }

    // String coercion
    if (value !== NO_CHANGE) {
      value = "" + value;
    }

    if (value === "") {
      this.removeProperty(property);
      return;
    }

    if (priority !== "" && priority !== NO_CHANGE &&
        !/^important$/i.test(priority)) {
      return;
    }

    var styles = this._parsed;
    if (value === NO_CHANGE) {
      if (!styles.property[property]) {
        return; // Not a valid property name.
      }
      if (priority !== "") {
        styles.priority[property] = "important";
      } else {
        delete styles.priority[property];
      }
    } else {
      // We don't just accept the property value.  Instead
      // we parse it to ensure that it is something valid.
      // If it contains a semicolon it is invalid
      if (value.indexOf(";") !== -1) return;

      var newprops = parseStyles(property + ":" + value);
      if (Object.getOwnPropertyNames(newprops.property).length === 0) {
        return; // no valid property found
      }
      if (Object.getOwnPropertyNames(newprops.priority).length !== 0) {
        return; // if the value included '!important' it wasn't valid.
      }

      // XXX handle shorthand properties

      for (var p in newprops.property) {
        styles.property[p] = newprops.property[p];
        if (priority === NO_CHANGE) {
          continue;
        } else if (priority !== "") {
          styles.priority[p] = "important";
        } else if (styles.priority[p]) {
          delete styles.priority[p];
        }
      }
    }

    // Serialize and update cssText and element.style!
    this._serialize();
  }},

  setPropertyValue: { value: function(property, value) {
    return this.setProperty(property, value, NO_CHANGE);
  }},

  setPropertyPriority: { value: function(property, priority) {
    return this.setProperty(property, NO_CHANGE, priority);
  }},

  removeProperty: { value: function(property) {
    property = property.toLowerCase();
    var styles = this._parsed;
    if (property in styles.property) {
      delete styles.property[property];
      delete styles.priority[property];

      // Serialize and update cssText and element.style!
      this._serialize();
    }
  }},
});

var cssProperties = {
  background: "background",
  backgroundAttachment: "background-attachment",
  backgroundColor: "background-color",
  backgroundImage: "background-image",
  backgroundPosition: "background-position",
  backgroundRepeat: "background-repeat",
  border: "border",
  borderCollapse: "border-collapse",
  borderColor: "border-color",
  borderSpacing: "border-spacing",
  borderStyle: "border-style",
  borderTop: "border-top",
  borderRight: "border-right",
  borderBottom: "border-bottom",
  borderLeft: "border-left",
  borderTopColor: "border-top-color",
  borderRightColor: "border-right-color",
  borderBottomColor: "border-bottom-color",
  borderLeftColor: "border-left-color",
  borderTopStyle: "border-top-style",
  borderRightStyle: "border-right-style",
  borderBottomStyle: "border-bottom-style",
  borderLeftStyle: "border-left-style",
  borderTopWidth: "border-top-width",
  borderRightWidth: "border-right-width",
  borderBottomWidth: "border-bottom-width",
  borderLeftWidth: "border-left-width",
  borderWidth: "border-width",
  bottom: "bottom",
  captionSide: "caption-side",
  clear: "clear",
  clip: "clip",
  color: "color",
  content: "content",
  counterIncrement: "counter-increment",
  counterReset: "counter-reset",
  cursor: "cursor",
  direction: "direction",
  display: "display",
  emptyCells: "empty-cells",
  cssFloat: "float",
  font: "font",
  fontFamily: "font-family",
  fontSize: "font-size",
  fontSizeAdjust: "font-size-adjust",
  fontStretch: "font-stretch",
  fontStyle: "font-style",
  fontVariant: "font-variant",
  fontWeight: "font-weight",
  height: "height",
  left: "left",
  letterSpacing: "letter-spacing",
  lineHeight: "line-height",
  listStyle: "list-style",
  listStyleImage: "list-style-image",
  listStylePosition: "list-style-position",
  listStyleType: "list-style-type",
  margin: "margin",
  marginTop: "margin-top",
  marginRight: "margin-right",
  marginBottom: "margin-bottom",
  marginLeft: "margin-left",
  markerOffset: "marker-offset",
  marks: "marks",
  maxHeight: "max-height",
  maxWidth: "max-width",
  minHeight: "min-height",
  minWidth: "min-width",
  opacity: "opacity",
  orphans: "orphans",
  outline: "outline",
  outlineColor: "outline-color",
  outlineStyle: "outline-style",
  outlineWidth: "outline-width",
  overflow: "overflow",
  padding: "padding",
  paddingTop: "padding-top",
  paddingRight: "padding-right",
  paddingBottom: "padding-bottom",
  paddingLeft: "padding-left",
  page: "page",
  pageBreakAfter: "page-break-after",
  pageBreakBefore: "page-break-before",
  pageBreakInside: "page-break-inside",
  position: "position",
  quotes: "quotes",
  right: "right",
  size: "size",
  tableLayout: "table-layout",
  textAlign: "text-align",
  textDecoration: "text-decoration",
  textIndent: "text-indent",
  textShadow: "text-shadow",
  textTransform: "text-transform",
  top: "top",
  unicodeBidi: "unicode-bidi",
  verticalAlign: "vertical-align",
  visibility: "visibility",
  whiteSpace: "white-space",
  widows: "widows",
  width: "width",
  wordSpacing: "word-spacing",
  zIndex: "z-index",
};

for(var prop in cssProperties) defineStyleProperty(prop);

function defineStyleProperty(jsname) {
  var cssname = cssProperties[jsname];
  Object.defineProperty(CSSStyleDeclaration.prototype, jsname, {
    get: function() {
      return this.getPropertyValue(cssname);
    },
    set: function(value) {
      this.setProperty(cssname, value);
    }
  });
}


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Node = __webpack_require__(2);

var createDocumentFragmentFromArguments = function(document, args) {
  var docFrag = document.createDocumentFragment();

  for (var i=0; i<args.length; i++) {
    var argItem = args[i];
    var isNode = argItem instanceof Node;
    docFrag.appendChild(isNode ? argItem :
                        document.createTextNode(String(argItem)));
  }

  return docFrag;
};

// The ChildNode interface contains methods that are particular to `Node`
// objects that can have a parent.  It is implemented by `Element`,
// `DocumentType`, and `CharacterData` objects.
var ChildNode = {

  // Inserts a set of Node or String objects in the children list of this
  // ChildNode's parent, just after this ChildNode.  String objects are
  // inserted as the equivalent Text nodes.
  after: { value: function after() {
    var argArr = Array.prototype.slice.call(arguments);
    var parentNode = this.parentNode, nextSibling = this.nextSibling;
    if (parentNode === null) { return; }
    // Find "viable next sibling"; that is, next one not in argArr
    while (nextSibling && argArr.some(function(v) { return v===nextSibling; }))
      nextSibling = nextSibling.nextSibling;
    // ok, parent and sibling are saved away since this node could itself
    // appear in argArr and we're about to move argArr to a document fragment.
    var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);

    parentNode.insertBefore(docFrag, nextSibling);
  }},

  // Inserts a set of Node or String objects in the children list of this
  // ChildNode's parent, just before this ChildNode.  String objects are
  // inserted as the equivalent Text nodes.
  before: { value: function before() {
    var argArr = Array.prototype.slice.call(arguments);
    var parentNode = this.parentNode, prevSibling = this.previousSibling;
    if (parentNode === null) { return; }
    // Find "viable prev sibling"; that is, prev one not in argArr
    while (prevSibling && argArr.some(function(v) { return v===prevSibling; }))
      prevSibling = prevSibling.previousSibling;
    // ok, parent and sibling are saved away since this node could itself
    // appear in argArr and we're about to move argArr to a document fragment.
    var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);

    var nextSibling =
        prevSibling ? prevSibling.nextSibling : parentNode.firstChild;
    parentNode.insertBefore(docFrag, nextSibling);
  }},

  // Remove this node from its parent
  remove: { value: function remove() {
    if (this.parentNode === null) return;

    // Send mutation events if necessary
    if (this.rooted && this.doc) this.doc.mutateRemove(this);

    // Remove this node from its parents array of children
    this.parentNode.childNodes.splice(this.index, 1);

    // Update the structure id for all ancestors
    this.parentNode.modify();

    // Forget this node's parent
    this.parentNode = null;
  }},

  // Replace this node with the nodes or strings provided as arguments.
  replaceWith: { value: function replaceWith() {
    var argArr = Array.prototype.slice.call(arguments);
    var parentNode = this.parentNode, nextSibling = this.nextSibling;
    if (parentNode === null) { return; }
    // Find "viable next sibling"; that is, next one not in argArr
    while (nextSibling && argArr.some(function(v) { return v===nextSibling; }))
      nextSibling = nextSibling.nextSibling;
    // ok, parent and sibling are saved away since this node could itself
    // appear in argArr and we're about to move argArr to a document fragment.
    var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);
    if (this.parentNode === parentNode) {
      parentNode.replaceChild(docFrag, this);
    } else {
      // `this` was inserted into docFrag
      parentNode.insertBefore(docFrag, nextSibling);
    }
  }},

};

module.exports = ChildNode;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Document;

var Node = __webpack_require__(2);
var NodeList = __webpack_require__(9);
var Element = __webpack_require__(4);
var Text = __webpack_require__(38);
var Comment = __webpack_require__(28);
var Event = __webpack_require__(5);
var DocumentFragment = __webpack_require__(31);
var ProcessingInstruction = __webpack_require__(37);
var DOMImplementation = __webpack_require__(7);
var TreeWalker = __webpack_require__(73);
var NodeIterator = __webpack_require__(72);
var NodeFilter = __webpack_require__(8);
var URL = __webpack_require__(16);
var select = __webpack_require__(19);
var events = __webpack_require__(44);
var xml = __webpack_require__(20);
var html = __webpack_require__(18);
var svg = __webpack_require__(47);
var utils = __webpack_require__(1);
var MUTATE = __webpack_require__(70);
var NAMESPACE = utils.NAMESPACE;
var isApiWritable = __webpack_require__(42).isApiWritable;

function Document(isHTML, address) {
  this.nodeType = Node.DOCUMENT_NODE;
  this.isHTML = isHTML;
  this._address = address || 'about:blank';
  this.readyState = 'loading';
  this.implementation = new DOMImplementation();

  // DOMCore says that documents are always associated with themselves
  this.ownerDocument = null; // ... but W3C tests expect null

  // These will be initialized by our custom versions of
  // appendChild and insertBefore that override the inherited
  // Node methods.
  // XXX: override those methods!
  this.doctype = null;
  this.documentElement = null;
  this.childNodes = new NodeList();

  // "Associated inert template document"
  this._templateDocCache = null;

  // Documents are always rooted, by definition
  this._nid = 1;
  this._nextnid = 2; // For numbering children of the document
  this._nodes = [null, this];  // nid to node map

  // This maintains the mapping from element ids to element nodes.
  // We may need to update this mapping every time a node is rooted
  // or uprooted, and any time an attribute is added, removed or changed
  // on a rooted element.
  this.byId = Object.create(null);

  // This property holds a monotonically increasing value akin to
  // a timestamp used to record the last modification time of nodes
  // and their subtrees. See the lastModTime attribute and modify()
  // method of the Node class. And see FilteredElementList for an example
  // of the use of lastModTime
  this.modclock = 0;
}

// Map from lowercase event category names (used as arguments to
// createEvent()) to the property name in the impl object of the
// event constructor.
var supportedEvents = {
  event: 'Event',
  customevent: 'CustomEvent',
  uievent: 'UIEvent',
  mouseevent: 'MouseEvent'
};

// Certain arguments to document.createEvent() must be treated specially
var replacementEvent = {
  events: 'event',
  htmlevents: 'event',
  mouseevents: 'mouseevent',
  mutationevents: 'mutationevent',
  uievents: 'uievent'
};

var mirrorAttr = function(f, name, defaultValue) {
  return {
    get: function() {
      var o = f.call(this);
      if (o) { return o[name]; }
      return defaultValue;
    },
    set: function(value) {
      var o = f.call(this);
      if (o) { o[name] = value; }
    },
  };
};

Document.prototype = Object.create(Node.prototype, {
  // This method allows dom.js to communicate with a renderer
  // that displays the document in some way
  // XXX: I should probably move this to the window object
  _setMutationHandler: { value: function(handler) {
    this.mutationHandler = handler;
  }},

  // This method allows dom.js to receive event notifications
  // from the renderer.
  // XXX: I should probably move this to the window object
  _dispatchRendererEvent: { value: function(targetNid, type, details) {
    var target = this._nodes[targetNid];
    if (!target) return;
    target._dispatchEvent(new Event(type, details), true);
  }},

  nodeName: { value: '#document'},
  nodeValue: {
    get: function() {
      return null;
    },
    set: function() {}
  },

  // XXX: DOMCore may remove documentURI, so it is NYI for now
  documentURI: { get: utils.nyi, set: utils.nyi },
  compatMode: { get: function() {
    // The _quirks property is set by the HTML parser
    return this._quirks ? 'BackCompat' : 'CSS1Compat';
  }},
  parentNode: { value: null },

  createTextNode: { value: function(data) {
    return new Text(this, '' + data);
  }},
  createComment: { value: function(data) {
    return new Comment(this, data);
  }},
  createDocumentFragment: { value: function() {
    return new DocumentFragment(this);
  }},
  createProcessingInstruction: { value: function(target, data) {
    if (!xml.isValidName(target) || data.indexOf('?>') !== -1)
      utils.InvalidCharacterError();
    return new ProcessingInstruction(this, target, data);
  }},

  createElement: { value: function(localName) {
    if (!xml.isValidName(localName)) utils.InvalidCharacterError();
    if (this.isHTML) localName = utils.toASCIILowerCase(localName);
    return html.createElement(this, localName, null);
  }, writable: isApiWritable },

  createElementNS: { value: function(namespace, qualifiedName) {
    if (!xml.isValidName(qualifiedName)) utils.InvalidCharacterError();
    if (!xml.isValidQName(qualifiedName)) utils.NamespaceError();

    var pos, prefix, localName;
    if ((pos = qualifiedName.indexOf(':')) !== -1) {
      prefix = qualifiedName.substring(0, pos);
      localName = qualifiedName.substring(pos+1);

      if (namespace === '' ||
        (prefix === 'xml' && namespace !== NAMESPACE.XML))
        utils.NamespaceError();
    }
    else {
      prefix = null;
      localName = qualifiedName;
    }

    if (((qualifiedName === 'xmlns' || prefix === 'xmlns') &&
       namespace !== NAMESPACE.XMLNS) ||
      (namespace === NAMESPACE.XMLNS &&
       qualifiedName !== 'xmlns' &&
       prefix !== 'xmlns'))
      utils.NamespaceError();

    if (namespace === NAMESPACE.HTML) {
      return html.createElement(this, localName, prefix);
    }
    else if (namespace === NAMESPACE.SVG) {
      return svg.createElement(this, localName, prefix);
    }

    return new Element(this, localName, namespace, prefix);
  }, writable: isApiWritable },

  createEvent: { value: function createEvent(interfaceName) {
    interfaceName = interfaceName.toLowerCase();
    var name = replacementEvent[interfaceName] || interfaceName;
    var constructor = events[supportedEvents[name]];

    if (constructor) {
      var e = new constructor();
      e._initialized = false;
      return e;
    }
    else {
      utils.NotSupportedError();
    }
  }},

  // See: http://www.w3.org/TR/dom/#dom-document-createtreewalker
  createTreeWalker: {value: function (root, whatToShow, filter) {
    whatToShow = whatToShow === undefined ? NodeFilter.SHOW_ALL : whatToShow;

    if (filter && typeof filter === 'object' &&
        typeof filter.acceptNode === 'function') {
      filter = filter.acceptNode.bind(filter);
      // Support filter being a function
      // https://developer.mozilla.org/en-US/docs/DOM/document.createTreeWalker
    }
    else if (typeof filter !== 'function') {
      filter = null;
    }
    return new TreeWalker(root, whatToShow, filter);
  }},

  // See: http://www.w3.org/TR/dom/#dom-document-createnodeiterator
  createNodeIterator: {value: function (root, whatToShow, filter) {
    whatToShow = whatToShow === undefined ? NodeFilter.SHOW_ALL : whatToShow;

    if (filter && typeof filter === 'object' &&
        typeof filter.acceptNode === 'function') {
      filter = filter.acceptNode.bind(filter);
      // Support filter being a function
      // https://developer.mozilla.org/en-US/docs/DOM/document.createNodeIterator
    }
    else if (typeof filter !== 'function') {
      filter = null;
    }
    return new NodeIterator(root, whatToShow, filter);
  }},

  // Maintain the documentElement and
  // doctype properties of the document.  Each of the following
  // methods chains to the Node implementation of the method
  // to do the actual inserting, removal or replacement.

  _updateDocTypeElement: { value: function _updateDocTypeElement() {
    var i, n, nodes = this.childNodes, length = nodes.length;
    this.doctype = this.documentElement = null;
    for (i=0; i<length; i++) {
      n = nodes[i];
      if (n.nodeType === Node.DOCUMENT_TYPE_NODE)
        this.doctype = n;
      else if (n.nodeType === Node.ELEMENT_NODE)
        this.documentElement = n;
    }
  }},

  insertBefore: { value: function insertBefore(child, refChild) {
    Node.prototype.insertBefore.call(this, child, refChild);
    this._updateDocTypeElement();
    return child;
  }},

  replaceChild: { value: function replaceChild(node, child) {
    Node.prototype.replaceChild.call(this, node, child);
    this._updateDocTypeElement();
    return child;
  }},

  removeChild: { value: function removeChild(child) {
    Node.prototype.removeChild.call(this, child);
    this._updateDocTypeElement();
    return child;
  }},

  getElementById: { value: function(id) {
    var n = this.byId[id];
    if (!n) return null;
    if (n instanceof MultiId) { // there was more than one element with this id
      return n.getFirst();
    }
    return n;
  }},

  _hasMultipleElementsWithId: { value: function(id) {
    // Used internally by querySelectorAll optimization
    return (this.byId[id] instanceof MultiId);
  }},

  // Just copy this method from the Element prototype
  getElementsByName: { value: Element.prototype.getElementsByName },
  getElementsByTagName: { value: Element.prototype.getElementsByTagName },
  getElementsByTagNameNS: { value: Element.prototype.getElementsByTagNameNS },
  getElementsByClassName: { value: Element.prototype.getElementsByClassName },

  adoptNode: { value: function adoptNode(node) {
    if (node.nodeType === Node.DOCUMENT_NODE) utils.NotSupportedError();

    if (node.parentNode) node.parentNode.removeChild(node);

    if (node.ownerDocument !== this)
      recursivelySetOwner(node, this);

    return node;
  }},

  importNode: { value: function importNode(node, deep) {
    return this.adoptNode(node.cloneNode(deep));
  }, writable: isApiWritable },

  // The following attributes and methods are from the HTML spec
  URL: { get: utils.nyi },
  domain: { get: utils.nyi, set: utils.nyi },
  referrer: { get: utils.nyi },
  cookie: { get: utils.nyi, set: utils.nyi },
  lastModified: { get: utils.nyi },
  location: {
	get: function() {
	  return this.defaultView ? this.defaultView.location : null; // gh #75
	},
	set: utils.nyi
  },
  _titleElement: {
    get: function() {
      // The title element of a document is the first title element in the
      // document in tree order, if there is one, or null otherwise.
      return this.getElementsByTagName('title').item(0) || null;
    }
  },
  title: {
    get: function() {
      var elt = this._titleElement;
      // The child text content of the title element, or '' if null.
      var value = elt ? elt.textContent : '';
      // Strip and collapse whitespace in value
      return value.replace(/[ \t\n\r\f]+/g, ' ').trim();
    },
    set: function(value) {
      var elt = this._titleElement;
      var head = this.head;
      if (!elt && !head) { return; /* according to spec */ }
      if (!elt) {
        elt = this.createElement('title');
        head.appendChild(elt);
      }
      elt.textContent = value;
    }
  },
  dir: mirrorAttr(function() {
    var htmlElement = this.documentElement;
    if (htmlElement && htmlElement.tagName === 'HTML') { return htmlElement; }
  }, 'dir', ''),
  fgColor: mirrorAttr(function() { return this.body; }, 'text', ''),
  linkColor: mirrorAttr(function() { return this.body; }, 'link', ''),
  vlinkColor: mirrorAttr(function() { return this.body; }, 'vLink', ''),
  alinkColor: mirrorAttr(function() { return this.body; }, 'aLink', ''),
  bgColor: mirrorAttr(function() { return this.body; }, 'bgColor', ''),

  // Return the first <body> child of the document element.
  // XXX For now, setting this attribute is not implemented.
  body: {
    get: function() {
      return namedHTMLChild(this.documentElement, 'body');
    },
    set: utils.nyi
  },
  // Return the first <head> child of the document element.
  head: { get: function() {
    return namedHTMLChild(this.documentElement, 'head');
  }},
  images: { get: utils.nyi },
  embeds: { get: utils.nyi },
  plugins: { get: utils.nyi },
  links: { get: utils.nyi },
  forms: { get: utils.nyi },
  scripts: { get: utils.nyi },
  innerHTML: {
    get: function() { return this.serialize(); },
    set: utils.nyi
  },
  outerHTML: {
    get: function() { return this.serialize(); },
    set: utils.nyi
  },

  write: { value: function(args) {
    if (!this.isHTML) utils.InvalidStateError();

    // XXX: still have to implement the ignore part
    if (!this._parser /* && this._ignore_destructive_writes > 0 */ )
      return;

    if (!this._parser) {
      // XXX call document.open, etc.
    }

    var s = arguments.join('');

    // If the Document object's reload override flag is set, then
    // append the string consisting of the concatenation of all the
    // arguments to the method to the Document's reload override
    // buffer.
    // XXX: don't know what this is about.  Still have to do it

    // If there is no pending parsing-blocking script, have the
    // tokenizer process the characters that were inserted, one at a
    // time, processing resulting tokens as they are emitted, and
    // stopping when the tokenizer reaches the insertion point or when
    // the processing of the tokenizer is aborted by the tree
    // construction stage (this can happen if a script end tag token is
    // emitted by the tokenizer).

    // XXX: still have to do the above. Sounds as if we don't
    // always call parse() here.  If we're blocked, then we just
    // insert the text into the stream but don't parse it reentrantly...

    // Invoke the parser reentrantly
    this._parser.parse(s);
  }},

  writeln: { value: function writeln(args) {
    this.write(Array.prototype.join.call(arguments, '') + '\n');
  }},

  open: { value: function() {
    this.documentElement = null;
  }},

  close: { value: function() {
    this.readyState = 'complete';
    var ev = new Event('DOMContentLoaded');
    this._dispatchEvent(ev, true);
    if (this.defaultView) {
      ev = new Event('load');
      this.defaultView._dispatchEvent(ev, true);
    }
  }},

  // Utility methods
  clone: { value: function clone() {
    // Can't clone an entire document
    utils.DataCloneError();
  }},

  isEqual: { value: function isEqual(n) {
    // Any two documents are shallowly equal.
    // Node.isEqualNode will also test the children
    return true;
  }},

  // Implementation-specific function.  Called when a text, comment,
  // or pi value changes.
  mutateValue: { value: function(node) {
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.VALUE,
        target: node,
        data: node.data
      });
    }
  }},

  // Invoked when an attribute's value changes. Attr holds the new
  // value.  oldval is the old value.  Attribute mutations can also
  // involve changes to the prefix (and therefore the qualified name)
  mutateAttr: { value: function(attr, oldval) {
    // Manage id->element mapping for getElementsById()
    // XXX: this special case id handling should not go here,
    // but in the attribute declaration for the id attribute
    /*
    if (attr.localName === 'id' && attr.namespaceURI === null) {
      if (oldval) delId(oldval, attr.ownerElement);
      addId(attr.value, attr.ownerElement);
    }
    */
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.ATTR,
        target: attr.ownerElement,
        attr: attr
      });
    }
  }},

  // Used by removeAttribute and removeAttributeNS for attributes.
  mutateRemoveAttr: { value: function(attr) {
/*
* This is now handled in Attributes.js
    // Manage id to element mapping
    if (attr.localName === 'id' && attr.namespaceURI === null) {
      this.delId(attr.value, attr.ownerElement);
    }
*/
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.REMOVE_ATTR,
        target: attr.ownerElement,
        attr: attr
      });
    }
  }},

  // Called by Node.removeChild, etc. to remove a rooted element from
  // the tree. Only needs to generate a single mutation event when a
  // node is removed, but must recursively mark all descendants as not
  // rooted.
  mutateRemove: { value: function(node) {
    // Send a single mutation event
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.REMOVE,
        target: node.parentNode,
        node: node
      });
    }

    // Mark this and all descendants as not rooted
    recursivelyUproot(node);
  }},

  // Called when a new element becomes rooted.  It must recursively
  // generate mutation events for each of the children, and mark them all
  // as rooted.
  mutateInsert: { value: function(node) {
    // Mark node and its descendants as rooted
    recursivelyRoot(node);

    // Send a single mutation event
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.INSERT,
        target: node.parentNode,
        node: node
      });
    }
  }},

  // Called when a rooted element is moved within the document
  mutateMove: { value: function(node) {
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.MOVE,
        target: node
      });
    }
  }},


  // Add a mapping from  id to n for n.ownerDocument
  addId: { value: function addId(id, n) {
    var val = this.byId[id];
    if (!val) {
      this.byId[id] = n;
    }
    else {
      // TODO: Add a way to opt-out console warnings
      //console.warn('Duplicate element id ' + id);
      if (!(val instanceof MultiId)) {
        val = new MultiId(val);
        this.byId[id] = val;
      }
      val.add(n);
    }
  }},

  // Delete the mapping from id to n for n.ownerDocument
  delId: { value: function delId(id, n) {
    var val = this.byId[id];
    utils.assert(val);

    if (val instanceof MultiId) {
      val.del(n);
      if (val.length === 1) { // convert back to a single node
        this.byId[id] = val.downgrade();
      }
    }
    else {
      this.byId[id] = undefined;
    }
  }},

  _resolve: { value: function(href) {
    //XXX: Cache the URL
    return new URL(this._documentBaseURL).resolve(href);
  }},

  _documentBaseURL: { get: function() {
    // XXX: This is not implemented correctly yet
    var url = this._address;
    if (url === 'about:blank') url = '/';

    var base = this.querySelector('base[href]');
    if (base) {
      return new URL(url).resolve(base.getAttribute('href'));
    }
    return url;

    // The document base URL of a Document object is the
    // absolute URL obtained by running these substeps:

    //     Let fallback base url be the document's address.

    //     If fallback base url is about:blank, and the
    //     Document's browsing context has a creator browsing
    //     context, then let fallback base url be the document
    //     base URL of the creator Document instead.

    //     If the Document is an iframe srcdoc document, then
    //     let fallback base url be the document base URL of
    //     the Document's browsing context's browsing context
    //     container's Document instead.

    //     If there is no base element that has an href
    //     attribute, then the document base URL is fallback
    //     base url; abort these steps. Otherwise, let url be
    //     the value of the href attribute of the first such
    //     element.

    //     Resolve url relative to fallback base url (thus,
    //     the base href attribute isn't affected by xml:base
    //     attributes).

    //     The document base URL is the result of the previous
    //     step if it was successful; otherwise it is fallback
    //     base url.
  }},

  _templateDoc: { get: function() {
    if (!this._templateDocCache) {
      // "associated inert template document"
      var newDoc = new Document(this.isHTML, this._address);
      this._templateDocCache = newDoc._templateDocCache = newDoc;
    }
    return this._templateDocCache;
  }},

  querySelector: { value: function(selector) {
    return select(selector, this)[0];
  }},

  querySelectorAll: { value: function(selector) {
    var nodes = select(selector, this);
    return nodes.item ? nodes : new NodeList(nodes);
  }}

});


var eventHandlerTypes = [
  'abort', 'canplay', 'canplaythrough', 'change', 'click', 'contextmenu',
  'cuechange', 'dblclick', 'drag', 'dragend', 'dragenter', 'dragleave',
  'dragover', 'dragstart', 'drop', 'durationchange', 'emptied', 'ended',
  'input', 'invalid', 'keydown', 'keypress', 'keyup', 'loadeddata',
  'loadedmetadata', 'loadstart', 'mousedown', 'mousemove', 'mouseout',
  'mouseover', 'mouseup', 'mousewheel', 'pause', 'play', 'playing',
  'progress', 'ratechange', 'readystatechange', 'reset', 'seeked',
  'seeking', 'select', 'show', 'stalled', 'submit', 'suspend',
  'timeupdate', 'volumechange', 'waiting',

  'blur', 'error', 'focus', 'load', 'scroll'
];

// Add event handler idl attribute getters and setters to Document
eventHandlerTypes.forEach(function(type) {
  // Define the event handler registration IDL attribute for this type
  Object.defineProperty(Document.prototype, 'on' + type, {
    get: function() {
      return this._getEventHandler(type);
    },
    set: function(v) {
      this._setEventHandler(type, v);
    }
  });
});

function namedHTMLChild(parent, name) {
  if (parent && parent.isHTML) {
    var kids = parent.childNodes;
    for(var i = 0, n = kids.length; i < n; i++) {
      if (kids[i].nodeType === Node.ELEMENT_NODE &&
        kids[i].localName === name &&
        kids[i].namespaceURI === NAMESPACE.HTML) {
        return kids[i];
      }
    }
  }
  return null;
}

function root(n) {
  n._nid = n.ownerDocument._nextnid++;
  n.ownerDocument._nodes[n._nid] = n;
  // Manage id to element mapping
  if (n.nodeType === Node.ELEMENT_NODE) {
    var id = n.getAttribute('id');
    if (id) n.ownerDocument.addId(id, n);

    // Script elements need to know when they're inserted
    // into the document
    if (n._roothook) n._roothook();
  }
}

function uproot(n) {
  // Manage id to element mapping
  if (n.nodeType === Node.ELEMENT_NODE) {
    var id = n.getAttribute('id');
    if (id) n.ownerDocument.delId(id, n);
  }
  n.ownerDocument._nodes[n._nid] = undefined;
  n._nid = undefined;
}

function recursivelyRoot(node) {
  root(node);
  // XXX:
  // accessing childNodes on a leaf node creates a new array the
  // first time, so be careful to write this loop so that it
  // doesn't do that. node is polymorphic, so maybe this is hard to
  // optimize?  Try switching on nodeType?
/*
  if (node.hasChildNodes()) {
    var kids = node.childNodes;
    for(var i = 0, n = kids.length;  i < n; i++)
      recursivelyRoot(kids[i]);
  }
*/
  if (node.nodeType === Node.ELEMENT_NODE) {
    var kids = node.childNodes;
    for(var i = 0, n = kids.length; i < n; i++)
      recursivelyRoot(kids[i]);
  }
}

function recursivelyUproot(node) {
  uproot(node);
  for(var i = 0, n = node.childNodes.length; i < n; i++)
    recursivelyUproot(node.childNodes[i]);
}

function recursivelySetOwner(node, owner) {
  node.ownerDocument = owner;
  node._lastModTime = undefined; // mod times are document-based
  var kids = node.childNodes;
  for(var i = 0, n = kids.length; i < n; i++)
    recursivelySetOwner(kids[i], owner);
}

// A class for storing multiple nodes with the same ID
function MultiId(node) {
  this.nodes = Object.create(null);
  this.nodes[node._nid] = node;
  this.length = 1;
  this.firstNode = undefined;
}

// Add a node to the list, with O(1) time
MultiId.prototype.add = function(node) {
  if (!this.nodes[node._nid]) {
    this.nodes[node._nid] = node;
    this.length++;
    this.firstNode = undefined;
  }
};

// Remove a node from the list, with O(1) time
MultiId.prototype.del = function(node) {
  if (this.nodes[node._nid]) {
    delete this.nodes[node._nid];
    this.length--;
    this.firstNode = undefined;
  }
};

// Get the first node from the list, in the document order
// Takes O(N) time in the size of the list, with a cache that is invalidated
// when the list is modified.
MultiId.prototype.getFirst = function() {
  /* jshint bitwise: false */
  if (!this.firstNode) {
    var nid;
    for (nid in this.nodes) {
      if (this.firstNode === undefined ||
        this.firstNode.compareDocumentPosition(this.nodes[nid]) & Node.DOCUMENT_POSITION_PRECEDING) {
        this.firstNode = this.nodes[nid];
      }
    }
  }
  return this.firstNode;
};

// If there is only one node left, return it. Otherwise return "this".
MultiId.prototype.downgrade = function() {
  if (this.length === 1) {
    var nid;
    for (nid in this.nodes) {
      return this.nodes[nid];
    }
  }
  return this;
};


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = DocumentType;

var Node = __webpack_require__(2);
var Leaf = __webpack_require__(33);
var utils = __webpack_require__(1);
var ChildNode = __webpack_require__(12);

function DocumentType(name, publicId, systemId) {
  // Unlike other nodes, doctype nodes always start off unowned
  // until inserted
  this.nodeType = Node.DOCUMENT_TYPE_NODE;
  this.ownerDocument = null;
  this.name = name;
  this.publicId = publicId || "";
  this.systemId = systemId || "";
}

DocumentType.prototype = Object.create(Leaf.prototype, {
  nodeName: { get: function() { return this.name; }},
  nodeValue: {
    get: function() { return null; },
    set: function() {}
  },

  // Utility methods
  clone: { value: function clone() {
    utils.DataCloneError();
  }},

  isEqual: { value: function isEqual(n) {
    return this.name === n.name &&
      this.publicId === n.publicId &&
      this.systemId === n.systemId;
  }}
});

Object.defineProperties(DocumentType.prototype, ChildNode);


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = HTMLParser;

var Document = __webpack_require__(13);
var DocumentType = __webpack_require__(14);
var Node = __webpack_require__(2);
var NAMESPACE = __webpack_require__(1).NAMESPACE;
var html = __webpack_require__(18);
var impl = html.elements;

var pushAll = Function.prototype.apply.bind(Array.prototype.push);

/*
 * This file contains an implementation of the HTML parsing algorithm.
 * The algorithm and the implementation are complex because HTML
 * explicitly defines how the parser should behave for all possible
 * valid and invalid inputs.
 *
 * Usage:
 *
 * The file defines a single HTMLParser() function, which dom.js exposes
 * publicly as document.implementation.mozHTMLParser(). This is a
 * factory function, not a constructor.
 *
 * When you call document.implementation.mozHTMLParser(), it returns
 * an object that has parse() and document() methods. To parse HTML text,
 * pass the text (in one or more chunks) to the parse() method.  When
 * you've passed all the text (on the last chunk, or afterward) pass
 * true as the second argument to parse() to tell the parser that there
 * is no more coming. Call document() to get the document object that
 * the parser is parsing into.  You can call this at any time, before
 * or after calling parse().
 *
 * The first argument to mozHTMLParser is the absolute URL of the document.
 *
 * The second argument is optional and is for internal use only.  Pass an
 * element as the fragmentContext to do innerHTML parsing for the
 * element.  To do innerHTML parsing on a document, pass null. Otherwise,
 * omit the 2nd argument. See HTMLElement.innerHTML for an example.  Note
 * that if you pass a context element, the end() method will return an
 * unwrapped document instead of a wrapped one.
 *
 * Implementation details:
 *
 * This is a long file of almost 7000 lines. It is structured as one
 * big function nested within another big function.  The outer
 * function defines a bunch of constant data, utility functions
 * that use that data, and a couple of classes used by the parser.
 * The outer function also defines and returns the
 * inner function. This inner function is the HTMLParser factory
 * function that implements the parser and holds all the parser state
 * as local variables.  The HTMLParser function is quite big because
 * it defines many nested functions that use those local variables.
 *
 * There are three tightly coupled parser stages: a scanner, a
 * tokenizer and a tree builder. In a (possibly misguided) attempt at
 * efficiency, the stages are not implemented as separate classes:
 * everything shares state and is (mostly) implemented in imperative
 * (rather than OO) style.
 *
 * The stages of the parser work like this: When the client code calls
 * the parser's parse() method, the specified string is passed to
 * scanChars(). The scanner loops through that string and passes characters
 * (sometimes one at a time, sometimes in chunks) to the tokenizer stage.
 * The tokenizer groups the characters into tokens: tags, endtags, runs
 * of text, comments, doctype declarations, and the end-of-file (EOF)
 * token.  These tokens are then passed to the tree building stage via
 * the insertToken() function.  The tree building stage builds up the
 * document tree.
 *
 * The tokenizer stage is a finite state machine.  Each state is
 * implemented as a function with a name that ends in "_state".  The
 * initial state is data_state(). The current tokenizer state is stored
 * in the variable 'tokenizer'.  Most state functions expect a single
 * integer argument which represents a single UTF-16 codepoint.  Some
 * states want more characters and set a lookahead property on
 * themselves.  The scanChars() function in the scanner checks for this
 * lookahead property.  If it doesn't exist, then scanChars() just passes
 * the next input character to the current tokenizer state function.
 * Otherwise, scanChars() looks ahead (a given # of characters, or for a
 * matching string, or for a matching regexp) and passes a string of
 * characters to the current tokenizer state function.
 *
 * As a shortcut, certain states of the tokenizer use regular expressions
 * to look ahead in the scanner's input buffer for runs of text, simple
 * tags and attributes.  For well-formed input, these shortcuts skip a
 * lot of state transitions and speed things up a bit.
 *
 * When a tokenizer state function has consumed a complete token, it
 * emits that token, by calling insertToken(), or by calling a utility
 * function that itself calls insertToken().  These tokens are passed to
 * the tree building stage, which is also a state machine.  Like the
 * tokenizer, the tree building states are implemented as functions, and
 * these functions have names that end with _mode (because the HTML spec
 * refers to them as insertion modes). The current insertion mode is held
 * by the 'parser' variable.  Each insertion mode function takes up to 4
 * arguments.  The first is a token type, represented by the constants
 * TAG, ENDTAG, TEXT, COMMENT, DOCTYPE and EOF.  The second argument is
 * the value of the token: the text or comment data, or tagname or
 * doctype.  For tags, the 3rd argument is an array of attributes.  For
 * DOCTYPES it is the optional public id.  For tags, the 4th argument is
 * true if the tag is self-closing. For doctypes, the 4th argument is the
 * optional system id.
 *
 * Search for "***" to find the major sub-divisions in the code.
 */


/***
 * Data prolog.  Lots of constants declared here, including some
 * very large objects.  They're used throughout the code that follows
 */
// Token types for the tree builder.
var EOF = -1;
var TEXT = 1;
var TAG = 2;
var ENDTAG = 3;
var COMMENT = 4;
var DOCTYPE = 5;

// A re-usable empty array
var NOATTRS = [];

// These DTD public ids put the browser in quirks mode
var quirkyPublicIds = /^HTML$|^-\/\/W3O\/\/DTD W3 HTML Strict 3\.0\/\/EN\/\/$|^-\/W3C\/DTD HTML 4\.0 Transitional\/EN$|^\+\/\/Silmaril\/\/dtd html Pro v0r11 19970101\/\/|^-\/\/AdvaSoft Ltd\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/AS\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict\/\/|^-\/\/IETF\/\/DTD HTML 2\.0\/\/|^-\/\/IETF\/\/DTD HTML 2\.1E\/\/|^-\/\/IETF\/\/DTD HTML 3\.0\/\/|^-\/\/IETF\/\/DTD HTML 3\.2 Final\/\/|^-\/\/IETF\/\/DTD HTML 3\.2\/\/|^-\/\/IETF\/\/DTD HTML 3\/\/|^-\/\/IETF\/\/DTD HTML Level 0\/\/|^-\/\/IETF\/\/DTD HTML Level 1\/\/|^-\/\/IETF\/\/DTD HTML Level 2\/\/|^-\/\/IETF\/\/DTD HTML Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 0\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict\/\/|^-\/\/IETF\/\/DTD HTML\/\/|^-\/\/Metrius\/\/DTD Metrius Presentational\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 Tables\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 Tables\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD HTML\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD Strict HTML\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML 2\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended 1\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended Relaxed 1\.0\/\/|^-\/\/SoftQuad Software\/\/DTD HoTMetaL PRO 6\.0::19990601::extensions to HTML 4\.0\/\/|^-\/\/SoftQuad\/\/DTD HoTMetaL PRO 4\.0::19971010::extensions to HTML 4\.0\/\/|^-\/\/Spyglass\/\/DTD HTML 2\.0 Extended\/\/|^-\/\/SQ\/\/DTD HTML 2\.0 HoTMetaL \+ extensions\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava HTML\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava Strict HTML\/\/|^-\/\/W3C\/\/DTD HTML 3 1995-03-24\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Draft\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Final\/\/|^-\/\/W3C\/\/DTD HTML 3\.2\/\/|^-\/\/W3C\/\/DTD HTML 3\.2S Draft\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Transitional\/\/|^-\/\/W3C\/\/DTD HTML Experimental 19960712\/\/|^-\/\/W3C\/\/DTD HTML Experimental 970421\/\/|^-\/\/W3C\/\/DTD W3 HTML\/\/|^-\/\/W3O\/\/DTD W3 HTML 3\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML 2\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML\/\//i;

var quirkySystemId = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";

var conditionallyQuirkyPublicIds = /^-\/\/W3C\/\/DTD HTML 4\.01 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.01 Transitional\/\//i;

// These DTD public ids put the browser in limited quirks mode
var limitedQuirkyPublicIds = /^-\/\/W3C\/\/DTD XHTML 1\.0 Frameset\/\/|^-\/\/W3C\/\/DTD XHTML 1\.0 Transitional\/\//i;


// Element sets below. See the isA() function for a way to test
// whether an element is a member of a set
var specialSet = Object.create(null);
specialSet[NAMESPACE.HTML] = {
  __proto__: null,
  "address":true, "applet":true, "area":true, "article":true,
  "aside":true, "base":true, "basefont":true, "bgsound":true,
  "blockquote":true, "body":true, "br":true, "button":true,
  "caption":true, "center":true, "col":true, "colgroup":true,
  "dd":true, "details":true, "dir":true,
  "div":true, "dl":true, "dt":true, "embed":true,
  "fieldset":true, "figcaption":true, "figure":true, "footer":true,
  "form":true, "frame":true, "frameset":true, "h1":true,
  "h2":true, "h3":true, "h4":true, "h5":true,
  "h6":true, "head":true, "header":true, "hgroup":true,
  "hr":true, "html":true, "iframe":true, "img":true,
  "input":true, "li":true, "link":true,
  "listing":true, "main":true, "marquee":true, "menu":true, "meta":true,
  "nav":true, "noembed":true, "noframes":true, "noscript":true,
  "object":true, "ol":true, "p":true, "param":true,
  "plaintext":true, "pre":true, "script":true, "section":true,
  "select":true, "source":true, "style":true, "summary":true, "table":true,
  "tbody":true, "td":true, "template":true, "textarea":true, "tfoot":true,
  "th":true, "thead":true, "title":true, "tr":true, "track":true,
  // Note that "xmp" was removed from the "special" set in the latest
  // spec, apparently by accident; see
  // https://github.com/whatwg/html/pull/1919
  "ul":true, "wbr":true, "xmp":true
};
specialSet[NAMESPACE.SVG] = {
  __proto__: null,
  "foreignObject": true, "desc": true, "title": true
};
specialSet[NAMESPACE.MATHML] = {
  __proto__: null,
  "mi":true, "mo":true, "mn":true, "ms":true,
  "mtext":true, "annotation-xml":true
};

// The set of address, div, and p HTML tags
var addressdivpSet = Object.create(null);
addressdivpSet[NAMESPACE.HTML] = {
  __proto__: null,
  "address":true, "div":true, "p":true
};

var dddtSet = Object.create(null);
dddtSet[NAMESPACE.HTML] = {
  __proto__: null,
  "dd":true, "dt":true
};

var tablesectionrowSet = Object.create(null);
tablesectionrowSet[NAMESPACE.HTML] = {
  __proto__: null,
  "table":true, "thead":true, "tbody":true, "tfoot":true, "tr":true
};

var impliedEndTagsSet = Object.create(null);
impliedEndTagsSet[NAMESPACE.HTML] = {
  __proto__: null,
  "dd": true, "dt": true, "li": true, "menuitem": true, "optgroup": true,
  "option": true, "p": true, "rb": true, "rp": true, "rt": true, "rtc": true
};

var thoroughImpliedEndTagsSet = Object.create(null);
thoroughImpliedEndTagsSet[NAMESPACE.HTML] = {
  __proto__: null,
  "caption": true, "colgroup": true, "dd": true, "dt": true, "li": true,
  "optgroup": true, "option": true, "p": true, "rb": true, "rp": true,
  "rt": true, "rtc": true, "tbody": true, "td": true, "tfoot": true,
  "th": true, "thead": true, "tr": true
};

var tableContextSet = Object.create(null);
tableContextSet[NAMESPACE.HTML] = {
  __proto__: null,
  "table": true, "template": true, "html": true
};

var tableBodyContextSet = Object.create(null);
tableBodyContextSet[NAMESPACE.HTML] = {
  __proto__: null,
  "tbody": true, "tfoot": true, "thead": true, "template": true, "html": true
};

var tableRowContextSet = Object.create(null);
tableRowContextSet[NAMESPACE.HTML] = {
  __proto__: null,
  "tr": true, "template": true, "html": true
};

// See http://www.w3.org/TR/html5/forms.html#form-associated-element
var formassociatedSet = Object.create(null);
formassociatedSet[NAMESPACE.HTML] = {
  __proto__: null,
  "button": true, "fieldset": true, "input": true, "keygen": true,
  "object": true, "output": true, "select": true, "textarea": true,
  "img": true
};

var inScopeSet = Object.create(null);
inScopeSet[NAMESPACE.HTML]= {
  __proto__: null,
  "applet":true, "caption":true, "html":true, "table":true,
  "td":true, "th":true, "marquee":true, "object":true,
  "template":true
};
inScopeSet[NAMESPACE.MATHML] = {
  __proto__: null,
  "mi":true, "mo":true, "mn":true, "ms":true,
  "mtext":true, "annotation-xml":true
};
inScopeSet[NAMESPACE.SVG] = {
  __proto__: null,
  "foreignObject":true, "desc":true, "title":true
};

var inListItemScopeSet = Object.create(inScopeSet);
inListItemScopeSet[NAMESPACE.HTML] =
  Object.create(inScopeSet[NAMESPACE.HTML]);
inListItemScopeSet[NAMESPACE.HTML].ol = true;
inListItemScopeSet[NAMESPACE.HTML].ul = true;

var inButtonScopeSet = Object.create(inScopeSet);
inButtonScopeSet[NAMESPACE.HTML] =
  Object.create(inScopeSet[NAMESPACE.HTML]);
inButtonScopeSet[NAMESPACE.HTML].button = true;

var inTableScopeSet = Object.create(null);
inTableScopeSet[NAMESPACE.HTML] = {
  __proto__: null,
  "html":true, "table":true, "template":true
};

// The set of elements for select scope is the everything *except* these
var invertedSelectScopeSet = Object.create(null);
invertedSelectScopeSet[NAMESPACE.HTML] = {
  __proto__: null,
  "optgroup":true, "option":true
};

var mathmlTextIntegrationPointSet = Object.create(null);
mathmlTextIntegrationPointSet[NAMESPACE.MATHML] = {
  __proto__: null,
  mi: true,
  mo: true,
  mn: true,
  ms: true,
  mtext: true
};

var htmlIntegrationPointSet = Object.create(null);
htmlIntegrationPointSet[NAMESPACE.SVG] = {
  __proto__: null,
  foreignObject: true,
  desc: true,
  title: true
};

var foreignAttributes = {
  __proto__: null,
  "xlink:actuate": NAMESPACE.XLINK, "xlink:arcrole": NAMESPACE.XLINK,
  "xlink:href":   NAMESPACE.XLINK,  "xlink:role":    NAMESPACE.XLINK,
  "xlink:show":   NAMESPACE.XLINK,  "xlink:title":   NAMESPACE.XLINK,
  "xlink:type":   NAMESPACE.XLINK,  "xml:base":      NAMESPACE.XML,
  "xml:lang":     NAMESPACE.XML,    "xml:space":     NAMESPACE.XML,
  "xmlns":        NAMESPACE.XMLNS,  "xmlns:xlink":   NAMESPACE.XMLNS
};


// Lowercase to mixed case mapping for SVG attributes and tagnames
var svgAttrAdjustments = {
  __proto__: null,
  attributename: "attributeName", attributetype: "attributeType",
  basefrequency: "baseFrequency", baseprofile: "baseProfile",
  calcmode: "calcMode", clippathunits: "clipPathUnits",
  diffuseconstant: "diffuseConstant",
  edgemode: "edgeMode",
  filterunits: "filterUnits",
  glyphref: "glyphRef", gradienttransform: "gradientTransform",
  gradientunits: "gradientUnits", kernelmatrix: "kernelMatrix",
  kernelunitlength: "kernelUnitLength", keypoints: "keyPoints",
  keysplines: "keySplines", keytimes: "keyTimes",
  lengthadjust: "lengthAdjust", limitingconeangle: "limitingConeAngle",
  markerheight: "markerHeight", markerunits: "markerUnits",
  markerwidth: "markerWidth", maskcontentunits: "maskContentUnits",
  maskunits: "maskUnits", numoctaves: "numOctaves",
  pathlength: "pathLength", patterncontentunits: "patternContentUnits",
  patterntransform: "patternTransform", patternunits: "patternUnits",
  pointsatx: "pointsAtX", pointsaty: "pointsAtY",
  pointsatz: "pointsAtZ", preservealpha: "preserveAlpha",
  preserveaspectratio: "preserveAspectRatio",
  primitiveunits: "primitiveUnits", refx: "refX",
  refy: "refY", repeatcount: "repeatCount",
  repeatdur: "repeatDur", requiredextensions: "requiredExtensions",
  requiredfeatures: "requiredFeatures",
  specularconstant: "specularConstant",
  specularexponent: "specularExponent", spreadmethod: "spreadMethod",
  startoffset: "startOffset", stddeviation: "stdDeviation",
  stitchtiles: "stitchTiles", surfacescale: "surfaceScale",
  systemlanguage: "systemLanguage", tablevalues: "tableValues",
  targetx: "targetX", targety: "targetY",
  textlength: "textLength", viewbox: "viewBox",
  viewtarget: "viewTarget", xchannelselector: "xChannelSelector",
  ychannelselector: "yChannelSelector", zoomandpan: "zoomAndPan"
};

var svgTagNameAdjustments = {
  __proto__: null,
  altglyph: "altGlyph", altglyphdef: "altGlyphDef",
  altglyphitem: "altGlyphItem", animatecolor: "animateColor",
  animatemotion: "animateMotion", animatetransform: "animateTransform",
  clippath: "clipPath", feblend: "feBlend",
  fecolormatrix: "feColorMatrix",
  fecomponenttransfer: "feComponentTransfer", fecomposite: "feComposite",
  feconvolvematrix: "feConvolveMatrix",
  fediffuselighting: "feDiffuseLighting",
  fedisplacementmap: "feDisplacementMap",
  fedistantlight: "feDistantLight", feflood: "feFlood",
  fefunca: "feFuncA", fefuncb: "feFuncB",
  fefuncg: "feFuncG", fefuncr: "feFuncR",
  fegaussianblur: "feGaussianBlur", feimage: "feImage",
  femerge: "feMerge", femergenode: "feMergeNode",
  femorphology: "feMorphology", feoffset: "feOffset",
  fepointlight: "fePointLight", fespecularlighting: "feSpecularLighting",
  fespotlight: "feSpotLight", fetile: "feTile",
  feturbulence: "feTurbulence", foreignobject: "foreignObject",
  glyphref: "glyphRef", lineargradient: "linearGradient",
  radialgradient: "radialGradient", textpath: "textPath"
};


// Data for parsing numeric and named character references
// These next 3 objects are direct translations of tables
// in the HTML spec into JavaScript object format
var numericCharRefReplacements = {
  __proto__: null,
  0x00:0xFFFD, 0x80:0x20AC, 0x82:0x201A, 0x83:0x0192, 0x84:0x201E,
  0x85:0x2026, 0x86:0x2020, 0x87:0x2021, 0x88:0x02C6, 0x89:0x2030,
  0x8A:0x0160, 0x8B:0x2039, 0x8C:0x0152, 0x8E:0x017D, 0x91:0x2018,
  0x92:0x2019, 0x93:0x201C, 0x94:0x201D, 0x95:0x2022, 0x96:0x2013,
  0x97:0x2014, 0x98:0x02DC, 0x99:0x2122, 0x9A:0x0161, 0x9B:0x203A,
  0x9C:0x0153, 0x9E:0x017E, 0x9F:0x0178
};

/*
 * This table is generated with test/tools/update-entities.js
 */
var namedCharRefs = {
  __proto__: null,
  "AElig":0xc6, "AElig;":0xc6,
  "AMP":0x26, "AMP;":0x26,
  "Aacute":0xc1, "Aacute;":0xc1,
  "Abreve;":0x102, "Acirc":0xc2,
  "Acirc;":0xc2, "Acy;":0x410,
  "Afr;":[0xd835,0xdd04], "Agrave":0xc0,
  "Agrave;":0xc0, "Alpha;":0x391,
  "Amacr;":0x100, "And;":0x2a53,
  "Aogon;":0x104, "Aopf;":[0xd835,0xdd38],
  "ApplyFunction;":0x2061, "Aring":0xc5,
  "Aring;":0xc5, "Ascr;":[0xd835,0xdc9c],
  "Assign;":0x2254, "Atilde":0xc3,
  "Atilde;":0xc3, "Auml":0xc4,
  "Auml;":0xc4, "Backslash;":0x2216,
  "Barv;":0x2ae7, "Barwed;":0x2306,
  "Bcy;":0x411, "Because;":0x2235,
  "Bernoullis;":0x212c, "Beta;":0x392,
  "Bfr;":[0xd835,0xdd05], "Bopf;":[0xd835,0xdd39],
  "Breve;":0x2d8, "Bscr;":0x212c,
  "Bumpeq;":0x224e, "CHcy;":0x427,
  "COPY":0xa9, "COPY;":0xa9,
  "Cacute;":0x106, "Cap;":0x22d2,
  "CapitalDifferentialD;":0x2145, "Cayleys;":0x212d,
  "Ccaron;":0x10c, "Ccedil":0xc7,
  "Ccedil;":0xc7, "Ccirc;":0x108,
  "Cconint;":0x2230, "Cdot;":0x10a,
  "Cedilla;":0xb8, "CenterDot;":0xb7,
  "Cfr;":0x212d, "Chi;":0x3a7,
  "CircleDot;":0x2299, "CircleMinus;":0x2296,
  "CirclePlus;":0x2295, "CircleTimes;":0x2297,
  "ClockwiseContourIntegral;":0x2232, "CloseCurlyDoubleQuote;":0x201d,
  "CloseCurlyQuote;":0x2019, "Colon;":0x2237,
  "Colone;":0x2a74, "Congruent;":0x2261,
  "Conint;":0x222f, "ContourIntegral;":0x222e,
  "Copf;":0x2102, "Coproduct;":0x2210,
  "CounterClockwiseContourIntegral;":0x2233, "Cross;":0x2a2f,
  "Cscr;":[0xd835,0xdc9e], "Cup;":0x22d3,
  "CupCap;":0x224d, "DD;":0x2145,
  "DDotrahd;":0x2911, "DJcy;":0x402,
  "DScy;":0x405, "DZcy;":0x40f,
  "Dagger;":0x2021, "Darr;":0x21a1,
  "Dashv;":0x2ae4, "Dcaron;":0x10e,
  "Dcy;":0x414, "Del;":0x2207,
  "Delta;":0x394, "Dfr;":[0xd835,0xdd07],
  "DiacriticalAcute;":0xb4, "DiacriticalDot;":0x2d9,
  "DiacriticalDoubleAcute;":0x2dd, "DiacriticalGrave;":0x60,
  "DiacriticalTilde;":0x2dc, "Diamond;":0x22c4,
  "DifferentialD;":0x2146, "Dopf;":[0xd835,0xdd3b],
  "Dot;":0xa8, "DotDot;":0x20dc,
  "DotEqual;":0x2250, "DoubleContourIntegral;":0x222f,
  "DoubleDot;":0xa8, "DoubleDownArrow;":0x21d3,
  "DoubleLeftArrow;":0x21d0, "DoubleLeftRightArrow;":0x21d4,
  "DoubleLeftTee;":0x2ae4, "DoubleLongLeftArrow;":0x27f8,
  "DoubleLongLeftRightArrow;":0x27fa, "DoubleLongRightArrow;":0x27f9,
  "DoubleRightArrow;":0x21d2, "DoubleRightTee;":0x22a8,
  "DoubleUpArrow;":0x21d1, "DoubleUpDownArrow;":0x21d5,
  "DoubleVerticalBar;":0x2225, "DownArrow;":0x2193,
  "DownArrowBar;":0x2913, "DownArrowUpArrow;":0x21f5,
  "DownBreve;":0x311, "DownLeftRightVector;":0x2950,
  "DownLeftTeeVector;":0x295e, "DownLeftVector;":0x21bd,
  "DownLeftVectorBar;":0x2956, "DownRightTeeVector;":0x295f,
  "DownRightVector;":0x21c1, "DownRightVectorBar;":0x2957,
  "DownTee;":0x22a4, "DownTeeArrow;":0x21a7,
  "Downarrow;":0x21d3, "Dscr;":[0xd835,0xdc9f],
  "Dstrok;":0x110, "ENG;":0x14a,
  "ETH":0xd0, "ETH;":0xd0,
  "Eacute":0xc9, "Eacute;":0xc9,
  "Ecaron;":0x11a, "Ecirc":0xca,
  "Ecirc;":0xca, "Ecy;":0x42d,
  "Edot;":0x116, "Efr;":[0xd835,0xdd08],
  "Egrave":0xc8, "Egrave;":0xc8,
  "Element;":0x2208, "Emacr;":0x112,
  "EmptySmallSquare;":0x25fb, "EmptyVerySmallSquare;":0x25ab,
  "Eogon;":0x118, "Eopf;":[0xd835,0xdd3c],
  "Epsilon;":0x395, "Equal;":0x2a75,
  "EqualTilde;":0x2242, "Equilibrium;":0x21cc,
  "Escr;":0x2130, "Esim;":0x2a73,
  "Eta;":0x397, "Euml":0xcb,
  "Euml;":0xcb, "Exists;":0x2203,
  "ExponentialE;":0x2147, "Fcy;":0x424,
  "Ffr;":[0xd835,0xdd09], "FilledSmallSquare;":0x25fc,
  "FilledVerySmallSquare;":0x25aa, "Fopf;":[0xd835,0xdd3d],
  "ForAll;":0x2200, "Fouriertrf;":0x2131,
  "Fscr;":0x2131, "GJcy;":0x403,
  "GT":0x3e, "GT;":0x3e,
  "Gamma;":0x393, "Gammad;":0x3dc,
  "Gbreve;":0x11e, "Gcedil;":0x122,
  "Gcirc;":0x11c, "Gcy;":0x413,
  "Gdot;":0x120, "Gfr;":[0xd835,0xdd0a],
  "Gg;":0x22d9, "Gopf;":[0xd835,0xdd3e],
  "GreaterEqual;":0x2265, "GreaterEqualLess;":0x22db,
  "GreaterFullEqual;":0x2267, "GreaterGreater;":0x2aa2,
  "GreaterLess;":0x2277, "GreaterSlantEqual;":0x2a7e,
  "GreaterTilde;":0x2273, "Gscr;":[0xd835,0xdca2],
  "Gt;":0x226b, "HARDcy;":0x42a,
  "Hacek;":0x2c7, "Hat;":0x5e,
  "Hcirc;":0x124, "Hfr;":0x210c,
  "HilbertSpace;":0x210b, "Hopf;":0x210d,
  "HorizontalLine;":0x2500, "Hscr;":0x210b,
  "Hstrok;":0x126, "HumpDownHump;":0x224e,
  "HumpEqual;":0x224f, "IEcy;":0x415,
  "IJlig;":0x132, "IOcy;":0x401,
  "Iacute":0xcd, "Iacute;":0xcd,
  "Icirc":0xce, "Icirc;":0xce,
  "Icy;":0x418, "Idot;":0x130,
  "Ifr;":0x2111, "Igrave":0xcc,
  "Igrave;":0xcc, "Im;":0x2111,
  "Imacr;":0x12a, "ImaginaryI;":0x2148,
  "Implies;":0x21d2, "Int;":0x222c,
  "Integral;":0x222b, "Intersection;":0x22c2,
  "InvisibleComma;":0x2063, "InvisibleTimes;":0x2062,
  "Iogon;":0x12e, "Iopf;":[0xd835,0xdd40],
  "Iota;":0x399, "Iscr;":0x2110,
  "Itilde;":0x128, "Iukcy;":0x406,
  "Iuml":0xcf, "Iuml;":0xcf,
  "Jcirc;":0x134, "Jcy;":0x419,
  "Jfr;":[0xd835,0xdd0d], "Jopf;":[0xd835,0xdd41],
  "Jscr;":[0xd835,0xdca5], "Jsercy;":0x408,
  "Jukcy;":0x404, "KHcy;":0x425,
  "KJcy;":0x40c, "Kappa;":0x39a,
  "Kcedil;":0x136, "Kcy;":0x41a,
  "Kfr;":[0xd835,0xdd0e], "Kopf;":[0xd835,0xdd42],
  "Kscr;":[0xd835,0xdca6], "LJcy;":0x409,
  "LT":0x3c, "LT;":0x3c,
  "Lacute;":0x139, "Lambda;":0x39b,
  "Lang;":0x27ea, "Laplacetrf;":0x2112,
  "Larr;":0x219e, "Lcaron;":0x13d,
  "Lcedil;":0x13b, "Lcy;":0x41b,
  "LeftAngleBracket;":0x27e8, "LeftArrow;":0x2190,
  "LeftArrowBar;":0x21e4, "LeftArrowRightArrow;":0x21c6,
  "LeftCeiling;":0x2308, "LeftDoubleBracket;":0x27e6,
  "LeftDownTeeVector;":0x2961, "LeftDownVector;":0x21c3,
  "LeftDownVectorBar;":0x2959, "LeftFloor;":0x230a,
  "LeftRightArrow;":0x2194, "LeftRightVector;":0x294e,
  "LeftTee;":0x22a3, "LeftTeeArrow;":0x21a4,
  "LeftTeeVector;":0x295a, "LeftTriangle;":0x22b2,
  "LeftTriangleBar;":0x29cf, "LeftTriangleEqual;":0x22b4,
  "LeftUpDownVector;":0x2951, "LeftUpTeeVector;":0x2960,
  "LeftUpVector;":0x21bf, "LeftUpVectorBar;":0x2958,
  "LeftVector;":0x21bc, "LeftVectorBar;":0x2952,
  "Leftarrow;":0x21d0, "Leftrightarrow;":0x21d4,
  "LessEqualGreater;":0x22da, "LessFullEqual;":0x2266,
  "LessGreater;":0x2276, "LessLess;":0x2aa1,
  "LessSlantEqual;":0x2a7d, "LessTilde;":0x2272,
  "Lfr;":[0xd835,0xdd0f], "Ll;":0x22d8,
  "Lleftarrow;":0x21da, "Lmidot;":0x13f,
  "LongLeftArrow;":0x27f5, "LongLeftRightArrow;":0x27f7,
  "LongRightArrow;":0x27f6, "Longleftarrow;":0x27f8,
  "Longleftrightarrow;":0x27fa, "Longrightarrow;":0x27f9,
  "Lopf;":[0xd835,0xdd43], "LowerLeftArrow;":0x2199,
  "LowerRightArrow;":0x2198, "Lscr;":0x2112,
  "Lsh;":0x21b0, "Lstrok;":0x141,
  "Lt;":0x226a, "Map;":0x2905,
  "Mcy;":0x41c, "MediumSpace;":0x205f,
  "Mellintrf;":0x2133, "Mfr;":[0xd835,0xdd10],
  "MinusPlus;":0x2213, "Mopf;":[0xd835,0xdd44],
  "Mscr;":0x2133, "Mu;":0x39c,
  "NJcy;":0x40a, "Nacute;":0x143,
  "Ncaron;":0x147, "Ncedil;":0x145,
  "Ncy;":0x41d, "NegativeMediumSpace;":0x200b,
  "NegativeThickSpace;":0x200b, "NegativeThinSpace;":0x200b,
  "NegativeVeryThinSpace;":0x200b, "NestedGreaterGreater;":0x226b,
  "NestedLessLess;":0x226a, "NewLine;":0xa,
  "Nfr;":[0xd835,0xdd11], "NoBreak;":0x2060,
  "NonBreakingSpace;":0xa0, "Nopf;":0x2115,
  "Not;":0x2aec, "NotCongruent;":0x2262,
  "NotCupCap;":0x226d, "NotDoubleVerticalBar;":0x2226,
  "NotElement;":0x2209, "NotEqual;":0x2260,
  "NotEqualTilde;":[0x2242,0x338], "NotExists;":0x2204,
  "NotGreater;":0x226f, "NotGreaterEqual;":0x2271,
  "NotGreaterFullEqual;":[0x2267,0x338], "NotGreaterGreater;":[0x226b,0x338],
  "NotGreaterLess;":0x2279, "NotGreaterSlantEqual;":[0x2a7e,0x338],
  "NotGreaterTilde;":0x2275, "NotHumpDownHump;":[0x224e,0x338],
  "NotHumpEqual;":[0x224f,0x338], "NotLeftTriangle;":0x22ea,
  "NotLeftTriangleBar;":[0x29cf,0x338], "NotLeftTriangleEqual;":0x22ec,
  "NotLess;":0x226e, "NotLessEqual;":0x2270,
  "NotLessGreater;":0x2278, "NotLessLess;":[0x226a,0x338],
  "NotLessSlantEqual;":[0x2a7d,0x338], "NotLessTilde;":0x2274,
  "NotNestedGreaterGreater;":[0x2aa2,0x338], "NotNestedLessLess;":[0x2aa1,0x338],
  "NotPrecedes;":0x2280, "NotPrecedesEqual;":[0x2aaf,0x338],
  "NotPrecedesSlantEqual;":0x22e0, "NotReverseElement;":0x220c,
  "NotRightTriangle;":0x22eb, "NotRightTriangleBar;":[0x29d0,0x338],
  "NotRightTriangleEqual;":0x22ed, "NotSquareSubset;":[0x228f,0x338],
  "NotSquareSubsetEqual;":0x22e2, "NotSquareSuperset;":[0x2290,0x338],
  "NotSquareSupersetEqual;":0x22e3, "NotSubset;":[0x2282,0x20d2],
  "NotSubsetEqual;":0x2288, "NotSucceeds;":0x2281,
  "NotSucceedsEqual;":[0x2ab0,0x338], "NotSucceedsSlantEqual;":0x22e1,
  "NotSucceedsTilde;":[0x227f,0x338], "NotSuperset;":[0x2283,0x20d2],
  "NotSupersetEqual;":0x2289, "NotTilde;":0x2241,
  "NotTildeEqual;":0x2244, "NotTildeFullEqual;":0x2247,
  "NotTildeTilde;":0x2249, "NotVerticalBar;":0x2224,
  "Nscr;":[0xd835,0xdca9], "Ntilde":0xd1,
  "Ntilde;":0xd1, "Nu;":0x39d,
  "OElig;":0x152, "Oacute":0xd3,
  "Oacute;":0xd3, "Ocirc":0xd4,
  "Ocirc;":0xd4, "Ocy;":0x41e,
  "Odblac;":0x150, "Ofr;":[0xd835,0xdd12],
  "Ograve":0xd2, "Ograve;":0xd2,
  "Omacr;":0x14c, "Omega;":0x3a9,
  "Omicron;":0x39f, "Oopf;":[0xd835,0xdd46],
  "OpenCurlyDoubleQuote;":0x201c, "OpenCurlyQuote;":0x2018,
  "Or;":0x2a54, "Oscr;":[0xd835,0xdcaa],
  "Oslash":0xd8, "Oslash;":0xd8,
  "Otilde":0xd5, "Otilde;":0xd5,
  "Otimes;":0x2a37, "Ouml":0xd6,
  "Ouml;":0xd6, "OverBar;":0x203e,
  "OverBrace;":0x23de, "OverBracket;":0x23b4,
  "OverParenthesis;":0x23dc, "PartialD;":0x2202,
  "Pcy;":0x41f, "Pfr;":[0xd835,0xdd13],
  "Phi;":0x3a6, "Pi;":0x3a0,
  "PlusMinus;":0xb1, "Poincareplane;":0x210c,
  "Popf;":0x2119, "Pr;":0x2abb,
  "Precedes;":0x227a, "PrecedesEqual;":0x2aaf,
  "PrecedesSlantEqual;":0x227c, "PrecedesTilde;":0x227e,
  "Prime;":0x2033, "Product;":0x220f,
  "Proportion;":0x2237, "Proportional;":0x221d,
  "Pscr;":[0xd835,0xdcab], "Psi;":0x3a8,
  "QUOT":0x22, "QUOT;":0x22,
  "Qfr;":[0xd835,0xdd14], "Qopf;":0x211a,
  "Qscr;":[0xd835,0xdcac], "RBarr;":0x2910,
  "REG":0xae, "REG;":0xae,
  "Racute;":0x154, "Rang;":0x27eb,
  "Rarr;":0x21a0, "Rarrtl;":0x2916,
  "Rcaron;":0x158, "Rcedil;":0x156,
  "Rcy;":0x420, "Re;":0x211c,
  "ReverseElement;":0x220b, "ReverseEquilibrium;":0x21cb,
  "ReverseUpEquilibrium;":0x296f, "Rfr;":0x211c,
  "Rho;":0x3a1, "RightAngleBracket;":0x27e9,
  "RightArrow;":0x2192, "RightArrowBar;":0x21e5,
  "RightArrowLeftArrow;":0x21c4, "RightCeiling;":0x2309,
  "RightDoubleBracket;":0x27e7, "RightDownTeeVector;":0x295d,
  "RightDownVector;":0x21c2, "RightDownVectorBar;":0x2955,
  "RightFloor;":0x230b, "RightTee;":0x22a2,
  "RightTeeArrow;":0x21a6, "RightTeeVector;":0x295b,
  "RightTriangle;":0x22b3, "RightTriangleBar;":0x29d0,
  "RightTriangleEqual;":0x22b5, "RightUpDownVector;":0x294f,
  "RightUpTeeVector;":0x295c, "RightUpVector;":0x21be,
  "RightUpVectorBar;":0x2954, "RightVector;":0x21c0,
  "RightVectorBar;":0x2953, "Rightarrow;":0x21d2,
  "Ropf;":0x211d, "RoundImplies;":0x2970,
  "Rrightarrow;":0x21db, "Rscr;":0x211b,
  "Rsh;":0x21b1, "RuleDelayed;":0x29f4,
  "SHCHcy;":0x429, "SHcy;":0x428,
  "SOFTcy;":0x42c, "Sacute;":0x15a,
  "Sc;":0x2abc, "Scaron;":0x160,
  "Scedil;":0x15e, "Scirc;":0x15c,
  "Scy;":0x421, "Sfr;":[0xd835,0xdd16],
  "ShortDownArrow;":0x2193, "ShortLeftArrow;":0x2190,
  "ShortRightArrow;":0x2192, "ShortUpArrow;":0x2191,
  "Sigma;":0x3a3, "SmallCircle;":0x2218,
  "Sopf;":[0xd835,0xdd4a], "Sqrt;":0x221a,
  "Square;":0x25a1, "SquareIntersection;":0x2293,
  "SquareSubset;":0x228f, "SquareSubsetEqual;":0x2291,
  "SquareSuperset;":0x2290, "SquareSupersetEqual;":0x2292,
  "SquareUnion;":0x2294, "Sscr;":[0xd835,0xdcae],
  "Star;":0x22c6, "Sub;":0x22d0,
  "Subset;":0x22d0, "SubsetEqual;":0x2286,
  "Succeeds;":0x227b, "SucceedsEqual;":0x2ab0,
  "SucceedsSlantEqual;":0x227d, "SucceedsTilde;":0x227f,
  "SuchThat;":0x220b, "Sum;":0x2211,
  "Sup;":0x22d1, "Superset;":0x2283,
  "SupersetEqual;":0x2287, "Supset;":0x22d1,
  "THORN":0xde, "THORN;":0xde,
  "TRADE;":0x2122, "TSHcy;":0x40b,
  "TScy;":0x426, "Tab;":0x9,
  "Tau;":0x3a4, "Tcaron;":0x164,
  "Tcedil;":0x162, "Tcy;":0x422,
  "Tfr;":[0xd835,0xdd17], "Therefore;":0x2234,
  "Theta;":0x398, "ThickSpace;":[0x205f,0x200a],
  "ThinSpace;":0x2009, "Tilde;":0x223c,
  "TildeEqual;":0x2243, "TildeFullEqual;":0x2245,
  "TildeTilde;":0x2248, "Topf;":[0xd835,0xdd4b],
  "TripleDot;":0x20db, "Tscr;":[0xd835,0xdcaf],
  "Tstrok;":0x166, "Uacute":0xda,
  "Uacute;":0xda, "Uarr;":0x219f,
  "Uarrocir;":0x2949, "Ubrcy;":0x40e,
  "Ubreve;":0x16c, "Ucirc":0xdb,
  "Ucirc;":0xdb, "Ucy;":0x423,
  "Udblac;":0x170, "Ufr;":[0xd835,0xdd18],
  "Ugrave":0xd9, "Ugrave;":0xd9,
  "Umacr;":0x16a, "UnderBar;":0x5f,
  "UnderBrace;":0x23df, "UnderBracket;":0x23b5,
  "UnderParenthesis;":0x23dd, "Union;":0x22c3,
  "UnionPlus;":0x228e, "Uogon;":0x172,
  "Uopf;":[0xd835,0xdd4c], "UpArrow;":0x2191,
  "UpArrowBar;":0x2912, "UpArrowDownArrow;":0x21c5,
  "UpDownArrow;":0x2195, "UpEquilibrium;":0x296e,
  "UpTee;":0x22a5, "UpTeeArrow;":0x21a5,
  "Uparrow;":0x21d1, "Updownarrow;":0x21d5,
  "UpperLeftArrow;":0x2196, "UpperRightArrow;":0x2197,
  "Upsi;":0x3d2, "Upsilon;":0x3a5,
  "Uring;":0x16e, "Uscr;":[0xd835,0xdcb0],
  "Utilde;":0x168, "Uuml":0xdc,
  "Uuml;":0xdc, "VDash;":0x22ab,
  "Vbar;":0x2aeb, "Vcy;":0x412,
  "Vdash;":0x22a9, "Vdashl;":0x2ae6,
  "Vee;":0x22c1, "Verbar;":0x2016,
  "Vert;":0x2016, "VerticalBar;":0x2223,
  "VerticalLine;":0x7c, "VerticalSeparator;":0x2758,
  "VerticalTilde;":0x2240, "VeryThinSpace;":0x200a,
  "Vfr;":[0xd835,0xdd19], "Vopf;":[0xd835,0xdd4d],
  "Vscr;":[0xd835,0xdcb1], "Vvdash;":0x22aa,
  "Wcirc;":0x174, "Wedge;":0x22c0,
  "Wfr;":[0xd835,0xdd1a], "Wopf;":[0xd835,0xdd4e],
  "Wscr;":[0xd835,0xdcb2], "Xfr;":[0xd835,0xdd1b],
  "Xi;":0x39e, "Xopf;":[0xd835,0xdd4f],
  "Xscr;":[0xd835,0xdcb3], "YAcy;":0x42f,
  "YIcy;":0x407, "YUcy;":0x42e,
  "Yacute":0xdd, "Yacute;":0xdd,
  "Ycirc;":0x176, "Ycy;":0x42b,
  "Yfr;":[0xd835,0xdd1c], "Yopf;":[0xd835,0xdd50],
  "Yscr;":[0xd835,0xdcb4], "Yuml;":0x178,
  "ZHcy;":0x416, "Zacute;":0x179,
  "Zcaron;":0x17d, "Zcy;":0x417,
  "Zdot;":0x17b, "ZeroWidthSpace;":0x200b,
  "Zeta;":0x396, "Zfr;":0x2128,
  "Zopf;":0x2124, "Zscr;":[0xd835,0xdcb5],
  "aacute":0xe1, "aacute;":0xe1,
  "abreve;":0x103, "ac;":0x223e,
  "acE;":[0x223e,0x333], "acd;":0x223f,
  "acirc":0xe2, "acirc;":0xe2,
  "acute":0xb4, "acute;":0xb4,
  "acy;":0x430, "aelig":0xe6,
  "aelig;":0xe6, "af;":0x2061,
  "afr;":[0xd835,0xdd1e], "agrave":0xe0,
  "agrave;":0xe0, "alefsym;":0x2135,
  "aleph;":0x2135, "alpha;":0x3b1,
  "amacr;":0x101, "amalg;":0x2a3f,
  "amp":0x26, "amp;":0x26,
  "and;":0x2227, "andand;":0x2a55,
  "andd;":0x2a5c, "andslope;":0x2a58,
  "andv;":0x2a5a, "ang;":0x2220,
  "ange;":0x29a4, "angle;":0x2220,
  "angmsd;":0x2221, "angmsdaa;":0x29a8,
  "angmsdab;":0x29a9, "angmsdac;":0x29aa,
  "angmsdad;":0x29ab, "angmsdae;":0x29ac,
  "angmsdaf;":0x29ad, "angmsdag;":0x29ae,
  "angmsdah;":0x29af, "angrt;":0x221f,
  "angrtvb;":0x22be, "angrtvbd;":0x299d,
  "angsph;":0x2222, "angst;":0xc5,
  "angzarr;":0x237c, "aogon;":0x105,
  "aopf;":[0xd835,0xdd52], "ap;":0x2248,
  "apE;":0x2a70, "apacir;":0x2a6f,
  "ape;":0x224a, "apid;":0x224b,
  "apos;":0x27, "approx;":0x2248,
  "approxeq;":0x224a, "aring":0xe5,
  "aring;":0xe5, "ascr;":[0xd835,0xdcb6],
  "ast;":0x2a, "asymp;":0x2248,
  "asympeq;":0x224d, "atilde":0xe3,
  "atilde;":0xe3, "auml":0xe4,
  "auml;":0xe4, "awconint;":0x2233,
  "awint;":0x2a11, "bNot;":0x2aed,
  "backcong;":0x224c, "backepsilon;":0x3f6,
  "backprime;":0x2035, "backsim;":0x223d,
  "backsimeq;":0x22cd, "barvee;":0x22bd,
  "barwed;":0x2305, "barwedge;":0x2305,
  "bbrk;":0x23b5, "bbrktbrk;":0x23b6,
  "bcong;":0x224c, "bcy;":0x431,
  "bdquo;":0x201e, "becaus;":0x2235,
  "because;":0x2235, "bemptyv;":0x29b0,
  "bepsi;":0x3f6, "bernou;":0x212c,
  "beta;":0x3b2, "beth;":0x2136,
  "between;":0x226c, "bfr;":[0xd835,0xdd1f],
  "bigcap;":0x22c2, "bigcirc;":0x25ef,
  "bigcup;":0x22c3, "bigodot;":0x2a00,
  "bigoplus;":0x2a01, "bigotimes;":0x2a02,
  "bigsqcup;":0x2a06, "bigstar;":0x2605,
  "bigtriangledown;":0x25bd, "bigtriangleup;":0x25b3,
  "biguplus;":0x2a04, "bigvee;":0x22c1,
  "bigwedge;":0x22c0, "bkarow;":0x290d,
  "blacklozenge;":0x29eb, "blacksquare;":0x25aa,
  "blacktriangle;":0x25b4, "blacktriangledown;":0x25be,
  "blacktriangleleft;":0x25c2, "blacktriangleright;":0x25b8,
  "blank;":0x2423, "blk12;":0x2592,
  "blk14;":0x2591, "blk34;":0x2593,
  "block;":0x2588, "bne;":[0x3d,0x20e5],
  "bnequiv;":[0x2261,0x20e5], "bnot;":0x2310,
  "bopf;":[0xd835,0xdd53], "bot;":0x22a5,
  "bottom;":0x22a5, "bowtie;":0x22c8,
  "boxDL;":0x2557, "boxDR;":0x2554,
  "boxDl;":0x2556, "boxDr;":0x2553,
  "boxH;":0x2550, "boxHD;":0x2566,
  "boxHU;":0x2569, "boxHd;":0x2564,
  "boxHu;":0x2567, "boxUL;":0x255d,
  "boxUR;":0x255a, "boxUl;":0x255c,
  "boxUr;":0x2559, "boxV;":0x2551,
  "boxVH;":0x256c, "boxVL;":0x2563,
  "boxVR;":0x2560, "boxVh;":0x256b,
  "boxVl;":0x2562, "boxVr;":0x255f,
  "boxbox;":0x29c9, "boxdL;":0x2555,
  "boxdR;":0x2552, "boxdl;":0x2510,
  "boxdr;":0x250c, "boxh;":0x2500,
  "boxhD;":0x2565, "boxhU;":0x2568,
  "boxhd;":0x252c, "boxhu;":0x2534,
  "boxminus;":0x229f, "boxplus;":0x229e,
  "boxtimes;":0x22a0, "boxuL;":0x255b,
  "boxuR;":0x2558, "boxul;":0x2518,
  "boxur;":0x2514, "boxv;":0x2502,
  "boxvH;":0x256a, "boxvL;":0x2561,
  "boxvR;":0x255e, "boxvh;":0x253c,
  "boxvl;":0x2524, "boxvr;":0x251c,
  "bprime;":0x2035, "breve;":0x2d8,
  "brvbar":0xa6, "brvbar;":0xa6,
  "bscr;":[0xd835,0xdcb7], "bsemi;":0x204f,
  "bsim;":0x223d, "bsime;":0x22cd,
  "bsol;":0x5c, "bsolb;":0x29c5,
  "bsolhsub;":0x27c8, "bull;":0x2022,
  "bullet;":0x2022, "bump;":0x224e,
  "bumpE;":0x2aae, "bumpe;":0x224f,
  "bumpeq;":0x224f, "cacute;":0x107,
  "cap;":0x2229, "capand;":0x2a44,
  "capbrcup;":0x2a49, "capcap;":0x2a4b,
  "capcup;":0x2a47, "capdot;":0x2a40,
  "caps;":[0x2229,0xfe00], "caret;":0x2041,
  "caron;":0x2c7, "ccaps;":0x2a4d,
  "ccaron;":0x10d, "ccedil":0xe7,
  "ccedil;":0xe7, "ccirc;":0x109,
  "ccups;":0x2a4c, "ccupssm;":0x2a50,
  "cdot;":0x10b, "cedil":0xb8,
  "cedil;":0xb8, "cemptyv;":0x29b2,
  "cent":0xa2, "cent;":0xa2,
  "centerdot;":0xb7, "cfr;":[0xd835,0xdd20],
  "chcy;":0x447, "check;":0x2713,
  "checkmark;":0x2713, "chi;":0x3c7,
  "cir;":0x25cb, "cirE;":0x29c3,
  "circ;":0x2c6, "circeq;":0x2257,
  "circlearrowleft;":0x21ba, "circlearrowright;":0x21bb,
  "circledR;":0xae, "circledS;":0x24c8,
  "circledast;":0x229b, "circledcirc;":0x229a,
  "circleddash;":0x229d, "cire;":0x2257,
  "cirfnint;":0x2a10, "cirmid;":0x2aef,
  "cirscir;":0x29c2, "clubs;":0x2663,
  "clubsuit;":0x2663, "colon;":0x3a,
  "colone;":0x2254, "coloneq;":0x2254,
  "comma;":0x2c, "commat;":0x40,
  "comp;":0x2201, "compfn;":0x2218,
  "complement;":0x2201, "complexes;":0x2102,
  "cong;":0x2245, "congdot;":0x2a6d,
  "conint;":0x222e, "copf;":[0xd835,0xdd54],
  "coprod;":0x2210, "copy":0xa9,
  "copy;":0xa9, "copysr;":0x2117,
  "crarr;":0x21b5, "cross;":0x2717,
  "cscr;":[0xd835,0xdcb8], "csub;":0x2acf,
  "csube;":0x2ad1, "csup;":0x2ad0,
  "csupe;":0x2ad2, "ctdot;":0x22ef,
  "cudarrl;":0x2938, "cudarrr;":0x2935,
  "cuepr;":0x22de, "cuesc;":0x22df,
  "cularr;":0x21b6, "cularrp;":0x293d,
  "cup;":0x222a, "cupbrcap;":0x2a48,
  "cupcap;":0x2a46, "cupcup;":0x2a4a,
  "cupdot;":0x228d, "cupor;":0x2a45,
  "cups;":[0x222a,0xfe00], "curarr;":0x21b7,
  "curarrm;":0x293c, "curlyeqprec;":0x22de,
  "curlyeqsucc;":0x22df, "curlyvee;":0x22ce,
  "curlywedge;":0x22cf, "curren":0xa4,
  "curren;":0xa4, "curvearrowleft;":0x21b6,
  "curvearrowright;":0x21b7, "cuvee;":0x22ce,
  "cuwed;":0x22cf, "cwconint;":0x2232,
  "cwint;":0x2231, "cylcty;":0x232d,
  "dArr;":0x21d3, "dHar;":0x2965,
  "dagger;":0x2020, "daleth;":0x2138,
  "darr;":0x2193, "dash;":0x2010,
  "dashv;":0x22a3, "dbkarow;":0x290f,
  "dblac;":0x2dd, "dcaron;":0x10f,
  "dcy;":0x434, "dd;":0x2146,
  "ddagger;":0x2021, "ddarr;":0x21ca,
  "ddotseq;":0x2a77, "deg":0xb0,
  "deg;":0xb0, "delta;":0x3b4,
  "demptyv;":0x29b1, "dfisht;":0x297f,
  "dfr;":[0xd835,0xdd21], "dharl;":0x21c3,
  "dharr;":0x21c2, "diam;":0x22c4,
  "diamond;":0x22c4, "diamondsuit;":0x2666,
  "diams;":0x2666, "die;":0xa8,
  "digamma;":0x3dd, "disin;":0x22f2,
  "div;":0xf7, "divide":0xf7,
  "divide;":0xf7, "divideontimes;":0x22c7,
  "divonx;":0x22c7, "djcy;":0x452,
  "dlcorn;":0x231e, "dlcrop;":0x230d,
  "dollar;":0x24, "dopf;":[0xd835,0xdd55],
  "dot;":0x2d9, "doteq;":0x2250,
  "doteqdot;":0x2251, "dotminus;":0x2238,
  "dotplus;":0x2214, "dotsquare;":0x22a1,
  "doublebarwedge;":0x2306, "downarrow;":0x2193,
  "downdownarrows;":0x21ca, "downharpoonleft;":0x21c3,
  "downharpoonright;":0x21c2, "drbkarow;":0x2910,
  "drcorn;":0x231f, "drcrop;":0x230c,
  "dscr;":[0xd835,0xdcb9], "dscy;":0x455,
  "dsol;":0x29f6, "dstrok;":0x111,
  "dtdot;":0x22f1, "dtri;":0x25bf,
  "dtrif;":0x25be, "duarr;":0x21f5,
  "duhar;":0x296f, "dwangle;":0x29a6,
  "dzcy;":0x45f, "dzigrarr;":0x27ff,
  "eDDot;":0x2a77, "eDot;":0x2251,
  "eacute":0xe9, "eacute;":0xe9,
  "easter;":0x2a6e, "ecaron;":0x11b,
  "ecir;":0x2256, "ecirc":0xea,
  "ecirc;":0xea, "ecolon;":0x2255,
  "ecy;":0x44d, "edot;":0x117,
  "ee;":0x2147, "efDot;":0x2252,
  "efr;":[0xd835,0xdd22], "eg;":0x2a9a,
  "egrave":0xe8, "egrave;":0xe8,
  "egs;":0x2a96, "egsdot;":0x2a98,
  "el;":0x2a99, "elinters;":0x23e7,
  "ell;":0x2113, "els;":0x2a95,
  "elsdot;":0x2a97, "emacr;":0x113,
  "empty;":0x2205, "emptyset;":0x2205,
  "emptyv;":0x2205, "emsp13;":0x2004,
  "emsp14;":0x2005, "emsp;":0x2003,
  "eng;":0x14b, "ensp;":0x2002,
  "eogon;":0x119, "eopf;":[0xd835,0xdd56],
  "epar;":0x22d5, "eparsl;":0x29e3,
  "eplus;":0x2a71, "epsi;":0x3b5,
  "epsilon;":0x3b5, "epsiv;":0x3f5,
  "eqcirc;":0x2256, "eqcolon;":0x2255,
  "eqsim;":0x2242, "eqslantgtr;":0x2a96,
  "eqslantless;":0x2a95, "equals;":0x3d,
  "equest;":0x225f, "equiv;":0x2261,
  "equivDD;":0x2a78, "eqvparsl;":0x29e5,
  "erDot;":0x2253, "erarr;":0x2971,
  "escr;":0x212f, "esdot;":0x2250,
  "esim;":0x2242, "eta;":0x3b7,
  "eth":0xf0, "eth;":0xf0,
  "euml":0xeb, "euml;":0xeb,
  "euro;":0x20ac, "excl;":0x21,
  "exist;":0x2203, "expectation;":0x2130,
  "exponentiale;":0x2147, "fallingdotseq;":0x2252,
  "fcy;":0x444, "female;":0x2640,
  "ffilig;":0xfb03, "fflig;":0xfb00,
  "ffllig;":0xfb04, "ffr;":[0xd835,0xdd23],
  "filig;":0xfb01, "fjlig;":[0x66,0x6a],
  "flat;":0x266d, "fllig;":0xfb02,
  "fltns;":0x25b1, "fnof;":0x192,
  "fopf;":[0xd835,0xdd57], "forall;":0x2200,
  "fork;":0x22d4, "forkv;":0x2ad9,
  "fpartint;":0x2a0d, "frac12":0xbd,
  "frac12;":0xbd, "frac13;":0x2153,
  "frac14":0xbc, "frac14;":0xbc,
  "frac15;":0x2155, "frac16;":0x2159,
  "frac18;":0x215b, "frac23;":0x2154,
  "frac25;":0x2156, "frac34":0xbe,
  "frac34;":0xbe, "frac35;":0x2157,
  "frac38;":0x215c, "frac45;":0x2158,
  "frac56;":0x215a, "frac58;":0x215d,
  "frac78;":0x215e, "frasl;":0x2044,
  "frown;":0x2322, "fscr;":[0xd835,0xdcbb],
  "gE;":0x2267, "gEl;":0x2a8c,
  "gacute;":0x1f5, "gamma;":0x3b3,
  "gammad;":0x3dd, "gap;":0x2a86,
  "gbreve;":0x11f, "gcirc;":0x11d,
  "gcy;":0x433, "gdot;":0x121,
  "ge;":0x2265, "gel;":0x22db,
  "geq;":0x2265, "geqq;":0x2267,
  "geqslant;":0x2a7e, "ges;":0x2a7e,
  "gescc;":0x2aa9, "gesdot;":0x2a80,
  "gesdoto;":0x2a82, "gesdotol;":0x2a84,
  "gesl;":[0x22db,0xfe00], "gesles;":0x2a94,
  "gfr;":[0xd835,0xdd24], "gg;":0x226b,
  "ggg;":0x22d9, "gimel;":0x2137,
  "gjcy;":0x453, "gl;":0x2277,
  "glE;":0x2a92, "gla;":0x2aa5,
  "glj;":0x2aa4, "gnE;":0x2269,
  "gnap;":0x2a8a, "gnapprox;":0x2a8a,
  "gne;":0x2a88, "gneq;":0x2a88,
  "gneqq;":0x2269, "gnsim;":0x22e7,
  "gopf;":[0xd835,0xdd58], "grave;":0x60,
  "gscr;":0x210a, "gsim;":0x2273,
  "gsime;":0x2a8e, "gsiml;":0x2a90,
  "gt":0x3e, "gt;":0x3e,
  "gtcc;":0x2aa7, "gtcir;":0x2a7a,
  "gtdot;":0x22d7, "gtlPar;":0x2995,
  "gtquest;":0x2a7c, "gtrapprox;":0x2a86,
  "gtrarr;":0x2978, "gtrdot;":0x22d7,
  "gtreqless;":0x22db, "gtreqqless;":0x2a8c,
  "gtrless;":0x2277, "gtrsim;":0x2273,
  "gvertneqq;":[0x2269,0xfe00], "gvnE;":[0x2269,0xfe00],
  "hArr;":0x21d4, "hairsp;":0x200a,
  "half;":0xbd, "hamilt;":0x210b,
  "hardcy;":0x44a, "harr;":0x2194,
  "harrcir;":0x2948, "harrw;":0x21ad,
  "hbar;":0x210f, "hcirc;":0x125,
  "hearts;":0x2665, "heartsuit;":0x2665,
  "hellip;":0x2026, "hercon;":0x22b9,
  "hfr;":[0xd835,0xdd25], "hksearow;":0x2925,
  "hkswarow;":0x2926, "hoarr;":0x21ff,
  "homtht;":0x223b, "hookleftarrow;":0x21a9,
  "hookrightarrow;":0x21aa, "hopf;":[0xd835,0xdd59],
  "horbar;":0x2015, "hscr;":[0xd835,0xdcbd],
  "hslash;":0x210f, "hstrok;":0x127,
  "hybull;":0x2043, "hyphen;":0x2010,
  "iacute":0xed, "iacute;":0xed,
  "ic;":0x2063, "icirc":0xee,
  "icirc;":0xee, "icy;":0x438,
  "iecy;":0x435, "iexcl":0xa1,
  "iexcl;":0xa1, "iff;":0x21d4,
  "ifr;":[0xd835,0xdd26], "igrave":0xec,
  "igrave;":0xec, "ii;":0x2148,
  "iiiint;":0x2a0c, "iiint;":0x222d,
  "iinfin;":0x29dc, "iiota;":0x2129,
  "ijlig;":0x133, "imacr;":0x12b,
  "image;":0x2111, "imagline;":0x2110,
  "imagpart;":0x2111, "imath;":0x131,
  "imof;":0x22b7, "imped;":0x1b5,
  "in;":0x2208, "incare;":0x2105,
  "infin;":0x221e, "infintie;":0x29dd,
  "inodot;":0x131, "int;":0x222b,
  "intcal;":0x22ba, "integers;":0x2124,
  "intercal;":0x22ba, "intlarhk;":0x2a17,
  "intprod;":0x2a3c, "iocy;":0x451,
  "iogon;":0x12f, "iopf;":[0xd835,0xdd5a],
  "iota;":0x3b9, "iprod;":0x2a3c,
  "iquest":0xbf, "iquest;":0xbf,
  "iscr;":[0xd835,0xdcbe], "isin;":0x2208,
  "isinE;":0x22f9, "isindot;":0x22f5,
  "isins;":0x22f4, "isinsv;":0x22f3,
  "isinv;":0x2208, "it;":0x2062,
  "itilde;":0x129, "iukcy;":0x456,
  "iuml":0xef, "iuml;":0xef,
  "jcirc;":0x135, "jcy;":0x439,
  "jfr;":[0xd835,0xdd27], "jmath;":0x237,
  "jopf;":[0xd835,0xdd5b], "jscr;":[0xd835,0xdcbf],
  "jsercy;":0x458, "jukcy;":0x454,
  "kappa;":0x3ba, "kappav;":0x3f0,
  "kcedil;":0x137, "kcy;":0x43a,
  "kfr;":[0xd835,0xdd28], "kgreen;":0x138,
  "khcy;":0x445, "kjcy;":0x45c,
  "kopf;":[0xd835,0xdd5c], "kscr;":[0xd835,0xdcc0],
  "lAarr;":0x21da, "lArr;":0x21d0,
  "lAtail;":0x291b, "lBarr;":0x290e,
  "lE;":0x2266, "lEg;":0x2a8b,
  "lHar;":0x2962, "lacute;":0x13a,
  "laemptyv;":0x29b4, "lagran;":0x2112,
  "lambda;":0x3bb, "lang;":0x27e8,
  "langd;":0x2991, "langle;":0x27e8,
  "lap;":0x2a85, "laquo":0xab,
  "laquo;":0xab, "larr;":0x2190,
  "larrb;":0x21e4, "larrbfs;":0x291f,
  "larrfs;":0x291d, "larrhk;":0x21a9,
  "larrlp;":0x21ab, "larrpl;":0x2939,
  "larrsim;":0x2973, "larrtl;":0x21a2,
  "lat;":0x2aab, "latail;":0x2919,
  "late;":0x2aad, "lates;":[0x2aad,0xfe00],
  "lbarr;":0x290c, "lbbrk;":0x2772,
  "lbrace;":0x7b, "lbrack;":0x5b,
  "lbrke;":0x298b, "lbrksld;":0x298f,
  "lbrkslu;":0x298d, "lcaron;":0x13e,
  "lcedil;":0x13c, "lceil;":0x2308,
  "lcub;":0x7b, "lcy;":0x43b,
  "ldca;":0x2936, "ldquo;":0x201c,
  "ldquor;":0x201e, "ldrdhar;":0x2967,
  "ldrushar;":0x294b, "ldsh;":0x21b2,
  "le;":0x2264, "leftarrow;":0x2190,
  "leftarrowtail;":0x21a2, "leftharpoondown;":0x21bd,
  "leftharpoonup;":0x21bc, "leftleftarrows;":0x21c7,
  "leftrightarrow;":0x2194, "leftrightarrows;":0x21c6,
  "leftrightharpoons;":0x21cb, "leftrightsquigarrow;":0x21ad,
  "leftthreetimes;":0x22cb, "leg;":0x22da,
  "leq;":0x2264, "leqq;":0x2266,
  "leqslant;":0x2a7d, "les;":0x2a7d,
  "lescc;":0x2aa8, "lesdot;":0x2a7f,
  "lesdoto;":0x2a81, "lesdotor;":0x2a83,
  "lesg;":[0x22da,0xfe00], "lesges;":0x2a93,
  "lessapprox;":0x2a85, "lessdot;":0x22d6,
  "lesseqgtr;":0x22da, "lesseqqgtr;":0x2a8b,
  "lessgtr;":0x2276, "lesssim;":0x2272,
  "lfisht;":0x297c, "lfloor;":0x230a,
  "lfr;":[0xd835,0xdd29], "lg;":0x2276,
  "lgE;":0x2a91, "lhard;":0x21bd,
  "lharu;":0x21bc, "lharul;":0x296a,
  "lhblk;":0x2584, "ljcy;":0x459,
  "ll;":0x226a, "llarr;":0x21c7,
  "llcorner;":0x231e, "llhard;":0x296b,
  "lltri;":0x25fa, "lmidot;":0x140,
  "lmoust;":0x23b0, "lmoustache;":0x23b0,
  "lnE;":0x2268, "lnap;":0x2a89,
  "lnapprox;":0x2a89, "lne;":0x2a87,
  "lneq;":0x2a87, "lneqq;":0x2268,
  "lnsim;":0x22e6, "loang;":0x27ec,
  "loarr;":0x21fd, "lobrk;":0x27e6,
  "longleftarrow;":0x27f5, "longleftrightarrow;":0x27f7,
  "longmapsto;":0x27fc, "longrightarrow;":0x27f6,
  "looparrowleft;":0x21ab, "looparrowright;":0x21ac,
  "lopar;":0x2985, "lopf;":[0xd835,0xdd5d],
  "loplus;":0x2a2d, "lotimes;":0x2a34,
  "lowast;":0x2217, "lowbar;":0x5f,
  "loz;":0x25ca, "lozenge;":0x25ca,
  "lozf;":0x29eb, "lpar;":0x28,
  "lparlt;":0x2993, "lrarr;":0x21c6,
  "lrcorner;":0x231f, "lrhar;":0x21cb,
  "lrhard;":0x296d, "lrm;":0x200e,
  "lrtri;":0x22bf, "lsaquo;":0x2039,
  "lscr;":[0xd835,0xdcc1], "lsh;":0x21b0,
  "lsim;":0x2272, "lsime;":0x2a8d,
  "lsimg;":0x2a8f, "lsqb;":0x5b,
  "lsquo;":0x2018, "lsquor;":0x201a,
  "lstrok;":0x142, "lt":0x3c,
  "lt;":0x3c, "ltcc;":0x2aa6,
  "ltcir;":0x2a79, "ltdot;":0x22d6,
  "lthree;":0x22cb, "ltimes;":0x22c9,
  "ltlarr;":0x2976, "ltquest;":0x2a7b,
  "ltrPar;":0x2996, "ltri;":0x25c3,
  "ltrie;":0x22b4, "ltrif;":0x25c2,
  "lurdshar;":0x294a, "luruhar;":0x2966,
  "lvertneqq;":[0x2268,0xfe00], "lvnE;":[0x2268,0xfe00],
  "mDDot;":0x223a, "macr":0xaf,
  "macr;":0xaf, "male;":0x2642,
  "malt;":0x2720, "maltese;":0x2720,
  "map;":0x21a6, "mapsto;":0x21a6,
  "mapstodown;":0x21a7, "mapstoleft;":0x21a4,
  "mapstoup;":0x21a5, "marker;":0x25ae,
  "mcomma;":0x2a29, "mcy;":0x43c,
  "mdash;":0x2014, "measuredangle;":0x2221,
  "mfr;":[0xd835,0xdd2a], "mho;":0x2127,
  "micro":0xb5, "micro;":0xb5,
  "mid;":0x2223, "midast;":0x2a,
  "midcir;":0x2af0, "middot":0xb7,
  "middot;":0xb7, "minus;":0x2212,
  "minusb;":0x229f, "minusd;":0x2238,
  "minusdu;":0x2a2a, "mlcp;":0x2adb,
  "mldr;":0x2026, "mnplus;":0x2213,
  "models;":0x22a7, "mopf;":[0xd835,0xdd5e],
  "mp;":0x2213, "mscr;":[0xd835,0xdcc2],
  "mstpos;":0x223e, "mu;":0x3bc,
  "multimap;":0x22b8, "mumap;":0x22b8,
  "nGg;":[0x22d9,0x338], "nGt;":[0x226b,0x20d2],
  "nGtv;":[0x226b,0x338], "nLeftarrow;":0x21cd,
  "nLeftrightarrow;":0x21ce, "nLl;":[0x22d8,0x338],
  "nLt;":[0x226a,0x20d2], "nLtv;":[0x226a,0x338],
  "nRightarrow;":0x21cf, "nVDash;":0x22af,
  "nVdash;":0x22ae, "nabla;":0x2207,
  "nacute;":0x144, "nang;":[0x2220,0x20d2],
  "nap;":0x2249, "napE;":[0x2a70,0x338],
  "napid;":[0x224b,0x338], "napos;":0x149,
  "napprox;":0x2249, "natur;":0x266e,
  "natural;":0x266e, "naturals;":0x2115,
  "nbsp":0xa0, "nbsp;":0xa0,
  "nbump;":[0x224e,0x338], "nbumpe;":[0x224f,0x338],
  "ncap;":0x2a43, "ncaron;":0x148,
  "ncedil;":0x146, "ncong;":0x2247,
  "ncongdot;":[0x2a6d,0x338], "ncup;":0x2a42,
  "ncy;":0x43d, "ndash;":0x2013,
  "ne;":0x2260, "neArr;":0x21d7,
  "nearhk;":0x2924, "nearr;":0x2197,
  "nearrow;":0x2197, "nedot;":[0x2250,0x338],
  "nequiv;":0x2262, "nesear;":0x2928,
  "nesim;":[0x2242,0x338], "nexist;":0x2204,
  "nexists;":0x2204, "nfr;":[0xd835,0xdd2b],
  "ngE;":[0x2267,0x338], "nge;":0x2271,
  "ngeq;":0x2271, "ngeqq;":[0x2267,0x338],
  "ngeqslant;":[0x2a7e,0x338], "nges;":[0x2a7e,0x338],
  "ngsim;":0x2275, "ngt;":0x226f,
  "ngtr;":0x226f, "nhArr;":0x21ce,
  "nharr;":0x21ae, "nhpar;":0x2af2,
  "ni;":0x220b, "nis;":0x22fc,
  "nisd;":0x22fa, "niv;":0x220b,
  "njcy;":0x45a, "nlArr;":0x21cd,
  "nlE;":[0x2266,0x338], "nlarr;":0x219a,
  "nldr;":0x2025, "nle;":0x2270,
  "nleftarrow;":0x219a, "nleftrightarrow;":0x21ae,
  "nleq;":0x2270, "nleqq;":[0x2266,0x338],
  "nleqslant;":[0x2a7d,0x338], "nles;":[0x2a7d,0x338],
  "nless;":0x226e, "nlsim;":0x2274,
  "nlt;":0x226e, "nltri;":0x22ea,
  "nltrie;":0x22ec, "nmid;":0x2224,
  "nopf;":[0xd835,0xdd5f], "not":0xac,
  "not;":0xac, "notin;":0x2209,
  "notinE;":[0x22f9,0x338], "notindot;":[0x22f5,0x338],
  "notinva;":0x2209, "notinvb;":0x22f7,
  "notinvc;":0x22f6, "notni;":0x220c,
  "notniva;":0x220c, "notnivb;":0x22fe,
  "notnivc;":0x22fd, "npar;":0x2226,
  "nparallel;":0x2226, "nparsl;":[0x2afd,0x20e5],
  "npart;":[0x2202,0x338], "npolint;":0x2a14,
  "npr;":0x2280, "nprcue;":0x22e0,
  "npre;":[0x2aaf,0x338], "nprec;":0x2280,
  "npreceq;":[0x2aaf,0x338], "nrArr;":0x21cf,
  "nrarr;":0x219b, "nrarrc;":[0x2933,0x338],
  "nrarrw;":[0x219d,0x338], "nrightarrow;":0x219b,
  "nrtri;":0x22eb, "nrtrie;":0x22ed,
  "nsc;":0x2281, "nsccue;":0x22e1,
  "nsce;":[0x2ab0,0x338], "nscr;":[0xd835,0xdcc3],
  "nshortmid;":0x2224, "nshortparallel;":0x2226,
  "nsim;":0x2241, "nsime;":0x2244,
  "nsimeq;":0x2244, "nsmid;":0x2224,
  "nspar;":0x2226, "nsqsube;":0x22e2,
  "nsqsupe;":0x22e3, "nsub;":0x2284,
  "nsubE;":[0x2ac5,0x338], "nsube;":0x2288,
  "nsubset;":[0x2282,0x20d2], "nsubseteq;":0x2288,
  "nsubseteqq;":[0x2ac5,0x338], "nsucc;":0x2281,
  "nsucceq;":[0x2ab0,0x338], "nsup;":0x2285,
  "nsupE;":[0x2ac6,0x338], "nsupe;":0x2289,
  "nsupset;":[0x2283,0x20d2], "nsupseteq;":0x2289,
  "nsupseteqq;":[0x2ac6,0x338], "ntgl;":0x2279,
  "ntilde":0xf1, "ntilde;":0xf1,
  "ntlg;":0x2278, "ntriangleleft;":0x22ea,
  "ntrianglelefteq;":0x22ec, "ntriangleright;":0x22eb,
  "ntrianglerighteq;":0x22ed, "nu;":0x3bd,
  "num;":0x23, "numero;":0x2116,
  "numsp;":0x2007, "nvDash;":0x22ad,
  "nvHarr;":0x2904, "nvap;":[0x224d,0x20d2],
  "nvdash;":0x22ac, "nvge;":[0x2265,0x20d2],
  "nvgt;":[0x3e,0x20d2], "nvinfin;":0x29de,
  "nvlArr;":0x2902, "nvle;":[0x2264,0x20d2],
  "nvlt;":[0x3c,0x20d2], "nvltrie;":[0x22b4,0x20d2],
  "nvrArr;":0x2903, "nvrtrie;":[0x22b5,0x20d2],
  "nvsim;":[0x223c,0x20d2], "nwArr;":0x21d6,
  "nwarhk;":0x2923, "nwarr;":0x2196,
  "nwarrow;":0x2196, "nwnear;":0x2927,
  "oS;":0x24c8, "oacute":0xf3,
  "oacute;":0xf3, "oast;":0x229b,
  "ocir;":0x229a, "ocirc":0xf4,
  "ocirc;":0xf4, "ocy;":0x43e,
  "odash;":0x229d, "odblac;":0x151,
  "odiv;":0x2a38, "odot;":0x2299,
  "odsold;":0x29bc, "oelig;":0x153,
  "ofcir;":0x29bf, "ofr;":[0xd835,0xdd2c],
  "ogon;":0x2db, "ograve":0xf2,
  "ograve;":0xf2, "ogt;":0x29c1,
  "ohbar;":0x29b5, "ohm;":0x3a9,
  "oint;":0x222e, "olarr;":0x21ba,
  "olcir;":0x29be, "olcross;":0x29bb,
  "oline;":0x203e, "olt;":0x29c0,
  "omacr;":0x14d, "omega;":0x3c9,
  "omicron;":0x3bf, "omid;":0x29b6,
  "ominus;":0x2296, "oopf;":[0xd835,0xdd60],
  "opar;":0x29b7, "operp;":0x29b9,
  "oplus;":0x2295, "or;":0x2228,
  "orarr;":0x21bb, "ord;":0x2a5d,
  "order;":0x2134, "orderof;":0x2134,
  "ordf":0xaa, "ordf;":0xaa,
  "ordm":0xba, "ordm;":0xba,
  "origof;":0x22b6, "oror;":0x2a56,
  "orslope;":0x2a57, "orv;":0x2a5b,
  "oscr;":0x2134, "oslash":0xf8,
  "oslash;":0xf8, "osol;":0x2298,
  "otilde":0xf5, "otilde;":0xf5,
  "otimes;":0x2297, "otimesas;":0x2a36,
  "ouml":0xf6, "ouml;":0xf6,
  "ovbar;":0x233d, "par;":0x2225,
  "para":0xb6, "para;":0xb6,
  "parallel;":0x2225, "parsim;":0x2af3,
  "parsl;":0x2afd, "part;":0x2202,
  "pcy;":0x43f, "percnt;":0x25,
  "period;":0x2e, "permil;":0x2030,
  "perp;":0x22a5, "pertenk;":0x2031,
  "pfr;":[0xd835,0xdd2d], "phi;":0x3c6,
  "phiv;":0x3d5, "phmmat;":0x2133,
  "phone;":0x260e, "pi;":0x3c0,
  "pitchfork;":0x22d4, "piv;":0x3d6,
  "planck;":0x210f, "planckh;":0x210e,
  "plankv;":0x210f, "plus;":0x2b,
  "plusacir;":0x2a23, "plusb;":0x229e,
  "pluscir;":0x2a22, "plusdo;":0x2214,
  "plusdu;":0x2a25, "pluse;":0x2a72,
  "plusmn":0xb1, "plusmn;":0xb1,
  "plussim;":0x2a26, "plustwo;":0x2a27,
  "pm;":0xb1, "pointint;":0x2a15,
  "popf;":[0xd835,0xdd61], "pound":0xa3,
  "pound;":0xa3, "pr;":0x227a,
  "prE;":0x2ab3, "prap;":0x2ab7,
  "prcue;":0x227c, "pre;":0x2aaf,
  "prec;":0x227a, "precapprox;":0x2ab7,
  "preccurlyeq;":0x227c, "preceq;":0x2aaf,
  "precnapprox;":0x2ab9, "precneqq;":0x2ab5,
  "precnsim;":0x22e8, "precsim;":0x227e,
  "prime;":0x2032, "primes;":0x2119,
  "prnE;":0x2ab5, "prnap;":0x2ab9,
  "prnsim;":0x22e8, "prod;":0x220f,
  "profalar;":0x232e, "profline;":0x2312,
  "profsurf;":0x2313, "prop;":0x221d,
  "propto;":0x221d, "prsim;":0x227e,
  "prurel;":0x22b0, "pscr;":[0xd835,0xdcc5],
  "psi;":0x3c8, "puncsp;":0x2008,
  "qfr;":[0xd835,0xdd2e], "qint;":0x2a0c,
  "qopf;":[0xd835,0xdd62], "qprime;":0x2057,
  "qscr;":[0xd835,0xdcc6], "quaternions;":0x210d,
  "quatint;":0x2a16, "quest;":0x3f,
  "questeq;":0x225f, "quot":0x22,
  "quot;":0x22, "rAarr;":0x21db,
  "rArr;":0x21d2, "rAtail;":0x291c,
  "rBarr;":0x290f, "rHar;":0x2964,
  "race;":[0x223d,0x331], "racute;":0x155,
  "radic;":0x221a, "raemptyv;":0x29b3,
  "rang;":0x27e9, "rangd;":0x2992,
  "range;":0x29a5, "rangle;":0x27e9,
  "raquo":0xbb, "raquo;":0xbb,
  "rarr;":0x2192, "rarrap;":0x2975,
  "rarrb;":0x21e5, "rarrbfs;":0x2920,
  "rarrc;":0x2933, "rarrfs;":0x291e,
  "rarrhk;":0x21aa, "rarrlp;":0x21ac,
  "rarrpl;":0x2945, "rarrsim;":0x2974,
  "rarrtl;":0x21a3, "rarrw;":0x219d,
  "ratail;":0x291a, "ratio;":0x2236,
  "rationals;":0x211a, "rbarr;":0x290d,
  "rbbrk;":0x2773, "rbrace;":0x7d,
  "rbrack;":0x5d, "rbrke;":0x298c,
  "rbrksld;":0x298e, "rbrkslu;":0x2990,
  "rcaron;":0x159, "rcedil;":0x157,
  "rceil;":0x2309, "rcub;":0x7d,
  "rcy;":0x440, "rdca;":0x2937,
  "rdldhar;":0x2969, "rdquo;":0x201d,
  "rdquor;":0x201d, "rdsh;":0x21b3,
  "real;":0x211c, "realine;":0x211b,
  "realpart;":0x211c, "reals;":0x211d,
  "rect;":0x25ad, "reg":0xae,
  "reg;":0xae, "rfisht;":0x297d,
  "rfloor;":0x230b, "rfr;":[0xd835,0xdd2f],
  "rhard;":0x21c1, "rharu;":0x21c0,
  "rharul;":0x296c, "rho;":0x3c1,
  "rhov;":0x3f1, "rightarrow;":0x2192,
  "rightarrowtail;":0x21a3, "rightharpoondown;":0x21c1,
  "rightharpoonup;":0x21c0, "rightleftarrows;":0x21c4,
  "rightleftharpoons;":0x21cc, "rightrightarrows;":0x21c9,
  "rightsquigarrow;":0x219d, "rightthreetimes;":0x22cc,
  "ring;":0x2da, "risingdotseq;":0x2253,
  "rlarr;":0x21c4, "rlhar;":0x21cc,
  "rlm;":0x200f, "rmoust;":0x23b1,
  "rmoustache;":0x23b1, "rnmid;":0x2aee,
  "roang;":0x27ed, "roarr;":0x21fe,
  "robrk;":0x27e7, "ropar;":0x2986,
  "ropf;":[0xd835,0xdd63], "roplus;":0x2a2e,
  "rotimes;":0x2a35, "rpar;":0x29,
  "rpargt;":0x2994, "rppolint;":0x2a12,
  "rrarr;":0x21c9, "rsaquo;":0x203a,
  "rscr;":[0xd835,0xdcc7], "rsh;":0x21b1,
  "rsqb;":0x5d, "rsquo;":0x2019,
  "rsquor;":0x2019, "rthree;":0x22cc,
  "rtimes;":0x22ca, "rtri;":0x25b9,
  "rtrie;":0x22b5, "rtrif;":0x25b8,
  "rtriltri;":0x29ce, "ruluhar;":0x2968,
  "rx;":0x211e, "sacute;":0x15b,
  "sbquo;":0x201a, "sc;":0x227b,
  "scE;":0x2ab4, "scap;":0x2ab8,
  "scaron;":0x161, "sccue;":0x227d,
  "sce;":0x2ab0, "scedil;":0x15f,
  "scirc;":0x15d, "scnE;":0x2ab6,
  "scnap;":0x2aba, "scnsim;":0x22e9,
  "scpolint;":0x2a13, "scsim;":0x227f,
  "scy;":0x441, "sdot;":0x22c5,
  "sdotb;":0x22a1, "sdote;":0x2a66,
  "seArr;":0x21d8, "searhk;":0x2925,
  "searr;":0x2198, "searrow;":0x2198,
  "sect":0xa7, "sect;":0xa7,
  "semi;":0x3b, "seswar;":0x2929,
  "setminus;":0x2216, "setmn;":0x2216,
  "sext;":0x2736, "sfr;":[0xd835,0xdd30],
  "sfrown;":0x2322, "sharp;":0x266f,
  "shchcy;":0x449, "shcy;":0x448,
  "shortmid;":0x2223, "shortparallel;":0x2225,
  "shy":0xad, "shy;":0xad,
  "sigma;":0x3c3, "sigmaf;":0x3c2,
  "sigmav;":0x3c2, "sim;":0x223c,
  "simdot;":0x2a6a, "sime;":0x2243,
  "simeq;":0x2243, "simg;":0x2a9e,
  "simgE;":0x2aa0, "siml;":0x2a9d,
  "simlE;":0x2a9f, "simne;":0x2246,
  "simplus;":0x2a24, "simrarr;":0x2972,
  "slarr;":0x2190, "smallsetminus;":0x2216,
  "smashp;":0x2a33, "smeparsl;":0x29e4,
  "smid;":0x2223, "smile;":0x2323,
  "smt;":0x2aaa, "smte;":0x2aac,
  "smtes;":[0x2aac,0xfe00], "softcy;":0x44c,
  "sol;":0x2f, "solb;":0x29c4,
  "solbar;":0x233f, "sopf;":[0xd835,0xdd64],
  "spades;":0x2660, "spadesuit;":0x2660,
  "spar;":0x2225, "sqcap;":0x2293,
  "sqcaps;":[0x2293,0xfe00], "sqcup;":0x2294,
  "sqcups;":[0x2294,0xfe00], "sqsub;":0x228f,
  "sqsube;":0x2291, "sqsubset;":0x228f,
  "sqsubseteq;":0x2291, "sqsup;":0x2290,
  "sqsupe;":0x2292, "sqsupset;":0x2290,
  "sqsupseteq;":0x2292, "squ;":0x25a1,
  "square;":0x25a1, "squarf;":0x25aa,
  "squf;":0x25aa, "srarr;":0x2192,
  "sscr;":[0xd835,0xdcc8], "ssetmn;":0x2216,
  "ssmile;":0x2323, "sstarf;":0x22c6,
  "star;":0x2606, "starf;":0x2605,
  "straightepsilon;":0x3f5, "straightphi;":0x3d5,
  "strns;":0xaf, "sub;":0x2282,
  "subE;":0x2ac5, "subdot;":0x2abd,
  "sube;":0x2286, "subedot;":0x2ac3,
  "submult;":0x2ac1, "subnE;":0x2acb,
  "subne;":0x228a, "subplus;":0x2abf,
  "subrarr;":0x2979, "subset;":0x2282,
  "subseteq;":0x2286, "subseteqq;":0x2ac5,
  "subsetneq;":0x228a, "subsetneqq;":0x2acb,
  "subsim;":0x2ac7, "subsub;":0x2ad5,
  "subsup;":0x2ad3, "succ;":0x227b,
  "succapprox;":0x2ab8, "succcurlyeq;":0x227d,
  "succeq;":0x2ab0, "succnapprox;":0x2aba,
  "succneqq;":0x2ab6, "succnsim;":0x22e9,
  "succsim;":0x227f, "sum;":0x2211,
  "sung;":0x266a, "sup1":0xb9,
  "sup1;":0xb9, "sup2":0xb2,
  "sup2;":0xb2, "sup3":0xb3,
  "sup3;":0xb3, "sup;":0x2283,
  "supE;":0x2ac6, "supdot;":0x2abe,
  "supdsub;":0x2ad8, "supe;":0x2287,
  "supedot;":0x2ac4, "suphsol;":0x27c9,
  "suphsub;":0x2ad7, "suplarr;":0x297b,
  "supmult;":0x2ac2, "supnE;":0x2acc,
  "supne;":0x228b, "supplus;":0x2ac0,
  "supset;":0x2283, "supseteq;":0x2287,
  "supseteqq;":0x2ac6, "supsetneq;":0x228b,
  "supsetneqq;":0x2acc, "supsim;":0x2ac8,
  "supsub;":0x2ad4, "supsup;":0x2ad6,
  "swArr;":0x21d9, "swarhk;":0x2926,
  "swarr;":0x2199, "swarrow;":0x2199,
  "swnwar;":0x292a, "szlig":0xdf,
  "szlig;":0xdf, "target;":0x2316,
  "tau;":0x3c4, "tbrk;":0x23b4,
  "tcaron;":0x165, "tcedil;":0x163,
  "tcy;":0x442, "tdot;":0x20db,
  "telrec;":0x2315, "tfr;":[0xd835,0xdd31],
  "there4;":0x2234, "therefore;":0x2234,
  "theta;":0x3b8, "thetasym;":0x3d1,
  "thetav;":0x3d1, "thickapprox;":0x2248,
  "thicksim;":0x223c, "thinsp;":0x2009,
  "thkap;":0x2248, "thksim;":0x223c,
  "thorn":0xfe, "thorn;":0xfe,
  "tilde;":0x2dc, "times":0xd7,
  "times;":0xd7, "timesb;":0x22a0,
  "timesbar;":0x2a31, "timesd;":0x2a30,
  "tint;":0x222d, "toea;":0x2928,
  "top;":0x22a4, "topbot;":0x2336,
  "topcir;":0x2af1, "topf;":[0xd835,0xdd65],
  "topfork;":0x2ada, "tosa;":0x2929,
  "tprime;":0x2034, "trade;":0x2122,
  "triangle;":0x25b5, "triangledown;":0x25bf,
  "triangleleft;":0x25c3, "trianglelefteq;":0x22b4,
  "triangleq;":0x225c, "triangleright;":0x25b9,
  "trianglerighteq;":0x22b5, "tridot;":0x25ec,
  "trie;":0x225c, "triminus;":0x2a3a,
  "triplus;":0x2a39, "trisb;":0x29cd,
  "tritime;":0x2a3b, "trpezium;":0x23e2,
  "tscr;":[0xd835,0xdcc9], "tscy;":0x446,
  "tshcy;":0x45b, "tstrok;":0x167,
  "twixt;":0x226c, "twoheadleftarrow;":0x219e,
  "twoheadrightarrow;":0x21a0, "uArr;":0x21d1,
  "uHar;":0x2963, "uacute":0xfa,
  "uacute;":0xfa, "uarr;":0x2191,
  "ubrcy;":0x45e, "ubreve;":0x16d,
  "ucirc":0xfb, "ucirc;":0xfb,
  "ucy;":0x443, "udarr;":0x21c5,
  "udblac;":0x171, "udhar;":0x296e,
  "ufisht;":0x297e, "ufr;":[0xd835,0xdd32],
  "ugrave":0xf9, "ugrave;":0xf9,
  "uharl;":0x21bf, "uharr;":0x21be,
  "uhblk;":0x2580, "ulcorn;":0x231c,
  "ulcorner;":0x231c, "ulcrop;":0x230f,
  "ultri;":0x25f8, "umacr;":0x16b,
  "uml":0xa8, "uml;":0xa8,
  "uogon;":0x173, "uopf;":[0xd835,0xdd66],
  "uparrow;":0x2191, "updownarrow;":0x2195,
  "upharpoonleft;":0x21bf, "upharpoonright;":0x21be,
  "uplus;":0x228e, "upsi;":0x3c5,
  "upsih;":0x3d2, "upsilon;":0x3c5,
  "upuparrows;":0x21c8, "urcorn;":0x231d,
  "urcorner;":0x231d, "urcrop;":0x230e,
  "uring;":0x16f, "urtri;":0x25f9,
  "uscr;":[0xd835,0xdcca], "utdot;":0x22f0,
  "utilde;":0x169, "utri;":0x25b5,
  "utrif;":0x25b4, "uuarr;":0x21c8,
  "uuml":0xfc, "uuml;":0xfc,
  "uwangle;":0x29a7, "vArr;":0x21d5,
  "vBar;":0x2ae8, "vBarv;":0x2ae9,
  "vDash;":0x22a8, "vangrt;":0x299c,
  "varepsilon;":0x3f5, "varkappa;":0x3f0,
  "varnothing;":0x2205, "varphi;":0x3d5,
  "varpi;":0x3d6, "varpropto;":0x221d,
  "varr;":0x2195, "varrho;":0x3f1,
  "varsigma;":0x3c2, "varsubsetneq;":[0x228a,0xfe00],
  "varsubsetneqq;":[0x2acb,0xfe00], "varsupsetneq;":[0x228b,0xfe00],
  "varsupsetneqq;":[0x2acc,0xfe00], "vartheta;":0x3d1,
  "vartriangleleft;":0x22b2, "vartriangleright;":0x22b3,
  "vcy;":0x432, "vdash;":0x22a2,
  "vee;":0x2228, "veebar;":0x22bb,
  "veeeq;":0x225a, "vellip;":0x22ee,
  "verbar;":0x7c, "vert;":0x7c,
  "vfr;":[0xd835,0xdd33], "vltri;":0x22b2,
  "vnsub;":[0x2282,0x20d2], "vnsup;":[0x2283,0x20d2],
  "vopf;":[0xd835,0xdd67], "vprop;":0x221d,
  "vrtri;":0x22b3, "vscr;":[0xd835,0xdccb],
  "vsubnE;":[0x2acb,0xfe00], "vsubne;":[0x228a,0xfe00],
  "vsupnE;":[0x2acc,0xfe00], "vsupne;":[0x228b,0xfe00],
  "vzigzag;":0x299a, "wcirc;":0x175,
  "wedbar;":0x2a5f, "wedge;":0x2227,
  "wedgeq;":0x2259, "weierp;":0x2118,
  "wfr;":[0xd835,0xdd34], "wopf;":[0xd835,0xdd68],
  "wp;":0x2118, "wr;":0x2240,
  "wreath;":0x2240, "wscr;":[0xd835,0xdccc],
  "xcap;":0x22c2, "xcirc;":0x25ef,
  "xcup;":0x22c3, "xdtri;":0x25bd,
  "xfr;":[0xd835,0xdd35], "xhArr;":0x27fa,
  "xharr;":0x27f7, "xi;":0x3be,
  "xlArr;":0x27f8, "xlarr;":0x27f5,
  "xmap;":0x27fc, "xnis;":0x22fb,
  "xodot;":0x2a00, "xopf;":[0xd835,0xdd69],
  "xoplus;":0x2a01, "xotime;":0x2a02,
  "xrArr;":0x27f9, "xrarr;":0x27f6,
  "xscr;":[0xd835,0xdccd], "xsqcup;":0x2a06,
  "xuplus;":0x2a04, "xutri;":0x25b3,
  "xvee;":0x22c1, "xwedge;":0x22c0,
  "yacute":0xfd, "yacute;":0xfd,
  "yacy;":0x44f, "ycirc;":0x177,
  "ycy;":0x44b, "yen":0xa5,
  "yen;":0xa5, "yfr;":[0xd835,0xdd36],
  "yicy;":0x457, "yopf;":[0xd835,0xdd6a],
  "yscr;":[0xd835,0xdcce], "yucy;":0x44e,
  "yuml":0xff, "yuml;":0xff,
  "zacute;":0x17a, "zcaron;":0x17e,
  "zcy;":0x437, "zdot;":0x17c,
  "zeetrf;":0x2128, "zeta;":0x3b6,
  "zfr;":[0xd835,0xdd37], "zhcy;":0x436,
  "zigrarr;":0x21dd, "zopf;":[0xd835,0xdd6b],
  "zscr;":[0xd835,0xdccf], "zwj;":0x200d,
  "zwnj;":0x200c,
};
/*
 * This regexp is generated with test/tools/update-entities.js
 * It will always match at least one character -- but note that there
 * are no entities whose names are a single character long.
 */
var NAMEDCHARREF = /(A(?:Elig;?|MP;?|acute;?|breve;|c(?:irc;?|y;)|fr;|grave;?|lpha;|macr;|nd;|o(?:gon;|pf;)|pplyFunction;|ring;?|s(?:cr;|sign;)|tilde;?|uml;?)|B(?:a(?:ckslash;|r(?:v;|wed;))|cy;|e(?:cause;|rnoullis;|ta;)|fr;|opf;|reve;|scr;|umpeq;)|C(?:Hcy;|OPY;?|a(?:cute;|p(?:;|italDifferentialD;)|yleys;)|c(?:aron;|edil;?|irc;|onint;)|dot;|e(?:dilla;|nterDot;)|fr;|hi;|ircle(?:Dot;|Minus;|Plus;|Times;)|lo(?:ckwiseContourIntegral;|seCurly(?:DoubleQuote;|Quote;))|o(?:lon(?:;|e;)|n(?:gruent;|int;|tourIntegral;)|p(?:f;|roduct;)|unterClockwiseContourIntegral;)|ross;|scr;|up(?:;|Cap;))|D(?:D(?:;|otrahd;)|Jcy;|Scy;|Zcy;|a(?:gger;|rr;|shv;)|c(?:aron;|y;)|el(?:;|ta;)|fr;|i(?:a(?:critical(?:Acute;|Do(?:t;|ubleAcute;)|Grave;|Tilde;)|mond;)|fferentialD;)|o(?:pf;|t(?:;|Dot;|Equal;)|uble(?:ContourIntegral;|Do(?:t;|wnArrow;)|L(?:eft(?:Arrow;|RightArrow;|Tee;)|ong(?:Left(?:Arrow;|RightArrow;)|RightArrow;))|Right(?:Arrow;|Tee;)|Up(?:Arrow;|DownArrow;)|VerticalBar;)|wn(?:Arrow(?:;|Bar;|UpArrow;)|Breve;|Left(?:RightVector;|TeeVector;|Vector(?:;|Bar;))|Right(?:TeeVector;|Vector(?:;|Bar;))|Tee(?:;|Arrow;)|arrow;))|s(?:cr;|trok;))|E(?:NG;|TH;?|acute;?|c(?:aron;|irc;?|y;)|dot;|fr;|grave;?|lement;|m(?:acr;|pty(?:SmallSquare;|VerySmallSquare;))|o(?:gon;|pf;)|psilon;|qu(?:al(?:;|Tilde;)|ilibrium;)|s(?:cr;|im;)|ta;|uml;?|x(?:ists;|ponentialE;))|F(?:cy;|fr;|illed(?:SmallSquare;|VerySmallSquare;)|o(?:pf;|rAll;|uriertrf;)|scr;)|G(?:Jcy;|T;?|amma(?:;|d;)|breve;|c(?:edil;|irc;|y;)|dot;|fr;|g;|opf;|reater(?:Equal(?:;|Less;)|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|scr;|t;)|H(?:ARDcy;|a(?:cek;|t;)|circ;|fr;|ilbertSpace;|o(?:pf;|rizontalLine;)|s(?:cr;|trok;)|ump(?:DownHump;|Equal;))|I(?:Ecy;|Jlig;|Ocy;|acute;?|c(?:irc;?|y;)|dot;|fr;|grave;?|m(?:;|a(?:cr;|ginaryI;)|plies;)|n(?:t(?:;|e(?:gral;|rsection;))|visible(?:Comma;|Times;))|o(?:gon;|pf;|ta;)|scr;|tilde;|u(?:kcy;|ml;?))|J(?:c(?:irc;|y;)|fr;|opf;|s(?:cr;|ercy;)|ukcy;)|K(?:Hcy;|Jcy;|appa;|c(?:edil;|y;)|fr;|opf;|scr;)|L(?:Jcy;|T;?|a(?:cute;|mbda;|ng;|placetrf;|rr;)|c(?:aron;|edil;|y;)|e(?:ft(?:A(?:ngleBracket;|rrow(?:;|Bar;|RightArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|Right(?:Arrow;|Vector;)|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;|rightarrow;)|ss(?:EqualGreater;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;))|fr;|l(?:;|eftarrow;)|midot;|o(?:ng(?:Left(?:Arrow;|RightArrow;)|RightArrow;|left(?:arrow;|rightarrow;)|rightarrow;)|pf;|wer(?:LeftArrow;|RightArrow;))|s(?:cr;|h;|trok;)|t;)|M(?:ap;|cy;|e(?:diumSpace;|llintrf;)|fr;|inusPlus;|opf;|scr;|u;)|N(?:Jcy;|acute;|c(?:aron;|edil;|y;)|e(?:gative(?:MediumSpace;|Thi(?:ckSpace;|nSpace;)|VeryThinSpace;)|sted(?:GreaterGreater;|LessLess;)|wLine;)|fr;|o(?:Break;|nBreakingSpace;|pf;|t(?:;|C(?:ongruent;|upCap;)|DoubleVerticalBar;|E(?:lement;|qual(?:;|Tilde;)|xists;)|Greater(?:;|Equal;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|Hump(?:DownHump;|Equal;)|Le(?:ftTriangle(?:;|Bar;|Equal;)|ss(?:;|Equal;|Greater;|Less;|SlantEqual;|Tilde;))|Nested(?:GreaterGreater;|LessLess;)|Precedes(?:;|Equal;|SlantEqual;)|R(?:everseElement;|ightTriangle(?:;|Bar;|Equal;))|S(?:quareSu(?:bset(?:;|Equal;)|perset(?:;|Equal;))|u(?:bset(?:;|Equal;)|cceeds(?:;|Equal;|SlantEqual;|Tilde;)|perset(?:;|Equal;)))|Tilde(?:;|Equal;|FullEqual;|Tilde;)|VerticalBar;))|scr;|tilde;?|u;)|O(?:Elig;|acute;?|c(?:irc;?|y;)|dblac;|fr;|grave;?|m(?:acr;|ega;|icron;)|opf;|penCurly(?:DoubleQuote;|Quote;)|r;|s(?:cr;|lash;?)|ti(?:lde;?|mes;)|uml;?|ver(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;))|P(?:artialD;|cy;|fr;|hi;|i;|lusMinus;|o(?:incareplane;|pf;)|r(?:;|ecedes(?:;|Equal;|SlantEqual;|Tilde;)|ime;|o(?:duct;|portion(?:;|al;)))|s(?:cr;|i;))|Q(?:UOT;?|fr;|opf;|scr;)|R(?:Barr;|EG;?|a(?:cute;|ng;|rr(?:;|tl;))|c(?:aron;|edil;|y;)|e(?:;|verse(?:E(?:lement;|quilibrium;)|UpEquilibrium;))|fr;|ho;|ight(?:A(?:ngleBracket;|rrow(?:;|Bar;|LeftArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;)|o(?:pf;|undImplies;)|rightarrow;|s(?:cr;|h;)|uleDelayed;)|S(?:H(?:CHcy;|cy;)|OFTcy;|acute;|c(?:;|aron;|edil;|irc;|y;)|fr;|hort(?:DownArrow;|LeftArrow;|RightArrow;|UpArrow;)|igma;|mallCircle;|opf;|q(?:rt;|uare(?:;|Intersection;|Su(?:bset(?:;|Equal;)|perset(?:;|Equal;))|Union;))|scr;|tar;|u(?:b(?:;|set(?:;|Equal;))|c(?:ceeds(?:;|Equal;|SlantEqual;|Tilde;)|hThat;)|m;|p(?:;|erset(?:;|Equal;)|set;)))|T(?:HORN;?|RADE;|S(?:Hcy;|cy;)|a(?:b;|u;)|c(?:aron;|edil;|y;)|fr;|h(?:e(?:refore;|ta;)|i(?:ckSpace;|nSpace;))|ilde(?:;|Equal;|FullEqual;|Tilde;)|opf;|ripleDot;|s(?:cr;|trok;))|U(?:a(?:cute;?|rr(?:;|ocir;))|br(?:cy;|eve;)|c(?:irc;?|y;)|dblac;|fr;|grave;?|macr;|n(?:der(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;)|ion(?:;|Plus;))|o(?:gon;|pf;)|p(?:Arrow(?:;|Bar;|DownArrow;)|DownArrow;|Equilibrium;|Tee(?:;|Arrow;)|arrow;|downarrow;|per(?:LeftArrow;|RightArrow;)|si(?:;|lon;))|ring;|scr;|tilde;|uml;?)|V(?:Dash;|bar;|cy;|dash(?:;|l;)|e(?:e;|r(?:bar;|t(?:;|ical(?:Bar;|Line;|Separator;|Tilde;))|yThinSpace;))|fr;|opf;|scr;|vdash;)|W(?:circ;|edge;|fr;|opf;|scr;)|X(?:fr;|i;|opf;|scr;)|Y(?:Acy;|Icy;|Ucy;|acute;?|c(?:irc;|y;)|fr;|opf;|scr;|uml;)|Z(?:Hcy;|acute;|c(?:aron;|y;)|dot;|e(?:roWidthSpace;|ta;)|fr;|opf;|scr;)|a(?:acute;?|breve;|c(?:;|E;|d;|irc;?|ute;?|y;)|elig;?|f(?:;|r;)|grave;?|l(?:e(?:fsym;|ph;)|pha;)|m(?:a(?:cr;|lg;)|p;?)|n(?:d(?:;|and;|d;|slope;|v;)|g(?:;|e;|le;|msd(?:;|a(?:a;|b;|c;|d;|e;|f;|g;|h;))|rt(?:;|vb(?:;|d;))|s(?:ph;|t;)|zarr;))|o(?:gon;|pf;)|p(?:;|E;|acir;|e;|id;|os;|prox(?:;|eq;))|ring;?|s(?:cr;|t;|ymp(?:;|eq;))|tilde;?|uml;?|w(?:conint;|int;))|b(?:Not;|a(?:ck(?:cong;|epsilon;|prime;|sim(?:;|eq;))|r(?:vee;|wed(?:;|ge;)))|brk(?:;|tbrk;)|c(?:ong;|y;)|dquo;|e(?:caus(?:;|e;)|mptyv;|psi;|rnou;|t(?:a;|h;|ween;))|fr;|ig(?:c(?:ap;|irc;|up;)|o(?:dot;|plus;|times;)|s(?:qcup;|tar;)|triangle(?:down;|up;)|uplus;|vee;|wedge;)|karow;|l(?:a(?:ck(?:lozenge;|square;|triangle(?:;|down;|left;|right;))|nk;)|k(?:1(?:2;|4;)|34;)|ock;)|n(?:e(?:;|quiv;)|ot;)|o(?:pf;|t(?:;|tom;)|wtie;|x(?:D(?:L;|R;|l;|r;)|H(?:;|D;|U;|d;|u;)|U(?:L;|R;|l;|r;)|V(?:;|H;|L;|R;|h;|l;|r;)|box;|d(?:L;|R;|l;|r;)|h(?:;|D;|U;|d;|u;)|minus;|plus;|times;|u(?:L;|R;|l;|r;)|v(?:;|H;|L;|R;|h;|l;|r;)))|prime;|r(?:eve;|vbar;?)|s(?:cr;|emi;|im(?:;|e;)|ol(?:;|b;|hsub;))|u(?:ll(?:;|et;)|mp(?:;|E;|e(?:;|q;))))|c(?:a(?:cute;|p(?:;|and;|brcup;|c(?:ap;|up;)|dot;|s;)|r(?:et;|on;))|c(?:a(?:ps;|ron;)|edil;?|irc;|ups(?:;|sm;))|dot;|e(?:dil;?|mptyv;|nt(?:;|erdot;|))|fr;|h(?:cy;|eck(?:;|mark;)|i;)|ir(?:;|E;|c(?:;|eq;|le(?:arrow(?:left;|right;)|d(?:R;|S;|ast;|circ;|dash;)))|e;|fnint;|mid;|scir;)|lubs(?:;|uit;)|o(?:lon(?:;|e(?:;|q;))|m(?:ma(?:;|t;)|p(?:;|fn;|le(?:ment;|xes;)))|n(?:g(?:;|dot;)|int;)|p(?:f;|rod;|y(?:;|sr;|)))|r(?:arr;|oss;)|s(?:cr;|u(?:b(?:;|e;)|p(?:;|e;)))|tdot;|u(?:darr(?:l;|r;)|e(?:pr;|sc;)|larr(?:;|p;)|p(?:;|brcap;|c(?:ap;|up;)|dot;|or;|s;)|r(?:arr(?:;|m;)|ly(?:eq(?:prec;|succ;)|vee;|wedge;)|ren;?|vearrow(?:left;|right;))|vee;|wed;)|w(?:conint;|int;)|ylcty;)|d(?:Arr;|Har;|a(?:gger;|leth;|rr;|sh(?:;|v;))|b(?:karow;|lac;)|c(?:aron;|y;)|d(?:;|a(?:gger;|rr;)|otseq;)|e(?:g;?|lta;|mptyv;)|f(?:isht;|r;)|har(?:l;|r;)|i(?:am(?:;|ond(?:;|suit;)|s;)|e;|gamma;|sin;|v(?:;|ide(?:;|ontimes;|)|onx;))|jcy;|lc(?:orn;|rop;)|o(?:llar;|pf;|t(?:;|eq(?:;|dot;)|minus;|plus;|square;)|ublebarwedge;|wn(?:arrow;|downarrows;|harpoon(?:left;|right;)))|r(?:bkarow;|c(?:orn;|rop;))|s(?:c(?:r;|y;)|ol;|trok;)|t(?:dot;|ri(?:;|f;))|u(?:arr;|har;)|wangle;|z(?:cy;|igrarr;))|e(?:D(?:Dot;|ot;)|a(?:cute;?|ster;)|c(?:aron;|ir(?:;|c;?)|olon;|y;)|dot;|e;|f(?:Dot;|r;)|g(?:;|rave;?|s(?:;|dot;))|l(?:;|inters;|l;|s(?:;|dot;))|m(?:acr;|pty(?:;|set;|v;)|sp(?:1(?:3;|4;)|;))|n(?:g;|sp;)|o(?:gon;|pf;)|p(?:ar(?:;|sl;)|lus;|si(?:;|lon;|v;))|q(?:c(?:irc;|olon;)|s(?:im;|lant(?:gtr;|less;))|u(?:als;|est;|iv(?:;|DD;))|vparsl;)|r(?:Dot;|arr;)|s(?:cr;|dot;|im;)|t(?:a;|h;?)|u(?:ml;?|ro;)|x(?:cl;|ist;|p(?:ectation;|onentiale;)))|f(?:allingdotseq;|cy;|emale;|f(?:ilig;|l(?:ig;|lig;)|r;)|ilig;|jlig;|l(?:at;|lig;|tns;)|nof;|o(?:pf;|r(?:all;|k(?:;|v;)))|partint;|r(?:a(?:c(?:1(?:2;?|3;|4;?|5;|6;|8;)|2(?:3;|5;)|3(?:4;?|5;|8;)|45;|5(?:6;|8;)|78;)|sl;)|own;)|scr;)|g(?:E(?:;|l;)|a(?:cute;|mma(?:;|d;)|p;)|breve;|c(?:irc;|y;)|dot;|e(?:;|l;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|l;))|l(?:;|es;)))|fr;|g(?:;|g;)|imel;|jcy;|l(?:;|E;|a;|j;)|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|opf;|rave;|s(?:cr;|im(?:;|e;|l;))|t(?:;|c(?:c;|ir;)|dot;|lPar;|quest;|r(?:a(?:pprox;|rr;)|dot;|eq(?:less;|qless;)|less;|sim;)|)|v(?:ertneqq;|nE;))|h(?:Arr;|a(?:irsp;|lf;|milt;|r(?:dcy;|r(?:;|cir;|w;)))|bar;|circ;|e(?:arts(?:;|uit;)|llip;|rcon;)|fr;|ks(?:earow;|warow;)|o(?:arr;|mtht;|ok(?:leftarrow;|rightarrow;)|pf;|rbar;)|s(?:cr;|lash;|trok;)|y(?:bull;|phen;))|i(?:acute;?|c(?:;|irc;?|y;)|e(?:cy;|xcl;?)|f(?:f;|r;)|grave;?|i(?:;|i(?:int;|nt;)|nfin;|ota;)|jlig;|m(?:a(?:cr;|g(?:e;|line;|part;)|th;)|of;|ped;)|n(?:;|care;|fin(?:;|tie;)|odot;|t(?:;|cal;|e(?:gers;|rcal;)|larhk;|prod;))|o(?:cy;|gon;|pf;|ta;)|prod;|quest;?|s(?:cr;|in(?:;|E;|dot;|s(?:;|v;)|v;))|t(?:;|ilde;)|u(?:kcy;|ml;?))|j(?:c(?:irc;|y;)|fr;|math;|opf;|s(?:cr;|ercy;)|ukcy;)|k(?:appa(?:;|v;)|c(?:edil;|y;)|fr;|green;|hcy;|jcy;|opf;|scr;)|l(?:A(?:arr;|rr;|tail;)|Barr;|E(?:;|g;)|Har;|a(?:cute;|emptyv;|gran;|mbda;|ng(?:;|d;|le;)|p;|quo;?|rr(?:;|b(?:;|fs;)|fs;|hk;|lp;|pl;|sim;|tl;)|t(?:;|ail;|e(?:;|s;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|quo(?:;|r;)|r(?:dhar;|ushar;)|sh;)|e(?:;|ft(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|leftarrows;|right(?:arrow(?:;|s;)|harpoons;|squigarrow;)|threetimes;)|g;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|r;))|g(?:;|es;)|s(?:approx;|dot;|eq(?:gtr;|qgtr;)|gtr;|sim;)))|f(?:isht;|loor;|r;)|g(?:;|E;)|h(?:ar(?:d;|u(?:;|l;))|blk;)|jcy;|l(?:;|arr;|corner;|hard;|tri;)|m(?:idot;|oust(?:;|ache;))|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|o(?:a(?:ng;|rr;)|brk;|ng(?:left(?:arrow;|rightarrow;)|mapsto;|rightarrow;)|oparrow(?:left;|right;)|p(?:ar;|f;|lus;)|times;|w(?:ast;|bar;)|z(?:;|enge;|f;))|par(?:;|lt;)|r(?:arr;|corner;|har(?:;|d;)|m;|tri;)|s(?:aquo;|cr;|h;|im(?:;|e;|g;)|q(?:b;|uo(?:;|r;))|trok;)|t(?:;|c(?:c;|ir;)|dot;|hree;|imes;|larr;|quest;|r(?:Par;|i(?:;|e;|f;))|)|ur(?:dshar;|uhar;)|v(?:ertneqq;|nE;))|m(?:DDot;|a(?:cr;?|l(?:e;|t(?:;|ese;))|p(?:;|sto(?:;|down;|left;|up;))|rker;)|c(?:omma;|y;)|dash;|easuredangle;|fr;|ho;|i(?:cro;?|d(?:;|ast;|cir;|dot;?)|nus(?:;|b;|d(?:;|u;)))|l(?:cp;|dr;)|nplus;|o(?:dels;|pf;)|p;|s(?:cr;|tpos;)|u(?:;|ltimap;|map;))|n(?:G(?:g;|t(?:;|v;))|L(?:eft(?:arrow;|rightarrow;)|l;|t(?:;|v;))|Rightarrow;|V(?:Dash;|dash;)|a(?:bla;|cute;|ng;|p(?:;|E;|id;|os;|prox;)|tur(?:;|al(?:;|s;)))|b(?:sp;?|ump(?:;|e;))|c(?:a(?:p;|ron;)|edil;|ong(?:;|dot;)|up;|y;)|dash;|e(?:;|Arr;|ar(?:hk;|r(?:;|ow;))|dot;|quiv;|s(?:ear;|im;)|xist(?:;|s;))|fr;|g(?:E;|e(?:;|q(?:;|q;|slant;)|s;)|sim;|t(?:;|r;))|h(?:Arr;|arr;|par;)|i(?:;|s(?:;|d;)|v;)|jcy;|l(?:Arr;|E;|arr;|dr;|e(?:;|ft(?:arrow;|rightarrow;)|q(?:;|q;|slant;)|s(?:;|s;))|sim;|t(?:;|ri(?:;|e;)))|mid;|o(?:pf;|t(?:;|in(?:;|E;|dot;|v(?:a;|b;|c;))|ni(?:;|v(?:a;|b;|c;))|))|p(?:ar(?:;|allel;|sl;|t;)|olint;|r(?:;|cue;|e(?:;|c(?:;|eq;))))|r(?:Arr;|arr(?:;|c;|w;)|ightarrow;|tri(?:;|e;))|s(?:c(?:;|cue;|e;|r;)|hort(?:mid;|parallel;)|im(?:;|e(?:;|q;))|mid;|par;|qsu(?:be;|pe;)|u(?:b(?:;|E;|e;|set(?:;|eq(?:;|q;)))|cc(?:;|eq;)|p(?:;|E;|e;|set(?:;|eq(?:;|q;)))))|t(?:gl;|ilde;?|lg;|riangle(?:left(?:;|eq;)|right(?:;|eq;)))|u(?:;|m(?:;|ero;|sp;))|v(?:Dash;|Harr;|ap;|dash;|g(?:e;|t;)|infin;|l(?:Arr;|e;|t(?:;|rie;))|r(?:Arr;|trie;)|sim;)|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|near;))|o(?:S;|a(?:cute;?|st;)|c(?:ir(?:;|c;?)|y;)|d(?:ash;|blac;|iv;|ot;|sold;)|elig;|f(?:cir;|r;)|g(?:on;|rave;?|t;)|h(?:bar;|m;)|int;|l(?:arr;|c(?:ir;|ross;)|ine;|t;)|m(?:acr;|ega;|i(?:cron;|d;|nus;))|opf;|p(?:ar;|erp;|lus;)|r(?:;|arr;|d(?:;|er(?:;|of;)|f;?|m;?)|igof;|or;|slope;|v;)|s(?:cr;|lash;?|ol;)|ti(?:lde;?|mes(?:;|as;))|uml;?|vbar;)|p(?:ar(?:;|a(?:;|llel;|)|s(?:im;|l;)|t;)|cy;|er(?:cnt;|iod;|mil;|p;|tenk;)|fr;|h(?:i(?:;|v;)|mmat;|one;)|i(?:;|tchfork;|v;)|l(?:an(?:ck(?:;|h;)|kv;)|us(?:;|acir;|b;|cir;|d(?:o;|u;)|e;|mn;?|sim;|two;))|m;|o(?:intint;|pf;|und;?)|r(?:;|E;|ap;|cue;|e(?:;|c(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;))|ime(?:;|s;)|n(?:E;|ap;|sim;)|o(?:d;|f(?:alar;|line;|surf;)|p(?:;|to;))|sim;|urel;)|s(?:cr;|i;)|uncsp;)|q(?:fr;|int;|opf;|prime;|scr;|u(?:at(?:ernions;|int;)|est(?:;|eq;)|ot;?))|r(?:A(?:arr;|rr;|tail;)|Barr;|Har;|a(?:c(?:e;|ute;)|dic;|emptyv;|ng(?:;|d;|e;|le;)|quo;?|rr(?:;|ap;|b(?:;|fs;)|c;|fs;|hk;|lp;|pl;|sim;|tl;|w;)|t(?:ail;|io(?:;|nals;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|ldhar;|quo(?:;|r;)|sh;)|e(?:al(?:;|ine;|part;|s;)|ct;|g;?)|f(?:isht;|loor;|r;)|h(?:ar(?:d;|u(?:;|l;))|o(?:;|v;))|i(?:ght(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|left(?:arrows;|harpoons;)|rightarrows;|squigarrow;|threetimes;)|ng;|singdotseq;)|l(?:arr;|har;|m;)|moust(?:;|ache;)|nmid;|o(?:a(?:ng;|rr;)|brk;|p(?:ar;|f;|lus;)|times;)|p(?:ar(?:;|gt;)|polint;)|rarr;|s(?:aquo;|cr;|h;|q(?:b;|uo(?:;|r;)))|t(?:hree;|imes;|ri(?:;|e;|f;|ltri;))|uluhar;|x;)|s(?:acute;|bquo;|c(?:;|E;|a(?:p;|ron;)|cue;|e(?:;|dil;)|irc;|n(?:E;|ap;|sim;)|polint;|sim;|y;)|dot(?:;|b;|e;)|e(?:Arr;|ar(?:hk;|r(?:;|ow;))|ct;?|mi;|swar;|tm(?:inus;|n;)|xt;)|fr(?:;|own;)|h(?:arp;|c(?:hcy;|y;)|ort(?:mid;|parallel;)|y;?)|i(?:gma(?:;|f;|v;)|m(?:;|dot;|e(?:;|q;)|g(?:;|E;)|l(?:;|E;)|ne;|plus;|rarr;))|larr;|m(?:a(?:llsetminus;|shp;)|eparsl;|i(?:d;|le;)|t(?:;|e(?:;|s;)))|o(?:ftcy;|l(?:;|b(?:;|ar;))|pf;)|pa(?:des(?:;|uit;)|r;)|q(?:c(?:ap(?:;|s;)|up(?:;|s;))|su(?:b(?:;|e;|set(?:;|eq;))|p(?:;|e;|set(?:;|eq;)))|u(?:;|ar(?:e;|f;)|f;))|rarr;|s(?:cr;|etmn;|mile;|tarf;)|t(?:ar(?:;|f;)|r(?:aight(?:epsilon;|phi;)|ns;))|u(?:b(?:;|E;|dot;|e(?:;|dot;)|mult;|n(?:E;|e;)|plus;|rarr;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;)))|cc(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;)|m;|ng;|p(?:1;?|2;?|3;?|;|E;|d(?:ot;|sub;)|e(?:;|dot;)|hs(?:ol;|ub;)|larr;|mult;|n(?:E;|e;)|plus;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;))))|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|nwar;)|zlig;?)|t(?:a(?:rget;|u;)|brk;|c(?:aron;|edil;|y;)|dot;|elrec;|fr;|h(?:e(?:re(?:4;|fore;)|ta(?:;|sym;|v;))|i(?:ck(?:approx;|sim;)|nsp;)|k(?:ap;|sim;)|orn;?)|i(?:lde;|mes(?:;|b(?:;|ar;)|d;|)|nt;)|o(?:ea;|p(?:;|bot;|cir;|f(?:;|ork;))|sa;)|prime;|r(?:ade;|i(?:angle(?:;|down;|left(?:;|eq;)|q;|right(?:;|eq;))|dot;|e;|minus;|plus;|sb;|time;)|pezium;)|s(?:c(?:r;|y;)|hcy;|trok;)|w(?:ixt;|ohead(?:leftarrow;|rightarrow;)))|u(?:Arr;|Har;|a(?:cute;?|rr;)|br(?:cy;|eve;)|c(?:irc;?|y;)|d(?:arr;|blac;|har;)|f(?:isht;|r;)|grave;?|h(?:ar(?:l;|r;)|blk;)|l(?:c(?:orn(?:;|er;)|rop;)|tri;)|m(?:acr;|l;?)|o(?:gon;|pf;)|p(?:arrow;|downarrow;|harpoon(?:left;|right;)|lus;|si(?:;|h;|lon;)|uparrows;)|r(?:c(?:orn(?:;|er;)|rop;)|ing;|tri;)|scr;|t(?:dot;|ilde;|ri(?:;|f;))|u(?:arr;|ml;?)|wangle;)|v(?:Arr;|Bar(?:;|v;)|Dash;|a(?:ngrt;|r(?:epsilon;|kappa;|nothing;|p(?:hi;|i;|ropto;)|r(?:;|ho;)|s(?:igma;|u(?:bsetneq(?:;|q;)|psetneq(?:;|q;)))|t(?:heta;|riangle(?:left;|right;))))|cy;|dash;|e(?:e(?:;|bar;|eq;)|llip;|r(?:bar;|t;))|fr;|ltri;|nsu(?:b;|p;)|opf;|prop;|rtri;|s(?:cr;|u(?:bn(?:E;|e;)|pn(?:E;|e;)))|zigzag;)|w(?:circ;|e(?:d(?:bar;|ge(?:;|q;))|ierp;)|fr;|opf;|p;|r(?:;|eath;)|scr;)|x(?:c(?:ap;|irc;|up;)|dtri;|fr;|h(?:Arr;|arr;)|i;|l(?:Arr;|arr;)|map;|nis;|o(?:dot;|p(?:f;|lus;)|time;)|r(?:Arr;|arr;)|s(?:cr;|qcup;)|u(?:plus;|tri;)|vee;|wedge;)|y(?:ac(?:ute;?|y;)|c(?:irc;|y;)|en;?|fr;|icy;|opf;|scr;|u(?:cy;|ml;?))|z(?:acute;|c(?:aron;|y;)|dot;|e(?:etrf;|ta;)|fr;|hcy;|igrarr;|opf;|scr;|w(?:j;|nj;)))|[\s\S]/g;

var NAMEDCHARREF_MAXLEN = 32;

// Regular expression constants used by the tokenizer and parser

// Note that \r is included in all of these regexps because it will need
// to be converted to LF by the scanChars() function.
var DBLQUOTEATTRVAL = /[^\r"&\u0000]+/g;
var SINGLEQUOTEATTRVAL = /[^\r'&\u0000]+/g;
var UNQUOTEDATTRVAL = /[^\r\t\n\f &>\u0000]+/g;
var TAGNAME = /[^\r\t\n\f \/>A-Z\u0000]+/g;
var ATTRNAME = /[^\r\t\n\f \/=>A-Z\u0000]+/g;

var CDATATEXT = /[^\]\r\u0000\uffff]*/g;
var DATATEXT = /[^&<\r\u0000\uffff]*/g;
var RAWTEXT = /[^<\r\u0000\uffff]*/g;
var PLAINTEXT = /[^\r\u0000\uffff]*/g;
// Since we don't have the 'sticky tag', add '|.' to the end of SIMPLETAG
// and SIMPLEATTR so that we are guaranteed to always match.  This prevents
// us from scanning past the lastIndex set. (Note that the desired matches
// are always greater than 1 char long, so longest-match will ensure that .
// is not matched unless the desired match fails.)
var SIMPLETAG = /(?:(\/)?([a-z]+)>)|[\s\S]/g;
var SIMPLEATTR = /(?:([-a-z]+)[ \t\n\f]*=[ \t\n\f]*('[^'&\r\u0000]*'|"[^"&\r\u0000]*"|[^\t\n\r\f "&'\u0000>][^&> \t\n\r\f\u0000]*[ \t\n\f]))|[\s\S]/g;

var NONWS = /[^\x09\x0A\x0C\x0D\x20]/;
var ALLNONWS = /[^\x09\x0A\x0C\x0D\x20]/g; // like above, with g flag
var NONWSNONNUL = /[^\x00\x09\x0A\x0C\x0D\x20]/; // don't allow NUL either
var LEADINGWS = /^[\x09\x0A\x0C\x0D\x20]+/;
var NULCHARS = /\x00/g;

/***
 * These are utility functions that don't use any of the parser's
 * internal state.
 */
function buf2str(buf) {
  var CHUNKSIZE=16384;
  if (buf.length < CHUNKSIZE) {
    return String.fromCharCode.apply(String, buf);
  }
  // special case for large strings, to avoid busting the stack.
  var result = '';
  for (var i = 0; i < buf.length; i += CHUNKSIZE) {
    result += String.fromCharCode.apply(String, buf.slice(i, i+CHUNKSIZE));
  }
  return result;
}

function str2buf(s) {
  var result = [];
  for (var i=0; i<s.length; i++) {
    result[i] = s.charCodeAt(i);
  }
  return result;
}

// Determine whether the element is a member of the set.
// The set is an object that maps namespaces to objects. The objects
// then map local tagnames to the value true if that tag is part of the set
function isA(elt, set) {
  if (typeof set === 'string') {
    // convenience case for testing a particular HTML element
    return elt.namespaceURI === NAMESPACE.HTML &&
      elt.localName === set;
  }
  var tagnames = set[elt.namespaceURI];
  return tagnames && tagnames[elt.localName];
}

function isMathmlTextIntegrationPoint(n) {
  return isA(n, mathmlTextIntegrationPointSet);
}

function isHTMLIntegrationPoint(n) {
  if (isA(n, htmlIntegrationPointSet)) return true;
  if (n.namespaceURI === NAMESPACE.MATHML &&
    n.localName === "annotation-xml") {
    var encoding = n.getAttribute("encoding");
    if (encoding) encoding = encoding.toLowerCase();
    if (encoding === "text/html" ||
      encoding === "application/xhtml+xml")
      return true;
  }
  return false;
}

function adjustSVGTagName(name) {
  if (name in svgTagNameAdjustments)
    return svgTagNameAdjustments[name];
  else
    return name;
}

function adjustSVGAttributes(attrs) {
  for(var i = 0, n = attrs.length; i < n; i++) {
    if (attrs[i][0] in svgAttrAdjustments) {
      attrs[i][0] = svgAttrAdjustments[attrs[i][0]];
    }
  }
}

function adjustMathMLAttributes(attrs) {
  for(var i = 0, n = attrs.length; i < n; i++) {
    if (attrs[i][0] === "definitionurl") {
      attrs[i][0] = "definitionURL";
      break;
    }
  }
}

function adjustForeignAttributes(attrs) {
  for(var i = 0, n = attrs.length; i < n; i++) {
    if (attrs[i][0] in foreignAttributes) {
      // Attributes with namespaces get a 3rd element:
      // [Qname, value, namespace]
      attrs[i].push(foreignAttributes[attrs[i][0]]);
    }
  }
}

// For each attribute in attrs, if elt doesn't have an attribute
// by that name, add the attribute to elt
// XXX: I'm ignoring namespaces for now
function transferAttributes(attrs, elt) {
  for(var i = 0, n = attrs.length; i < n; i++) {
    var name = attrs[i][0], value = attrs[i][1];
    if (elt.hasAttribute(name)) continue;
    elt._setAttribute(name, value);
  }
}

/***
 * The ElementStack class
 */
HTMLParser.ElementStack = function ElementStack() {
  this.elements = [];
  this.top = null; // stack.top is the "current node" in the spec
};

/*
// This is for debugging only
HTMLParser.ElementStack.prototype.toString = function(e) {
  return "STACK: " +
  this.elements.map(function(e) {return e.localName;}).join("-");
}
*/

HTMLParser.ElementStack.prototype.push = function(e) {
  this.elements.push(e);
  this.top = e;
};

HTMLParser.ElementStack.prototype.pop = function(e) {
  this.elements.pop();
  this.top = this.elements[this.elements.length-1];
};

// Pop elements off the stack up to and including the first
// element with the specified (HTML) tagname
HTMLParser.ElementStack.prototype.popTag = function(tag) {
  for(var i = this.elements.length-1; i > 0; i--) {
    var e = this.elements[i];
    if (isA(e, tag)) break;
  }
  this.elements.length = i;
  this.top = this.elements[i-1];
};

// Pop elements off the stack up to and including the first
// element that is an instance of the specified type
HTMLParser.ElementStack.prototype.popElementType = function(type) {
  for(var i = this.elements.length-1; i > 0; i--) {
    if (this.elements[i] instanceof type) break;
  }
  this.elements.length = i;
  this.top = this.elements[i-1];
};

// Pop elements off the stack up to and including the element e.
// Note that this is very different from removeElement()
// This requires that e is on the stack.
HTMLParser.ElementStack.prototype.popElement = function(e) {
  for(var i = this.elements.length-1; i > 0; i--) {
    if (this.elements[i] === e) break;
  }
  this.elements.length = i;
  this.top = this.elements[i-1];
};

// Remove a specific element from the stack.
// Do nothing if the element is not on the stack
HTMLParser.ElementStack.prototype.removeElement = function(e) {
  if (this.top === e) this.pop();
  else {
    var idx = this.elements.lastIndexOf(e);
    if (idx !== -1)
      this.elements.splice(idx, 1);
  }
};

HTMLParser.ElementStack.prototype.clearToContext = function(set) {
  // Note that we don't loop to 0. Never pop the <html> elt off.
  for(var i = this.elements.length-1; i > 0; i--) {
    if (isA(this.elements[i], set)) break;
  }
  this.elements.length = i+1;
  this.top = this.elements[i];
};

HTMLParser.ElementStack.prototype.contains = function(tag) {
  return this.inSpecificScope(tag, Object.create(null));
};

HTMLParser.ElementStack.prototype.inSpecificScope = function(tag, set) {
  for(var i = this.elements.length-1; i >= 0; i--) {
    var elt = this.elements[i];
    if (isA(elt, tag)) return true;
    if (isA(elt, set)) return false;
  }
  return false;
};

// Like the above, but for a specific element, not a tagname
HTMLParser.ElementStack.prototype.elementInSpecificScope = function(target, set) {
  for(var i = this.elements.length-1; i >= 0; i--) {
    var elt = this.elements[i];
    if (elt === target) return true;
    if (isA(elt, set)) return false;
  }
  return false;
};

// Like the above, but for an element interface, not a tagname
HTMLParser.ElementStack.prototype.elementTypeInSpecificScope = function(target, set) {
  for(var i = this.elements.length-1; i >= 0; i--) {
    var elt = this.elements[i];
    if (elt instanceof target) return true;
    if (isA(elt, set)) return false;
  }
  return false;
};

HTMLParser.ElementStack.prototype.inScope = function(tag) {
  return this.inSpecificScope(tag, inScopeSet);
};

HTMLParser.ElementStack.prototype.elementInScope = function(e) {
  return this.elementInSpecificScope(e, inScopeSet);
};

HTMLParser.ElementStack.prototype.elementTypeInScope = function(type) {
  return this.elementTypeInSpecificScope(type, inScopeSet);
};

HTMLParser.ElementStack.prototype.inButtonScope = function(tag) {
  return this.inSpecificScope(tag, inButtonScopeSet);
};

HTMLParser.ElementStack.prototype.inListItemScope = function(tag) {
  return this.inSpecificScope(tag, inListItemScopeSet);
};

HTMLParser.ElementStack.prototype.inTableScope = function(tag) {
  return this.inSpecificScope(tag, inTableScopeSet);
};

HTMLParser.ElementStack.prototype.inSelectScope = function(tag) {
  // Can't implement this one with inSpecificScope, since it involves
  // a set defined by inverting another set. So implement manually.
  for(var i = this.elements.length-1; i >= 0; i--) {
    var elt = this.elements[i];
    if (elt.namespaceURI !== NAMESPACE.HTML) return false;
    var localname = elt.localName;
    if (localname === tag) return true;
    if (localname !== "optgroup" && localname !== "option")
      return false;
  }
  return false;
};

HTMLParser.ElementStack.prototype.generateImpliedEndTags = function(butnot, thorough) {
  var endTagSet = thorough ? thoroughImpliedEndTagsSet : impliedEndTagsSet;
  for(var i = this.elements.length-1; i >= 0; i--) {
    var e = this.elements[i];
    if (butnot && isA(e, butnot)) break;
    if (!isA(this.elements[i], endTagSet)) break;
  }

  this.elements.length = i+1;
  this.top = this.elements[i];
};

/***
 * The ActiveFormattingElements class
 */
HTMLParser.ActiveFormattingElements = function AFE() {
  this.list = []; // elements
  this.attrs = []; // attribute tokens for cloning
};

HTMLParser.ActiveFormattingElements.prototype.MARKER = { localName: "|" };

/*
// For debugging
HTMLParser.ActiveFormattingElements.prototype.toString = function() {
  return "AFE: " +
  this.list.map(function(e) { return e.localName; }).join("-");
}
*/

HTMLParser.ActiveFormattingElements.prototype.insertMarker = function() {
  this.list.push(this.MARKER);
  this.attrs.push(this.MARKER);
};

HTMLParser.ActiveFormattingElements.prototype.push = function(elt, attrs) {
  // Scan backwards: if there are already 3 copies of this element
  // before we encounter a marker, then drop the last one
  var count = 0;
  for(var i = this.list.length-1; i >= 0; i--) {
    if (this.list[i] === this.MARKER) break;
    // equal() is defined below
    if (equal(elt, this.list[i], this.attrs[i])) {
      count++;
      if (count === 3) {
        this.list.splice(i, 1);
        this.attrs.splice(i, 1);
        break;
      }
    }
  }


  // Now push the element onto the list
  this.list.push(elt);

  // Copy the attributes and push those on, too
  var attrcopy = [];
  for(var ii = 0; ii < attrs.length; ii++) {
    attrcopy[ii] = attrs[ii];
  }

  this.attrs.push(attrcopy);

  // This function defines equality of two elements for the purposes
  // of the AFE list.  Note that it compares the new elements
  // attributes to the saved array of attributes associated with
  // the old element because a script could have changed the
  // old element's set of attributes
  function equal(newelt, oldelt, oldattrs) {
    if (newelt.localName !== oldelt.localName) return false;
    if (newelt._numattrs !== oldattrs.length) return false;
    for(var i = 0, n = oldattrs.length; i < n; i++) {
      var oldname = oldattrs[i][0];
      var oldval = oldattrs[i][1];
      if (!newelt.hasAttribute(oldname)) return false;
      if (newelt.getAttribute(oldname) !== oldval) return false;
    }
    return true;
  }
};

HTMLParser.ActiveFormattingElements.prototype.clearToMarker = function() {
  for(var i = this.list.length-1; i >= 0; i--) {
    if (this.list[i] === this.MARKER) break;
  }
  if (i < 0) i = 0;
  this.list.length = i;
  this.attrs.length = i;
};

// Find and return the last element with the specified tag between the
// end of the list and the last marker on the list.
// Used when parsing <a> in_body_mode()
HTMLParser.ActiveFormattingElements.prototype.findElementByTag = function(tag) {
  for(var i = this.list.length-1; i >= 0; i--) {
    var elt = this.list[i];
    if (elt === this.MARKER) break;
    if (elt.localName === tag) return elt;
  }
  return null;
};

HTMLParser.ActiveFormattingElements.prototype.indexOf = function(e) {
  return this.list.lastIndexOf(e);
};

// Find the element e in the list and remove it
// Used when parsing <a> in_body()
HTMLParser.ActiveFormattingElements.prototype.remove = function(e) {
  var idx = this.list.lastIndexOf(e);
  if (idx !== -1) {
    this.list.splice(idx, 1);
    this.attrs.splice(idx, 1);
  }
};

// Find element a in the list and replace it with element b
// XXX: Do I need to handle attributes here?
HTMLParser.ActiveFormattingElements.prototype.replace = function(a, b, attrs) {
  var idx = this.list.lastIndexOf(a);
  if (idx !== -1) {
    this.list[idx] = b;
    this.attrs[idx] = attrs;
  }
};

// Find a in the list and insert b after it
// This is only used for insert a bookmark object, so the
// attrs array doesn't really matter
HTMLParser.ActiveFormattingElements.prototype.insertAfter = function(a,b) {
  var idx = this.list.lastIndexOf(a);
  if (idx !== -1) {
    this.list.splice(idx, 0, b);
    this.attrs.splice(idx, 0, b);
  }
};




/***
 * This is the parser factory function. It is the return value of
 * the outer closure that it is defined within.  Most of the parser
 * implementation details are inside this function.
 */
function HTMLParser(address, fragmentContext, options) {
  /***
   * These are the parser's state variables
   */
  // Scanner state
  var chars = null;
  var numchars = 0; // Length of chars
  var nextchar = 0; // Index of next char
  var input_complete = false; // Becomes true when end() called.
  var scanner_skip_newline = false; // If previous char was CR
  var reentrant_invocations = 0;
  var saved_scanner_state = [];
  var leftovers = "";
  var first_batch = true;
  var paused = 0; // Becomes non-zero while loading scripts


  // Tokenizer state
  var tokenizer = data_state; // Current tokenizer state
  var return_state;
  var character_reference_code;
  var tagnamebuf = "";
  var lasttagname = ""; // holds the target end tag for text states
  var tempbuf = [];
  var attrnamebuf = "";
  var attrvaluebuf = "";
  var commentbuf = [];
  var doctypenamebuf = [];
  var doctypepublicbuf = [];
  var doctypesystembuf = [];
  var attributes = [];
  var is_end_tag = false;

  // Tree builder state
  var parser = initial_mode; // Current insertion mode
  var originalInsertionMode = null; // A saved insertion mode
  var templateInsertionModes = []; // Stack of template insertion modes.
  var stack = new HTMLParser.ElementStack(); // Stack of open elements
  var afe = new HTMLParser.ActiveFormattingElements(); // mis-nested tags
  var fragment = (fragmentContext!==undefined); // For innerHTML, etc.
  var head_element_pointer = null;
  var form_element_pointer = null;
  var scripting_enabled = true;
  if (fragmentContext) {
	scripting_enabled = fragmentContext.ownerDocument._scripting_enabled;
  }
  if (options && options.scripting_enabled === false)
    scripting_enabled = false;
  var frameset_ok = true;
  var force_quirks = false;
  var pending_table_text;
  var text_integration_mode; // XXX a spec bug workaround?

  // A single run of characters, buffered up to be sent to
  // the parser as a single string.
  var textrun = [];
  var textIncludesNUL = false;
  var ignore_linefeed = false;

  /***
   * This is the parser object that will be the return value of this
   * factory function, which is some 5000 lines below.
   * Note that the variable "parser" is the current state of the
   * parser's state machine.  This variable "htmlparser" is the
   * return value and defines the public API of the parser
   */
  var htmlparser = {
    document: function() {
      return doc;
    },

    // Internal function used from HTMLScriptElement to pause the
    // parser while a script is being loaded from the network
    pause: function() {
      // print("pausing parser");
      paused++;
    },

    // Called when a script finishes loading
    resume: function() {
      // print("resuming parser");
      paused--;
      // XXX: added this to force a resumption.
      // Is this the right thing to do?
      this.parse("");
    },

    // Parse the HTML text s.
    // The second argument should be true if there is no more
    // text to be parsed, and should be false or omitted otherwise.
    // The second argument must not be set for recursive invocations
    // from document.write()
    parse: function(s, end) {

      // If we're paused, remember the text to parse, but
      // don't parse it now.
      if (paused > 0) {
        leftovers += s;
        return;
      }


      if (reentrant_invocations === 0) {
        // A normal, top-level invocation
        if (leftovers) {
          s = leftovers + s;
          leftovers = "";
        }

        // Add a special marker character to the end of
        // the buffer.  If the scanner is at the end of
        // the buffer and input_complete is set, then this
        // character will transform into an EOF token.
        // Having an actual character that represents EOF
        // in the character buffer makes lookahead regexp
        // matching work more easily, and this is
        // important for character references.
        if (end) {
          s += "\uFFFF";
          input_complete = true; // Makes scanChars() send EOF
        }

        chars = s;
        numchars = s.length;
        nextchar = 0;

        if (first_batch) {
          // We skip a leading Byte Order Mark (\uFEFF)
          // on first batch of text we're given
          first_batch = false;
          if (chars.charCodeAt(0) === 0xFEFF) nextchar = 1;
        }

        reentrant_invocations++;
        scanChars();
        leftovers = chars.substring(nextchar, numchars);
        reentrant_invocations--;
      }
      else {
        // This is the re-entrant case, which we have to
        // handle a little differently.
        reentrant_invocations++;

        // Save current scanner state
        saved_scanner_state.push(chars, numchars, nextchar);

        // Set new scanner state
        chars = s;
        numchars = s.length;
        nextchar = 0;

        // Now scan as many of these new chars as we can
        scanChars();

        leftovers = chars.substring(nextchar, numchars);

        // restore old scanner state
        nextchar = saved_scanner_state.pop();
        numchars = saved_scanner_state.pop();
        chars = saved_scanner_state.pop();

        // If there were leftover chars from this invocation
        // insert them into the pending invocation's buffer
        // and trim already processed chars at the same time
        if (leftovers) {
          chars = leftovers + chars.substring(nextchar);
          numchars = chars.length;
          nextchar = 0;
          leftovers = "";
        }

        // Decrement the counter
        reentrant_invocations--;
      }
    }
  };


  // This is the document we'll be building up
  var doc = new Document(true, address);

  // The document needs to know about the parser, for document.write().
  // This _parser property will be deleted when we're done parsing.
  doc._parser = htmlparser;

  // XXX I think that any document we use this parser on should support
  // scripts. But I may need to configure that through a parser parameter
  // Only documents with windows ("browsing contexts" to be precise)
  // allow scripting.
  doc._scripting_enabled = scripting_enabled;


  /***
   * The actual code of the HTMLParser() factory function begins here.
   */

  if (fragmentContext) { // for innerHTML parsing
    if (fragmentContext.ownerDocument._quirks)
      doc._quirks = true;
    if (fragmentContext.ownerDocument._limitedQuirks)
      doc._limitedQuirks = true;

    // Set the initial tokenizer state
    if (fragmentContext.namespaceURI === NAMESPACE.HTML) {
      switch(fragmentContext.localName) {
      case "title":
      case "textarea":
        tokenizer = rcdata_state;
        break;
      case "style":
      case "xmp":
      case "iframe":
      case "noembed":
      case "noframes":
      case "script":
      case "plaintext":
        tokenizer = plaintext_state;
        break;
      case "noscript":
        if (scripting_enabled)
          tokenizer = plaintext_state;
      }
    }

    var root = doc.createElement("html");
    doc._appendChild(root);
    stack.push(root);
    if (fragmentContext instanceof impl.HTMLTemplateElement) {
      templateInsertionModes.push(in_template_mode);
    }
    resetInsertionMode();

    for(var e = fragmentContext; e !== null; e = e.parentElement) {
      if (e instanceof impl.HTMLFormElement) {
        form_element_pointer = e;
        break;
      }
    }
  }

  /***
   * Scanner functions
   */
  // Loop through the characters in chars, and pass them one at a time
  // to the tokenizer FSM. Return when no more characters can be processed
  // (This may leave 1 or more characters in the buffer: like a CR
  // waiting to see if the next char is LF, or for states that require
  // lookahead...)
  function scanChars() {
    var codepoint, s, pattern, eof;

    while(nextchar < numchars) {

      // If we just tokenized a </script> tag, then the paused flag
      // may have been set to tell us to stop tokenizing while
      // the script is loading
      if (paused > 0) {
        return;
      }


      switch(typeof tokenizer.lookahead) {
      case 'undefined':
        codepoint = chars.charCodeAt(nextchar++);
        if (scanner_skip_newline) {
          scanner_skip_newline = false;
          if (codepoint === 0x000A) {
            nextchar++;
            continue;
          }
        }
        switch(codepoint) {
        case 0x000D:
          // CR always turns into LF, but if the next character
          // is LF, then that second LF is skipped.
          if (nextchar < numchars) {
            if (chars.charCodeAt(nextchar) === 0x000A)
              nextchar++;
          }
          else {
            // We don't know the next char right now, so we
            // can't check if it is a LF.  So set a flag
            scanner_skip_newline = true;
          }

          // In either case, emit a LF
          tokenizer(0x000A);

          break;
        case 0xFFFF:
          if (input_complete && nextchar === numchars) {
            tokenizer(EOF); // codepoint will be 0xFFFF here
            break;
          }
          /* falls through */
        default:
          tokenizer(codepoint);
          break;
        }
        break;

      case 'number':
        codepoint = chars.charCodeAt(nextchar);

        // The only tokenizer states that require fixed lookahead
        // only consume alphanum characters, so we don't have
        // to worry about CR and LF in this case

        // tokenizer wants n chars of lookahead
        var n = tokenizer.lookahead;
        var needsString = true;
        if (n < 0) {
          needsString = false;
          n = -n;
        }

        if (n < numchars - nextchar) {
          // If we can look ahead that far
          s = needsString ? chars.substring(nextchar, nextchar+n) : null;
          eof = false;
        }
        else { // if we don't have that many characters
          if (input_complete) { // If no more are coming
            // Just return what we have
            s = needsString ? chars.substring(nextchar, numchars) : null;
            eof = true;
            if (codepoint === 0xFFFF && nextchar === numchars-1)
              codepoint = EOF;
          }
          else {
            // Return now and wait for more chars later
            return;
          }
        }
        tokenizer(codepoint, s, eof);
        break;
      case 'string':
        codepoint = chars.charCodeAt(nextchar);

        // tokenizer wants characters up to a matching string
        pattern = tokenizer.lookahead;
        var pos = chars.indexOf(pattern, nextchar);
        if (pos !== -1) {
          s = chars.substring(nextchar, pos + pattern.length);
          eof = false;
        }
        else {  // No match
          // If more characters coming, wait for them
          if (!input_complete) return;

          // Otherwise, we've got to return what we've got
          s = chars.substring(nextchar, numchars);
          if (codepoint === 0xFFFF && nextchar === numchars-1)
            codepoint = EOF;
          eof = true;
        }

        // The tokenizer states that require this kind of
        // lookahead have to be careful to handle CR characters
        // correctly
        tokenizer(codepoint, s, eof);
        break;
      }
    }
  }


  /***
   * Tokenizer utility functions
   */
  function addAttribute(name,value) {
    // Make sure there isn't already an attribute with this name
    // If there is, ignore this one.
    for(var i = 0; i < attributes.length; i++) {
      if (attributes[i][0] === name) return;
    }

    if (value !== undefined) {
      attributes.push([name, value]);
    }
    else {
      attributes.push([name]);
    }
  }

  // Shortcut for simple attributes
  function handleSimpleAttribute() {
    SIMPLEATTR.lastIndex = nextchar-1;
    var matched = SIMPLEATTR.exec(chars);
    if (!matched) throw new Error("should never happen");
    var name = matched[1];
    if (!name) return false;
    var value = matched[2];
    var len = value.length;
    switch(value[0]) {
    case '"':
    case "'":
      value = value.substring(1, len-1);
      nextchar += (matched[0].length-1);
      tokenizer = after_attribute_value_quoted_state;
      break;
    default:
      tokenizer = before_attribute_name_state;
      nextchar += (matched[0].length-1);
      value = value.substring(0, len-1);
      break;
    }

    // Make sure there isn't already an attribute with this name
    // If there is, ignore this one.
    for(var i = 0; i < attributes.length; i++) {
      if (attributes[i][0] === name) return true;
    }

    attributes.push([name, value]);
    return true;
  }

  function beginTagName() {
    is_end_tag = false;
    tagnamebuf = "";
    attributes.length = 0;
  }
  function beginEndTagName() {
    is_end_tag = true;
    tagnamebuf = "";
    attributes.length = 0;
  }

  function beginTempBuf() { tempbuf.length = 0; }
  function beginAttrName() { attrnamebuf = ""; }
  function beginAttrValue() { attrvaluebuf = ""; }
  function beginComment() { commentbuf.length = 0; }
  function beginDoctype() {
    doctypenamebuf.length = 0;
    doctypepublicbuf = null;
    doctypesystembuf = null;
  }
  function beginDoctypePublicId() { doctypepublicbuf = []; }
  function beginDoctypeSystemId() { doctypesystembuf = []; }
  function forcequirks() { force_quirks = true; }
  function cdataAllowed() {
    return stack.top &&
      stack.top.namespaceURI !== "http://www.w3.org/1999/xhtml";
  }

  // Return true if the codepoints in the specified buffer match the
  // characters of lasttagname
  function appropriateEndTag(buf) {
    return lasttagname === buf;
  }

  function flushText() {
    if (textrun.length > 0) {
      var s = buf2str(textrun);
      textrun.length = 0;

      if (ignore_linefeed) {
        ignore_linefeed = false;
        if (s[0] === "\n") s = s.substring(1);
        if (s.length === 0) return;
      }

      insertToken(TEXT, s);
      textIncludesNUL = false;
    }
    ignore_linefeed = false;
  }

  // Consume chars matched by the pattern and return them as a string. Starts
  // matching at the current position, so users should drop the current char
  // otherwise.
  function getMatchingChars(pattern) {
    pattern.lastIndex = nextchar - 1;
    var match = pattern.exec(chars);
    if (match && match.index === nextchar - 1) {
      match = match[0];
      nextchar += match.length - 1;
      /* Careful!  Make sure we haven't matched the EOF character! */
      if (input_complete && nextchar === numchars) {
        // Oops, backup one.
        match = match.slice(0, -1);
        nextchar--;
      }
      return match;
    } else {
      throw new Error("should never happen");
    }
  }

  // emit a string of chars that match a regexp
  // Returns false if no chars matched.
  function emitCharsWhile(pattern) {
    pattern.lastIndex = nextchar-1;
    var match = pattern.exec(chars)[0];
    if (!match) return false;
    emitCharString(match);
    nextchar += match.length - 1;
    return true;
  }

  // This is used by CDATA sections
  function emitCharString(s) {
    if (textrun.length > 0) flushText();

    if (ignore_linefeed) {
      ignore_linefeed = false;
      if (s[0] === "\n") s = s.substring(1);
      if (s.length === 0) return;
    }

    insertToken(TEXT, s);
  }

  function emitTag() {
    if (is_end_tag) insertToken(ENDTAG, tagnamebuf);
    else {
      // Remember the last open tag we emitted
      var tagname = tagnamebuf;
      tagnamebuf = "";
      lasttagname = tagname;
      insertToken(TAG, tagname, attributes);
    }
  }


  // A shortcut: look ahead and if this is a open or close tag
  // in lowercase with no spaces and no attributes, just emit it now.
  function emitSimpleTag() {
    SIMPLETAG.lastIndex = nextchar;
    var matched = SIMPLETAG.exec(chars);
    if (!matched) throw new Error("should never happen");
    var tagname = matched[2];
    if (!tagname) return false;
    var endtag = matched[1];
    if (endtag) {
      nextchar += (tagname.length+2);
      insertToken(ENDTAG, tagname);
    }
    else {
      nextchar += (tagname.length+1);
      lasttagname = tagname;
      insertToken(TAG, tagname, NOATTRS);
    }
    return true;
  }

  function emitSelfClosingTag() {
    if (is_end_tag) insertToken(ENDTAG, tagnamebuf, null, true);
    else {
      insertToken(TAG, tagnamebuf, attributes, true);
    }
  }

  function emitDoctype() {
    insertToken(DOCTYPE,
          buf2str(doctypenamebuf),
          doctypepublicbuf ? buf2str(doctypepublicbuf) : undefined,
          doctypesystembuf ? buf2str(doctypesystembuf) : undefined);
  }

  function emitEOF() {
    flushText();
    parser(EOF); // EOF never goes to insertForeignContent()
    doc.modclock = 1; // Start tracking modifications
  }

  // Insert a token, either using the current parser insertion mode
  // (for HTML stuff) or using the insertForeignToken() method.
  var insertToken = htmlparser.insertToken = function insertToken(t, value, arg3, arg4) {
    flushText();
    var current = stack.top;

    if (!current || current.namespaceURI === NAMESPACE.HTML) {
      // This is the common case
      parser(t, value, arg3, arg4);
    }
    else {
      // Otherwise we may need to insert this token as foreign content
      if (t !== TAG && t !== TEXT) {
        insertForeignToken(t, value, arg3, arg4);
      }
      else {
        // But in some cases we treat it as regular content
        if ((isMathmlTextIntegrationPoint(current) &&
           (t === TEXT ||
            (t === TAG &&
             value !== "mglyph" && value !== "malignmark"))) ||
          (t === TAG &&
           value === "svg" &&
           current.namespaceURI === NAMESPACE.MATHML &&
           current.localName === "annotation-xml") ||
          isHTMLIntegrationPoint(current)) {

          // XXX: the text_integration_mode stuff is an
          // attempted bug workaround of mine
          text_integration_mode = true;
          parser(t, value, arg3, arg4);
          text_integration_mode = false;
        }
        // Otherwise it is foreign content
        else {
          insertForeignToken(t, value, arg3, arg4);
        }
      }
    }
  };


  /***
   * Tree building utility functions
   */
  function insertComment(data) {
    var parent = stack.top;
    if (foster_parent_mode && isA(parent, tablesectionrowSet)) {
      fosterParent(function(doc) { return doc.createComment(data); });
    } else {
      // "If the adjusted insertion location is inside a template element,
      // let it instead be inside the template element's template contents"
      if (parent instanceof impl.HTMLTemplateElement) {
        parent = parent.content;
      }
      parent._appendChild(parent.ownerDocument.createComment(data));
    }
  }

  function insertText(s) {
    var parent = stack.top;
    if (foster_parent_mode && isA(parent, tablesectionrowSet)) {
      fosterParent(function(doc) { return doc.createTextNode(s); });
    } else {
      // "If the adjusted insertion location is inside a template element,
      // let it instead be inside the template element's template contents"
      if (parent instanceof impl.HTMLTemplateElement) {
        parent = parent.content;
      }
      // "If there is a Text node immediately before the adjusted insertion
      // location, then append data to that Text node's data."
      var lastChild = parent.lastChild;
      if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {
        lastChild.appendData(s);
      } else {
        parent._appendChild(parent.ownerDocument.createTextNode(s));
      }
    }
  }

  function createHTMLElt(doc, name, attrs) {
    // Create the element this way, rather than with
    // doc.createElement because createElement() does error
    // checking on the element name that we need to avoid here.
    var elt = html.createElement(doc, name, null);

    if (attrs) {
      for(var i = 0, n = attrs.length; i < n; i++) {
        // Use the _ version to avoid testing the validity
        // of the attribute name
        elt._setAttribute(attrs[i][0], attrs[i][1]);
      }
    }
    // XXX
    // If the element is a resettable form element,
    // run its reset algorithm now
    // XXX
    // handle case where form-element-pointer is not null
    return elt;
  }

  // The in_table insertion mode turns on this flag, and that makes
  // insertHTMLElement use the foster parenting algorithm for elements
  // tags inside a table
  var foster_parent_mode = false;

  function insertHTMLElement(name, attrs) {
    var elt = insertElement(function(doc) {
      return createHTMLElt(doc, name, attrs);
    });

    // XXX
    // If this is a form element, set its form attribute property here
    if (isA(elt, formassociatedSet)) {
      elt._form = form_element_pointer;
    }

    return elt;
  }

  // Insert the element into the open element or foster parent it
  function insertElement(eltFunc) {
    var elt;
    if (foster_parent_mode && isA(stack.top, tablesectionrowSet)) {
      elt = fosterParent(eltFunc);
    }
    else if (stack.top instanceof impl.HTMLTemplateElement) {
      // "If the adjusted insertion location is inside a template element,
      // let it instead be inside the template element's template contents"
      elt = eltFunc(stack.top.content.ownerDocument);
      stack.top.content._appendChild(elt);
    } else {
      elt = eltFunc(stack.top.ownerDocument);
      stack.top._appendChild(elt);
    }

    stack.push(elt);
    return elt;
  }

  function insertForeignElement(name, attrs, ns) {
    return insertElement(function(doc) {
      var elt = doc.createElementNS(ns, name);
      if (attrs) {
        for(var i = 0, n = attrs.length; i < n; i++) {
          var attr = attrs[i];
          if (attr.length === 2)
            elt._setAttribute(attr[0], attr[1]);
          else {
            elt._setAttributeNS(attr[2], attr[0], attr[1]);
          }
        }
      }
      return elt;
    });
  }

  function lastElementOfType(type) {
    for(var i = stack.elements.length-1; i >= 0; i--) {
      if (stack.elements[i] instanceof type) {
        return i;
      }
    }
    return -1;
  }

  function fosterParent(eltFunc) {
    var parent, before, lastTable = -1, lastTemplate = -1, elt;

    lastTable = lastElementOfType(impl.HTMLTableElement);
    lastTemplate = lastElementOfType(impl.HTMLTemplateElement);

    if (lastTemplate >= 0 && (lastTable < 0 || lastTemplate > lastTable)) {
      parent = stack.elements[lastTemplate];
    } else if (lastTable >= 0) {
      parent = stack.elements[lastTable].parentNode;
      if (parent) {
        before = stack.elements[lastTable];
      } else {
        parent = stack.elements[lastTable - 1];
      }
    }
    if (!parent) parent = stack.elements[0]; // the `html` element.

    // "If the adjusted insertion location is inside a template element,
    // let it instead be inside the template element's template contents"
    if (parent instanceof impl.HTMLTemplateElement) {
      parent = parent.content;
    }
    // Create element in the appropriate document.
    elt = eltFunc(parent.ownerDocument);

    if (elt.nodeType === Node.TEXT_NODE) {
      var prev;
      if (before) prev = before.previousSibling;
      else prev = parent.lastChild;
      if (prev && prev.nodeType === Node.TEXT_NODE) {
        prev.appendData(elt.data);
        return elt;
      }
    }
    if (before)
      parent.insertBefore(elt, before);
    else
      parent._appendChild(elt);
    return elt;
  }


  function resetInsertionMode() {
    var last = false;
    for(var i = stack.elements.length-1; i >= 0; i--) {
      var node = stack.elements[i];
      if (i === 0) {
        last = true;
        if (fragment) {
          node = fragmentContext;
        }
      }
      if (node.namespaceURI === NAMESPACE.HTML) {
        var tag = node.localName;
        switch(tag) {
        case "select":
          for(var j = i; j > 0; ) {
            var ancestor = stack.elements[--j];
            if (ancestor instanceof impl.HTMLTemplateElement) {
              break;
            } else if (ancestor instanceof impl.HTMLTableElement) {
              parser = in_select_in_table_mode;
              return;
            }
          }
          parser = in_select_mode;
          return;
        case "tr":
          parser = in_row_mode;
          return;
        case "tbody":
        case "tfoot":
        case "thead":
          parser = in_table_body_mode;
          return;
        case "caption":
          parser = in_caption_mode;
          return;
        case "colgroup":
          parser = in_column_group_mode;
          return;
        case "table":
          parser = in_table_mode;
          return;
        case "template":
          parser = templateInsertionModes[templateInsertionModes.length-1];
          return;
        case "body":
          parser = in_body_mode;
          return;
        case "frameset":
          parser = in_frameset_mode;
          return;
        case "html":
          if (head_element_pointer === null) {
            parser = before_head_mode;
          } else {
            parser = after_head_mode;
          }
          return;
        default:
          if (!last) {
            if (tag === "head") {
              parser = in_head_mode;
              return;
            }
            if (tag === "td" || tag === "th") {
              parser = in_cell_mode;
              return;
            }
          }
        }
      }
      if (last) {
        parser = in_body_mode;
        return;
      }
    }
  }


  function parseRawText(name, attrs) {
    insertHTMLElement(name, attrs);
    tokenizer = rawtext_state;
    originalInsertionMode = parser;
    parser = text_mode;
  }

  function parseRCDATA(name, attrs) {
    insertHTMLElement(name, attrs);
    tokenizer = rcdata_state;
    originalInsertionMode = parser;
    parser = text_mode;
  }

  // Make a copy of element i on the list of active formatting
  // elements, using its original attributes, not current
  // attributes (which may have been modified by a script)
  function afeclone(doc, i) {
    return {
      elt: createHTMLElt(doc, afe.list[i].localName, afe.attrs[i]),
      attrs: afe.attrs[i],
    };
  }


  function afereconstruct() {
    if (afe.list.length === 0) return;
    var entry = afe.list[afe.list.length-1];
    // If the last is a marker , do nothing
    if (entry === afe.MARKER) return;
    // Or if it is an open element, do nothing
    if (stack.elements.lastIndexOf(entry) !== -1) return;

    // Loop backward through the list until we find a marker or an
    // open element, and then move forward one from there.
    for(var i = afe.list.length-2; i >= 0; i--) {
      entry = afe.list[i];
      if (entry === afe.MARKER) break;
      if (stack.elements.lastIndexOf(entry) !== -1) break;
    }

    // Now loop forward, starting from the element after the current
    // one, recreating formatting elements and pushing them back onto
    // the list of open elements
    for(i = i+1; i < afe.list.length; i++) {
      var newelt = insertElement(function(doc) { return afeclone(doc, i).elt; });
      afe.list[i] = newelt;
    }
  }

  // Used by the adoptionAgency() function
  var BOOKMARK = {localName:"BM"};

  function adoptionAgency(tag) {
    // If the current node is an HTML element whose tag name is subject,
    // and the current node is not in the list of active formatting
    // elements, then pop the current node off the stack of open
    // elements and abort these steps.
    if (isA(stack.top, tag) && afe.indexOf(stack.top) === -1) {
      stack.pop();
      return true; // no more handling required
    }

    // Let outer loop counter be zero.
    var outer = 0;

    // Outer loop: If outer loop counter is greater than or
    // equal to eight, then abort these steps.
    while(outer < 8) {
      // Increment outer loop counter by one.
      outer++;

      // Let the formatting element be the last element in the list
      // of active formatting elements that: is between the end of
      // the list and the last scope marker in the list, if any, or
      // the start of the list otherwise, and has the same tag name
      // as the token.
      var fmtelt = afe.findElementByTag(tag);

      // If there is no such node, then abort these steps and instead
      // act as described in the "any other end tag" entry below.
      if (!fmtelt) {
        return false; // false means handle by the default case
      }

      // Otherwise, if there is such a node, but that node is not in
      // the stack of open elements, then this is a parse error;
      // remove the element from the list, and abort these steps.
      var index = stack.elements.lastIndexOf(fmtelt);
      if (index === -1) {
        afe.remove(fmtelt);
        return true;   // true means no more handling required
      }

      // Otherwise, if there is such a node, and that node is also in
      // the stack of open elements, but the element is not in scope,
      // then this is a parse error; ignore the token, and abort
      // these steps.
      if (!stack.elementInScope(fmtelt)) {
        return true;
      }

      // Let the furthest block be the topmost node in the stack of
      // open elements that is lower in the stack than the formatting
      // element, and is an element in the special category. There
      // might not be one.
      var furthestblock = null, furthestblockindex;
      for(var i = index+1; i < stack.elements.length; i++) {
        if (isA(stack.elements[i], specialSet)) {
          furthestblock = stack.elements[i];
          furthestblockindex = i;
          break;
        }
      }

      // If there is no furthest block, then the UA must skip the
      // subsequent steps and instead just pop all the nodes from the
      // bottom of the stack of open elements, from the current node
      // up to and including the formatting element, and remove the
      // formatting element from the list of active formatting
      // elements.
      if (!furthestblock) {
        stack.popElement(fmtelt);
        afe.remove(fmtelt);
        return true;
      }
      else {
        // Let the common ancestor be the element immediately above
        // the formatting element in the stack of open elements.
        var ancestor = stack.elements[index-1];

        // Let a bookmark note the position of the formatting
        // element in the list of active formatting elements
        // relative to the elements on either side of it in the
        // list.
        afe.insertAfter(fmtelt, BOOKMARK);

        // Let node and last node be the furthest block.
        var node = furthestblock;
        var lastnode = furthestblock;
        var nodeindex = furthestblockindex;
        var nodeafeindex;

        // Let inner loop counter be zero.
        var inner = 0;

        while (true) {

          // Increment inner loop counter by one.
          inner++;

          // Let node be the element immediately above node in
          // the stack of open elements, or if node is no longer
          // in the stack of open elements (e.g. because it got
          // removed by this algorithm), the element that was
          // immediately above node in the stack of open elements
          // before node was removed.
          node = stack.elements[--nodeindex];

          // If node is the formatting element, then go
          // to the next step in the overall algorithm.
          if (node === fmtelt) break;

          // If the inner loop counter is greater than three and node
          // is in the list of active formatting elements, then remove
          // node from the list of active formatting elements.
          nodeafeindex = afe.indexOf(node);
          if (inner > 3 && nodeafeindex !== -1) {
            afe.remove(node);
            nodeafeindex = -1;
          }

          // If node is not in the list of active formatting
          // elements, then remove node from the stack of open
          // elements and then go back to the step labeled inner
          // loop.
          if (nodeafeindex === -1) {
            stack.removeElement(node);
            continue;
          }

          // Create an element for the token for which the
          // element node was created with common ancestor as
          // the intended parent, replace the entry for node
          // in the list of active formatting elements with an
          // entry for the new element, replace the entry for
          // node in the stack of open elements with an entry for
          // the new element, and let node be the new element.
          var newelt = afeclone(ancestor.ownerDocument, nodeafeindex);
          afe.replace(node, newelt.elt, newelt.attrs);
          stack.elements[nodeindex] = newelt.elt;
          node = newelt.elt;

          // If last node is the furthest block, then move the
          // aforementioned bookmark to be immediately after the
          // new node in the list of active formatting elements.
          if (lastnode === furthestblock) {
            afe.remove(BOOKMARK);
            afe.insertAfter(newelt.elt, BOOKMARK);
          }

          // Insert last node into node, first removing it from
          // its previous parent node if any.
          node._appendChild(lastnode);

          // Let last node be node.
          lastnode = node;
        }

        // If the common ancestor node is a table, tbody, tfoot,
        // thead, or tr element, then, foster parent whatever last
        // node ended up being in the previous step, first removing
        // it from its previous parent node if any.
        if (foster_parent_mode && isA(ancestor, tablesectionrowSet)) {
          fosterParent(function() { return lastnode; });
        }
        // Otherwise, append whatever last node ended up being in
        // the previous step to the common ancestor node, first
        // removing it from its previous parent node if any.
        else if (ancestor instanceof impl.HTMLTemplateElement) {
          ancestor.content._appendChild(lastnode);
        } else {
          ancestor._appendChild(lastnode);
        }

        // Create an element for the token for which the
        // formatting element was created, with furthest block
        // as the intended parent.
        var newelt2 = afeclone(furthestblock.ownerDocument, afe.indexOf(fmtelt));

        // Take all of the child nodes of the furthest block and
        // append them to the element created in the last step.
        while(furthestblock.hasChildNodes()) {
          newelt2.elt._appendChild(furthestblock.firstChild);
        }

        // Append that new element to the furthest block.
        furthestblock._appendChild(newelt2.elt);

        // Remove the formatting element from the list of active
        // formatting elements, and insert the new element into the
        // list of active formatting elements at the position of
        // the aforementioned bookmark.
        afe.remove(fmtelt);
        afe.replace(BOOKMARK, newelt2.elt, newelt2.attrs);

        // Remove the formatting element from the stack of open
        // elements, and insert the new element into the stack of
        // open elements immediately below the position of the
        // furthest block in that stack.
        stack.removeElement(fmtelt);
        var pos = stack.elements.lastIndexOf(furthestblock);
        stack.elements.splice(pos+1, 0, newelt2.elt);
      }
    }

    return true;
  }

  // We do this when we get /script in in_text_mode
  function handleScriptEnd() {
    // XXX:
    // This is just a stub implementation right now and doesn't run scripts.
    // Getting this method right involves the event loop, URL resolution
    // script fetching etc. For now I just want to be able to parse
    // documents and test the parser.

    //var script = stack.top;
    stack.pop();
    parser = originalInsertionMode;
    //script._prepare();
    return;

    // XXX: here is what this method is supposed to do

    // Provide a stable state.

    // Let script be the current node (which will be a script
    // element).

    // Pop the current node off the stack of open elements.

    // Switch the insertion mode to the original insertion mode.

    // Let the old insertion point have the same value as the current
    // insertion point. Let the insertion point be just before the
    // next input character.

    // Increment the parser's script nesting level by one.

    // Prepare the script. This might cause some script to execute,
    // which might cause new characters to be inserted into the
    // tokenizer, and might cause the tokenizer to output more tokens,
    // resulting in a reentrant invocation of the parser.

    // Decrement the parser's script nesting level by one. If the
    // parser's script nesting level is zero, then set the parser
    // pause flag to false.

    // Let the insertion point have the value of the old insertion
    // point. (In other words, restore the insertion point to its
    // previous value. This value might be the "undefined" value.)

    // At this stage, if there is a pending parsing-blocking script,
    // then:

    // If the script nesting level is not zero:

    //   Set the parser pause flag to true, and abort the processing
    //   of any nested invocations of the tokenizer, yielding
    //   control back to the caller. (Tokenization will resume when
    //   the caller returns to the "outer" tree construction stage.)

    //   The tree construction stage of this particular parser is
    //   being called reentrantly, say from a call to
    //   document.write().

    // Otherwise:

    //     Run these steps:

    //       Let the script be the pending parsing-blocking
    //       script. There is no longer a pending
    //       parsing-blocking script.

    //       Block the tokenizer for this instance of the HTML
    //       parser, such that the event loop will not run tasks
    //       that invoke the tokenizer.

    //       If the parser's Document has a style sheet that is
    //       blocking scripts or the script's "ready to be
    //       parser-executed" flag is not set: spin the event
    //       loop until the parser's Document has no style sheet
    //       that is blocking scripts and the script's "ready to
    //       be parser-executed" flag is set.

    //       Unblock the tokenizer for this instance of the HTML
    //       parser, such that tasks that invoke the tokenizer
    //       can again be run.

    //       Let the insertion point be just before the next
    //       input character.

    //       Increment the parser's script nesting level by one
    //       (it should be zero before this step, so this sets
    //       it to one).

    //       Execute the script.

    //       Decrement the parser's script nesting level by
    //       one. If the parser's script nesting level is zero
    //       (which it always should be at this point), then set
    //       the parser pause flag to false.

    //       Let the insertion point be undefined again.

    //       If there is once again a pending parsing-blocking
    //       script, then repeat these steps from step 1.


  }

  function stopParsing() {
    // XXX This is just a temporary implementation to get the parser working.
    // A full implementation involves scripts and events and the event loop.

    // Remove the link from document to parser.
    // This is instead of "set the insertion point to undefined".
    // It means that document.write() can't write into the doc anymore.
    delete doc._parser;

    stack.elements.length = 0; // pop everything off

    // If there is a window object associated with the document
    // then trigger an load event on it
    if (doc.defaultView) {
      doc.defaultView.dispatchEvent(new impl.Event("load",{}));
    }

  }

  /****
   * Tokenizer states
   */

  /**
   * This file was partially mechanically generated from
   * http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html
   *
   * After mechanical conversion, it was further converted from
   * prose to JS by hand, but the intent is that it is a very
   * faithful rendering of the HTML tokenization spec in
   * JavaScript.
   *
   * It is not a goal of this tokenizer to detect or report
   * parse errors.
   *
   * XXX The tokenizer is supposed to work with straight UTF32
   * codepoints. But I don't think it has any dependencies on
   * any character outside of the BMP so I think it is safe to
   * pass it UTF16 characters. I don't think it will ever change
   * state in the middle of a surrogate pair.
   */

  /*
   * Each state is represented by a function.  For most states, the
   * scanner simply passes the next character (as an integer
   * codepoint) to the current state function and automatically
   * consumes the character.  If the state function can't process
   * the character it can call pushback() to push it back to the
   * scanner.
   *
   * Some states require lookahead, though.  If a state function has
   * a lookahead property, then it is invoked differently.  In this
   * case, the scanner invokes the function with 3 arguments: 1) the
   * next codepoint 2) a string of lookahead text 3) a boolean that
   * is true if the lookahead goes all the way to the EOF. (XXX
   * actually maybe this third is not necessary... the lookahead
   * could just include \uFFFF?)
   *
   * If the lookahead property of a state function is an integer, it
   * specifies the number of characters required. If it is a string,
   * then the scanner will scan for that string and return all
   * characters up to and including that sequence, or up to EOF.  If
   * the lookahead property is a regexp, then the scanner will match
   * the regexp at the current point and return the matching string.
   *
   * States that require lookahead are responsible for explicitly
   * consuming the characters they process. They do this by
   * incrementing nextchar by the number of processed characters.
   */
  function reconsume(c, new_state) {
    tokenizer = new_state;
    nextchar--; // pushback
  }

  function data_state(c) {
    switch(c) {
    case 0x0026: // AMPERSAND
      return_state = data_state;
      tokenizer = character_reference_state;
      break;
    case 0x003C: // LESS-THAN SIGN
      if (emitSimpleTag()) // Shortcut for <p>, <dl>, </div> etc.
        break;
      tokenizer = tag_open_state;
      break;
    case 0x0000: // NULL
      // Usually null characters emitted by the tokenizer will be
      // ignored by the tree builder, but sometimes they'll be
      // converted to \uFFFD.  I don't want to have the search every
      // string emitted to replace NULs, so I'll set a flag
      // if I've emitted a NUL.
      textrun.push(c);
      textIncludesNUL = true;
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      // Instead of just pushing a single character and then
      // coming back to the very same place, lookahead and
      // emit everything we can at once.
      /*jshint -W030 */
      emitCharsWhile(DATATEXT) || textrun.push(c);
      break;
    }
  }

  function rcdata_state(c) {
    // Save the open tag so we can find a matching close tag
    switch(c) {
    case 0x0026: // AMPERSAND
      return_state = rcdata_state;
      tokenizer = character_reference_state;
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = rcdata_less_than_sign_state;
      break;
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      textIncludesNUL = true;
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      textrun.push(c);
      break;
    }
  }

  function rawtext_state(c) {
    switch(c) {
    case 0x003C: // LESS-THAN SIGN
      tokenizer = rawtext_less_than_sign_state;
      break;
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      /*jshint -W030 */
      emitCharsWhile(RAWTEXT) || textrun.push(c);
      break;
    }
  }

  function script_data_state(c) {
    switch(c) {
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_less_than_sign_state;
      break;
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      /*jshint -W030 */
      emitCharsWhile(RAWTEXT) || textrun.push(c);
      break;
    }
  }

  function plaintext_state(c) {
    switch(c) {
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      /*jshint -W030 */
      emitCharsWhile(PLAINTEXT) || textrun.push(c);
      break;
    }
  }

  function tag_open_state(c) {
    switch(c) {
    case 0x0021: // EXCLAMATION MARK
      tokenizer = markup_declaration_open_state;
      break;
    case 0x002F: // SOLIDUS
      tokenizer = end_tag_open_state;
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginTagName();
      reconsume(c, tag_name_state);
      break;
    case 0x003F: // QUESTION MARK
      reconsume(c, bogus_comment_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, data_state);
      break;
    }
  }

  function end_tag_open_state(c) {
    switch(c) {
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginEndTagName();
      reconsume(c, tag_name_state);
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      break;
    case -1: // EOF
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x002F); // SOLIDUS
      emitEOF();
      break;
    default:
      reconsume(c, bogus_comment_state);
      break;
    }
  }

  function tag_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = before_attribute_name_state;
      break;
    case 0x002F: // SOLIDUS
      tokenizer = self_closing_start_tag_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitTag();
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      tagnamebuf += String.fromCharCode(c + 0x0020);
      break;
    case 0x0000: // NULL
      tagnamebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      tagnamebuf += getMatchingChars(TAGNAME);
      break;
    }
  }

  function rcdata_less_than_sign_state(c) {
    /* identical to the RAWTEXT less-than sign state, except s/RAWTEXT/RCDATA/g */
    if (c === 0x002F) {  // SOLIDUS
      beginTempBuf();
      tokenizer = rcdata_end_tag_open_state;
    }
    else {
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, rcdata_state);
    }
  }

  function rcdata_end_tag_open_state(c) {
    /* identical to the RAWTEXT (and Script data) end tag open state, except s/RAWTEXT/RCDATA/g */
    switch(c) {
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginEndTagName();
      reconsume(c, rcdata_end_tag_name_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x002F); // SOLIDUS
      reconsume(c, rcdata_state);
      break;
    }
  }

  function rcdata_end_tag_name_state(c) {
    /* identical to the RAWTEXT (and Script data) end tag name state, except s/RAWTEXT/RCDATA/g */
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = before_attribute_name_state;
        return;
      }
      break;
    case 0x002F: // SOLIDUS
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = self_closing_start_tag_state;
        return;
      }
      break;
    case 0x003E: // GREATER-THAN SIGN
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = data_state;
        emitTag();
        return;
      }
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:

      tagnamebuf += String.fromCharCode(c + 0x0020);
      tempbuf.push(c);
      return;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:

      tagnamebuf += String.fromCharCode(c);
      tempbuf.push(c);
      return;
    default:
      break;
    }

    // If we don't return in one of the cases above, then this was not
    // an appropriately matching close tag, so back out by emitting all
    // the characters as text
    textrun.push(0x003C); // LESS-THAN SIGN
    textrun.push(0x002F); // SOLIDUS
    pushAll(textrun, tempbuf);
    reconsume(c, rcdata_state);
  }

  function rawtext_less_than_sign_state(c) {
    /* identical to the RCDATA less-than sign state, except s/RCDATA/RAWTEXT/g
     */
    if (c === 0x002F) { // SOLIDUS
      beginTempBuf();
      tokenizer = rawtext_end_tag_open_state;
    }
    else {
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, rawtext_state);
    }
  }

  function rawtext_end_tag_open_state(c) {
    /* identical to the RCDATA (and Script data) end tag open state, except s/RCDATA/RAWTEXT/g */
    switch(c) {
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginEndTagName();
      reconsume(c, rawtext_end_tag_name_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x002F); // SOLIDUS
      reconsume(c, rawtext_state);
      break;
    }
  }

  function rawtext_end_tag_name_state(c) {
    /* identical to the RCDATA (and Script data) end tag name state, except s/RCDATA/RAWTEXT/g */
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = before_attribute_name_state;
        return;
      }
      break;
    case 0x002F: // SOLIDUS
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = self_closing_start_tag_state;
        return;
      }
      break;
    case 0x003E: // GREATER-THAN SIGN
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = data_state;
        emitTag();
        return;
      }
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      tagnamebuf += String.fromCharCode(c + 0x0020);
      tempbuf.push(c);
      return;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      tagnamebuf += String.fromCharCode(c);
      tempbuf.push(c);
      return;
    default:
      break;
    }

    // If we don't return in one of the cases above, then this was not
    // an appropriately matching close tag, so back out by emitting all
    // the characters as text
    textrun.push(0x003C); // LESS-THAN SIGN
    textrun.push(0x002F); // SOLIDUS
    pushAll(textrun,tempbuf);
    reconsume(c, rawtext_state);
  }

  function script_data_less_than_sign_state(c) {
    switch(c) {
    case 0x002F: // SOLIDUS
      beginTempBuf();
      tokenizer = script_data_end_tag_open_state;
      break;
    case 0x0021: // EXCLAMATION MARK
      tokenizer = script_data_escape_start_state;
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x0021); // EXCLAMATION MARK
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, script_data_state);
      break;
    }
  }

  function script_data_end_tag_open_state(c) {
    /* identical to the RCDATA (and RAWTEXT) end tag open state, except s/RCDATA/Script data/g */
    switch(c) {
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginEndTagName();
      reconsume(c, script_data_end_tag_name_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x002F); // SOLIDUS
      reconsume(c, script_data_state);
      break;
    }
  }

  function script_data_end_tag_name_state(c) {
    /* identical to the RCDATA (and RAWTEXT) end tag name state, except s/RCDATA/Script data/g */
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = before_attribute_name_state;
        return;
      }
      break;
    case 0x002F: // SOLIDUS
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = self_closing_start_tag_state;
        return;
      }
      break;
    case 0x003E: // GREATER-THAN SIGN
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = data_state;
        emitTag();
        return;
      }
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:

      tagnamebuf += String.fromCharCode(c + 0x0020);
      tempbuf.push(c);
      return;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:

      tagnamebuf += String.fromCharCode(c);
      tempbuf.push(c);
      return;
    default:
      break;
    }

    // If we don't return in one of the cases above, then this was not
    // an appropriately matching close tag, so back out by emitting all
    // the characters as text
    textrun.push(0x003C); // LESS-THAN SIGN
    textrun.push(0x002F); // SOLIDUS
    pushAll(textrun,tempbuf);
    reconsume(c, script_data_state);
  }

  function script_data_escape_start_state(c) {
    if (c === 0x002D) { // HYPHEN-MINUS
      tokenizer = script_data_escape_start_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
    }
    else {
      reconsume(c, script_data_state);
    }
  }

  function script_data_escape_start_dash_state(c) {
    if (c === 0x002D) { // HYPHEN-MINUS
      tokenizer = script_data_escaped_dash_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
    }
    else {
      reconsume(c, script_data_state);
    }
  }

  function script_data_escaped_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = script_data_escaped_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_escaped_less_than_sign_state;
      break;
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      textrun.push(c);
      break;
    }
  }

  function script_data_escaped_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = script_data_escaped_dash_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_escaped_less_than_sign_state;
      break;
    case 0x0000: // NULL
      tokenizer = script_data_escaped_state;
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      tokenizer = script_data_escaped_state;
      textrun.push(c);
      break;
    }
  }

  function script_data_escaped_dash_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_escaped_less_than_sign_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = script_data_state;
      textrun.push(0x003E); // GREATER-THAN SIGN
      break;
    case 0x0000: // NULL
      tokenizer = script_data_escaped_state;
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      tokenizer = script_data_escaped_state;
      textrun.push(c);
      break;
    }
  }

  function script_data_escaped_less_than_sign_state(c) {
    switch(c) {
    case 0x002F: // SOLIDUS
      beginTempBuf();
      tokenizer = script_data_escaped_end_tag_open_state;
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginTempBuf();
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, script_data_double_escape_start_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, script_data_escaped_state);
      break;
    }
  }

  function script_data_escaped_end_tag_open_state(c) {
    switch(c) {
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginEndTagName();
      reconsume(c, script_data_escaped_end_tag_name_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x002F); // SOLIDUS
      reconsume(c, script_data_escaped_state);
      break;
    }
  }

  function script_data_escaped_end_tag_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = before_attribute_name_state;
        return;
      }
      break;
    case 0x002F: // SOLIDUS
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = self_closing_start_tag_state;
        return;
      }
      break;
    case 0x003E: // GREATER-THAN SIGN
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = data_state;
        emitTag();
        return;
      }
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      tagnamebuf += String.fromCharCode(c + 0x0020);
      tempbuf.push(c);
      return;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      tagnamebuf += String.fromCharCode(c);
      tempbuf.push(c);
      return;
    default:
      break;
    }

    // We get here in the default case, and if the closing tagname
    // is not an appropriate tagname.
    textrun.push(0x003C); // LESS-THAN SIGN
    textrun.push(0x002F); // SOLIDUS
    pushAll(textrun,tempbuf);
    reconsume(c, script_data_escaped_state);
  }

  function script_data_double_escape_start_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
    case 0x002F: // SOLIDUS
    case 0x003E: // GREATER-THAN SIGN
      if (buf2str(tempbuf) === "script") {
        tokenizer = script_data_double_escaped_state;
      }
      else {
        tokenizer = script_data_escaped_state;
      }
      textrun.push(c);
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      tempbuf.push(c + 0x0020);
      textrun.push(c);
      break;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      tempbuf.push(c);
      textrun.push(c);
      break;
    default:
      reconsume(c, script_data_escaped_state);
      break;
    }
  }

  function script_data_double_escaped_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = script_data_double_escaped_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_double_escaped_less_than_sign_state;
      textrun.push(0x003C); // LESS-THAN SIGN
      break;
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      textrun.push(c);
      break;
    }
  }

  function script_data_double_escaped_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = script_data_double_escaped_dash_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_double_escaped_less_than_sign_state;
      textrun.push(0x003C); // LESS-THAN SIGN
      break;
    case 0x0000: // NULL
      tokenizer = script_data_double_escaped_state;
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      tokenizer = script_data_double_escaped_state;
      textrun.push(c);
      break;
    }
  }

  function script_data_double_escaped_dash_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_double_escaped_less_than_sign_state;
      textrun.push(0x003C); // LESS-THAN SIGN
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = script_data_state;
      textrun.push(0x003E); // GREATER-THAN SIGN
      break;
    case 0x0000: // NULL
      tokenizer = script_data_double_escaped_state;
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      tokenizer = script_data_double_escaped_state;
      textrun.push(c);
      break;
    }
  }

  function script_data_double_escaped_less_than_sign_state(c) {
    if (c === 0x002F) { // SOLIDUS
      beginTempBuf();
      tokenizer = script_data_double_escape_end_state;
      textrun.push(0x002F); // SOLIDUS
    }
    else {
      reconsume(c, script_data_double_escaped_state);
    }
  }

  function script_data_double_escape_end_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
    case 0x002F: // SOLIDUS
    case 0x003E: // GREATER-THAN SIGN
      if (buf2str(tempbuf) === "script") {
        tokenizer = script_data_escaped_state;
      }
      else {
        tokenizer = script_data_double_escaped_state;
      }
      textrun.push(c);
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      tempbuf.push(c + 0x0020);
      textrun.push(c);
      break;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      tempbuf.push(c);
      textrun.push(c);
      break;
    default:
      reconsume(c, script_data_double_escaped_state);
      break;
    }
  }

  function before_attribute_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    // For SOLIDUS, GREATER-THAN SIGN, and EOF, spec says "reconsume in
    // the after attribute name state", but in our implementation that
    // state always has an active attribute in attrnamebuf.  Just clone
    // the rules here, without the addAttribute business.
    case 0x002F: // SOLIDUS
      tokenizer = self_closing_start_tag_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitTag();
      break;
    case -1: // EOF
      emitEOF();
      break;
    case 0x003D: // EQUALS SIGN
      beginAttrName();
      attrnamebuf += String.fromCharCode(c);
      tokenizer = attribute_name_state;
      break;
    default:
      if (handleSimpleAttribute()) break;
      beginAttrName();
      reconsume(c, attribute_name_state);
      break;
    }
  }

  // beginAttrName() must have been called before this point
  // There is an active attribute in attrnamebuf (but not attrvaluebuf)
  function attribute_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
    case 0x002F: // SOLIDUS
    case 0x003E: // GREATER-THAN SIGN
    case -1: // EOF
      reconsume(c, after_attribute_name_state);
      break;
    case 0x003D: // EQUALS SIGN
      tokenizer = before_attribute_value_state;
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      attrnamebuf += String.fromCharCode(c + 0x0020);
      break;
    case 0x0000: // NULL
      attrnamebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case 0x0022: // QUOTATION MARK
    case 0x0027: // APOSTROPHE
    case 0x003C: // LESS-THAN SIGN
      /* falls through */
    default:
      attrnamebuf += getMatchingChars(ATTRNAME);
      break;
    }
  }

  // There is an active attribute in attrnamebuf, but not yet in attrvaluebuf.
  function after_attribute_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    case 0x002F: // SOLIDUS
      // Keep in sync with before_attribute_name_state.
      addAttribute(attrnamebuf);
      tokenizer = self_closing_start_tag_state;
      break;
    case 0x003D: // EQUALS SIGN
      tokenizer = before_attribute_value_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      // Keep in sync with before_attribute_name_state.
      tokenizer = data_state;
      addAttribute(attrnamebuf);
      emitTag();
      break;
    case -1: // EOF
      // Keep in sync with before_attribute_name_state.
      addAttribute(attrnamebuf);
      emitEOF();
      break;
    default:
      addAttribute(attrnamebuf);
      beginAttrName();
      reconsume(c, attribute_name_state);
      break;
    }
  }

  function before_attribute_value_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    case 0x0022: // QUOTATION MARK
      beginAttrValue();
      tokenizer = attribute_value_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginAttrValue();
      tokenizer = attribute_value_single_quoted_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      /* falls through */
    default:
      beginAttrValue();
      reconsume(c, attribute_value_unquoted_state);
      break;
    }
  }

  function attribute_value_double_quoted_state(c) {
    switch(c) {
    case 0x0022: // QUOTATION MARK
      addAttribute(attrnamebuf, attrvaluebuf);
      tokenizer = after_attribute_value_quoted_state;
      break;
    case 0x0026: // AMPERSAND
      return_state = attribute_value_double_quoted_state;
      tokenizer = character_reference_state;
      break;
    case 0x0000: // NULL
      attrvaluebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      emitEOF();
      break;
    case 0x000A: // LF
      // this could be a converted \r, so don't use getMatchingChars
      attrvaluebuf += String.fromCharCode(c);
      break;
    default:
      attrvaluebuf += getMatchingChars(DBLQUOTEATTRVAL);
      break;
    }
  }

  function attribute_value_single_quoted_state(c) {
    switch(c) {
    case 0x0027: // APOSTROPHE
      addAttribute(attrnamebuf, attrvaluebuf);
      tokenizer = after_attribute_value_quoted_state;
      break;
    case 0x0026: // AMPERSAND
      return_state = attribute_value_single_quoted_state;
      tokenizer = character_reference_state;
      break;
    case 0x0000: // NULL
      attrvaluebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      emitEOF();
      break;
    case 0x000A: // LF
      // this could be a converted \r, so don't use getMatchingChars
      attrvaluebuf += String.fromCharCode(c);
      break;
    default:
      attrvaluebuf += getMatchingChars(SINGLEQUOTEATTRVAL);
      break;
    }
  }

  function attribute_value_unquoted_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      addAttribute(attrnamebuf, attrvaluebuf);
      tokenizer = before_attribute_name_state;
      break;
    case 0x0026: // AMPERSAND
      return_state = attribute_value_unquoted_state;
      tokenizer = character_reference_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      addAttribute(attrnamebuf, attrvaluebuf);
      tokenizer = data_state;
      emitTag();
      break;
    case 0x0000: // NULL
      attrvaluebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      nextchar--; // pushback
      tokenizer = data_state;
      break;
    case 0x0022: // QUOTATION MARK
    case 0x0027: // APOSTROPHE
    case 0x003C: // LESS-THAN SIGN
    case 0x003D: // EQUALS SIGN
    case 0x0060: // GRAVE ACCENT
      /* falls through */
    default:
      attrvaluebuf += getMatchingChars(UNQUOTEDATTRVAL);
      break;
    }
  }

  function after_attribute_value_quoted_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = before_attribute_name_state;
      break;
    case 0x002F: // SOLIDUS
      tokenizer = self_closing_start_tag_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitTag();
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      reconsume(c, before_attribute_name_state);
      break;
    }
  }

  function self_closing_start_tag_state(c) {
    switch(c) {
    case 0x003E: // GREATER-THAN SIGN
      // Set the <i>self-closing flag</i> of the current tag token.
      tokenizer = data_state;
      emitSelfClosingTag(true);
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      reconsume(c, before_attribute_name_state);
      break;
    }
  }

  function bogus_comment_state(c, lookahead, eof) {
    var len = lookahead.length;

    if (eof) {
      nextchar += len-1; // don't consume the eof
    }
    else {
      nextchar += len;
    }

    var comment = lookahead.substring(0, len-1);

    comment = comment.replace(/\u0000/g,"\uFFFD");
    comment = comment.replace(/\u000D\u000A/g,"\u000A");
    comment = comment.replace(/\u000D/g,"\u000A");

    insertToken(COMMENT, comment);
    tokenizer = data_state;
  }
  bogus_comment_state.lookahead = ">";

  function markup_declaration_open_state(c, lookahead, eof) {
    if (lookahead[0] === "-" && lookahead[1] === "-") {
      nextchar += 2;
      beginComment();
      tokenizer = comment_start_state;
      return;
    }

    if (lookahead.toUpperCase() === "DOCTYPE") {
      nextchar += 7;
      tokenizer = doctype_state;
    }
    else if (lookahead === "[CDATA[" && cdataAllowed()) {
      nextchar += 7;
      tokenizer = cdata_section_state;
    }
    else {
      tokenizer = bogus_comment_state;
    }
  }
  markup_declaration_open_state.lookahead = 7;

  function comment_start_state(c) {
    beginComment();
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_start_dash_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      insertToken(COMMENT, buf2str(commentbuf));
      break; /* see comment in comment end state */
    default:
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_start_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_end_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      insertToken(COMMENT, buf2str(commentbuf));
      break;
    case -1: // EOF
      insertToken(COMMENT, buf2str(commentbuf));
      emitEOF();
      break; /* see comment in comment end state */
    default:
      commentbuf.push(0x002D /* HYPHEN-MINUS */);
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_state(c) {
    switch(c) {
    case 0x003C: // LESS-THAN SIGN
      commentbuf.push(c);
      tokenizer = comment_less_than_sign_state;
      break;
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_end_dash_state;
      break;
    case 0x0000: // NULL
      commentbuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      insertToken(COMMENT, buf2str(commentbuf));
      emitEOF();
      break; /* see comment in comment end state */
    default:
      commentbuf.push(c);
      break;
    }
  }

  function comment_less_than_sign_state(c) {
    switch(c) {
    case 0x0021: // EXCLAMATION MARK
      commentbuf.push(c);
      tokenizer = comment_less_than_sign_bang_state;
      break;
    case 0x003C: // LESS-THAN SIGN
      commentbuf.push(c);
      break;
    default:
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_less_than_sign_bang_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_less_than_sign_bang_dash_state;
      break;
    default:
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_less_than_sign_bang_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_less_than_sign_bang_dash_dash_state;
      break;
    default:
      reconsume(c, comment_end_dash_state);
      break;
    }
  }

  function comment_less_than_sign_bang_dash_dash_state(c) {
    switch(c) {
    case 0x003E: // GREATER-THAN SIGN
    case -1: // EOF
      reconsume(c, comment_end_state);
      break;
    default:
      // parse error
      reconsume(c, comment_end_state);
      break;
    }
  }

  function comment_end_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_end_state;
      break;
    case -1: // EOF
      insertToken(COMMENT, buf2str(commentbuf));
      emitEOF();
      break; /* see comment in comment end state */
    default:
      commentbuf.push(0x002D /* HYPHEN-MINUS */);
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_end_state(c) {
    switch(c) {
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      insertToken(COMMENT, buf2str(commentbuf));
      break;
    case 0x0021: // EXCLAMATION MARK
      tokenizer = comment_end_bang_state;
      break;
    case 0x002D: // HYPHEN-MINUS
      commentbuf.push(0x002D);
      break;
    case -1: // EOF
      insertToken(COMMENT, buf2str(commentbuf));
      emitEOF();
      break; /* For security reasons: otherwise, hostile user could put a script in a comment e.g. in a blog comment and then DOS the server so that the end tag isn't read, and then the commented script tag would be treated as live code */
    default:
      commentbuf.push(0x002D);
      commentbuf.push(0x002D);
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_end_bang_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      commentbuf.push(0x002D);
      commentbuf.push(0x002D);
      commentbuf.push(0x0021);
      tokenizer = comment_end_dash_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      insertToken(COMMENT, buf2str(commentbuf));
      break;
    case -1: // EOF
      insertToken(COMMENT, buf2str(commentbuf));
      emitEOF();
      break; /* see comment in comment end state */
    default:
      commentbuf.push(0x002D);
      commentbuf.push(0x002D);
      commentbuf.push(0x0021);
      reconsume(c, comment_state);
      break;
    }
  }

  function doctype_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = before_doctype_name_state;
      break;
    case -1: // EOF
      beginDoctype();
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      reconsume(c, before_doctype_name_state);
      break;
    }
  }

  function before_doctype_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      beginDoctype();
      doctypenamebuf.push(c + 0x0020);
      tokenizer = doctype_name_state;
      break;
    case 0x0000: // NULL
      beginDoctype();
      doctypenamebuf.push(0xFFFD);
      tokenizer = doctype_name_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      beginDoctype();
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      beginDoctype();
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      beginDoctype();
      doctypenamebuf.push(c);
      tokenizer = doctype_name_state;
      break;
    }
  }

  function doctype_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = after_doctype_name_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitDoctype();
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      doctypenamebuf.push(c + 0x0020);
      break;
    case 0x0000: // NULL
      doctypenamebuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      doctypenamebuf.push(c);
      break;
    }
  }

  function after_doctype_name_state(c, lookahead, eof) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      nextchar += 1;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      nextchar += 1;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      lookahead = lookahead.toUpperCase();
      if (lookahead === "PUBLIC") {
        nextchar += 6;
        tokenizer = after_doctype_public_keyword_state;
      }
      else if (lookahead === "SYSTEM") {
        nextchar += 6;
        tokenizer = after_doctype_system_keyword_state;
      }
      else {
        forcequirks();
        tokenizer = bogus_doctype_state;
      }
      break;
    }
  }
  after_doctype_name_state.lookahead = 6;

  function after_doctype_public_keyword_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = before_doctype_public_identifier_state;
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypePublicId();
      tokenizer = doctype_public_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypePublicId();
      tokenizer = doctype_public_identifier_single_quoted_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function before_doctype_public_identifier_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypePublicId();
      tokenizer = doctype_public_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypePublicId();
      tokenizer = doctype_public_identifier_single_quoted_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function doctype_public_identifier_double_quoted_state(c) {
    switch(c) {
    case 0x0022: // QUOTATION MARK
      tokenizer = after_doctype_public_identifier_state;
      break;
    case 0x0000: // NULL
      doctypepublicbuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      doctypepublicbuf.push(c);
      break;
    }
  }

  function doctype_public_identifier_single_quoted_state(c) {
    switch(c) {
    case 0x0027: // APOSTROPHE
      tokenizer = after_doctype_public_identifier_state;
      break;
    case 0x0000: // NULL
      doctypepublicbuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      doctypepublicbuf.push(c);
      break;
    }
  }

  function after_doctype_public_identifier_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = between_doctype_public_and_system_identifiers_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitDoctype();
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_single_quoted_state;
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function between_doctype_public_and_system_identifiers_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE Ignore the character.
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitDoctype();
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_single_quoted_state;
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function after_doctype_system_keyword_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = before_doctype_system_identifier_state;
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_single_quoted_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function before_doctype_system_identifier_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE Ignore the character.
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_single_quoted_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function doctype_system_identifier_double_quoted_state(c) {
    switch(c) {
    case 0x0022: // QUOTATION MARK
      tokenizer = after_doctype_system_identifier_state;
      break;
    case 0x0000: // NULL
      doctypesystembuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      doctypesystembuf.push(c);
      break;
    }
  }

  function doctype_system_identifier_single_quoted_state(c) {
    switch(c) {
    case 0x0027: // APOSTROPHE
      tokenizer = after_doctype_system_identifier_state;
      break;
    case 0x0000: // NULL
      doctypesystembuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      doctypesystembuf.push(c);
      break;
    }
  }

  function after_doctype_system_identifier_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      tokenizer = bogus_doctype_state;
      /* This does *not* set the DOCTYPE token's force-quirks flag. */
      break;
    }
  }

  function bogus_doctype_state(c) {
    switch(c) {
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      emitDoctype();
      emitEOF();
      break;
    default:
      /* Ignore the character. */
      break;
    }
  }

  function cdata_section_state(c) {
    switch(c) {
    case 0x005D: // RIGHT SQUARE BRACKET
      tokenizer = cdata_section_bracket_state;
      break;
    case -1: // EOF
      emitEOF();
      break;
    case 0x0000: // NULL
      textIncludesNUL = true;
      /* fall through */
    default:
      // Instead of just pushing a single character and then
      // coming back to the very same place, lookahead and
      // emit everything we can at once.
      /*jshint -W030 */
      emitCharsWhile(CDATATEXT) || textrun.push(c);
      break;
    }
  }

  function cdata_section_bracket_state(c) {
    switch(c) {
    case 0x005D: // RIGHT SQUARE BRACKET
      tokenizer = cdata_section_end_state;
      break;
    default:
      textrun.push(0x005D);
      reconsume(c, cdata_section_state);
      break;
    }
  }

  function cdata_section_end_state(c) {
    switch(c) {
    case 0x005D: // RIGHT SQUARE BRACKET
      textrun.push(0x005D);
      break;
    case 0x003E: // GREATER-THAN SIGN
      flushText();
      tokenizer = data_state;
      break;
    default:
      textrun.push(0x005D);
      textrun.push(0x005D);
      reconsume(c, cdata_section_state);
      break;
    }
  }

  function character_reference_state(c) {
    beginTempBuf();
    tempbuf.push(0x0026);
    switch(c) {
    case 0x0009: // TAB
    case 0x000A: // LINE FEED
    case 0x000C: // FORM FEED
    case 0x0020: // SPACE
    case 0x003C: // LESS-THAN SIGN
    case 0x0026: // AMPERSAND
    case -1: // EOF
      reconsume(c, character_reference_end_state);
      break;
    case 0x0023: // NUMBER SIGN
      tempbuf.push(c);
      tokenizer = numeric_character_reference_state;
      break;
    default:
      reconsume(c, named_character_reference_state);
      break;
    }
  }

  function named_character_reference_state(c) {
    NAMEDCHARREF.lastIndex = nextchar; // w/ lookahead no char has been consumed
    var matched = NAMEDCHARREF.exec(chars);
    if (!matched) throw new Error("should never happen");
    var name = matched[1];
    if (!name) {
      // If no match can be made, switch to the character reference end state
      tokenizer = character_reference_end_state;
      return;
    }

    // Consume the matched characters and append them to temporary buffer
    nextchar += name.length;
    pushAll(tempbuf, str2buf(name));

    switch(return_state) {
    case attribute_value_double_quoted_state:
    case attribute_value_single_quoted_state:
    case attribute_value_unquoted_state:
      // If the character reference was consumed as part of an attribute...
      if (name[name.length-1] !== ';') { // ...and the last char is not ;
        if (/[=A-Za-z0-9]/.test(chars[nextchar])) {
          tokenizer = character_reference_end_state;
          return;
        }
      }
      break;
    default:
      break;
    }

    beginTempBuf();
    var rv = namedCharRefs[name];
    if (typeof rv === 'number') {
      tempbuf.push(rv);
    } else {
      pushAll(tempbuf, rv);
    }
    tokenizer = character_reference_end_state;
  }
  // We might need to pause tokenization until we have enough characters
  // in the buffer for longest possible character reference.
  named_character_reference_state.lookahead = -NAMEDCHARREF_MAXLEN;

  function numeric_character_reference_state(c) {
    character_reference_code = 0;
    switch(c) {
    case 0x0078: // x
    case 0x0058: // X
      tempbuf.push(c);
      tokenizer = hexadecimal_character_reference_start_state;
      break;
    default:
      reconsume(c, decimal_character_reference_start_state);
      break;
    }
  }

  function hexadecimal_character_reference_start_state(c) {
    switch(c) {
    case 0x0030: case 0x0031: case 0x0032: case 0x0033: case 0x0034:
    case 0x0035: case 0x0036: case 0x0037: case 0x0038: case 0x0039: // [0-9]
    case 0x0041: case 0x0042: case 0x0043: case 0x0044: case 0x0045:
    case 0x0046: // [A-F]
    case 0x0061: case 0x0062: case 0x0063: case 0x0064: case 0x0065:
    case 0x0066: // [a-f]
      reconsume(c, hexadecimal_character_reference_state);
      break;
    default:
      reconsume(c, character_reference_end_state);
      break;
    }
  }

  function decimal_character_reference_start_state(c) {
    switch(c) {
    case 0x0030: case 0x0031: case 0x0032: case 0x0033: case 0x0034:
    case 0x0035: case 0x0036: case 0x0037: case 0x0038: case 0x0039: // [0-9]
      reconsume(c, decimal_character_reference_state);
      break;
    default:
      reconsume(c, character_reference_end_state);
      break;
    }
  }

  function hexadecimal_character_reference_state(c) {
    switch(c) {
    case 0x0041: case 0x0042: case 0x0043: case 0x0044: case 0x0045:
    case 0x0046: // [A-F]
      character_reference_code *= 16;
      character_reference_code += (c - 0x0037);
      break;
    case 0x0061: case 0x0062: case 0x0063: case 0x0064: case 0x0065:
    case 0x0066: // [a-f]
      character_reference_code *= 16;
      character_reference_code += (c - 0x0057);
      break;
    case 0x0030: case 0x0031: case 0x0032: case 0x0033: case 0x0034:
    case 0x0035: case 0x0036: case 0x0037: case 0x0038: case 0x0039: // [0-9]
      character_reference_code *= 16;
      character_reference_code += (c - 0x0030);
      break;
    case 0x003B: // SEMICOLON
      tokenizer = numeric_character_reference_end_state;
      break;
    default:
      reconsume(c, numeric_character_reference_end_state);
      break;
    }
  }

  function decimal_character_reference_state(c) {
    switch(c) {
    case 0x0030: case 0x0031: case 0x0032: case 0x0033: case 0x0034:
    case 0x0035: case 0x0036: case 0x0037: case 0x0038: case 0x0039: // [0-9]
      character_reference_code *= 10;
      character_reference_code += (c - 0x0030);
      break;
    case 0x003B: // SEMICOLON
      tokenizer = numeric_character_reference_end_state;
      break;
    default:
      reconsume(c, numeric_character_reference_end_state);
      break;
    }
  }

  function numeric_character_reference_end_state(c) {
    if (character_reference_code in numericCharRefReplacements) {
      character_reference_code = numericCharRefReplacements[character_reference_code];
    } else if (character_reference_code > 0x10FFFF || (character_reference_code >= 0xD800 && character_reference_code < 0xE000)) {
      character_reference_code = 0xFFFD;
    }

    beginTempBuf();
    if (character_reference_code <= 0xFFFF) {
      tempbuf.push(character_reference_code);
    } else {
      character_reference_code = character_reference_code - 0x10000;
      /* jshint bitwise: false */
      tempbuf.push(0xD800 + (character_reference_code >> 10));
      tempbuf.push(0xDC00 + (character_reference_code & 0x03FF));
    }
    reconsume(c, character_reference_end_state);
  }

  function character_reference_end_state(c) {
    switch(return_state) {
    case attribute_value_double_quoted_state:
    case attribute_value_single_quoted_state:
    case attribute_value_unquoted_state:
      // append each character to the current attribute's value
      attrvaluebuf += buf2str(tempbuf);
      break;
    default:
      pushAll(textrun, tempbuf);
      break;
    }
    reconsume(c, return_state);
  }

  /***
   * The tree builder insertion modes
   */

  // 11.2.5.4.1 The "initial" insertion mode
  function initial_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      value = value.replace(LEADINGWS, ""); // Ignore spaces
      if (value.length === 0) return; // Are we done?
      break; // Handle anything non-space text below
    case 4: // COMMENT
      doc._appendChild(doc.createComment(value));
      return;
    case 5: // DOCTYPE
      var name = value;
      var publicid = arg3;
      var systemid = arg4;
      // Use the constructor directly instead of
      // implementation.createDocumentType because the create
      // function throws errors on invalid characters, and
      // we don't want the parser to throw them.
      doc.appendChild(new DocumentType(name,publicid, systemid));

      // Note that there is no public API for setting quirks mode We can
      // do this here because we have access to implementation details
      if (force_quirks ||
        name.toLowerCase() !== "html" ||
        quirkyPublicIds.test(publicid) ||
        (systemid && systemid.toLowerCase() === quirkySystemId) ||
        (systemid === undefined &&
         conditionallyQuirkyPublicIds.test(publicid)))
        doc._quirks = true;
      else if (limitedQuirkyPublicIds.test(publicid) ||
           (systemid !== undefined &&
            conditionallyQuirkyPublicIds.test(publicid)))
        doc._limitedQuirks = true;
      parser = before_html_mode;
      return;
    }

    // tags or non-whitespace text
    doc._quirks = true;
    parser = before_html_mode;
    parser(t,value,arg3,arg4);
  }

  // 11.2.5.4.2 The "before html" insertion mode
  function before_html_mode(t,value,arg3,arg4) {
    var elt;
    switch(t) {
    case 1: // TEXT
      value = value.replace(LEADINGWS, ""); // Ignore spaces
      if (value.length === 0) return; // Are we done?
      break; // Handle anything non-space text below
    case 5: // DOCTYPE
      /* ignore the token */
      return;
    case 4: // COMMENT
      doc._appendChild(doc.createComment(value));
      return;
    case 2: // TAG
      if (value === "html") {
        elt = createHTMLElt(doc, value, arg3);
        stack.push(elt);
        doc.appendChild(elt);
        // XXX: handle application cache here
        parser = before_head_mode;
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "html":
      case "head":
      case "body":
      case "br":
        break;  // fall through on these
      default:
        return; // ignore most end tags
      }
    }

    // Anything that didn't get handled above is handled like this:
    elt = createHTMLElt(doc, "html", null);
    stack.push(elt);
    doc.appendChild(elt);
    // XXX: handle application cache here
    parser = before_head_mode;
    parser(t,value,arg3,arg4);
  }

  // 11.2.5.4.3 The "before head" insertion mode
  function before_head_mode(t,value,arg3,arg4) {
    switch(t) {
    case 1: // TEXT
      value = value.replace(LEADINGWS, "");  // Ignore spaces
      if (value.length === 0) return; // Are we done?
      break;  // Handle anything non-space text below
    case 5: // DOCTYPE
      /* ignore the token */
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t,value,arg3,arg4);
        return;
      case "head":
        var elt = insertHTMLElement(value, arg3);
        head_element_pointer = elt;
        parser = in_head_mode;
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "html":
      case "head":
      case "body":
      case "br":
        break;
      default:
        return; // ignore most end tags
      }
    }

    // If not handled explicitly above
    before_head_mode(TAG, "head", null); // create a head tag
    parser(t, value, arg3, arg4); // then try again with this token
  }

  function in_head_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      var ws = value.match(LEADINGWS);
      if (ws) {
        insertText(ws[0]);
        value = value.substring(ws[0].length);
      }
      if (value.length === 0) return;
      break; // Handle non-whitespace below
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "meta":
        // XXX:
        // May need to change the encoding based on this tag
        /* falls through */
      case "base":
      case "basefont":
      case "bgsound":
      case "link":
        insertHTMLElement(value, arg3);
        stack.pop();
        return;
      case "title":
        parseRCDATA(value, arg3);
        return;
      case "noscript":
        if (!scripting_enabled) {
          insertHTMLElement(value, arg3);
          parser = in_head_noscript_mode;
          return;
        }
        // Otherwise, if scripting is enabled...
        /* falls through */
      case "noframes":
      case "style":
        parseRawText(value,arg3);
        return;
      case "script":
        insertElement(function(doc) {
          var elt = createHTMLElt(doc, value, arg3);
          elt._parser_inserted = true;
          elt._force_async = false;
          if (fragment) elt._already_started = true;
          flushText();
          return elt;
        });
        tokenizer = script_data_state;
        originalInsertionMode = parser;
        parser = text_mode;
        return;
      case "template":
        insertHTMLElement(value, arg3);
        afe.insertMarker();
        frameset_ok = false;
        parser = in_template_mode;
        templateInsertionModes.push(parser);
        return;
      case "head":
        return; // ignore it
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "head":
        stack.pop();
        parser = after_head_mode;
        return;
      case "body":
      case "html":
      case "br":
        break; // handle these at the bottom of the function
      case "template":
        if (!stack.contains("template")) {
          return;
        }
        stack.generateImpliedEndTags(null, "thorough");
        stack.popTag("template");
        afe.clearToMarker();
        templateInsertionModes.pop();
        resetInsertionMode();
        return;
      default:
        // ignore any other end tag
        return;
      }
      break;
    }

    // If not handled above
    in_head_mode(ENDTAG, "head", null);   // synthetic </head>
    parser(t, value, arg3, arg4);   // Then redo this one
  }

  // 13.2.5.4.5 The "in head noscript" insertion mode
  function in_head_noscript_mode(t, value, arg3, arg4) {
    switch(t) {
    case 5: // DOCTYPE
      return;
    case 4: // COMMENT
      in_head_mode(t, value);
      return;
    case 1: // TEXT
      var ws = value.match(LEADINGWS);
      if (ws) {
        in_head_mode(t, ws[0]);
        value = value.substring(ws[0].length);
      }
      if (value.length === 0) return; // no more text
      break; // Handle non-whitespace below
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "basefont":
      case "bgsound":
      case "link":
      case "meta":
      case "noframes":
      case "style":
        in_head_mode(t, value, arg3);
        return;
      case "head":
      case "noscript":
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "noscript":
        stack.pop();
        parser = in_head_mode;
        return;
      case "br":
        break;  // goes to the outer default
      default:
        return; // ignore other end tags
      }
      break;
    }

    // If not handled above
    in_head_noscript_mode(ENDTAG, "noscript", null);
    parser(t, value, arg3, arg4);
  }

  function after_head_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      var ws = value.match(LEADINGWS);
      if (ws) {
        insertText(ws[0]);
        value = value.substring(ws[0].length);
      }
      if (value.length === 0) return;
      break; // Handle non-whitespace below
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "body":
        insertHTMLElement(value, arg3);
        frameset_ok = false;
        parser = in_body_mode;
        return;
      case "frameset":
        insertHTMLElement(value, arg3);
        parser = in_frameset_mode;
        return;
      case "base":
      case "basefont":
      case "bgsound":
      case "link":
      case "meta":
      case "noframes":
      case "script":
      case "style":
      case "template":
      case "title":
        stack.push(head_element_pointer);
        in_head_mode(TAG, value, arg3);
        stack.removeElement(head_element_pointer);
        return;
      case "head":
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "template":
        return in_head_mode(t, value, arg3, arg4);
      case "body":
      case "html":
      case "br":
        break;
      default:
        return;  // ignore any other end tag
      }
      break;
    }

    after_head_mode(TAG, "body", null);
    frameset_ok = true;
    parser(t, value, arg3, arg4);
  }

  // 13.2.5.4.7 The "in body" insertion mode
  function in_body_mode(t,value,arg3,arg4) {
    var body, i, node, elt;
    switch(t) {
    case 1: // TEXT
      if (textIncludesNUL) {
        value = value.replace(NULCHARS, "");
        if (value.length === 0) return;
      }
      // If any non-space characters
      if (frameset_ok && NONWS.test(value))
        frameset_ok = false;
      afereconstruct();
      insertText(value);
      return;
    case 5: // DOCTYPE
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case -1: // EOF
      if (templateInsertionModes.length) {
        return in_template_mode(t);
      }
      stopParsing();
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        if (stack.contains("template")) {
          return;
        }
        transferAttributes(arg3, stack.elements[0]);
        return;
      case "base":
      case "basefont":
      case "bgsound":
      case "link":
      case "meta":
      case "noframes":
      case "script":
      case "style":
      case "template":
      case "title":
        in_head_mode(TAG, value, arg3);
        return;
      case "body":
        body = stack.elements[1];
        if (!body || !(body instanceof impl.HTMLBodyElement) ||
            stack.contains("template"))
          return;
        frameset_ok = false;
        transferAttributes(arg3, body);
        return;
      case "frameset":
        if (!frameset_ok) return;
        body = stack.elements[1];
        if (!body || !(body instanceof impl.HTMLBodyElement))
          return;
        if (body.parentNode) body.parentNode.removeChild(body);
        while(!(stack.top instanceof impl.HTMLHtmlElement))
          stack.pop();
        insertHTMLElement(value, arg3);
        parser = in_frameset_mode;
        return;

      case "address":
      case "article":
      case "aside":
      case "blockquote":
      case "center":
      case "details":
      case "dialog":
      case "dir":
      case "div":
      case "dl":
      case "fieldset":
      case "figcaption":
      case "figure":
      case "footer":
      case "header":
      case "hgroup":
      case "main":
      case "nav":
      case "ol":
      case "p":
      case "section":
      case "summary":
      case "ul":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        insertHTMLElement(value, arg3);
        return;

      case "menu":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        if (isA(stack.top, 'menuitem')) {
          stack.pop();
        }
        insertHTMLElement(value, arg3);
        return;

      case "h1":
      case "h2":
      case "h3":
      case "h4":
      case "h5":
      case "h6":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        if (stack.top instanceof impl.HTMLHeadingElement)
          stack.pop();
        insertHTMLElement(value, arg3);
        return;

      case "pre":
      case "listing":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        insertHTMLElement(value, arg3);
        ignore_linefeed = true;
        frameset_ok = false;
        return;

      case "form":
        if (form_element_pointer && !stack.contains("template")) return;
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        elt = insertHTMLElement(value, arg3);
        if (!stack.contains("template"))
          form_element_pointer = elt;
        return;

      case "li":
        frameset_ok = false;
        for(i = stack.elements.length-1; i >= 0; i--) {
          node = stack.elements[i];
          if (node instanceof impl.HTMLLIElement) {
            in_body_mode(ENDTAG, "li");
            break;
          }
          if (isA(node, specialSet) && !isA(node, addressdivpSet))
            break;
        }
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        insertHTMLElement(value, arg3);
        return;

      case "dd":
      case "dt":
        frameset_ok = false;
        for(i = stack.elements.length-1; i >= 0; i--) {
          node = stack.elements[i];
          if (isA(node, dddtSet)) {
            in_body_mode(ENDTAG, node.localName);
            break;
          }
          if (isA(node, specialSet) && !isA(node, addressdivpSet))
            break;
        }
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        insertHTMLElement(value, arg3);
        return;

      case "plaintext":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        insertHTMLElement(value, arg3);
        tokenizer = plaintext_state;
        return;

      case "button":
        if (stack.inScope("button")) {
          in_body_mode(ENDTAG, "button");
          parser(t, value, arg3, arg4);
        }
        else {
          afereconstruct();
          insertHTMLElement(value, arg3);
          frameset_ok = false;
        }
        return;

      case "a":
        var activeElement = afe.findElementByTag("a");
        if (activeElement) {
          in_body_mode(ENDTAG, value);
          afe.remove(activeElement);
          stack.removeElement(activeElement);
        }
        /* falls through */
      case "b":
      case "big":
      case "code":
      case "em":
      case "font":
      case "i":
      case "s":
      case "small":
      case "strike":
      case "strong":
      case "tt":
      case "u":
        afereconstruct();
        afe.push(insertHTMLElement(value,arg3), arg3);
        return;

      case "nobr":
        afereconstruct();

        if (stack.inScope(value)) {
          in_body_mode(ENDTAG, value);
          afereconstruct();
        }
        afe.push(insertHTMLElement(value,arg3), arg3);
        return;

      case "applet":
      case "marquee":
      case "object":
        afereconstruct();
        insertHTMLElement(value,arg3);
        afe.insertMarker();
        frameset_ok = false;
        return;

      case "table":
        if (!doc._quirks && stack.inButtonScope("p")) {
          in_body_mode(ENDTAG, "p");
        }
        insertHTMLElement(value,arg3);
        frameset_ok = false;
        parser = in_table_mode;
        return;

      case "area":
      case "br":
      case "embed":
      case "img":
      case "keygen":
      case "wbr":
        afereconstruct();
        insertHTMLElement(value,arg3);
        stack.pop();
        frameset_ok = false;
        return;

      case "input":
        afereconstruct();
        elt = insertHTMLElement(value,arg3);
        stack.pop();
        var type = elt.getAttribute("type");
        if (!type || type.toLowerCase() !== "hidden")
          frameset_ok = false;
        return;

      case "param":
      case "source":
      case "track":
        insertHTMLElement(value,arg3);
        stack.pop();
        return;

      case "hr":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        if (isA(stack.top, 'menuitem')) {
          stack.pop();
        }
        insertHTMLElement(value,arg3);
        stack.pop();
        frameset_ok = false;
        return;

      case "image":
        in_body_mode(TAG, "img", arg3, arg4);
        return;

      case "textarea":
        insertHTMLElement(value,arg3);
        ignore_linefeed = true;
        frameset_ok = false;
        tokenizer = rcdata_state;
        originalInsertionMode = parser;
        parser = text_mode;
        return;

      case "xmp":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        afereconstruct();
        frameset_ok = false;
        parseRawText(value, arg3);
        return;

      case "iframe":
        frameset_ok = false;
        parseRawText(value, arg3);
        return;

      case "noembed":
        parseRawText(value,arg3);
        return;

      case "noscript":
        if (scripting_enabled) {
          parseRawText(value,arg3);
          return;
        }
        break;  // XXX Otherwise treat it as any other open tag?

      case "select":
        afereconstruct();
        insertHTMLElement(value,arg3);
        frameset_ok = false;
        if (parser === in_table_mode ||
          parser === in_caption_mode ||
          parser === in_table_body_mode ||
          parser === in_row_mode ||
          parser === in_cell_mode)
          parser = in_select_in_table_mode;
        else
          parser = in_select_mode;
        return;

      case "optgroup":
      case "option":
        if (stack.top instanceof impl.HTMLOptionElement) {
          in_body_mode(ENDTAG, "option");
        }
        afereconstruct();
        insertHTMLElement(value,arg3);
        return;

      case "menuitem":
        if (isA(stack.top, 'menuitem')) {
          stack.pop();
        }
        afereconstruct();
        insertHTMLElement(value, arg3);
        return;

      case "rb":
      case "rtc":
        if (stack.inScope("ruby")) {
          stack.generateImpliedEndTags();
        }
        insertHTMLElement(value,arg3);
        return;

      case "rp":
      case "rt":
        if (stack.inScope("ruby")) {
          stack.generateImpliedEndTags("rtc");
        }
        insertHTMLElement(value,arg3);
        return;

      case "math":
        afereconstruct();
        adjustMathMLAttributes(arg3);
        adjustForeignAttributes(arg3);
        insertForeignElement(value, arg3, NAMESPACE.MATHML);
        if (arg4) // self-closing flag
          stack.pop();
        return;

      case "svg":
        afereconstruct();
        adjustSVGAttributes(arg3);
        adjustForeignAttributes(arg3);
        insertForeignElement(value, arg3, NAMESPACE.SVG);
        if (arg4) // self-closing flag
          stack.pop();
        return;

      case "caption":
      case "col":
      case "colgroup":
      case "frame":
      case "head":
      case "tbody":
      case "td":
      case "tfoot":
      case "th":
      case "thead":
      case "tr":
        // Ignore table tags if we're not in_table mode
        return;
      }

      // Handle any other start tag here
      // (and also noscript tags when scripting is disabled)
      afereconstruct();
      insertHTMLElement(value,arg3);
      return;

    case 3: // ENDTAG
      switch(value) {
      case "template":
        in_head_mode(ENDTAG, value, arg3);
        return;
      case "body":
        if (!stack.inScope("body")) return;
        parser = after_body_mode;
        return;
      case "html":
        if (!stack.inScope("body")) return;
        parser = after_body_mode;
        parser(t, value, arg3);
        return;

      case "address":
      case "article":
      case "aside":
      case "blockquote":
      case "button":
      case "center":
      case "details":
      case "dialog":
      case "dir":
      case "div":
      case "dl":
      case "fieldset":
      case "figcaption":
      case "figure":
      case "footer":
      case "header":
      case "hgroup":
      case "listing":
      case "main":
      case "menu":
      case "nav":
      case "ol":
      case "pre":
      case "section":
      case "summary":
      case "ul":
        // Ignore if there is not a matching open tag
        if (!stack.inScope(value)) return;
        stack.generateImpliedEndTags();
        stack.popTag(value);
        return;

      case "form":
        if (!stack.contains("template")) {
          var openform = form_element_pointer;
          form_element_pointer = null;
          if (!openform || !stack.elementInScope(openform)) return;
          stack.generateImpliedEndTags();
          stack.removeElement(openform);
        } else {
          if (!stack.inScope("form")) return;
          stack.generateImpliedEndTags();
          stack.popTag("form");
        }
        return;

      case "p":
        if (!stack.inButtonScope(value)) {
          in_body_mode(TAG, value, null);
          parser(t, value, arg3, arg4);
        }
        else {
          stack.generateImpliedEndTags(value);
          stack.popTag(value);
        }
        return;

      case "li":
        if (!stack.inListItemScope(value)) return;
        stack.generateImpliedEndTags(value);
        stack.popTag(value);
        return;

      case "dd":
      case "dt":
        if (!stack.inScope(value)) return;
        stack.generateImpliedEndTags(value);
        stack.popTag(value);
        return;

      case "h1":
      case "h2":
      case "h3":
      case "h4":
      case "h5":
      case "h6":
        if (!stack.elementTypeInScope(impl.HTMLHeadingElement)) return;
        stack.generateImpliedEndTags();
        stack.popElementType(impl.HTMLHeadingElement);
        return;

      case "sarcasm":
        // Take a deep breath, and then:
        break;

      case "a":
      case "b":
      case "big":
      case "code":
      case "em":
      case "font":
      case "i":
      case "nobr":
      case "s":
      case "small":
      case "strike":
      case "strong":
      case "tt":
      case "u":
        var result = adoptionAgency(value);
        if (result) return;  // If we did something we're done
        break;         // Go to the "any other end tag" case

      case "applet":
      case "marquee":
      case "object":
        if (!stack.inScope(value)) return;
        stack.generateImpliedEndTags();
        stack.popTag(value);
        afe.clearToMarker();
        return;

      case "br":
        in_body_mode(TAG, value, null);  // Turn </br> into <br>
        return;
      }

      // Any other end tag goes here
      for(i = stack.elements.length-1; i >= 0; i--) {
        node = stack.elements[i];
        if (isA(node, value)) {
          stack.generateImpliedEndTags(value);
          stack.popElement(node);
          break;
        }
        else if (isA(node, specialSet)) {
          return;
        }
      }

      return;
    }
  }

  function text_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      insertText(value);
      return;
    case -1: // EOF
      if (stack.top instanceof impl.HTMLScriptElement)
        stack.top._already_started = true;
      stack.pop();
      parser = originalInsertionMode;
      parser(t);
      return;
    case 3: // ENDTAG
      if (value === "script") {
        handleScriptEnd();
      }
      else {
        stack.pop();
        parser = originalInsertionMode;
      }
      return;
    default:
      // We should never get any other token types
      return;
    }
  }

  function in_table_mode(t, value, arg3, arg4) {
    function getTypeAttr(attrs) {
      for(var i = 0, n = attrs.length; i < n; i++) {
        if (attrs[i][0] === "type")
          return attrs[i][1].toLowerCase();
      }
      return null;
    }

    switch(t) {
    case 1: // TEXT
      // XXX the text_integration_mode stuff is
      // just a hack I made up
      if (text_integration_mode) {
        in_body_mode(t, value, arg3, arg4);
        return;
      }
      else if (isA(stack.top, tablesectionrowSet)) {
        pending_table_text = [];
        originalInsertionMode = parser;
        parser = in_table_text_mode;
        parser(t, value, arg3, arg4);
        return;
      }
      break;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case 2: // TAG
      switch(value) {
      case "caption":
        stack.clearToContext(tableContextSet);
        afe.insertMarker();
        insertHTMLElement(value,arg3);
        parser = in_caption_mode;
        return;
      case "colgroup":
        stack.clearToContext(tableContextSet);
        insertHTMLElement(value,arg3);
        parser = in_column_group_mode;
        return;
      case "col":
        in_table_mode(TAG, "colgroup", null);
        parser(t, value, arg3, arg4);
        return;
      case "tbody":
      case "tfoot":
      case "thead":
        stack.clearToContext(tableContextSet);
        insertHTMLElement(value,arg3);
        parser = in_table_body_mode;
        return;
      case "td":
      case "th":
      case "tr":
        in_table_mode(TAG, "tbody", null);
        parser(t, value, arg3, arg4);
        return;

      case "table":
        if (!stack.inTableScope(value)) {
          return; // Ignore the token
        }
        in_table_mode(ENDTAG, value);
        parser(t, value, arg3, arg4);
        return;

      case "style":
      case "script":
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;

      case "input":
        var type = getTypeAttr(arg3);
        if (type !== "hidden") break;  // to the anything else case
        insertHTMLElement(value,arg3);
        stack.pop();
        return;

      case "form":
        if (form_element_pointer || stack.contains("template")) return;
        form_element_pointer = insertHTMLElement(value, arg3);
        stack.popElement(form_element_pointer);
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "table":
        if (!stack.inTableScope(value)) return;
        stack.popTag(value);
        resetInsertionMode();
        return;
      case "body":
      case "caption":
      case "col":
      case "colgroup":
      case "html":
      case "tbody":
      case "td":
      case "tfoot":
      case "th":
      case "thead":
      case "tr":
        return;
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      }

      break;
    case -1: // EOF
      in_body_mode(t, value, arg3, arg4);
      return;
    }

    // This is the anything else case
    foster_parent_mode = true;
    in_body_mode(t, value, arg3, arg4);
    foster_parent_mode = false;
  }

  function in_table_text_mode(t, value, arg3, arg4) {
    if (t === TEXT) {
      if (textIncludesNUL) {
        value = value.replace(NULCHARS, "");
        if (value.length === 0) return;
      }
      pending_table_text.push(value);
    }
    else {
      var s = pending_table_text.join("");
      pending_table_text.length = 0;
      if (NONWS.test(s)) { // If any non-whitespace characters
        // This must be the same code as the "anything else"
        // case of the in_table mode above.
        foster_parent_mode = true;
        in_body_mode(TEXT, s);
        foster_parent_mode = false;
      }
      else {
        insertText(s);
      }
      parser = originalInsertionMode;
      parser(t, value, arg3, arg4);
    }
  }


  function in_caption_mode(t, value, arg3, arg4) {
    function end_caption() {
      if (!stack.inTableScope("caption")) return false;
      stack.generateImpliedEndTags();
      stack.popTag("caption");
      afe.clearToMarker();
      parser = in_table_mode;
      return true;
    }

    switch(t) {
    case 2: // TAG
      switch(value) {
      case "caption":
      case "col":
      case "colgroup":
      case "tbody":
      case "td":
      case "tfoot":
      case "th":
      case "thead":
      case "tr":
        if (end_caption()) parser(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "caption":
        end_caption();
        return;
      case "table":
        if (end_caption()) parser(t, value, arg3, arg4);
        return;
      case "body":
      case "col":
      case "colgroup":
      case "html":
      case "tbody":
      case "td":
      case "tfoot":
      case "th":
      case "thead":
      case "tr":
        return;
      }
      break;
    }

    // The Anything Else case
    in_body_mode(t, value, arg3, arg4);
  }

  function in_column_group_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      var ws = value.match(LEADINGWS);
      if (ws) {
        insertText(ws[0]);
        value = value.substring(ws[0].length);
      }
      if (value.length === 0) return;
      break; // Handle non-whitespace below

    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "col":
        insertHTMLElement(value, arg3);
        stack.pop();
        return;
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "colgroup":
        if (!isA(stack.top, 'colgroup')) {
          return; // Ignore the token.
        }
        stack.pop();
        parser = in_table_mode;
        return;
      case "col":
        return;
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    case -1: // EOF
      in_body_mode(t, value, arg3, arg4);
      return;
    }

    // Anything else
    if (!isA(stack.top, 'colgroup')) {
      return; // Ignore the token.
    }
    in_column_group_mode(ENDTAG, "colgroup");
    parser(t, value, arg3, arg4);
  }

  function in_table_body_mode(t, value, arg3, arg4) {
    function endsect() {
      if (!stack.inTableScope("tbody") &&
        !stack.inTableScope("thead") &&
        !stack.inTableScope("tfoot"))
        return;
      stack.clearToContext(tableBodyContextSet);
      in_table_body_mode(ENDTAG, stack.top.localName, null);
      parser(t, value, arg3, arg4);
    }

    switch(t) {
    case 2: // TAG
      switch(value) {
      case "tr":
        stack.clearToContext(tableBodyContextSet);
        insertHTMLElement(value, arg3);
        parser = in_row_mode;
        return;
      case "th":
      case "td":
        in_table_body_mode(TAG, "tr", null);
        parser(t, value, arg3, arg4);
        return;
      case "caption":
      case "col":
      case "colgroup":
      case "tbody":
      case "tfoot":
      case "thead":
        endsect();
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "table":
        endsect();
        return;
      case "tbody":
      case "tfoot":
      case "thead":
        if (stack.inTableScope(value)) {
          stack.clearToContext(tableBodyContextSet);
          stack.pop();
          parser = in_table_mode;
        }
        return;
      case "body":
      case "caption":
      case "col":
      case "colgroup":
      case "html":
      case "td":
      case "th":
      case "tr":
        return;
      }
      break;
    }

    // Anything else:
    in_table_mode(t, value, arg3, arg4);
  }

  function in_row_mode(t, value, arg3, arg4) {
    function endrow() {
      if (!stack.inTableScope("tr")) return false;
      stack.clearToContext(tableRowContextSet);
      stack.pop();
      parser = in_table_body_mode;
      return true;
    }

    switch(t) {
    case 2: // TAG
      switch(value) {
      case "th":
      case "td":
        stack.clearToContext(tableRowContextSet);
        insertHTMLElement(value, arg3);
        parser = in_cell_mode;
        afe.insertMarker();
        return;
      case "caption":
      case "col":
      case "colgroup":
      case "tbody":
      case "tfoot":
      case "thead":
      case "tr":
        if (endrow()) parser(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "tr":
        endrow();
        return;
      case "table":
        if (endrow()) parser(t, value, arg3, arg4);
        return;
      case "tbody":
      case "tfoot":
      case "thead":
        if (stack.inTableScope(value)) {
          if (endrow()) parser(t, value, arg3, arg4);
        }
        return;
      case "body":
      case "caption":
      case "col":
      case "colgroup":
      case "html":
      case "td":
      case "th":
        return;
      }
      break;
    }

    // anything else
    in_table_mode(t, value, arg3, arg4);
  }

  function in_cell_mode(t, value, arg3, arg4) {
    switch(t) {
    case 2: // TAG
      switch(value) {
      case "caption":
      case "col":
      case "colgroup":
      case "tbody":
      case "td":
      case "tfoot":
      case "th":
      case "thead":
      case "tr":
        if (stack.inTableScope("td")) {
          in_cell_mode(ENDTAG, "td");
          parser(t, value, arg3, arg4);
        }
        else if (stack.inTableScope("th")) {
          in_cell_mode(ENDTAG, "th");
          parser(t, value, arg3, arg4);
        }
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "td":
      case "th":
        if (!stack.inTableScope(value)) return;
        stack.generateImpliedEndTags();
        stack.popTag(value);
        afe.clearToMarker();
        parser = in_row_mode;
        return;

      case "body":
      case "caption":
      case "col":
      case "colgroup":
      case "html":
        return;

      case "table":
      case "tbody":
      case "tfoot":
      case "thead":
      case "tr":
        if (!stack.inTableScope(value)) return;
        in_cell_mode(ENDTAG, stack.inTableScope("td") ? "td" : "th");
        parser(t, value, arg3, arg4);
        return;
      }
      break;
    }

    // anything else
    in_body_mode(t, value, arg3, arg4);
  }

  function in_select_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      if (textIncludesNUL) {
        value = value.replace(NULCHARS, "");
        if (value.length === 0) return;
      }
      insertText(value);
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case -1: // EOF
      in_body_mode(t, value, arg3, arg4);
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "option":
        if (stack.top instanceof impl.HTMLOptionElement)
          in_select_mode(ENDTAG, value);
        insertHTMLElement(value, arg3);
        return;
      case "optgroup":
        if (stack.top instanceof impl.HTMLOptionElement)
          in_select_mode(ENDTAG, "option");
        if (stack.top instanceof impl.HTMLOptGroupElement)
          in_select_mode(ENDTAG, value);
        insertHTMLElement(value, arg3);
        return;
      case "select":
        in_select_mode(ENDTAG, value); // treat it as a close tag
        return;

      case "input":
      case "keygen":
      case "textarea":
        if (!stack.inSelectScope("select")) return;
        in_select_mode(ENDTAG, "select");
        parser(t, value, arg3, arg4);
        return;

      case "script":
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "optgroup":
        if (stack.top instanceof impl.HTMLOptionElement &&
          stack.elements[stack.elements.length-2] instanceof
          impl.HTMLOptGroupElement) {
          in_select_mode(ENDTAG, "option");
        }
        if (stack.top instanceof impl.HTMLOptGroupElement)
          stack.pop();

        return;

      case "option":
        if (stack.top instanceof impl.HTMLOptionElement)
          stack.pop();
        return;

      case "select":
        if (!stack.inSelectScope(value)) return;
        stack.popTag(value);
        resetInsertionMode();
        return;

      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      }

      break;
    }

    // anything else: just ignore the token
  }

  function in_select_in_table_mode(t, value, arg3, arg4) {
    switch(value) {
    case "caption":
    case "table":
    case "tbody":
    case "tfoot":
    case "thead":
    case "tr":
    case "td":
    case "th":
      switch(t) {
      case 2: // TAG
        in_select_in_table_mode(ENDTAG, "select");
        parser(t, value, arg3, arg4);
        return;
      case 3: // ENDTAG
        if (stack.inTableScope(value)) {
          in_select_in_table_mode(ENDTAG, "select");
          parser(t, value, arg3, arg4);
        }
        return;
      }
    }

    // anything else
    in_select_mode(t, value, arg3, arg4);
  }

  function in_template_mode(t, value, arg3, arg4) {
    function switchModeAndReprocess(mode) {
      parser = mode;
      templateInsertionModes[templateInsertionModes.length-1] = parser;
      parser(t, value, arg3, arg4);
    }
    switch(t) {
    case 1: // TEXT
    case 4: // COMMENT
    case 5: // DOCTYPE
      in_body_mode(t, value, arg3, arg4);
      return;
    case -1: // EOF
      if (!stack.contains("template")) {
        stopParsing();
      } else {
        stack.popTag("template");
        afe.clearToMarker();
        templateInsertionModes.pop();
        resetInsertionMode();
        parser(t, value, arg3, arg4);
      }
      return;
    case 2: // TAG
      switch(value) {
      case "base":
      case "basefont":
      case "bgsound":
      case "link":
      case "meta":
      case "noframes":
      case "script":
      case "style":
      case "template":
      case "title":
        in_head_mode(t, value, arg3, arg4);
        return;
      case "caption":
      case "colgroup":
      case "tbody":
      case "tfoot":
      case "thead":
        switchModeAndReprocess(in_table_mode);
        return;
      case "col":
        switchModeAndReprocess(in_column_group_mode);
        return;
      case "tr":
        switchModeAndReprocess(in_table_body_mode);
        return;
      case "td":
      case "th":
        switchModeAndReprocess(in_row_mode);
        return;
      }
      switchModeAndReprocess(in_body_mode);
      return;
    case 3: // ENDTAG
      switch(value) {
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      default:
        return;
      }
    }
  }

  function after_body_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      // If any non-space chars, handle below
      if (NONWS.test(value)) break;
      in_body_mode(t, value);
      return;
    case 4: // COMMENT
      // Append it to the <html> element
      stack.elements[0]._appendChild(doc.createComment(value));
      return;
    case 5: // DOCTYPE
      return;
    case -1: // EOF
      stopParsing();
      return;
    case 2: // TAG
      if (value === "html") {
        in_body_mode(t, value, arg3, arg4);
        return;
      }
      break; // for any other tags
    case 3: // ENDTAG
      if (value === "html") {
        if (fragment) return;
        parser = after_after_body_mode;
        return;
      }
      break; // for any other tags
    }

    // anything else
    parser = in_body_mode;
    parser(t, value, arg3, arg4);
  }

  function in_frameset_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      // Ignore any non-space characters
      value = value.replace(ALLNONWS, "");
      if (value.length > 0) insertText(value);
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case -1: // EOF
      stopParsing();
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "frameset":
        insertHTMLElement(value, arg3);
        return;
      case "frame":
        insertHTMLElement(value, arg3);
        stack.pop();
        return;
      case "noframes":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      if (value === "frameset") {
        if (fragment && stack.top instanceof impl.HTMLHtmlElement)
          return;
        stack.pop();
        if (!fragment &&
          !(stack.top instanceof impl.HTMLFrameSetElement))
          parser = after_frameset_mode;
        return;
      }
      break;
    }

    // ignore anything else
  }

  function after_frameset_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      // Ignore any non-space characters
      value = value.replace(ALLNONWS, "");
      if (value.length > 0) insertText(value);
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case -1: // EOF
      stopParsing();
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "noframes":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      if (value === "html") {
        parser = after_after_frameset_mode;
        return;
      }
      break;
    }

    // ignore anything else
  }

  function after_after_body_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      // If any non-space chars, handle below
      if (NONWS.test(value)) break;
      in_body_mode(t, value, arg3, arg4);
      return;
    case 4: // COMMENT
      doc._appendChild(doc.createComment(value));
      return;
    case 5: // DOCTYPE
      in_body_mode(t, value, arg3, arg4);
      return;
    case -1: // EOF
      stopParsing();
      return;
    case 2: // TAG
      if (value === "html") {
        in_body_mode(t, value, arg3, arg4);
        return;
      }
      break;
    }

    // anything else
    parser = in_body_mode;
    parser(t, value, arg3, arg4);
  }

  function after_after_frameset_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      // Ignore any non-space characters
      value = value.replace(ALLNONWS, "");
      if (value.length > 0)
        in_body_mode(t, value, arg3, arg4);
      return;
    case 4: // COMMENT
      doc._appendChild(doc.createComment(value));
      return;
    case 5: // DOCTYPE
      in_body_mode(t, value, arg3, arg4);
      return;
    case -1: // EOF
      stopParsing();
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "noframes":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    }

    // ignore anything else
  }


  // 13.2.5.5 The rules for parsing tokens in foreign content
  //
  // This is like one of the insertion modes above, but is
  // invoked somewhat differently when the current token is not HTML.
  // See the insertToken() function.
  function insertForeignToken(t, value, arg3, arg4) {
    // A <font> tag is an HTML font tag if it has a color, font, or size
    // attribute.  Otherwise we assume it is foreign content
    function isHTMLFont(attrs) {
      for(var i = 0, n = attrs.length; i < n; i++) {
        switch(attrs[i][0]) {
        case "color":
        case "face":
        case "size":
          return true;
        }
      }
      return false;
    }

    var current;

    switch(t) {
    case 1: // TEXT
      // If any non-space, non-nul characters
      if (frameset_ok && NONWSNONNUL.test(value))
        frameset_ok = false;
      if (textIncludesNUL) {
        value = value.replace(NULCHARS, "\uFFFD");
      }
      insertText(value);
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      // ignore it
      return;
    case 2: // TAG
      switch(value) {
      case "font":
        if (!isHTMLFont(arg3)) break;
        /* falls through */
      case "b":
      case "big":
      case "blockquote":
      case "body":
      case "br":
      case "center":
      case "code":
      case "dd":
      case "div":
      case "dl":
      case "dt":
      case "em":
      case "embed":
      case "h1":
      case "h2":
      case "h3":
      case "h4":
      case "h5":
      case "h6":
      case "head":
      case "hr":
      case "i":
      case "img":
      case "li":
      case "listing":
      case "menu":
      case "meta":
      case "nobr":
      case "ol":
      case "p":
      case "pre":
      case "ruby":
      case "s":
      case "small":
      case "span":
      case "strong":
      case "strike":
      case "sub":
      case "sup":
      case "table":
      case "tt":
      case "u":
      case "ul":
      case "var":
        if (fragment) {
          break;
        }
        do {
          stack.pop();
          current = stack.top;
        } while(current.namespaceURI !== NAMESPACE.HTML &&
            !isMathmlTextIntegrationPoint(current) &&
            !isHTMLIntegrationPoint(current));

        insertToken(t, value, arg3, arg4);  // reprocess
        return;
      }

      // Any other start tag case goes here
      current = (stack.elements.length===1 && fragment) ? fragmentContext :
        stack.top;
      if (current.namespaceURI === NAMESPACE.MATHML) {
        adjustMathMLAttributes(arg3);
      }
      else if (current.namespaceURI === NAMESPACE.SVG) {
        value = adjustSVGTagName(value);
        adjustSVGAttributes(arg3);
      }
      adjustForeignAttributes(arg3);

      insertForeignElement(value, arg3, current.namespaceURI);
      if (arg4) { // the self-closing flag
        if (value === 'script' && current.namespaceURI === NAMESPACE.SVG) {
          // XXX deal with SVG scripts here
        }
        stack.pop();
      }
      return;

    case 3: // ENDTAG
      current = stack.top;
      if (value === "script" &&
        current.namespaceURI === NAMESPACE.SVG &&
        current.localName === "script") {

        stack.pop();

        // XXX
        // Deal with SVG scripts here
      }
      else {
        // The any other end tag case
        var i = stack.elements.length-1;
        var node = stack.elements[i];
        for(;;) {
          if (node.localName.toLowerCase() === value) {
            stack.popElement(node);
            break;
          }
          node = stack.elements[--i];
          // If non-html, keep looping
          if (node.namespaceURI !== NAMESPACE.HTML)
            continue;
          // Otherwise process the end tag as html
          parser(t, value, arg3, arg4);
          break;
        }
      }
      return;
    }
  }

  /***
   * Finally, this is the end of the HTMLParser() factory function.
   * It returns the htmlparser object with the append() and end() methods.
   */

  // Sneak another method into the htmlparser object to allow us to run
  // tokenizer tests.  This can be commented out in production code.
  // This is a hook for testing the tokenizer. It has to be here
  // because the tokenizer details are all hidden away within the closure.
  // It should return an array of tokens generated while parsing the
  // input string.
  htmlparser.testTokenizer = function(input, initialState, lastStartTag, charbychar) {
    var tokens = [];

    switch(initialState) {
    case "PCDATA state":
      tokenizer = data_state;
      break;
    case "RCDATA state":
      tokenizer = rcdata_state;
      break;
    case "RAWTEXT state":
      tokenizer = rawtext_state;
      break;
    case "PLAINTEXT state":
      tokenizer = plaintext_state;
      break;
    }

    if (lastStartTag) {
      lasttagname = lastStartTag;
    }

    insertToken = function(t, value, arg3, arg4) {
      flushText();
      switch(t) {
      case 1: // TEXT
        if (tokens.length > 0 &&
          tokens[tokens.length-1][0] === "Character") {
          tokens[tokens.length-1][1] += value;
        }
        else tokens.push(["Character", value]);
        break;
      case 4: // COMMENT
        tokens.push(["Comment", value]);
        break;
      case 5: // DOCTYPE
        tokens.push(["DOCTYPE", value,
               arg3 === undefined ? null : arg3,
               arg4 === undefined ? null : arg4,
               !force_quirks]);
        break;
      case 2: // TAG
        var attrs = Object.create(null);
        for(var i = 0; i < arg3.length; i++) {
          // XXX: does attribute order matter?
          var a = arg3[i];
          if (a.length === 1) {
            attrs[a[0]] = "";
          }
          else {
            attrs[a[0]] = a[1];
          }
        }
        var token = ["StartTag", value, attrs];
        if (arg4) token.push(true);
        tokens.push(token);
        break;
      case 3: // ENDTAG
        tokens.push(["EndTag", value]);
        break;
      case -1: // EOF
        break;
      }
    };

    if (!charbychar) {
      this.parse(input, true);
    }
    else {
      for(var i = 0; i < input.length; i++) {
        this.parse(input[i]);
      }
      this.parse("", true);
    }
    return tokens;
  };

  // Return the parser object from the HTMLParser() factory function
  return htmlparser;
}


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = URL;

function URL(url) {
  if (!url) return Object.create(URL.prototype);
  // Can't use String.trim() since it defines whitespace differently than HTML
  this.url = url.replace(/^[ \t\n\r\f]+|[ \t\n\r\f]+$/g, "");

  // See http://tools.ietf.org/html/rfc3986#appendix-B
  // and https://url.spec.whatwg.org/#parsing
  var match = URL.pattern.exec(this.url);
  if (match) {
    if (match[2]) this.scheme = match[2];
    if (match[4]) {
      // parse username/password
      var userinfo = match[4].match(URL.userinfoPattern);
      if (userinfo) {
        this.username = userinfo[1];
        this.password = userinfo[3];
        match[4] = match[4].substring(userinfo[0].length);
      }
      if (match[4].match(URL.portPattern)) {
        var pos = match[4].lastIndexOf(':');
        this.host = match[4].substring(0, pos);
        this.port = match[4].substring(pos+1);
      }
      else {
        this.host = match[4];
      }
    }
    if (match[5]) this.path = match[5];
    if (match[6]) this.query = match[7];
    if (match[8]) this.fragment = match[9];
  }
}

URL.pattern = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/;
URL.userinfoPattern = /^([^@:]*)(:([^@]*))?@/;
URL.portPattern = /:\d+$/;
URL.authorityPattern = /^[^:\/?#]+:\/\//;
URL.hierarchyPattern = /^[^:\/?#]+:\//;

// Return a percentEncoded version of s.
// S should be a single-character string
// XXX: needs to do utf-8 encoding?
URL.percentEncode = function percentEncode(s) {
  var c = s.charCodeAt(0);
  if (c < 256) return "%" + c.toString(16);
  else throw Error("can't percent-encode codepoints > 255 yet");
};

URL.prototype = {
  constructor: URL,

  // XXX: not sure if this is the precise definition of absolute
  isAbsolute: function() { return !!this.scheme; },
  isAuthorityBased: function() {
    return URL.authorityPattern.test(this.url);
  },
  isHierarchical: function() {
    return URL.hierarchyPattern.test(this.url);
  },

  toString: function() {
    var s = "";
    if (this.scheme !== undefined) s += this.scheme + ":";
    if (this.isAbsolute()) {
      s += '//';
      if (this.username || this.password) {
        s += this.username || '';
        if (this.password) {
          s += ':' + this.password;
        }
        s += '@';
      }
      s += this.host;
    }
    if (this.port !== undefined) s += ":" + this.port;
    if (this.path !== undefined) s += this.path;
    if (this.query !== undefined) s += "?" + this.query;
    if (this.fragment !== undefined) s += "#" + this.fragment;
    return s;
  },

  // See: http://tools.ietf.org/html/rfc3986#section-5.2
  // and https://url.spec.whatwg.org/#constructors
  resolve: function(relative) {
    var base = this;           // The base url we're resolving against
    var r = new URL(relative); // The relative reference url to resolve
    var t = new URL();         // The absolute target url we will return

    if (r.scheme !== undefined) {
      t.scheme = r.scheme;
      t.username = r.username;
      t.password = r.password;
      t.host = r.host;
      t.port = r.port;
      t.path = remove_dot_segments(r.path);
      t.query = r.query;
    }
    else {
      t.scheme = base.scheme;
      if (r.host !== undefined) {
        t.username = r.username;
        t.password = r.password;
        t.host = r.host;
        t.port = r.port;
        t.path = remove_dot_segments(r.path);
        t.query = r.query;
      }
      else {
        t.username = base.username;
        t.password = base.password;
        t.host = base.host;
        t.port = base.port;
        if (!r.path) { // undefined or empty
          t.path = base.path;
          if (r.query !== undefined)
            t.query = r.query;
          else
            t.query = base.query;
        }
        else {
          if (r.path.charAt(0) === "/") {
            t.path = remove_dot_segments(r.path);
          }
          else {
            t.path = merge(base.path, r.path);
            t.path = remove_dot_segments(t.path);
          }
          t.query = r.query;
        }
      }
    }
    t.fragment = r.fragment;

    return t.toString();


    function merge(basepath, refpath) {
      if (base.host !== undefined && !base.path)
        return "/" + refpath;

      var lastslash = basepath.lastIndexOf("/");
      if (lastslash === -1)
        return refpath;
      else
        return basepath.substring(0, lastslash+1) + refpath;
    }

    function remove_dot_segments(path) {
      if (!path) return path; // For "" or undefined

      var output = "";
      while(path.length > 0) {
        if (path === "." || path === "..") {
          path = "";
          break;
        }

        var twochars = path.substring(0,2);
        var threechars = path.substring(0,3);
        var fourchars = path.substring(0,4);
        if (threechars === "../") {
          path = path.substring(3);
        }
        else if (twochars === "./") {
          path = path.substring(2);
        }
        else if (threechars === "/./") {
          path = "/" + path.substring(3);
        }
        else if (twochars === "/." && path.length === 2) {
          path = "/";
        }
        else if (fourchars === "/../" ||
             (threechars === "/.." && path.length === 3)) {
          path = "/" + path.substring(4);

          output = output.replace(/\/?[^\/]*$/, "");
        }
        else {
          var segment = path.match(/(\/?([^\/]*))/)[0];
          output += segment;
          path = path.substring(segment.length);
        }
      }

      return output;
    }
  },
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DOMImplementation = __webpack_require__(7);
var EventTarget = __webpack_require__(32);
var Location = __webpack_require__(69);
var sloppy = __webpack_require__(46);
var utils = __webpack_require__(1);

module.exports = Window;

function Window(document) {
  this.document = document || new DOMImplementation().createHTMLDocument("");
  this.document._scripting_enabled = true;
  this.document.defaultView = this;
  this.location = new Location(this, this.document._address || 'about:blank');
}

Window.prototype = Object.create(EventTarget.prototype, {
  _run: { value: sloppy.Window_run },
  console: { value: console },
  history: { value: {
    back: utils.nyi,
    forward: utils.nyi,
    go: utils.nyi
  }},
  navigator: { value: __webpack_require__(71) },

  // Self-referential properties
  window: { get: function() { return this; }},
  self: { get: function() { return this; }},
  frames: { get: function() { return this; }},

  // Self-referential properties for a top-level window
  parent: { get: function() { return this; }},
  top: { get: function() { return this; }},

  // We don't support any other windows for now
  length: { value: 0 },           // no frames
  frameElement: { value: null },  // not part of a frame
  opener: { value: null },        // not opened by another window

  // The onload event handler.
  // XXX: need to support a bunch of other event types, too,
  // and have them interoperate with document.body.

  onload: {
    get: function() {
      return this._getEventHandler("load");
    },
    set: function(v) {
      this._setEventHandler("load", v);
    }
  },

  // XXX This is a completely broken implementation
  getComputedStyle: { value: function getComputedStyle(elt) {
    return elt.style;
  }}

});

utils.expose(__webpack_require__(74), Window);
utils.expose(__webpack_require__(45), Window);


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Node = __webpack_require__(2);
var Element = __webpack_require__(4);
var CSSStyleDeclaration = __webpack_require__(11);
var utils = __webpack_require__(1);
var URLUtils = __webpack_require__(40);
var defineElement = __webpack_require__(43);

var htmlElements = exports.elements = {};
var htmlNameToImpl = Object.create(null);

exports.createElement = function(doc, localName, prefix) {
  var impl = htmlNameToImpl[localName] || HTMLUnknownElement;
  return new impl(doc, localName, prefix);
};

function define(spec) {
  return defineElement(spec, HTMLElement, htmlElements, htmlNameToImpl);
}

function URL(attr) {
  return {
    get: function() {
      var v = this._getattr(attr);
      if (v === null) { return ''; }
      var url = this.doc._resolve(v);
      return (url === null) ? v : url;
    },
    set: function(value) {
      this._setattr(attr, value);
    }
  };
}

function CORS(attr) {
  return {
    get: function() {
      var v = this._getattr(attr);
      if (v === null) { return null; }
      if (v.toLowerCase() === 'use-credentials') { return 'use-credentials'; }
      return 'anonymous';
    },
    set: function(value) {
      if (value===null || value===undefined) {
        this.removeAttribute(attr);
      } else {
        this._setattr(attr, value);
      }
    }
  };
}

var REFERRER = {
  type: ["", "no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url"],
  missing: '',
};


// XXX: the default value for tabIndex should be 0 if the element is
// focusable and -1 if it is not.  But the full definition of focusable
// is actually hard to compute, so for now, I'll follow Firefox and
// just base the default value on the type of the element.
var focusableElements = {
  "A":true, "LINK":true, "BUTTON":true, "INPUT":true,
  "SELECT":true, "TEXTAREA":true, "COMMAND":true
};

var HTMLFormElement = function(doc, localName, prefix) {
  HTMLElement.call(this, doc, localName, prefix);
  this._form = null; // Prevent later deoptimization
};

var HTMLElement = exports.HTMLElement = define({
  superclass: Element,
  ctor: function HTMLElement(doc, localName, prefix) {
    Element.call(this, doc, localName, utils.NAMESPACE.HTML, prefix);
  },
  props: {
    innerHTML: {
      get: function() {
        return this.serialize();
      },
      set: function(v) {
        var parser = this.ownerDocument.implementation.mozHTMLParser(
          this.ownerDocument._address,
          this);
        parser.parse(v, true);
        var tmpdoc = parser.document();
        var root = tmpdoc.firstChild;
        var target = (this instanceof htmlNameToImpl.template) ?
            this.content : this;

        // Remove any existing children of this node
        while(target.hasChildNodes())
          target.removeChild(target.firstChild);

        // Now copy newly parsed children from the root to this node
        target.doc.adoptNode(root);
        while(root.hasChildNodes()) {
          target.appendChild(root.firstChild);
        }
      }
    },
    style: { get: function() {
      if (!this._style)
        this._style = new CSSStyleDeclaration(this);
      return this._style;
    }},

    click: { value: function() {
      if (this._click_in_progress) return;
      this._click_in_progress = true;
      try {
        if (this._pre_click_activation_steps)
          this._pre_click_activation_steps();

        var event = this.ownerDocument.createEvent("MouseEvent");
        event.initMouseEvent("click", true, true,
          this.ownerDocument.defaultView, 1,
          0, 0, 0, 0,
          // These 4 should be initialized with
          // the actually current keyboard state
          // somehow...
          false, false, false, false,
          0, null
        );

        // Dispatch this as an untrusted event since it is synthetic
        var success = this.dispatchEvent(event);

        if (success) {
          if (this._post_click_activation_steps)
            this._post_click_activation_steps(event);
        }
        else {
          if (this._cancelled_activation_steps)
            this._cancelled_activation_steps();
        }
      }
      finally {
        this._click_in_progress = false;
      }
    }}
  },
  attributes: {
    title: String,
    lang: String,
    dir: {type: ["ltr", "rtl", "auto"], missing: ''},
    accessKey: String,
    hidden: Boolean,
    tabIndex: {type: "long", default: function() {
      if (this.tagName in focusableElements ||
        this.contentEditable)
        return 0;
      else
        return -1;
    }}
  },
  events: [
    "abort", "canplay", "canplaythrough", "change", "click", "contextmenu",
    "cuechange", "dblclick", "drag", "dragend", "dragenter", "dragleave",
    "dragover", "dragstart", "drop", "durationchange", "emptied", "ended",
    "input", "invalid", "keydown", "keypress", "keyup", "loadeddata",
    "loadedmetadata", "loadstart", "mousedown", "mousemove", "mouseout",
    "mouseover", "mouseup", "mousewheel", "pause", "play", "playing",
    "progress", "ratechange", "readystatechange", "reset", "seeked",
    "seeking", "select", "show", "stalled", "submit", "suspend",
    "timeupdate", "volumechange", "waiting",

    // These last 5 event types will be overriden by HTMLBodyElement
    "blur", "error", "focus", "load", "scroll"
  ]
});


// XXX: reflect contextmenu as contextMenu, with element type


// style: the spec doesn't call this a reflected attribute.
//   may want to handle it manually.

// contentEditable: enumerated, not clear if it is actually
// reflected or requires custom getter/setter. Not listed as
// "limited to known values".  Raises syntax_err on bad setting,
// so I think this is custom.

// contextmenu: content is element id, idl type is an element
// draggable: boolean, but not a reflected attribute
// dropzone: reflected SettableTokenList, experimental, so don't
//   implement it right away.

// data-* attributes: need special handling in setAttribute?
// Or maybe that isn't necessary. Can I just scan the attribute list
// when building the dataset?  Liveness and caching issues?

// microdata attributes: many are simple reflected attributes, but
// I'm not going to implement this now.


var HTMLUnknownElement = define({
  ctor: function HTMLUnknownElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});


var formAssociatedProps = {
  // See http://www.w3.org/TR/html5/association-of-controls-and-forms.html#form-owner
  form: { get: function() {
    return this._form;
  }}
};

define({
  tag: 'a',
  ctor: function HTMLAnchorElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    _post_click_activation_steps: { value: function(e) {
      if (this.href) {
        // Follow the link
        // XXX: this is just a quick hack
        // XXX: the HTML spec probably requires more than this
        this.ownerDocument.defaultView.location = this.href;
      }
    }},
    blur: { value: function() {}},
    focus: { value: function() {}}
  },
  attributes: {
    href: URL,
    ping: String,
    download: String,
    target: String,
    rel: String,
    media: String,
    hreflang: String,
    type: String,
    referrerPolicy: REFERRER,
    // Obsolete
    coords: String,
    charset: String,
    name: String,
    rev: String,
    shape: String,
  }
});
URLUtils._inherit(htmlNameToImpl.a.prototype);

define({
  tag: 'area',
  ctor: function HTMLAreaElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    alt: String,
    target: String,
    download: String,
    rel: String,
    media: String,
    href: URL,
    hreflang: String,
    type: String,
    shape: String,
    coords: String,
    ping: String,
    // XXX: also reflect relList
    referrerPolicy: REFERRER,
    // Obsolete
    noHref: Boolean,
  }
});

define({
  tag: 'br',
  ctor: function HTMLBRElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    clear: String
  },
});

define({
  tag: 'base',
  ctor: function HTMLBaseElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    "target": String
  }
});


define({
  tag: 'body',
  ctor: function HTMLBodyElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  // Certain event handler attributes on a <body> tag actually set
  // handlers for the window rather than just that element.  Define
  // getters and setters for those here.  Note that some of these override
  // properties on HTMLElement.prototype.
  // XXX: If I add support for <frameset>, these have to go there, too
  // XXX
  // When the Window object is implemented, these attribute will have
  // to work with the same-named attributes on the Window.
  events: [
    "afterprint", "beforeprint", "beforeunload", "blur", "error",
    "focus","hashchange", "load", "message", "offline", "online",
    "pagehide", "pageshow","popstate","resize","scroll","storage","unload",
  ],
  attributes: {
    // Obsolete
    text: { type: String, treatNullAsEmptyString: true },
    link: { type: String, treatNullAsEmptyString: true },
    vLink: { type: String, treatNullAsEmptyString: true },
    aLink: { type: String, treatNullAsEmptyString: true },
    bgColor: { type: String, treatNullAsEmptyString: true },
    background: String,
  }
});

define({
  tag: 'button',
  ctor: function HTMLButtonElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    name: String,
    value: String,
    disabled: Boolean,
    autofocus: Boolean,
    type: { type:["submit", "reset", "button", "menu"], missing: 'submit' },
    formTarget: String,
    formNoValidate: Boolean,
    formMethod: { type: ["get", "post", "dialog"], invalid: 'get', missing: '' },
    formEnctype: { type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: '' },
  }
});

define({
  tag: 'dl',
  ctor: function HTMLDListElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    compact: Boolean,
  }
});

define({
  tag: 'data',
  ctor: function HTMLDataElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    value: String,
  }
});

define({
  tag: 'datalist',
  ctor: function HTMLDataListElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'details',
  ctor: function HTMLDetailsElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    "open": Boolean
  }
});

define({
  tag: 'div',
  ctor: function HTMLDivElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String
  }
});

define({
  tag: 'embed',
  ctor: function HTMLEmbedElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    src: URL,
    type: String,
    width: String,
    height: String,
    // Obsolete
    align: String,
    name: String,
  }
});

define({
  tag: 'fieldset',
  ctor: function HTMLFieldSetElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    disabled: Boolean,
    name: String
  }
});

define({
  tag: 'form',
  ctor: function HTMLFormElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    action: String,
    autocomplete: {type:['on', 'off'], missing: 'on'},
    name: String,
    acceptCharset: {name: "accept-charset"},
    target: String,
    noValidate: Boolean,
    method: { type: ["get", "post", "dialog"], invalid: 'get', missing: 'get' },
    // Both enctype and encoding reflect the enctype content attribute
    enctype: { type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: "application/x-www-form-urlencoded" },
    encoding: {name: 'enctype', type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: "application/x-www-form-urlencoded" },
  }
});

define({
  tag: 'hr',
  ctor: function HTMLHRElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String,
    color: String,
    noShade: Boolean,
    size: String,
    width: String,
  },
});

define({
  tag: 'head',
  ctor: function HTMLHeadElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tags: ['h1','h2','h3','h4','h5','h6'],
  ctor: function HTMLHeadingElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String,
  },
});

define({
  tag: 'html',
  ctor: function HTMLHtmlElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    version: String
  }
});

define({
  tag: 'iframe',
  ctor: function HTMLIFrameElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
    var Window = __webpack_require__(17); // Avoid circular dependencies.
    this._contentWindow = new Window();
  },
  props: {
    contentWindow: { get: function() {
      return this._contentWindow;
    } },
    contentDocument: { get: function() {
      return this.contentWindow.document;
    } },
  },
  attributes: {
    src: URL,
    srcdoc: String,
    name: String,
    width: String,
    height: String,
    // XXX: sandbox is a reflected settable token list
    seamless: Boolean,
    allowFullscreen: Boolean,
    allowUserMedia: Boolean,
    allowPaymentRequest: Boolean,
    referrerPolicy: REFERRER,
    // Obsolete
    align: String,
    scrolling: String,
    frameBorder: String,
    longDesc: URL,
    marginHeight: { type: String, treatNullAsEmptyString: true },
    marginWidth: { type: String, treatNullAsEmptyString: true },
  }
});

define({
  tag: 'img',
  ctor: function HTMLImageElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    alt: String,
    src: URL,
    srcset: String,
    crossOrigin: CORS,
    useMap: String,
    isMap: Boolean,
    height: { type: "unsigned long", default: 0 },
    width: { type: "unsigned long", default: 0 },
    referrerPolicy: REFERRER,
    // Obsolete:
    name: String,
    lowsrc: URL,
    align: String,
    hspace: { type: "unsigned long", default: 0 },
    vspace: { type: "unsigned long", default: 0 },
    longDesc: URL,
    border: { type: String, treatNullAsEmptyString: true },
  }
});

define({
  tag: 'input',
  ctor: function HTMLInputElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: {
    form: formAssociatedProps.form,
    _post_click_activation_steps: { value: function(e) {
      if (this.type === 'checkbox') {
        this.checked = !this.checked;
      }
      else if (this.type === 'radio') {
        var group = this.form.getElementsByName(this.name);
        for (var i=group.length-1; i >= 0; i--) {
          var el = group[i];
          el.checked = (el === this);
        }
      }
    }},
  },
  attributes: {
    name: String,
    disabled: Boolean,
    autofocus: Boolean,
    accept: String,
    alt: String,
    max: String,
    min: String,
    pattern: String,
    placeholder: String,
    step: String,
    dirName: String,
    defaultValue: {name: 'value'},
    multiple: Boolean,
    required: Boolean,
    readOnly: Boolean,
    checked: Boolean,
    value: String,
    src: URL,
    defaultChecked: {name: 'checked', type: Boolean},
    size: {type: 'unsigned long', default: 20, min: 1, setmin: 1},
    maxLength: {type: 'unsigned long', min: 0, setmin: 0, default: -1},
    autocomplete: String, // It's complicated
    type: { type:
            ["text", "hidden", "search", "tel", "url", "email", "password",
             "datetime", "date", "month", "week", "time", "datetime-local",
             "number", "range", "color", "checkbox", "radio", "file", "submit",
             "image", "reset", "button"],
            missing: 'text' },
    formTarget: String,
    formNoValidate: Boolean,
    formMethod: { type: ["get", "post"], invalid: 'get', missing: '' },
    formEnctype: { type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: '' },
    inputMode: { type: [ "verbatim", "latin", "latin-name", "latin-prose", "full-width-latin", "kana", "kana-name", "katakana", "numeric", "tel", "email", "url" ], missing: '' },
    // Obsolete
    align: String,
    useMap: String,
  }
});

define({
  tag: 'keygen',
  ctor: function HTMLKeygenElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    name: String,
    disabled: Boolean,
    autofocus: Boolean,
    challenge: String,
    keytype: { type:["rsa"], missing: '' },
  }
});

define({
  tag: 'li',
  ctor: function HTMLLIElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    value: {type: "long", default: 0},
    // Obsolete
    type: String,
  }
});

define({
  tag: 'label',
  ctor: function HTMLLabelElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    htmlFor: {name: 'for', type: String}
  }
});

define({
  tag: 'legend',
  ctor: function HTMLLegendElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String
  },
});

define({
  tag: 'link',
  ctor: function HTMLLinkElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // XXX Reflect DOMSettableTokenList sizes also DOMTokenList relList
    href: URL,
    rel: String,
    media: String,
    hreflang: String,
    type: String,
    crossOrigin: CORS,
    nonce: String,
    integrity: String,
    referrerPolicy: REFERRER,
    // Obsolete
    charset: String,
    rev: String,
    target: String,
  }
});

define({
  tag: 'map',
  ctor: function HTMLMapElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    name: String
  }
});

define({
  tag: 'menu',
  ctor: function HTMLMenuElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // XXX: not quite right, default should be popup if parent element is
    // popup.
    type: { type: [ 'context', 'popup', 'toolbar' ], missing: 'toolbar' },
    label: String,
    // Obsolete
    compact: Boolean,
  }
});

define({
  tag: 'meta',
  ctor: function HTMLMetaElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    name: String,
    content: String,
    httpEquiv: {name: 'http-equiv', type: String},
    // Obsolete
    scheme: String,
  }
});

define({
  tag: 'meter',
  ctor: function HTMLMeterElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps
});

define({
  tags: ['ins', 'del'],
  ctor: function HTMLModElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    cite: URL,
    dateTime: String
  }
});

define({
  tag: 'ol',
  ctor: function HTMLOListElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    // Utility function (see the start attribute default value). Returns
    // the number of <li> children of this element
    _numitems: { get: function() {
      var items = 0;
      this.childNodes.forEach(function(n) {
        if (n.nodeType === Node.ELEMENT_NODE && n.tagName === "LI")
          items++;
      });
      return items;
    }}
  },
  attributes: {
    type: String,
    reversed: Boolean,
    start: {
      type: "long",
      default: function() {
       // The default value of the start attribute is 1 unless the list is
       // reversed. Then it is the # of li children
       if (this.reversed)
         return this._numitems;
       else
         return 1;
      }
    },
    // Obsolete
    compact: Boolean,
  }
});

define({
  tag: 'object',
  ctor: function HTMLObjectElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    data: URL,
    type: String,
    name: String,
    useMap: String,
    typeMustMatch: Boolean,
    width: String,
    height: String,
    // Obsolete
    align: String,
    archive: String,
    code: String,
    declare: Boolean,
    hspace: { type: "unsigned long", default: 0 },
    standby: String,
    vspace: { type: "unsigned long", default: 0 },
    codeBase: URL,
    codeType: String,
    border: { type: String, treatNullAsEmptyString: true },
  }
});

define({
  tag: 'optgroup',
  ctor: function HTMLOptGroupElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    disabled: Boolean,
    label: String
  }
});

define({
  tag: 'option',
  ctor: function HTMLOptionElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    form: { get: function() {
      var p = this.parentNode;
      while (p && p.nodeType === Node.ELEMENT_NODE) {
        if (p.localName === 'select') return p.form;
        p = p.parentNode;
      }
    }}
  },
  attributes: {
    disabled: Boolean,
    defaultSelected: {name: 'selected', type: Boolean},
    label: String,
    value: String,
  }
});

define({
  tag: 'output',
  ctor: function HTMLOutputElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    // XXX Reflect for/htmlFor as a settable token list
    name: String
  }
});

define({
  tag: 'p',
  ctor: function HTMLParagraphElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String
  }
});

define({
  tag: 'param',
  ctor: function HTMLParamElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    name: String,
    value: String,
    // Obsolete
    type: String,
    valueType: String,
  }
});

define({
  tags: ['pre',/*legacy elements:*/'listing','xmp'],
  ctor: function HTMLPreElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    width: { type: "long", default: 0 },
  }
});

define({
  tag: 'progress',
  ctor: function HTMLProgressElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    max: {type: Number, float: true, default: 1.0, min: 0}
  }
});

define({
  tags: ['q', 'blockquote'],
  ctor: function HTMLQuoteElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    cite: URL
  }
});

define({
  tag: 'script',
  ctor: function HTMLScriptElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    text: {
      get: function() {
        var s = "";
        for(var i = 0, n = this.childNodes.length; i < n; i++) {
          var child = this.childNodes[i];
          if (child.nodeType === Node.TEXT_NODE)
            s += child._data;
        }
        return s;
      },
      set: function(value) {
        this.removeChildren();
        if (value !== null && value !== "") {
          this.appendChild(this.ownerDocument.createTextNode(value));
        }
      }
    }
  },
  attributes: {
    src: URL,
    type: String,
    charset: String,
    defer: Boolean,
    async: Boolean,
    crossOrigin: CORS,
    nonce: String,
    integrity: String,
  }
});

define({
  tag: 'select',
  ctor: function HTMLSelectElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: {
    form: formAssociatedProps.form,
    options: { get: function() {
      return this.getElementsByTagName('option');
    }}
  },
  attributes: {
    name: String,
    disabled: Boolean,
    autofocus: Boolean,
    multiple: Boolean,
    required: Boolean,
    size: {type: "unsigned long", default: 0}
  }
});

define({
  tag: 'source',
  ctor: function HTMLSourceElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    src: URL,
    type: String,
    media: String
  }
});

define({
  tag: 'span',
  ctor: function HTMLSpanElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'style',
  ctor: function HTMLStyleElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    media: String,
    type: String,
    scoped: Boolean
  }
});

define({
  tag: 'caption',
  ctor: function HTMLTableCaptionElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String,
  }
});


define({
  ctor: function HTMLTableCellElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    colSpan: {type: "unsigned long", default: 1},
    rowSpan: {type: "unsigned long", default: 1},
    //XXX Also reflect settable token list headers
    scope: { type: ['row','col','rowgroup','colgroup'], missing: '' },
    abbr: String,
    // Obsolete
    align: String,
    axis: String,
    height: String,
    width: String,
    ch: { name: 'char', type: String },
    chOff: { name: 'charoff', type: String },
    noWrap: Boolean,
    vAlign: String,
    bgColor: { type: String, treatNullAsEmptyString: true },
  }
});

define({
  tags: ['col', 'colgroup'],
  ctor: function HTMLTableColElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    span: {type: 'limited unsigned long with fallback', default: 1, min: 1},
    // Obsolete
    align: String,
    ch: { name: 'char', type: String },
    chOff: { name: 'charoff', type: String },
    vAlign: String,
    width: String,
  }
});

define({
  tag: 'table',
  ctor: function HTMLTableElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    rows: { get: function() {
      return this.getElementsByTagName('tr');
    }}
  },
  attributes: {
    // Obsolete
    align: String,
    border: String,
    frame: String,
    rules: String,
    summary: String,
    width: String,
    bgColor: { type: String, treatNullAsEmptyString: true },
    cellPadding: { type: String, treatNullAsEmptyString: true },
    cellSpacing: { type: String, treatNullAsEmptyString: true },
  }
});

define({
  tag: 'template',
  ctor: function HTMLTemplateElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
    this._contentFragment = doc._templateDoc.createDocumentFragment();
  },
  props: {
    content: { get: function() { return this._contentFragment; } },
    serialize: { value: function() { return this.content.serialize(); } }
  }
});

define({
  tag: 'tr',
  ctor: function HTMLTableRowElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    cells: { get: function() {
      return this.querySelectorAll('td,th');
    }}
  },
  attributes: {
    // Obsolete
    align: String,
    ch: { name: 'char', type: String },
    chOff: { name: 'charoff', type: String },
    vAlign: String,
    bgColor: { type: String, treatNullAsEmptyString: true },
  },
});

define({
  tags: ['thead', 'tfoot', 'tbody'],
  ctor: function HTMLTableSectionElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    rows: { get: function() {
      return this.getElementsByTagName('tr');
    }}
  },
  attributes: {
    // Obsolete
    align: String,
    ch: { name: 'char', type: String },
    chOff: { name: 'charoff', type: String },
    vAlign: String,
  }
});

define({
  tag: 'textarea',
  ctor: function HTMLTextAreaElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    autocomplete: String, // It's complicated
    name: String,
    disabled: Boolean,
    autofocus: Boolean,
    placeholder: String,
    wrap: String,
    dirName: String,
    required: Boolean,
    readOnly: Boolean,
    rows: {type: 'limited unsigned long with fallback', default: 2 },
    cols: {type: 'limited unsigned long with fallback', default: 20 },
    maxLength: {type: 'unsigned long', min: 0, setmin: 0, default: -1},
    inputMode: { type: [ "verbatim", "latin", "latin-name", "latin-prose", "full-width-latin", "kana", "kana-name", "katakana", "numeric", "tel", "email", "url" ], missing: '' },
  }
});

define({
  tag: 'time',
  ctor: function HTMLTimeElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    dateTime: String,
    pubDate: Boolean
  }
});

define({
  tag: 'title',
  ctor: function HTMLTitleElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    text: { get: function() {
      return this.textContent;
    }}
  }
});

define({
  tag: 'ul',
  ctor: function HTMLUListElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    type: String,
    // Obsolete
    compact: Boolean,
  }
});

define({
  ctor: function HTMLMediaElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    src: URL,
    crossOrigin: CORS,
    preload: { type:["metadata", "none", "auto", {value: "", alias: "auto"}], missing: 'auto' },
    loop: Boolean,
    autoplay: Boolean,
    mediaGroup: String,
    controls: Boolean,
    defaultMuted: {name: "muted", type: Boolean}
  }
});

define({
  tag: 'audio',
  superclass: htmlElements.HTMLMediaElement,
  ctor: function HTMLAudioElement(doc, localName, prefix) {
    htmlElements.HTMLMediaElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'video',
  superclass: htmlElements.HTMLMediaElement,
  ctor: function HTMLVideoElement(doc, localName, prefix) {
    htmlElements.HTMLMediaElement.call(this, doc, localName, prefix);
  },
  attributes: {
    poster: URL,
    width: {type: "unsigned long", min: 0, default: 0 },
    height: {type: "unsigned long", min: 0, default: 0 }
  }
});

define({
  tag: 'td',
  superclass: htmlElements.HTMLTableCellElement,
  ctor: function HTMLTableDataCellElement(doc, localName, prefix) {
    htmlElements.HTMLTableCellElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'th',
  superclass: htmlElements.HTMLTableCellElement,
  ctor: function HTMLTableHeaderCellElement(doc, localName, prefix) {
    htmlElements.HTMLTableCellElement.call(this, doc, localName, prefix);
  },
});

define({
  tag: 'frameset',
  ctor: function HTMLFrameSetElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'frame',
  ctor: function HTMLFrameElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'canvas',
  ctor: function HTMLCanvasElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    getContext: { value: utils.nyi },
    probablySupportsContext: { value: utils.nyi },
    setContext: { value: utils.nyi },
    transferControlToProxy: { value: utils.nyi },
    toDataURL: { value: utils.nyi },
    toBlob: { value: utils.nyi }
  },
  attributes: {
    width: { type: "unsigned long", default: 300},
    height: { type: "unsigned long", default: 150}
  }
});

define({
  tag: 'dialog',
  ctor: function HTMLDialogElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    show: { value: utils.nyi },
    showModal: { value: utils.nyi },
    close: { value: utils.nyi }
  },
  attributes: {
    open: Boolean,
    returnValue: String
  }
});

define({
  tag: 'menuitem',
  ctor: function HTMLMenuItemElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    // The menuitem's label
    _label: {
      get: function() {
        var val = this._getattr('label');
        if (val !== null && val !== '') { return val; }
        val = this.textContent;
        // Strip and collapse whitespace
        return val.replace(/[ \t\n\f\r]+/g, ' ').trim();
      }
    },
    // The menuitem label IDL attribute
    label: {
      get: function() {
        var val = this._getattr('label');
        if (val !== null) { return val; }
        return this._label;
      },
      set: function(v) {
        this._setattr('label', v);
      },
    }
  },
  attributes: {
    type: { type: ["command","checkbox","radio"], missing: 'command' },
    icon: URL,
    disabled: Boolean,
    checked: Boolean,
    radiogroup: String,
    default: Boolean
  }
});

define({
  tag: 'source',
  ctor: function HTMLSourceElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    srcset: String,
    sizes: String,
    media: String,
    src: URL,
    type: String
  }
});

define({
  tag: 'track',
  ctor: function HTMLTrackElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    src: URL,
    srclang: String,
    label: String,
    default: Boolean,
    kind: { type: ["subtitles", "captions", "descriptions", "chapters", "metadata"], missing: 'subtitles', invalid: 'metadata' },
  },
  props: {
    NONE: { get: function() { return 0; } },
    LOADING: { get: function() { return 1; } },
    LOADED: { get: function() { return 2; } },
    ERROR: { get: function() { return 3; } },
    readyState: { get: utils.nyi },
    track: { get: utils.nyi }
  }
});

define({
  tags: [
    "abbr", "address", "article", "aside", "b", "bdi", "bdo",
    "cite", "code", "dd", "dfn", "dt", "em", "figcaption", "figure",
    "footer", "header", "hgroup", "i", "kbd", "main", "mark", "nav", "noscript",
    "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "section", "small", "strong",
    "sub", "summary", "sup", "u", "var", "wbr",
    // Legacy elements
    "acronym", "basefont", "big", "center", "nobr", "noembed", "noframes",
    "plaintext", "strike", "tt"
  ]
});


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* jshint eqnull: true */
/**
 * Zest (https://github.com/chjj/zest)
 * A css selector engine.
 * Copyright (c) 2011-2012, Christopher Jeffrey. (MIT Licensed)
 */

/**
 * Helpers
 */

var window = Object.create(null, {
  location: { get: function() {
    throw new Error('window.location is not supported.');
  } }
});

var compareDocumentPosition = function(a, b) {
      return a.compareDocumentPosition(b);
};

var order = function(a, b) {
  /* jshint bitwise: false */
  return compareDocumentPosition(a, b) & 2 ? 1 : -1;
};

var next = function(el) {
  while ((el = el.nextSibling)
         && el.nodeType !== 1);
  return el;
};

var prev = function(el) {
  while ((el = el.previousSibling)
         && el.nodeType !== 1);
  return el;
};

var child = function(el) {
  /*jshint -W084 */
  if (el = el.firstChild) {
    while (el.nodeType !== 1
           && (el = el.nextSibling));
  }
  return el;
};

var lastChild = function(el) {
  /*jshint -W084 */
  if (el = el.lastChild) {
    while (el.nodeType !== 1
           && (el = el.previousSibling));
  }
  return el;
};

var unquote = function(str) {
  if (!str) return str;
  var ch = str[0];
  if (ch === '"' || ch === '\'') {
    if (str[str.length-1] === ch) {
      str = str.slice(1, -1);
    } else {
      // bad string.
      str = str.slice(1);
    }
    return str.replace(rules.str_escape, function(s) {
      var m = /^\\(?:([0-9A-Fa-f]+)|([\r\n\f]+))/.exec(s);
      if (!m) { return s.slice(1); }
      if (m[2]) { return ''; /* escaped newlines are ignored in strings. */ }
      var cp = parseInt(m[1], 16);
      return String.fromCodePoint ? String.fromCodePoint(cp) :
        // Not all JavaScript implementations have String.fromCodePoint yet.
        String.fromCharCode(cp);
    });
  } else if (rules.ident.test(str)) {
    return decodeid(str);
  } else {
    // NUMBER, PERCENTAGE, DIMENSION, etc
    return str;
  }
};

var decodeid = function(str) {
  return str.replace(rules.escape, function(s) {
    var m = /^\\([0-9A-Fa-f]+)/.exec(s);
    if (!m) { return s[1]; }
    var cp = parseInt(m[1], 16);
    return String.fromCodePoint ? String.fromCodePoint(cp) :
      // Not all JavaScript implementations have String.fromCodePoint yet.
      String.fromCharCode(cp);
  });
};

var indexOf = (function() {
  if (Array.prototype.indexOf) {
    return Array.prototype.indexOf;
  }
  return function(obj, item) {
    var i = this.length;
    while (i--) {
      if (this[i] === item) return i;
    }
    return -1;
  };
})();

var makeInside = function(start, end) {
  var regex = rules.inside.source
    .replace(/</g, start)
    .replace(/>/g, end);

  return new RegExp(regex);
};

var replace = function(regex, name, val) {
  regex = regex.source;
  regex = regex.replace(name, val.source || val);
  return new RegExp(regex);
};

var truncateUrl = function(url, num) {
  return url
    .replace(/^(?:\w+:\/\/|\/+)/, '')
    .replace(/(?:\/+|\/*#.*?)$/, '')
    .split('/', num)
    .join('/');
};

/**
 * Handle `nth` Selectors
 */

var parseNth = function(param_, test) {
  var param = param_.replace(/\s+/g, '')
    , cap;

  if (param === 'even') {
    param = '2n+0';
  } else if (param === 'odd') {
    param = '2n+1';
  } else if (param.indexOf('n') === -1) {
    param = '0n' + param;
  }

  cap = /^([+-])?(\d+)?n([+-])?(\d+)?$/.exec(param);

  return {
    group: cap[1] === '-'
      ? -(cap[2] || 1)
      : +(cap[2] || 1),
    offset: cap[4]
      ? (cap[3] === '-' ? -cap[4] : +cap[4])
      : 0
  };
};

var nth = function(param_, test, last) {
  var param = parseNth(param_)
    , group = param.group
    , offset = param.offset
    , find = !last ? child : lastChild
    , advance = !last ? next : prev;

  return function(el) {
    if (el.parentNode.nodeType !== 1) return;

    var rel = find(el.parentNode)
      , pos = 0;

    while (rel) {
      if (test(rel, el)) pos++;
      if (rel === el) {
        pos -= offset;
        return group && pos
          ? (pos % group) === 0 && (pos < 0 === group < 0)
          : !pos;
      }
      rel = advance(rel);
    }
  };
};

/**
 * Simple Selectors
 */

var selectors = {
  '*': (function() {
    if (false/*function() {
      var el = document.createElement('div');
      el.appendChild(document.createComment(''));
      return !!el.getElementsByTagName('*')[0];
    }()*/) {
      return function(el) {
        if (el.nodeType === 1) return true;
      };
    }
    return function() {
      return true;
    };
  })(),
  'type': function(type) {
    type = type.toLowerCase();
    return function(el) {
      return el.nodeName.toLowerCase() === type;
    };
  },
  'attr': function(key, op, val, i) {
    op = operators[op];
    return function(el) {
      var attr;
      switch (key) {
        case 'for':
          attr = el.htmlFor;
          break;
        case 'class':
          // className is '' when non-existent
          // getAttribute('class') is null
          attr = el.className;
          if (attr === '' && el.getAttribute('class') == null) {
            attr = null;
          }
          break;
        case 'href':
          attr = el.getAttribute('href', 2);
          break;
        case 'title':
          // getAttribute('title') can be '' when non-existent sometimes?
          attr = el.getAttribute('title') || null;
          break;
        // careful with attributes with special getter functions
        case 'id':
        case 'lang':
        case 'dir':
        case 'accessKey':
        case 'hidden':
        case 'tabIndex':
        case 'style':
          if (el.getAttribute) {
            attr = el.getAttribute(key);
            break;
          }
        /* falls through */
        default:
          if (el.hasAttribute && !el.hasAttribute(key)) {
            break;
          }
          attr = el[key] != null
            ? el[key]
            : el.getAttribute && el.getAttribute(key);
          break;
      }
      if (attr == null) return;
      attr = attr + '';
      if (i) {
        attr = attr.toLowerCase();
        val = val.toLowerCase();
      }
      return op(attr, val);
    };
  },
  ':first-child': function(el) {
    return !prev(el) && el.parentNode.nodeType === 1;
  },
  ':last-child': function(el) {
    return !next(el) && el.parentNode.nodeType === 1;
  },
  ':only-child': function(el) {
    return !prev(el) && !next(el)
      && el.parentNode.nodeType === 1;
  },
  ':nth-child': function(param, last) {
    return nth(param, function() {
      return true;
    }, last);
  },
  ':nth-last-child': function(param) {
    return selectors[':nth-child'](param, true);
  },
  ':root': function(el) {
    return el.ownerDocument.documentElement === el;
  },
  ':empty': function(el) {
    return !el.firstChild;
  },
  ':not': function(sel) {
    var test = compileGroup(sel);
    return function(el) {
      return !test(el);
    };
  },
  ':first-of-type': function(el) {
    if (el.parentNode.nodeType !== 1) return;
    var type = el.nodeName;
    /*jshint -W084 */
    while (el = prev(el)) {
      if (el.nodeName === type) return;
    }
    return true;
  },
  ':last-of-type': function(el) {
    if (el.parentNode.nodeType !== 1) return;
    var type = el.nodeName;
    /*jshint -W084 */
    while (el = next(el)) {
      if (el.nodeName === type) return;
    }
    return true;
  },
  ':only-of-type': function(el) {
    return selectors[':first-of-type'](el)
        && selectors[':last-of-type'](el);
  },
  ':nth-of-type': function(param, last) {
    return nth(param, function(rel, el) {
      return rel.nodeName === el.nodeName;
    }, last);
  },
  ':nth-last-of-type': function(param) {
    return selectors[':nth-of-type'](param, true);
  },
  ':checked': function(el) {
    return !!(el.checked || el.selected);
  },
  ':indeterminate': function(el) {
    return !selectors[':checked'](el);
  },
  ':enabled': function(el) {
    return !el.disabled && el.type !== 'hidden';
  },
  ':disabled': function(el) {
    return !!el.disabled;
  },
  ':target': function(el) {
    return el.id === window.location.hash.substring(1);
  },
  ':focus': function(el) {
    return el === el.ownerDocument.activeElement;
  },
  ':matches': function(sel) {
    return compileGroup(sel);
  },
  ':nth-match': function(param, last) {
    var args = param.split(/\s*,\s*/)
      , arg = args.shift()
      , test = compileGroup(args.join(','));

    return nth(arg, test, last);
  },
  ':nth-last-match': function(param) {
    return selectors[':nth-match'](param, true);
  },
  ':links-here': function(el) {
    return el + '' === window.location + '';
  },
  ':lang': function(param) {
    return function(el) {
      while (el) {
        if (el.lang) return el.lang.indexOf(param) === 0;
        el = el.parentNode;
      }
    };
  },
  ':dir': function(param) {
    return function(el) {
      while (el) {
        if (el.dir) return el.dir === param;
        el = el.parentNode;
      }
    };
  },
  ':scope': function(el, con) {
    var context = con || el.ownerDocument;
    if (context.nodeType === 9) {
      return el === context.documentElement;
    }
    return el === context;
  },
  ':any-link': function(el) {
    return typeof el.href === 'string';
  },
  ':local-link': function(el) {
    if (el.nodeName) {
      return el.href && el.host === window.location.host;
    }
    var param = +el + 1;
    return function(el) {
      if (!el.href) return;

      var url = window.location + ''
        , href = el + '';

      return truncateUrl(url, param) === truncateUrl(href, param);
    };
  },
  ':default': function(el) {
    return !!el.defaultSelected;
  },
  ':valid': function(el) {
    return el.willValidate || (el.validity && el.validity.valid);
  },
  ':invalid': function(el) {
    return !selectors[':valid'](el);
  },
  ':in-range': function(el) {
    return el.value > el.min && el.value <= el.max;
  },
  ':out-of-range': function(el) {
    return !selectors[':in-range'](el);
  },
  ':required': function(el) {
    return !!el.required;
  },
  ':optional': function(el) {
    return !el.required;
  },
  ':read-only': function(el) {
    if (el.readOnly) return true;

    var attr = el.getAttribute('contenteditable')
      , prop = el.contentEditable
      , name = el.nodeName.toLowerCase();

    name = name !== 'input' && name !== 'textarea';

    return (name || el.disabled) && attr == null && prop !== 'true';
  },
  ':read-write': function(el) {
    return !selectors[':read-only'](el);
  },
  ':hover': function() {
    throw new Error(':hover is not supported.');
  },
  ':active': function() {
    throw new Error(':active is not supported.');
  },
  ':link': function() {
    throw new Error(':link is not supported.');
  },
  ':visited': function() {
    throw new Error(':visited is not supported.');
  },
  ':column': function() {
    throw new Error(':column is not supported.');
  },
  ':nth-column': function() {
    throw new Error(':nth-column is not supported.');
  },
  ':nth-last-column': function() {
    throw new Error(':nth-last-column is not supported.');
  },
  ':current': function() {
    throw new Error(':current is not supported.');
  },
  ':past': function() {
    throw new Error(':past is not supported.');
  },
  ':future': function() {
    throw new Error(':future is not supported.');
  },
  // Non-standard, for compatibility purposes.
  ':contains': function(param) {
    return function(el) {
      var text = el.innerText || el.textContent || el.value || '';
      return text.indexOf(param) !== -1;
    };
  },
  ':has': function(param) {
    return function(el) {
      return find(param, el).length > 0;
    };
  }
  // Potentially add more pseudo selectors for
  // compatibility with sizzle and most other
  // selector engines (?).
};

/**
 * Attribute Operators
 */

var operators = {
  '-': function() {
    return true;
  },
  '=': function(attr, val) {
    return attr === val;
  },
  '*=': function(attr, val) {
    return attr.indexOf(val) !== -1;
  },
  '~=': function(attr, val) {
    var i = attr.indexOf(val)
      , f
      , l;

    if (i === -1) return;
    f = attr[i - 1];
    l = attr[i + val.length];

    return (!f || f === ' ') && (!l || l === ' ');
  },
  '|=': function(attr, val) {
    var i = attr.indexOf(val)
      , l;

    if (i !== 0) return;
    l = attr[i + val.length];

    return l === '-' || !l;
  },
  '^=': function(attr, val) {
    return attr.indexOf(val) === 0;
  },
  '$=': function(attr, val) {
    return attr.indexOf(val) + val.length === attr.length;
  },
  // non-standard
  '!=': function(attr, val) {
    return attr !== val;
  }
};

/**
 * Combinator Logic
 */

var combinators = {
  ' ': function(test) {
    return function(el) {
      /*jshint -W084 */
      while (el = el.parentNode) {
        if (test(el)) return el;
      }
    };
  },
  '>': function(test) {
    return function(el) {
      /*jshint -W084 */
      if (el = el.parentNode) {
        return test(el) && el;
      }
    };
  },
  '+': function(test) {
    return function(el) {
      /*jshint -W084 */
      if (el = prev(el)) {
        return test(el) && el;
      }
    };
  },
  '~': function(test) {
    return function(el) {
      /*jshint -W084 */
      while (el = prev(el)) {
        if (test(el)) return el;
      }
    };
  },
  'noop': function(test) {
    return function(el) {
      return test(el) && el;
    };
  },
  'ref': function(test, name) {
    var node;

    function ref(el) {
      var doc = el.ownerDocument
        , nodes = doc.getElementsByTagName('*')
        , i = nodes.length;

      while (i--) {
        node = nodes[i];
        if (ref.test(el)) {
          node = null;
          return true;
        }
      }

      node = null;
    }

    ref.combinator = function(el) {
      if (!node || !node.getAttribute) return;

      var attr = node.getAttribute(name) || '';
      if (attr[0] === '#') attr = attr.substring(1);

      if (attr === el.id && test(node)) {
        return node;
      }
    };

    return ref;
  }
};

/**
 * Grammar
 */

var rules = {
  escape: /\\(?:[^0-9A-Fa-f\r\n]|[0-9A-Fa-f]{1,6}[\r\n\t ]?)/g,
  str_escape: /(escape)|\\(\n|\r\n?|\f)/g,
  nonascii: /[\u00A0-\uFFFF]/,
  cssid: /(?:(?!-?[0-9])(?:escape|nonascii|[-_a-zA-Z0-9])+)/,
  qname: /^ *(cssid|\*)/,
  simple: /^(?:([.#]cssid)|pseudo|attr)/,
  ref: /^ *\/(cssid)\/ */,
  combinator: /^(?: +([^ \w*.#\\]) +|( )+|([^ \w*.#\\]))(?! *$)/,
  attr: /^\[(cssid)(?:([^\w]?=)(inside))?\]/,
  pseudo: /^(:cssid)(?:\((inside)\))?/,
  inside: /(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|<[^"'>]*>|\\["'>]|[^"'>])*/,
  ident: /^(cssid)$/
};

rules.cssid = replace(rules.cssid, 'nonascii', rules.nonascii);
rules.cssid = replace(rules.cssid, 'escape', rules.escape);
rules.qname = replace(rules.qname, 'cssid', rules.cssid);
rules.simple = replace(rules.simple, 'cssid', rules.cssid);
rules.ref = replace(rules.ref, 'cssid', rules.cssid);
rules.attr = replace(rules.attr, 'cssid', rules.cssid);
rules.pseudo = replace(rules.pseudo, 'cssid', rules.cssid);
rules.inside = replace(rules.inside, '[^"\'>]*', rules.inside);
rules.attr = replace(rules.attr, 'inside', makeInside('\\[', '\\]'));
rules.pseudo = replace(rules.pseudo, 'inside', makeInside('\\(', '\\)'));
rules.simple = replace(rules.simple, 'pseudo', rules.pseudo);
rules.simple = replace(rules.simple, 'attr', rules.attr);
rules.ident = replace(rules.ident, 'cssid', rules.cssid);
rules.str_escape = replace(rules.str_escape, 'escape', rules.escape);

/**
 * Compiling
 */

var compile = function(sel_) {
  var sel = sel_.replace(/^\s+|\s+$/g, '')
    , test
    , filter = []
    , buff = []
    , subject
    , qname
    , cap
    , op
    , ref;

  /*jshint -W084 */
  while (sel) {
    if (cap = rules.qname.exec(sel)) {
      sel = sel.substring(cap[0].length);
      qname = cap[1];
      buff.push(tok(qname, true));
    } else if (cap = rules.simple.exec(sel)) {
      sel = sel.substring(cap[0].length);
      qname = '*';
      buff.push(tok(qname, true));
      buff.push(tok(cap));
    } else {
      throw new SyntaxError('Invalid selector.');
    }

    while (cap = rules.simple.exec(sel)) {
      sel = sel.substring(cap[0].length);
      buff.push(tok(cap));
    }

    if (sel[0] === '!') {
      sel = sel.substring(1);
      subject = makeSubject();
      subject.qname = qname;
      buff.push(subject.simple);
    }

    if (cap = rules.ref.exec(sel)) {
      sel = sel.substring(cap[0].length);
      ref = combinators.ref(makeSimple(buff), decodeid(cap[1]));
      filter.push(ref.combinator);
      buff = [];
      continue;
    }

    if (cap = rules.combinator.exec(sel)) {
      sel = sel.substring(cap[0].length);
      op = cap[1] || cap[2] || cap[3];
      if (op === ',') {
        filter.push(combinators.noop(makeSimple(buff)));
        break;
      }
    } else {
      op = 'noop';
    }

    if (!combinators[op]) { throw new SyntaxError('Bad combinator.'); }
    filter.push(combinators[op](makeSimple(buff)));
    buff = [];
  }

  test = makeTest(filter);
  test.qname = qname;
  test.sel = sel;

  if (subject) {
    subject.lname = test.qname;

    subject.test = test;
    subject.qname = subject.qname;
    subject.sel = test.sel;
    test = subject;
  }

  if (ref) {
    ref.test = test;
    ref.qname = test.qname;
    ref.sel = test.sel;
    test = ref;
  }

  return test;
};

var tok = function(cap, qname) {
  // qname
  if (qname) {
    return cap === '*'
      ? selectors['*']
      : selectors.type(decodeid(cap));
  }

  // class/id
  if (cap[1]) {
    return cap[1][0] === '.'
	  // XXX unescape here?  or in attr?
      ? selectors.attr('class', '~=', decodeid(cap[1].substring(1)))
      : selectors.attr('id', '=', decodeid(cap[1].substring(1)));
  }

  // pseudo-name
  // inside-pseudo
  if (cap[2]) {
    return cap[3]
      ? selectors[decodeid(cap[2])](unquote(cap[3]))
      : selectors[decodeid(cap[2])];
  }

  // attr name
  // attr op
  // attr value
  if (cap[4]) {
    return selectors.attr(decodeid(cap[4]), cap[5] || '-', unquote(cap[6]), false);
  }

  throw new SyntaxError('Unknown Selector.');
};

var makeSimple = function(func) {
  var l = func.length
    , i;

  // Potentially make sure
  // `el` is truthy.
  if (l < 2) return func[0];

  return function(el) {
    if (!el) return;
    for (i = 0; i < l; i++) {
      if (!func[i](el)) return;
    }
    return true;
  };
};

var makeTest = function(func) {
  if (func.length < 2) {
    return function(el) {
      return !!func[0](el);
    };
  }
  return function(el) {
    var i = func.length;
    while (i--) {
      if (!(el = func[i](el))) return;
    }
    return true;
  };
};

var makeSubject = function() {
  var target;

  function subject(el) {
    var node = el.ownerDocument
      , scope = node.getElementsByTagName(subject.lname)
      , i = scope.length;

    while (i--) {
      if (subject.test(scope[i]) && target === el) {
        target = null;
        return true;
      }
    }

    target = null;
  }

  subject.simple = function(el) {
    target = el;
    return true;
  };

  return subject;
};

var compileGroup = function(sel) {
  var test = compile(sel)
    , tests = [ test ];

  while (test.sel) {
    test = compile(test.sel);
    tests.push(test);
  }

  if (tests.length < 2) return test;

  return function(el) {
    var l = tests.length
      , i = 0;

    for (; i < l; i++) {
      if (tests[i](el)) return true;
    }
  };
};

/**
 * Selection
 */

var find = function(sel, node) {
  var results = []
    , test = compile(sel)
    , scope = node.getElementsByTagName(test.qname)
    , i = 0
    , el;

  /*jshint -W084 */
  while (el = scope[i++]) {
    if (test(el)) results.push(el);
  }

  if (test.sel) {
    while (test.sel) {
      test = compile(test.sel);
      scope = node.getElementsByTagName(test.qname);
      i = 0;
      /*jshint -W084 */
      while (el = scope[i++]) {
        if (test(el) && indexOf.call(results, el) === -1) {
          results.push(el);
        }
      }
    }
    results.sort(order);
  }

  return results;
};

/**
 * Expose
 */

module.exports = exports = function(sel, context) {
  /* when context isn't a DocumentFragment and the selector is simple: */
  var id, r;
  if (context.nodeType !== 11 && sel.indexOf(' ') === -1) {
    if (sel[0] === '#' && context.rooted && /^#[A-Z_][-A-Z0-9_]*$/i.test(sel)) {
      if (context.doc._hasMultipleElementsWithId) {
        id = sel.substring(1);
        if (!context.doc._hasMultipleElementsWithId(id)) {
          r = context.doc.getElementById(id);
          return r ? [r] : [];
        }
      }
    }
    if (sel[0] === '.' && /^\.\w+$/.test(sel)) {
      return context.getElementsByClassName(sel.substring(1));
    }
    if (/^\w+$/.test(sel)) {
      return context.getElementsByTagName(sel);
    }
  }
  /* do things the hard/slow way */
  return find(sel, context);
};

exports.selectors = selectors;
exports.operators = operators;
exports.combinators = combinators;

exports.matches = function(el, sel) {
  var test = { sel: sel };
  do {
    test = compile(test.sel);
    if (test(el)) { return true; }
  } while (test.sel);
  return false;
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// This grammar is from the XML and XML Namespace specs. It specifies whether
// a string (such as an element or attribute name) is a valid Name or QName.
//
// Name           ::= NameStartChar (NameChar)*
// NameStartChar  ::= ":" | [A-Z] | "_" | [a-z] |
//                    [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |
//                    [#x370-#x37D] | [#x37F-#x1FFF] |
//                    [#x200C-#x200D] | [#x2070-#x218F] |
//                    [#x2C00-#x2FEF] | [#x3001-#xD7FF] |
//                    [#xF900-#xFDCF] | [#xFDF0-#xFFFD] |
//                    [#x10000-#xEFFFF]
//
// NameChar       ::= NameStartChar | "-" | "." | [0-9] |
//                    #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//
// QName          ::= PrefixedName| UnprefixedName
// PrefixedName   ::= Prefix ':' LocalPart
// UnprefixedName ::= LocalPart
// Prefix         ::= NCName
// LocalPart      ::= NCName
// NCName         ::= Name - (Char* ':' Char*)
//                    # An XML Name, minus the ":"
//

exports.isValidName = isValidName;
exports.isValidQName = isValidQName;

// Most names will be ASCII only. Try matching against simple regexps first
var simplename = /^[_:A-Za-z][-.:\w]+$/;
var simpleqname = /^([_A-Za-z][-.\w]+|[_A-Za-z][-.\w]+:[_A-Za-z][-.\w]+)$/;

// If the regular expressions above fail, try more complex ones that work
// for any identifiers using codepoints from the Unicode BMP
var ncnamestartchars = "_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02ff\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
var ncnamechars = "-._A-Za-z0-9\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02ff\u0300-\u037D\u037F-\u1FFF\u200C\u200D\u203f\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";

var ncname = "[" + ncnamestartchars + "][" + ncnamechars + "]*";
var namestartchars = ncnamestartchars + ":";
var namechars = ncnamechars + ":";
var name = new RegExp("^[" + namestartchars + "]" + "[" + namechars + "]*$");
var qname = new RegExp("^(" + ncname + "|" + ncname + ":" + ncname + ")$");

// XML says that these characters are also legal:
// [#x10000-#xEFFFF].  So if the patterns above fail, and the
// target string includes surrogates, then try the following
// patterns that allow surrogates and then run an extra validation
// step to make sure that the surrogates are in valid pairs and in
// the right range.  Note that since the characters \uf0000 to \u1f0000
// are not allowed, it means that the high surrogate can only go up to
// \uDB7f instead of \uDBFF.
var hassurrogates = /[\uD800-\uDB7F\uDC00-\uDFFF]/;
var surrogatechars = /[\uD800-\uDB7F\uDC00-\uDFFF]/g;
var surrogatepairs = /[\uD800-\uDB7F][\uDC00-\uDFFF]/g;

// Modify the variables above to allow surrogates
ncnamestartchars += "\uD800-\uDB7F\uDC00-\uDFFF";
ncnamechars += "\uD800-\uDB7F\uDC00-\uDFFF";
ncname = "[" + ncnamestartchars + "][" + ncnamechars + "]*";
namestartchars = ncnamestartchars + ":";
namechars = ncnamechars + ":";

// Build another set of regexps that include surrogates
var surrogatename = new RegExp("^[" + namestartchars + "]" + "[" + namechars + "]*$");
var surrogateqname = new RegExp("^(" + ncname + "|" + ncname + ":" + ncname + ")$");

function isValidName(s) {
  if (simplename.test(s)) return true; // Plain ASCII
  if (name.test(s)) return true; // Unicode BMP

  // Maybe the tests above failed because s includes surrogate pairs
  // Most likely, though, they failed for some more basic syntax problem
  if (!hassurrogates.test(s)) return false;

  // Is the string a valid name if we allow surrogates?
  if (!surrogatename.test(s)) return false;

  // Finally, are the surrogates all correctly paired up?
  var chars = s.match(surrogatechars), pairs = s.match(surrogatepairs);
  return pairs !== null && 2*pairs.length === chars.length;
}

function isValidQName(s) {
  if (simpleqname.test(s)) return true; // Plain ASCII
  if (qname.test(s)) return true; // Unicode BMP

  if (!hassurrogates.test(s)) return false;
  if (!surrogateqname.test(s)) return false;
  var chars = s.match(surrogatechars), pairs = s.match(surrogatepairs);
  return pairs !== null && 2*pairs.length === chars.length;
}


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(0);

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(43);

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(48);

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(73);

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Angular v5.2.2
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
	 true ? factory(exports, __webpack_require__(3), __webpack_require__(48), __webpack_require__(26), __webpack_require__(10), __webpack_require__(95), __webpack_require__(24), __webpack_require__(93), __webpack_require__(56), __webpack_require__(21), __webpack_require__(89), __webpack_require__(50), __webpack_require__(90), __webpack_require__(91), __webpack_require__(49), __webpack_require__(83)) :
	typeof define === 'function' && define.amd ? define('@angular/platform-server', ['exports', '@angular/core', '@angular/platform-browser', '@angular/animations/browser', '@angular/common', '@angular/common/http', '@angular/http', '@angular/platform-browser-dynamic', '@angular/platform-browser/animations', 'rxjs/Observable', 'rxjs/Subject', 'url', '@angular/compiler', 'rxjs/operator/filter', 'rxjs/operator/first', 'rxjs/operator/toPromise'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.platformServer = {}),global.ng.core,global.ng.platformBrowser,global.ng.animations.browser,global.ng.common,global.ng.common.http,global.ng.http,global.ng.platformBrowserDynamic,global.ng.platformBrowser.animations,global.Rx,global.Rx,global.url,global.ng.compiler,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype));
}(this, (function (exports,_angular_core,_angular_platformBrowser,_angular_animations_browser,_angular_common,_angular_common_http,_angular_http,_angular_platformBrowserDynamic,_angular_platformBrowser_animations,rxjs_Observable,rxjs_Subject,url,_angular_compiler,rxjs_operator_filter,rxjs_operator_first,rxjs_operator_toPromise) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/**
 * @license Angular v5.2.2
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var domino = __webpack_require__(76);
/**
 * @param {?} methodName
 * @return {?}
 */
function _notImplemented(methodName) {
    return new Error('This method is not implemented in DominoAdapter: ' + methodName);
}
/**
 * Parses a document string to a Document object.
 * @param {?} html
 * @param {?=} url
 * @return {?}
 */
function parseDocument(html, url$$1) {
    if (url$$1 === void 0) { url$$1 = '/'; }
    var /** @type {?} */ window = domino.createWindow(html, url$$1);
    var /** @type {?} */ doc = window.document;
    return doc;
}
/**
 * Serializes a document to string.
 * @param {?} doc
 * @return {?}
 */
function serializeDocument(doc) {
    return (/** @type {?} */ (doc)).serialize();
}
/**
 * DOM Adapter for the server platform based on https://github.com/fgnass/domino.
 */
var DominoAdapter = /** @class */ (function (_super) {
    __extends(DominoAdapter, _super);
    function DominoAdapter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @return {?}
     */
    DominoAdapter.makeCurrent = /**
     * @return {?}
     */
    function () { _angular_platformBrowser.ɵsetRootDomAdapter(new DominoAdapter()); };
    /**
     * @param {?} error
     * @return {?}
     */
    DominoAdapter.prototype.logError = /**
     * @param {?} error
     * @return {?}
     */
    function (error) { console.error(error); };
    /**
     * @param {?} error
     * @return {?}
     */
    DominoAdapter.prototype.log = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        // tslint:disable-next-line:no-console
        console.log(error);
    };
    /**
     * @param {?} error
     * @return {?}
     */
    DominoAdapter.prototype.logGroup = /**
     * @param {?} error
     * @return {?}
     */
    function (error) { console.error(error); };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.logGroupEnd = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.supportsDOMEvents = /**
     * @return {?}
     */
    function () { return false; };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.supportsNativeShadowDOM = /**
     * @return {?}
     */
    function () { return false; };
    /**
     * @param {?} nodeA
     * @param {?} nodeB
     * @return {?}
     */
    DominoAdapter.prototype.contains = /**
     * @param {?} nodeA
     * @param {?} nodeB
     * @return {?}
     */
    function (nodeA, nodeB) {
        var /** @type {?} */ inner = nodeB;
        while (inner) {
            if (inner === nodeA)
                return true;
            inner = inner.parent;
        }
        return false;
    };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.createHtmlDocument = /**
     * @return {?}
     */
    function () {
        return parseDocument('<html><head><title>fakeTitle</title></head><body></body></html>');
    };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getDefaultDocument = /**
     * @return {?}
     */
    function () {
        if (!DominoAdapter.defaultDoc) {
            DominoAdapter.defaultDoc = domino.createDocument();
        }
        return DominoAdapter.defaultDoc;
    };
    /**
     * @param {?} el
     * @param {?=} doc
     * @return {?}
     */
    DominoAdapter.prototype.createShadowRoot = /**
     * @param {?} el
     * @param {?=} doc
     * @return {?}
     */
    function (el, doc) {
        if (doc === void 0) { doc = document; }
        el.shadowRoot = doc.createDocumentFragment();
        el.shadowRoot.parent = el;
        return el.shadowRoot;
    };
    /**
     * @param {?} el
     * @return {?}
     */
    DominoAdapter.prototype.getShadowRoot = /**
     * @param {?} el
     * @return {?}
     */
    function (el) { return el.shadowRoot; };
    /**
     * @param {?} node
     * @return {?}
     */
    DominoAdapter.prototype.isTextNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return node.nodeType === DominoAdapter.defaultDoc.TEXT_NODE; };
    /**
     * @param {?} node
     * @return {?}
     */
    DominoAdapter.prototype.isCommentNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.nodeType === DominoAdapter.defaultDoc.COMMENT_NODE;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    DominoAdapter.prototype.isElementNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node ? node.nodeType === DominoAdapter.defaultDoc.ELEMENT_NODE : false;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    DominoAdapter.prototype.hasShadowRoot = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return node.shadowRoot != null; };
    /**
     * @param {?} node
     * @return {?}
     */
    DominoAdapter.prototype.isShadowRoot = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return this.getShadowRoot(node) == node; };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    DominoAdapter.prototype.getProperty = /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    function (el, name) {
        if (name === 'href') {
            // Domino tries tp resolve href-s which we do not want. Just return the
            // atribute value.
            return this.getAttribute(el, 'href');
        }
        else if (name === 'innerText') {
            // Domino does not support innerText. Just map it to textContent.
            return el.textContent;
        }
        return (/** @type {?} */ (el))[name];
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    DominoAdapter.prototype.setProperty = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (el, name, value) {
        if (name === 'href') {
            // Eventhough the server renderer reflects any properties to attributes
            // map 'href' to atribute just to handle when setProperty is directly called.
            this.setAttribute(el, 'href', value);
        }
        else if (name === 'innerText') {
            // Domino does not support innerText. Just map it to textContent.
            el.textContent = value;
        }
        (/** @type {?} */ (el))[name] = value;
    };
    /**
     * @param {?} doc
     * @param {?} target
     * @return {?}
     */
    DominoAdapter.prototype.getGlobalEventTarget = /**
     * @param {?} doc
     * @param {?} target
     * @return {?}
     */
    function (doc, target) {
        if (target === 'window') {
            return doc.defaultView;
        }
        if (target === 'document') {
            return doc;
        }
        if (target === 'body') {
            return doc.body;
        }
        return null;
    };
    /**
     * @param {?} doc
     * @return {?}
     */
    DominoAdapter.prototype.getBaseHref = /**
     * @param {?} doc
     * @return {?}
     */
    function (doc) {
        var /** @type {?} */ base = this.querySelector(doc.documentElement, 'base');
        var /** @type {?} */ href = '';
        if (base) {
            href = this.getHref(base);
        }
        // TODO(alxhub): Need relative path logic from BrowserDomAdapter here?
        return href;
    };
    /** @internal */
    /**
     * \@internal
     * @param {?} element
     * @return {?}
     */
    DominoAdapter.prototype._readStyleAttribute = /**
     * \@internal
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ styleMap = {};
        var /** @type {?} */ styleAttribute = element.getAttribute('style');
        if (styleAttribute) {
            var /** @type {?} */ styleList = styleAttribute.split(/;+/g);
            for (var /** @type {?} */ i = 0; i < styleList.length; i++) {
                if (styleList[i].length > 0) {
                    var /** @type {?} */ style = /** @type {?} */ (styleList[i]);
                    var /** @type {?} */ colon = style.indexOf(':');
                    if (colon === -1) {
                        throw new Error("Invalid CSS style: " + style);
                    }
                    (/** @type {?} */ (styleMap))[style.substr(0, colon).trim()] = style.substr(colon + 1).trim();
                }
            }
        }
        return styleMap;
    };
    /** @internal */
    /**
     * \@internal
     * @param {?} element
     * @param {?} styleMap
     * @return {?}
     */
    DominoAdapter.prototype._writeStyleAttribute = /**
     * \@internal
     * @param {?} element
     * @param {?} styleMap
     * @return {?}
     */
    function (element, styleMap) {
        var /** @type {?} */ styleAttrValue = '';
        for (var /** @type {?} */ key in styleMap) {
            var /** @type {?} */ newValue = styleMap[key];
            if (newValue) {
                styleAttrValue += key + ':' + styleMap[key] + ';';
            }
        }
        element.setAttribute('style', styleAttrValue);
    };
    /**
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */
    DominoAdapter.prototype.setStyle = /**
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */
    function (element, styleName, styleValue) {
        var /** @type {?} */ styleMap = this._readStyleAttribute(element);
        (/** @type {?} */ (styleMap))[styleName] = styleValue;
        this._writeStyleAttribute(element, styleMap);
    };
    /**
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */
    DominoAdapter.prototype.removeStyle = /**
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */
    function (element, styleName) { this.setStyle(element, styleName, null); };
    /**
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */
    DominoAdapter.prototype.getStyle = /**
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */
    function (element, styleName) {
        var /** @type {?} */ styleMap = this._readStyleAttribute(element);
        return styleMap.hasOwnProperty(styleName) ? (/** @type {?} */ (styleMap))[styleName] : '';
    };
    /**
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */
    DominoAdapter.prototype.hasStyle = /**
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */
    function (element, styleName, styleValue) {
        var /** @type {?} */ value = this.getStyle(element, styleName) || '';
        return styleValue ? value == styleValue : value.length > 0;
    };
    /**
     * @param {?} el
     * @param {?} evt
     * @return {?}
     */
    DominoAdapter.prototype.dispatchEvent = /**
     * @param {?} el
     * @param {?} evt
     * @return {?}
     */
    function (el, evt) {
        el.dispatchEvent(evt);
        // Dispatch the event to the window also.
        var /** @type {?} */ doc = el.ownerDocument || el;
        var /** @type {?} */ win = (/** @type {?} */ (doc)).defaultView;
        if (win) {
            win.dispatchEvent(evt);
        }
    };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getHistory = /**
     * @return {?}
     */
    function () { throw _notImplemented('getHistory'); };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getLocation = /**
     * @return {?}
     */
    function () { throw _notImplemented('getLocation'); };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getUserAgent = /**
     * @return {?}
     */
    function () { return 'Fake user agent'; };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.supportsWebAnimation = /**
     * @return {?}
     */
    function () { return false; };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.performanceNow = /**
     * @return {?}
     */
    function () { return Date.now(); };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getAnimationPrefix = /**
     * @return {?}
     */
    function () { return ''; };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getTransitionEnd = /**
     * @return {?}
     */
    function () { return 'transitionend'; };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.supportsAnimation = /**
     * @return {?}
     */
    function () { return true; };
    /**
     * @param {?} el
     * @return {?}
     */
    DominoAdapter.prototype.getDistributedNodes = /**
     * @param {?} el
     * @return {?}
     */
    function (el) { throw _notImplemented('getDistributedNodes'); };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.supportsCookies = /**
     * @return {?}
     */
    function () { return false; };
    /**
     * @param {?} name
     * @return {?}
     */
    DominoAdapter.prototype.getCookie = /**
     * @param {?} name
     * @return {?}
     */
    function (name) { throw _notImplemented('getCookie'); };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    DominoAdapter.prototype.setCookie = /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (name, value) { throw _notImplemented('setCookie'); };
    return DominoAdapter;
}(_angular_platformBrowser.ɵBrowserDomAdapter));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Representation of the current platform state.
 *
 * \@experimental
 */
var PlatformState = /** @class */ (function () {
    function PlatformState(_doc) {
        this._doc = _doc;
    }
    /**
     * Renders the current state of the platform to string.
     */
    /**
     * Renders the current state of the platform to string.
     * @return {?}
     */
    PlatformState.prototype.renderToString = /**
     * Renders the current state of the platform to string.
     * @return {?}
     */
    function () { return serializeDocument(this._doc); };
    /**
     * Returns the current DOM state.
     */
    /**
     * Returns the current DOM state.
     * @return {?}
     */
    PlatformState.prototype.getDocument = /**
     * Returns the current DOM state.
     * @return {?}
     */
    function () { return this._doc; };
    PlatformState.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    PlatformState.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
    ]; };
    return PlatformState;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var xhr2 = __webpack_require__(87);
var isAbsoluteUrl = /^[a-zA-Z\-\+.]+:\/\//;
/**
 * @param {?} url
 * @return {?}
 */
function validateRequestUrl(url$$1) {
    if (!isAbsoluteUrl.test(url$$1)) {
        throw new Error("URLs requested via Http on the server must be absolute. URL: " + url$$1);
    }
}
var ServerXhr = /** @class */ (function () {
    function ServerXhr() {
    }
    /**
     * @return {?}
     */
    ServerXhr.prototype.build = /**
     * @return {?}
     */
    function () { return new xhr2.XMLHttpRequest(); };
    ServerXhr.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ServerXhr.ctorParameters = function () { return []; };
    return ServerXhr;
}());
var ServerXsrfStrategy = /** @class */ (function () {
    function ServerXsrfStrategy() {
    }
    /**
     * @param {?} req
     * @return {?}
     */
    ServerXsrfStrategy.prototype.configureRequest = /**
     * @param {?} req
     * @return {?}
     */
    function (req) { };
    ServerXsrfStrategy.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ServerXsrfStrategy.ctorParameters = function () { return []; };
    return ServerXsrfStrategy;
}());
/**
 * @abstract
 */
var ZoneMacroTaskWrapper = /** @class */ (function () {
    function ZoneMacroTaskWrapper() {
    }
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneMacroTaskWrapper.prototype.wrap = /**
     * @param {?} request
     * @return {?}
     */
    function (request) {
        var _this = this;
        return new rxjs_Observable.Observable(function (observer) {
            var /** @type {?} */ task = /** @type {?} */ ((null));
            var /** @type {?} */ scheduled = false;
            var /** @type {?} */ sub = null;
            var /** @type {?} */ savedResult = null;
            var /** @type {?} */ savedError = null;
            var /** @type {?} */ scheduleTask = function (_task) {
                task = _task;
                scheduled = true;
                var /** @type {?} */ delegate = _this.delegate(request);
                sub = delegate.subscribe(function (res) { return savedResult = res; }, function (err) {
                    if (!scheduled) {
                        throw new Error('An http observable was completed twice. This shouldn\'t happen, please file a bug.');
                    }
                    savedError = err;
                    scheduled = false;
                    task.invoke();
                }, function () {
                    if (!scheduled) {
                        throw new Error('An http observable was completed twice. This shouldn\'t happen, please file a bug.');
                    }
                    scheduled = false;
                    task.invoke();
                });
            };
            var /** @type {?} */ cancelTask = function (_task) {
                if (!scheduled) {
                    return;
                }
                scheduled = false;
                if (sub) {
                    sub.unsubscribe();
                    sub = null;
                }
            };
            var /** @type {?} */ onComplete = function () {
                if (savedError !== null) {
                    observer.error(savedError);
                }
                else {
                    observer.next(savedResult);
                    observer.complete();
                }
            };
            // MockBackend for Http is synchronous, which means that if scheduleTask is by
            // scheduleMacroTask, the request will hit MockBackend and the response will be
            // sent, causing task.invoke() to be called.
            var /** @type {?} */ _task = Zone.current.scheduleMacroTask('ZoneMacroTaskWrapper.subscribe', onComplete, {}, function () { return null; }, cancelTask);
            scheduleTask(_task);
            return function () {
                if (scheduled && task) {
                    task.zone.cancelTask(task);
                    scheduled = false;
                }
                if (sub) {
                    sub.unsubscribe();
                    sub = null;
                }
            };
        });
    };
    return ZoneMacroTaskWrapper;
}());
var ZoneMacroTaskConnection = /** @class */ (function (_super) {
    __extends(ZoneMacroTaskConnection, _super);
    function ZoneMacroTaskConnection(request, backend) {
        var _this = _super.call(this) || this;
        _this.request = request;
        _this.backend = backend;
        validateRequestUrl(request.url);
        _this.response = _this.wrap(request);
        return _this;
    }
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneMacroTaskConnection.prototype.delegate = /**
     * @param {?} request
     * @return {?}
     */
    function (request) {
        this.lastConnection = this.backend.createConnection(request);
        return /** @type {?} */ (this.lastConnection.response);
    };
    Object.defineProperty(ZoneMacroTaskConnection.prototype, "readyState", {
        get: /**
         * @return {?}
         */
        function () {
            return !!this.lastConnection ? this.lastConnection.readyState : _angular_http.ReadyState.Unsent;
        },
        enumerable: true,
        configurable: true
    });
    return ZoneMacroTaskConnection;
}(ZoneMacroTaskWrapper));
var ZoneMacroTaskBackend = /** @class */ (function () {
    function ZoneMacroTaskBackend(backend) {
        this.backend = backend;
    }
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneMacroTaskBackend.prototype.createConnection = /**
     * @param {?} request
     * @return {?}
     */
    function (request) {
        return new ZoneMacroTaskConnection(request, this.backend);
    };
    return ZoneMacroTaskBackend;
}());
var ZoneClientBackend = /** @class */ (function (_super) {
    __extends(ZoneClientBackend, _super);
    function ZoneClientBackend(backend) {
        var _this = _super.call(this) || this;
        _this.backend = backend;
        return _this;
    }
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneClientBackend.prototype.handle = /**
     * @param {?} request
     * @return {?}
     */
    function (request) { return this.wrap(request); };
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneClientBackend.prototype.delegate = /**
     * @param {?} request
     * @return {?}
     */
    function (request) {
        return this.backend.handle(request);
    };
    return ZoneClientBackend;
}(ZoneMacroTaskWrapper));
/**
 * @param {?} xhrBackend
 * @param {?} options
 * @return {?}
 */
function httpFactory(xhrBackend, options) {
    var /** @type {?} */ macroBackend = new ZoneMacroTaskBackend(xhrBackend);
    return new _angular_http.Http(macroBackend, options);
}
/**
 * @param {?} backend
 * @param {?} interceptors
 * @return {?}
 */
function zoneWrappedInterceptingHandler(backend, interceptors) {
    var /** @type {?} */ realBackend = _angular_common_http.ɵinterceptingHandler(backend, interceptors);
    return new ZoneClientBackend(realBackend);
}
var SERVER_HTTP_PROVIDERS = [
    { provide: _angular_http.Http, useFactory: httpFactory, deps: [_angular_http.XHRBackend, _angular_http.RequestOptions] },
    { provide: _angular_http.BrowserXhr, useClass: ServerXhr }, { provide: _angular_http.XSRFStrategy, useClass: ServerXsrfStrategy },
    { provide: _angular_common_http.XhrFactory, useClass: ServerXhr }, {
        provide: _angular_common_http.HttpHandler,
        useFactory: zoneWrappedInterceptingHandler,
        deps: [_angular_common_http.HttpBackend, [new _angular_core.Optional(), _angular_common_http.HTTP_INTERCEPTORS]]
    }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Config object passed to initialize the platform.
 *
 * \@experimental
 * @record
 */

/**
 * The DI token for setting the initial config for the platform.
 *
 * \@experimental
 */
var INITIAL_CONFIG = new _angular_core.InjectionToken('Server.INITIAL_CONFIG');
/**
 * A function that will be executed when calling `renderModuleFactory` or `renderModule` just
 * before current platform state is rendered to string.
 *
 * \@experimental
 */
var BEFORE_APP_SERIALIZED = new _angular_core.InjectionToken('Server.RENDER_MODULE_HOOK');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} urlStr
 * @return {?}
 */
function parseUrl(urlStr) {
    var /** @type {?} */ parsedUrl = url.parse(urlStr);
    return {
        pathname: parsedUrl.pathname || '',
        search: parsedUrl.search || '',
        hash: parsedUrl.hash || '',
    };
}
/**
 * Server-side implementation of URL state. Implements `pathname`, `search`, and `hash`
 * but not the state stack.
 */
var ServerPlatformLocation = /** @class */ (function () {
    function ServerPlatformLocation(_doc, _config) {
        this._doc = _doc;
        this.pathname = '/';
        this.search = '';
        this.hash = '';
        this._hashUpdate = new rxjs_Subject.Subject();
        var /** @type {?} */ config = /** @type {?} */ (_config);
        if (!!config && !!config.url) {
            var /** @type {?} */ parsedUrl = parseUrl(config.url);
            this.pathname = parsedUrl.pathname;
            this.search = parsedUrl.search;
            this.hash = parsedUrl.hash;
        }
    }
    /**
     * @return {?}
     */
    ServerPlatformLocation.prototype.getBaseHrefFromDOM = /**
     * @return {?}
     */
    function () { return /** @type {?} */ ((_angular_platformBrowser.ɵgetDOM().getBaseHref(this._doc))); };
    /**
     * @param {?} fn
     * @return {?}
     */
    ServerPlatformLocation.prototype.onPopState = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        // No-op: a state stack is not implemented, so
        // no events will ever come.
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ServerPlatformLocation.prototype.onHashChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._hashUpdate.subscribe(fn); };
    Object.defineProperty(ServerPlatformLocation.prototype, "url", {
        get: /**
         * @return {?}
         */
        function () { return "" + this.pathname + this.search + this.hash; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @param {?} oldUrl
     * @return {?}
     */
    ServerPlatformLocation.prototype.setHash = /**
     * @param {?} value
     * @param {?} oldUrl
     * @return {?}
     */
    function (value, oldUrl) {
        var _this = this;
        if (this.hash === value) {
            // Don't fire events if the hash has not changed.
            return;
        }
        (/** @type {?} */ (this)).hash = value;
        var /** @type {?} */ newUrl = this.url;
        scheduleMicroTask(function () { return _this._hashUpdate.next(/** @type {?} */ ({ type: 'hashchange', oldUrl: oldUrl, newUrl: newUrl })); });
    };
    /**
     * @param {?} state
     * @param {?} title
     * @param {?} newUrl
     * @return {?}
     */
    ServerPlatformLocation.prototype.replaceState = /**
     * @param {?} state
     * @param {?} title
     * @param {?} newUrl
     * @return {?}
     */
    function (state, title, newUrl) {
        var /** @type {?} */ oldUrl = this.url;
        var /** @type {?} */ parsedUrl = parseUrl(newUrl);
        (/** @type {?} */ (this)).pathname = parsedUrl.pathname;
        (/** @type {?} */ (this)).search = parsedUrl.search;
        this.setHash(parsedUrl.hash, oldUrl);
    };
    /**
     * @param {?} state
     * @param {?} title
     * @param {?} newUrl
     * @return {?}
     */
    ServerPlatformLocation.prototype.pushState = /**
     * @param {?} state
     * @param {?} title
     * @param {?} newUrl
     * @return {?}
     */
    function (state, title, newUrl) {
        this.replaceState(state, title, newUrl);
    };
    /**
     * @return {?}
     */
    ServerPlatformLocation.prototype.forward = /**
     * @return {?}
     */
    function () { throw new Error('Not implemented'); };
    /**
     * @return {?}
     */
    ServerPlatformLocation.prototype.back = /**
     * @return {?}
     */
    function () { throw new Error('Not implemented'); };
    ServerPlatformLocation.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ServerPlatformLocation.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
        { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [INITIAL_CONFIG,] },] },
    ]; };
    return ServerPlatformLocation;
}());
/**
 * @param {?} fn
 * @return {?}
 */
function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var EMPTY_ARRAY = [];
var ServerRendererFactory2 = /** @class */ (function () {
    function ServerRendererFactory2(ngZone, document, sharedStylesHost) {
        this.ngZone = ngZone;
        this.document = document;
        this.sharedStylesHost = sharedStylesHost;
        this.rendererByCompId = new Map();
        this.schema = new _angular_compiler.DomElementSchemaRegistry();
        this.defaultRenderer = new DefaultServerRenderer2(document, ngZone, this.schema);
    }
    /**
     * @param {?} element
     * @param {?} type
     * @return {?}
     */
    ServerRendererFactory2.prototype.createRenderer = /**
     * @param {?} element
     * @param {?} type
     * @return {?}
     */
    function (element, type) {
        if (!element || !type) {
            return this.defaultRenderer;
        }
        switch (type.encapsulation) {
            case _angular_core.ViewEncapsulation.Native:
            case _angular_core.ViewEncapsulation.Emulated: {
                var /** @type {?} */ renderer = this.rendererByCompId.get(type.id);
                if (!renderer) {
                    renderer = new EmulatedEncapsulationServerRenderer2(this.document, this.ngZone, this.sharedStylesHost, this.schema, type);
                    this.rendererByCompId.set(type.id, renderer);
                }
                (/** @type {?} */ (renderer)).applyToHost(element);
                return renderer;
            }
            case _angular_core.ViewEncapsulation.Native:
                throw new Error('Native encapsulation is not supported on the server!');
            default: {
                if (!this.rendererByCompId.has(type.id)) {
                    var /** @type {?} */ styles = _angular_platformBrowser.ɵflattenStyles(type.id, type.styles, []);
                    this.sharedStylesHost.addStyles(styles);
                    this.rendererByCompId.set(type.id, this.defaultRenderer);
                }
                return this.defaultRenderer;
            }
        }
    };
    /**
     * @return {?}
     */
    ServerRendererFactory2.prototype.begin = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    ServerRendererFactory2.prototype.end = /**
     * @return {?}
     */
    function () { };
    ServerRendererFactory2.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ServerRendererFactory2.ctorParameters = function () { return [
        { type: _angular_core.NgZone, },
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
        { type: _angular_platformBrowser.ɵSharedStylesHost, },
    ]; };
    return ServerRendererFactory2;
}());
var DefaultServerRenderer2 = /** @class */ (function () {
    function DefaultServerRenderer2(document, ngZone, schema) {
        this.document = document;
        this.ngZone = ngZone;
        this.schema = schema;
        this.data = Object.create(null);
    }
    /**
     * @return {?}
     */
    DefaultServerRenderer2.prototype.destroy = /**
     * @return {?}
     */
    function () { };
    /**
     * @param {?} name
     * @param {?=} namespace
     * @param {?=} debugInfo
     * @return {?}
     */
    DefaultServerRenderer2.prototype.createElement = /**
     * @param {?} name
     * @param {?=} namespace
     * @param {?=} debugInfo
     * @return {?}
     */
    function (name, namespace, debugInfo) {
        if (namespace) {
            return _angular_platformBrowser.ɵgetDOM().createElementNS(_angular_platformBrowser.ɵNAMESPACE_URIS[namespace], name);
        }
        return _angular_platformBrowser.ɵgetDOM().createElement(name);
    };
    /**
     * @param {?} value
     * @param {?=} debugInfo
     * @return {?}
     */
    DefaultServerRenderer2.prototype.createComment = /**
     * @param {?} value
     * @param {?=} debugInfo
     * @return {?}
     */
    function (value, debugInfo) { return _angular_platformBrowser.ɵgetDOM().createComment(value); };
    /**
     * @param {?} value
     * @param {?=} debugInfo
     * @return {?}
     */
    DefaultServerRenderer2.prototype.createText = /**
     * @param {?} value
     * @param {?=} debugInfo
     * @return {?}
     */
    function (value, debugInfo) { return _angular_platformBrowser.ɵgetDOM().createTextNode(value); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    DefaultServerRenderer2.prototype.appendChild = /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    function (parent, newChild) { _angular_platformBrowser.ɵgetDOM().appendChild(parent, newChild); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    DefaultServerRenderer2.prototype.insertBefore = /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    function (parent, newChild, refChild) {
        if (parent) {
            _angular_platformBrowser.ɵgetDOM().insertBefore(parent, refChild, newChild);
        }
    };
    /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    DefaultServerRenderer2.prototype.removeChild = /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    function (parent, oldChild) {
        if (parent) {
            _angular_platformBrowser.ɵgetDOM().removeChild(parent, oldChild);
        }
    };
    /**
     * @param {?} selectorOrNode
     * @param {?=} debugInfo
     * @return {?}
     */
    DefaultServerRenderer2.prototype.selectRootElement = /**
     * @param {?} selectorOrNode
     * @param {?=} debugInfo
     * @return {?}
     */
    function (selectorOrNode, debugInfo) {
        var /** @type {?} */ el;
        if (typeof selectorOrNode === 'string') {
            el = _angular_platformBrowser.ɵgetDOM().querySelector(this.document, selectorOrNode);
            if (!el) {
                throw new Error("The selector \"" + selectorOrNode + "\" did not match any elements");
            }
        }
        else {
            el = selectorOrNode;
        }
        _angular_platformBrowser.ɵgetDOM().clearNodes(el);
        return el;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    DefaultServerRenderer2.prototype.parentNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return _angular_platformBrowser.ɵgetDOM().parentElement(node); };
    /**
     * @param {?} node
     * @return {?}
     */
    DefaultServerRenderer2.prototype.nextSibling = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return _angular_platformBrowser.ɵgetDOM().nextSibling(node); };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    DefaultServerRenderer2.prototype.setAttribute = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    function (el, name, value, namespace) {
        if (namespace) {
            _angular_platformBrowser.ɵgetDOM().setAttributeNS(el, _angular_platformBrowser.ɵNAMESPACE_URIS[namespace], namespace + ':' + name, value);
        }
        else {
            _angular_platformBrowser.ɵgetDOM().setAttribute(el, name, value);
        }
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    DefaultServerRenderer2.prototype.removeAttribute = /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    function (el, name, namespace) {
        if (namespace) {
            _angular_platformBrowser.ɵgetDOM().removeAttributeNS(el, _angular_platformBrowser.ɵNAMESPACE_URIS[namespace], name);
        }
        else {
            _angular_platformBrowser.ɵgetDOM().removeAttribute(el, name);
        }
    };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    DefaultServerRenderer2.prototype.addClass = /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    function (el, name) { _angular_platformBrowser.ɵgetDOM().addClass(el, name); };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    DefaultServerRenderer2.prototype.removeClass = /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    function (el, name) { _angular_platformBrowser.ɵgetDOM().removeClass(el, name); };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?} flags
     * @return {?}
     */
    DefaultServerRenderer2.prototype.setStyle = /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?} flags
     * @return {?}
     */
    function (el, style, value, flags) {
        _angular_platformBrowser.ɵgetDOM().setStyle(el, style, value);
    };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?} flags
     * @return {?}
     */
    DefaultServerRenderer2.prototype.removeStyle = /**
     * @param {?} el
     * @param {?} style
     * @param {?} flags
     * @return {?}
     */
    function (el, style, flags) {
        _angular_platformBrowser.ɵgetDOM().removeStyle(el, style);
    };
    /**
     * @param {?} tagName
     * @param {?} propertyName
     * @return {?}
     */
    DefaultServerRenderer2.prototype._isSafeToReflectProperty = /**
     * @param {?} tagName
     * @param {?} propertyName
     * @return {?}
     */
    function (tagName, propertyName) {
        return this.schema.securityContext(tagName, propertyName, true) ===
            this.schema.securityContext(tagName, propertyName, false);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    DefaultServerRenderer2.prototype.setProperty = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (el, name, value) {
        checkNoSyntheticProp(name, 'property');
        _angular_platformBrowser.ɵgetDOM().setProperty(el, name, value);
        // Mirror property values for known HTML element properties in the attributes.
        var /** @type {?} */ tagName = (/** @type {?} */ (el.tagName)).toLowerCase();
        if (value != null && (typeof value === 'number' || typeof value == 'string') &&
            this.schema.hasElement(tagName, EMPTY_ARRAY) &&
            this.schema.hasProperty(tagName, name, EMPTY_ARRAY) &&
            this._isSafeToReflectProperty(tagName, name)) {
            this.setAttribute(el, name, value.toString());
        }
    };
    /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    DefaultServerRenderer2.prototype.setValue = /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    function (node, value) { _angular_platformBrowser.ɵgetDOM().setText(node, value); };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    DefaultServerRenderer2.prototype.listen = /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    function (target, eventName, callback) {
        var _this = this;
        // Note: We are not using the EventsPlugin here as this is not needed
        // to run our tests.
        checkNoSyntheticProp(eventName, 'listener');
        var /** @type {?} */ el = typeof target === 'string' ? _angular_platformBrowser.ɵgetDOM().getGlobalEventTarget(this.document, target) : target;
        var /** @type {?} */ outsideHandler = function (event) { return _this.ngZone.runGuarded(function () { return callback(event); }); };
        return this.ngZone.runOutsideAngular(function () { return (_angular_platformBrowser.ɵgetDOM().onAndCancel(el, eventName, outsideHandler)); });
    };
    return DefaultServerRenderer2;
}());
var AT_CHARCODE = '@'.charCodeAt(0);
/**
 * @param {?} name
 * @param {?} nameKind
 * @return {?}
 */
function checkNoSyntheticProp(name, nameKind) {
    if (name.charCodeAt(0) === AT_CHARCODE) {
        throw new Error("Found the synthetic " + nameKind + " " + name + ". Please include either \"BrowserAnimationsModule\" or \"NoopAnimationsModule\" in your application.");
    }
}
var EmulatedEncapsulationServerRenderer2 = /** @class */ (function (_super) {
    __extends(EmulatedEncapsulationServerRenderer2, _super);
    function EmulatedEncapsulationServerRenderer2(document, ngZone, sharedStylesHost, schema, component) {
        var _this = _super.call(this, document, ngZone, schema) || this;
        _this.component = component;
        var /** @type {?} */ styles = _angular_platformBrowser.ɵflattenStyles(component.id, component.styles, []);
        sharedStylesHost.addStyles(styles);
        _this.contentAttr = _angular_platformBrowser.ɵshimContentAttribute(component.id);
        _this.hostAttr = _angular_platformBrowser.ɵshimHostAttribute(component.id);
        return _this;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    EmulatedEncapsulationServerRenderer2.prototype.applyToHost = /**
     * @param {?} element
     * @return {?}
     */
    function (element) { _super.prototype.setAttribute.call(this, element, this.hostAttr, ''); };
    /**
     * @param {?} parent
     * @param {?} name
     * @return {?}
     */
    EmulatedEncapsulationServerRenderer2.prototype.createElement = /**
     * @param {?} parent
     * @param {?} name
     * @return {?}
     */
    function (parent, name) {
        var /** @type {?} */ el = _super.prototype.createElement.call(this, parent, name);
        _super.prototype.setAttribute.call(this, el, this.contentAttr, '');
        return el;
    };
    return EmulatedEncapsulationServerRenderer2;
}(DefaultServerRenderer2));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ServerStylesHost = /** @class */ (function (_super) {
    __extends(ServerStylesHost, _super);
    function ServerStylesHost(doc, transitionId) {
        var _this = _super.call(this) || this;
        _this.doc = doc;
        _this.transitionId = transitionId;
        _this.head = null;
        _this.head = _angular_platformBrowser.ɵgetDOM().getElementsByTagName(doc, 'head')[0];
        return _this;
    }
    /**
     * @param {?} style
     * @return {?}
     */
    ServerStylesHost.prototype._addStyle = /**
     * @param {?} style
     * @return {?}
     */
    function (style) {
        var /** @type {?} */ adapter = _angular_platformBrowser.ɵgetDOM();
        var /** @type {?} */ el = adapter.createElement('style');
        adapter.setText(el, style);
        if (!!this.transitionId) {
            adapter.setAttribute(el, 'ng-transition', this.transitionId);
        }
        adapter.appendChild(this.head, el);
    };
    /**
     * @param {?} additions
     * @return {?}
     */
    ServerStylesHost.prototype.onStylesAdded = /**
     * @param {?} additions
     * @return {?}
     */
    function (additions) {
        var _this = this;
        additions.forEach(function (style) { return _this._addStyle(style); });
    };
    ServerStylesHost.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ServerStylesHost.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
        { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [_angular_platformBrowser.ɵTRANSITION_ID,] },] },
    ]; };
    return ServerStylesHost;
}(_angular_platformBrowser.ɵSharedStylesHost));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var INTERNAL_SERVER_PLATFORM_PROVIDERS = [
    { provide: _angular_platformBrowser.DOCUMENT, useFactory: _document, deps: [_angular_core.Injector] },
    { provide: _angular_core.PLATFORM_ID, useValue: _angular_common.ɵPLATFORM_SERVER_ID },
    { provide: _angular_core.PLATFORM_INITIALIZER, useFactory: initDominoAdapter, multi: true, deps: [_angular_core.Injector] }, {
        provide: _angular_common.PlatformLocation,
        useClass: ServerPlatformLocation,
        deps: [_angular_platformBrowser.DOCUMENT, [_angular_core.Optional, INITIAL_CONFIG]]
    },
    { provide: PlatformState, deps: [_angular_platformBrowser.DOCUMENT] },
    // Add special provider that allows multiple instances of platformServer* to be created.
    { provide: _angular_core.ɵALLOW_MULTIPLE_PLATFORMS, useValue: true }
];
/**
 * @param {?} injector
 * @return {?}
 */
function initDominoAdapter(injector) {
    return function () { DominoAdapter.makeCurrent(); };
}
/**
 * @param {?} renderer
 * @param {?} engine
 * @param {?} zone
 * @return {?}
 */
function instantiateServerRendererFactory(renderer, engine, zone) {
    return new _angular_platformBrowser_animations.ɵAnimationRendererFactory(renderer, engine, zone);
}
var SERVER_RENDER_PROVIDERS = [
    ServerRendererFactory2,
    {
        provide: _angular_core.RendererFactory2,
        useFactory: instantiateServerRendererFactory,
        deps: [ServerRendererFactory2, _angular_animations_browser.ɵAnimationEngine, _angular_core.NgZone]
    },
    ServerStylesHost,
    { provide: _angular_platformBrowser.ɵSharedStylesHost, useExisting: ServerStylesHost },
];
/**
 * The ng module for the server.
 *
 * \@experimental
 */
var ServerModule = /** @class */ (function () {
    function ServerModule() {
    }
    ServerModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    exports: [_angular_platformBrowser.BrowserModule],
                    imports: [_angular_http.HttpModule, _angular_common_http.HttpClientModule, _angular_platformBrowser_animations.NoopAnimationsModule],
                    providers: [
                        SERVER_RENDER_PROVIDERS,
                        SERVER_HTTP_PROVIDERS,
                        { provide: _angular_core.Testability, useValue: null },
                    ],
                },] },
    ];
    /** @nocollapse */
    ServerModule.ctorParameters = function () { return []; };
    return ServerModule;
}());
/**
 * @param {?} injector
 * @return {?}
 */
function _document(injector) {
    var /** @type {?} */ config = injector.get(INITIAL_CONFIG, null);
    if (config && config.document) {
        return parseDocument(config.document, config.url);
    }
    else {
        return _angular_platformBrowser.ɵgetDOM().createHtmlDocument();
    }
}
/**
 * \@experimental
 */
var platformServer = _angular_core.createPlatformFactory(_angular_core.platformCore, 'server', INTERNAL_SERVER_PLATFORM_PROVIDERS);
/**
 * The server platform that supports the runtime compiler.
 *
 * \@experimental
 */
var platformDynamicServer = _angular_core.createPlatformFactory(_angular_platformBrowserDynamic.ɵplatformCoreDynamic, 'serverDynamic', INTERNAL_SERVER_PLATFORM_PROVIDERS);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} doc
 * @param {?} appId
 * @param {?} transferStore
 * @return {?}
 */
function serializeTransferStateFactory(doc, appId, transferStore) {
    return function () {
        var /** @type {?} */ script = doc.createElement('script');
        script.id = appId + '-state';
        script.setAttribute('type', 'application/json');
        script.textContent = _angular_platformBrowser.ɵescapeHtml(transferStore.toJson());
        doc.body.appendChild(script);
    };
}
/**
 * NgModule to install on the server side while using the `TransferState` to transfer state from
 * server to client.
 *
 * \@experimental
 */
var ServerTransferStateModule = /** @class */ (function () {
    function ServerTransferStateModule() {
    }
    ServerTransferStateModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    providers: [
                        _angular_platformBrowser.TransferState, {
                            provide: BEFORE_APP_SERIALIZED,
                            useFactory: serializeTransferStateFactory,
                            deps: [_angular_platformBrowser.DOCUMENT, _angular_core.APP_ID, _angular_platformBrowser.TransferState],
                            multi: true,
                        }
                    ]
                },] },
    ];
    /** @nocollapse */
    ServerTransferStateModule.ctorParameters = function () { return []; };
    return ServerTransferStateModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} platformFactory
 * @param {?} options
 * @return {?}
 */
function _getPlatform(platformFactory, options) {
    var /** @type {?} */ extraProviders = options.extraProviders ? options.extraProviders : [];
    return platformFactory([
        { provide: INITIAL_CONFIG, useValue: { document: options.document, url: options.url } },
        extraProviders
    ]);
}
/**
 * @template T
 * @param {?} platform
 * @param {?} moduleRefPromise
 * @return {?}
 */
function _render(platform, moduleRefPromise) {
    return moduleRefPromise.then(function (moduleRef) {
        var /** @type {?} */ transitionId = moduleRef.injector.get(_angular_platformBrowser.ɵTRANSITION_ID, null);
        if (!transitionId) {
            throw new Error("renderModule[Factory]() requires the use of BrowserModule.withServerTransition() to ensure\nthe server-rendered app can be properly bootstrapped into a client app.");
        }
        var /** @type {?} */ applicationRef = moduleRef.injector.get(_angular_core.ApplicationRef);
        return rxjs_operator_toPromise.toPromise
            .call(rxjs_operator_first.first.call(rxjs_operator_filter.filter.call(applicationRef.isStable, function (isStable) { return isStable; })))
            .then(function () {
            var /** @type {?} */ platformState = platform.injector.get(PlatformState);
            // Run any BEFORE_APP_SERIALIZED callbacks just before rendering to string.
            var /** @type {?} */ callbacks = moduleRef.injector.get(BEFORE_APP_SERIALIZED, null);
            if (callbacks) {
                for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
                    var callback = callbacks_1[_i];
                    try {
                        callback();
                    }
                    catch (/** @type {?} */ e) {
                        // Ignore exceptions.
                        console.warn('Ignoring BEFORE_APP_SERIALIZED Exception: ', e);
                    }
                }
            }
            var /** @type {?} */ output = platformState.renderToString();
            platform.destroy();
            return output;
        });
    });
}
/**
 * Renders a Module to string.
 *
 * `document` is the full document HTML of the page to render, as a string.
 * `url` is the URL for the current render request.
 * `extraProviders` are the platform level providers for the current render request.
 *
 * Do not use this in a production server environment. Use pre-compiled {\@link NgModuleFactory} with
 * {\@link renderModuleFactory} instead.
 *
 * \@experimental
 * @template T
 * @param {?} module
 * @param {?} options
 * @return {?}
 */
function renderModule(module, options) {
    var /** @type {?} */ platform = _getPlatform(platformDynamicServer, options);
    return _render(platform, platform.bootstrapModule(module));
}
/**
 * Renders a {\@link NgModuleFactory} to string.
 *
 * `document` is the full document HTML of the page to render, as a string.
 * `url` is the URL for the current render request.
 * `extraProviders` are the platform level providers for the current render request.
 *
 * \@experimental
 * @template T
 * @param {?} moduleFactory
 * @param {?} options
 * @return {?}
 */
function renderModuleFactory(moduleFactory, options) {
    var /** @type {?} */ platform = _getPlatform(platformServer, options);
    return _render(platform, platform.bootstrapModuleFactory(moduleFactory));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@stable
 */
var VERSION = new _angular_core.Version('5.2.2');

exports.PlatformState = PlatformState;
exports.ServerModule = ServerModule;
exports.platformDynamicServer = platformDynamicServer;
exports.platformServer = platformServer;
exports.BEFORE_APP_SERIALIZED = BEFORE_APP_SERIALIZED;
exports.INITIAL_CONFIG = INITIAL_CONFIG;
exports.ServerTransferStateModule = ServerTransferStateModule;
exports.renderModule = renderModule;
exports.renderModuleFactory = renderModuleFactory;
exports.VERSION = VERSION;
exports.ɵINTERNAL_SERVER_PLATFORM_PROVIDERS = INTERNAL_SERVER_PLATFORM_PROVIDERS;
exports.ɵSERVER_RENDER_PROVIDERS = SERVER_RENDER_PROVIDERS;
exports.ɵServerRendererFactory2 = ServerRendererFactory2;
exports.ɵh = SERVER_HTTP_PROVIDERS;
exports.ɵd = ServerXhr;
exports.ɵe = ServerXsrfStrategy;
exports.ɵf = httpFactory;
exports.ɵg = zoneWrappedInterceptingHandler;
exports.ɵa = instantiateServerRendererFactory;
exports.ɵc = ServerStylesHost;
exports.ɵb = serializeTransferStateFactory;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=platform-server.umd.js.map


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Angular v5.2.2
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
	 true ? factory(exports, __webpack_require__(22)) :
	typeof define === 'function' && define.amd ? define('@angular/animations/browser', ['exports', '@angular/animations'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.animations = global.ng.animations || {}, global.ng.animations.browser = {}),global.ng.animations));
}(this, (function (exports,_angular_animations) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
};

/**
 * @license Angular v5.2.2
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} players
 * @return {?}
 */
function optimizeGroupPlayer(players) {
    switch (players.length) {
        case 0:
            return new _angular_animations.NoopAnimationPlayer();
        case 1:
            return players[0];
        default:
            return new _angular_animations.ɵAnimationGroupPlayer(players);
    }
}
/**
 * @param {?} driver
 * @param {?} normalizer
 * @param {?} element
 * @param {?} keyframes
 * @param {?=} preStyles
 * @param {?=} postStyles
 * @return {?}
 */
function normalizeKeyframes(driver, normalizer, element, keyframes, preStyles, postStyles) {
    if (preStyles === void 0) { preStyles = {}; }
    if (postStyles === void 0) { postStyles = {}; }
    var /** @type {?} */ errors = [];
    var /** @type {?} */ normalizedKeyframes = [];
    var /** @type {?} */ previousOffset = -1;
    var /** @type {?} */ previousKeyframe = null;
    keyframes.forEach(function (kf) {
        var /** @type {?} */ offset = /** @type {?} */ (kf['offset']);
        var /** @type {?} */ isSameOffset = offset == previousOffset;
        var /** @type {?} */ normalizedKeyframe = (isSameOffset && previousKeyframe) || {};
        Object.keys(kf).forEach(function (prop) {
            var /** @type {?} */ normalizedProp = prop;
            var /** @type {?} */ normalizedValue = kf[prop];
            if (prop !== 'offset') {
                normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);
                switch (normalizedValue) {
                    case _angular_animations.ɵPRE_STYLE:
                        normalizedValue = preStyles[prop];
                        break;
                    case _angular_animations.AUTO_STYLE:
                        normalizedValue = postStyles[prop];
                        break;
                    default:
                        normalizedValue =
                            normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);
                        break;
                }
            }
            normalizedKeyframe[normalizedProp] = normalizedValue;
        });
        if (!isSameOffset) {
            normalizedKeyframes.push(normalizedKeyframe);
        }
        previousKeyframe = normalizedKeyframe;
        previousOffset = offset;
    });
    if (errors.length) {
        var /** @type {?} */ LINE_START = '\n - ';
        throw new Error("Unable to animate due to the following errors:" + LINE_START + errors.join(LINE_START));
    }
    return normalizedKeyframes;
}
/**
 * @param {?} player
 * @param {?} eventName
 * @param {?} event
 * @param {?} callback
 * @return {?}
 */
function listenOnPlayer(player, eventName, event, callback) {
    switch (eventName) {
        case 'start':
            player.onStart(function () { return callback(event && copyAnimationEvent(event, 'start', player.totalTime)); });
            break;
        case 'done':
            player.onDone(function () { return callback(event && copyAnimationEvent(event, 'done', player.totalTime)); });
            break;
        case 'destroy':
            player.onDestroy(function () { return callback(event && copyAnimationEvent(event, 'destroy', player.totalTime)); });
            break;
    }
}
/**
 * @param {?} e
 * @param {?=} phaseName
 * @param {?=} totalTime
 * @return {?}
 */
function copyAnimationEvent(e, phaseName, totalTime) {
    var /** @type {?} */ event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, totalTime == undefined ? e.totalTime : totalTime);
    var /** @type {?} */ data = (/** @type {?} */ (e))['_data'];
    if (data != null) {
        (/** @type {?} */ (event))['_data'] = data;
    }
    return event;
}
/**
 * @param {?} element
 * @param {?} triggerName
 * @param {?} fromState
 * @param {?} toState
 * @param {?=} phaseName
 * @param {?=} totalTime
 * @return {?}
 */
function makeAnimationEvent(element, triggerName, fromState, toState, phaseName, totalTime) {
    if (phaseName === void 0) { phaseName = ''; }
    if (totalTime === void 0) { totalTime = 0; }
    return { element: element, triggerName: triggerName, fromState: fromState, toState: toState, phaseName: phaseName, totalTime: totalTime };
}
/**
 * @param {?} map
 * @param {?} key
 * @param {?} defaultValue
 * @return {?}
 */
function getOrSetAsInMap(map, key, defaultValue) {
    var /** @type {?} */ value;
    if (map instanceof Map) {
        value = map.get(key);
        if (!value) {
            map.set(key, value = defaultValue);
        }
    }
    else {
        value = map[key];
        if (!value) {
            value = map[key] = defaultValue;
        }
    }
    return value;
}
/**
 * @param {?} command
 * @return {?}
 */
function parseTimelineCommand(command) {
    var /** @type {?} */ separatorPos = command.indexOf(':');
    var /** @type {?} */ id = command.substring(1, separatorPos);
    var /** @type {?} */ action = command.substr(separatorPos + 1);
    return [id, action];
}
var _contains = function (elm1, elm2) { return false; };
var _matches = function (element, selector) {
    return false;
};
var _query = function (element, selector, multi) {
    return [];
};
if (typeof Element != 'undefined') {
    // this is well supported in all browsers
    _contains = function (elm1, elm2) { return /** @type {?} */ (elm1.contains(elm2)); };
    if (Element.prototype.matches) {
        _matches = function (element, selector) { return element.matches(selector); };
    }
    else {
        var /** @type {?} */ proto = /** @type {?} */ (Element.prototype);
        var /** @type {?} */ fn_1 = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector ||
            proto.oMatchesSelector || proto.webkitMatchesSelector;
        if (fn_1) {
            _matches = function (element, selector) { return fn_1.apply(element, [selector]); };
        }
    }
    _query = function (element, selector, multi) {
        var /** @type {?} */ results = [];
        if (multi) {
            results.push.apply(results, element.querySelectorAll(selector));
        }
        else {
            var /** @type {?} */ elm = element.querySelector(selector);
            if (elm) {
                results.push(elm);
            }
        }
        return results;
    };
}
/**
 * @param {?} prop
 * @return {?}
 */
function containsVendorPrefix(prop) {
    // Webkit is the only real popular vendor prefix nowadays
    // cc: http://shouldiprefix.com/
    return prop.substring(1, 6) == 'ebkit'; // webkit or Webkit
}
var _CACHED_BODY = null;
var _IS_WEBKIT = false;
/**
 * @param {?} prop
 * @return {?}
 */
function validateStyleProperty(prop) {
    if (!_CACHED_BODY) {
        _CACHED_BODY = getBodyNode() || {};
        _IS_WEBKIT = /** @type {?} */ ((_CACHED_BODY)).style ? ('WebkitAppearance' in /** @type {?} */ ((_CACHED_BODY)).style) : false;
    }
    var /** @type {?} */ result = true;
    if (/** @type {?} */ ((_CACHED_BODY)).style && !containsVendorPrefix(prop)) {
        result = prop in /** @type {?} */ ((_CACHED_BODY)).style;
        if (!result && _IS_WEBKIT) {
            var /** @type {?} */ camelProp = 'Webkit' + prop.charAt(0).toUpperCase() + prop.substr(1);
            result = camelProp in /** @type {?} */ ((_CACHED_BODY)).style;
        }
    }
    return result;
}
/**
 * @return {?}
 */
function getBodyNode() {
    if (typeof document != 'undefined') {
        return document.body;
    }
    return null;
}
var matchesElement = _matches;
var containsElement = _contains;
var invokeQuery = _query;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@experimental
 */
var NoopAnimationDriver = /** @class */ (function () {
    function NoopAnimationDriver() {
    }
    /**
     * @param {?} prop
     * @return {?}
     */
    NoopAnimationDriver.prototype.validateStyleProperty = /**
     * @param {?} prop
     * @return {?}
     */
    function (prop) { return validateStyleProperty(prop); };
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    NoopAnimationDriver.prototype.matchesElement = /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    function (element, selector) {
        return matchesElement(element, selector);
    };
    /**
     * @param {?} elm1
     * @param {?} elm2
     * @return {?}
     */
    NoopAnimationDriver.prototype.containsElement = /**
     * @param {?} elm1
     * @param {?} elm2
     * @return {?}
     */
    function (elm1, elm2) { return containsElement(elm1, elm2); };
    /**
     * @param {?} element
     * @param {?} selector
     * @param {?} multi
     * @return {?}
     */
    NoopAnimationDriver.prototype.query = /**
     * @param {?} element
     * @param {?} selector
     * @param {?} multi
     * @return {?}
     */
    function (element, selector, multi) {
        return invokeQuery(element, selector, multi);
    };
    /**
     * @param {?} element
     * @param {?} prop
     * @param {?=} defaultValue
     * @return {?}
     */
    NoopAnimationDriver.prototype.computeStyle = /**
     * @param {?} element
     * @param {?} prop
     * @param {?=} defaultValue
     * @return {?}
     */
    function (element, prop, defaultValue) {
        return defaultValue || '';
    };
    /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} duration
     * @param {?} delay
     * @param {?} easing
     * @param {?=} previousPlayers
     * @return {?}
     */
    NoopAnimationDriver.prototype.animate = /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} duration
     * @param {?} delay
     * @param {?} easing
     * @param {?=} previousPlayers
     * @return {?}
     */
    function (element, keyframes, duration, delay, easing, previousPlayers) {
        if (previousPlayers === void 0) { previousPlayers = []; }
        return new _angular_animations.NoopAnimationPlayer();
    };
    return NoopAnimationDriver;
}());
/**
 * \@experimental
 * @abstract
 */
var AnimationDriver = /** @class */ (function () {
    function AnimationDriver() {
    }
    AnimationDriver.NOOP = new NoopAnimationDriver();
    return AnimationDriver;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ONE_SECOND = 1000;
var SUBSTITUTION_EXPR_START = '{{';
var SUBSTITUTION_EXPR_END = '}}';
var ENTER_CLASSNAME = 'ng-enter';
var LEAVE_CLASSNAME = 'ng-leave';


var NG_TRIGGER_CLASSNAME = 'ng-trigger';
var NG_TRIGGER_SELECTOR = '.ng-trigger';
var NG_ANIMATING_CLASSNAME = 'ng-animating';
var NG_ANIMATING_SELECTOR = '.ng-animating';
/**
 * @param {?} value
 * @return {?}
 */
function resolveTimingValue(value) {
    if (typeof value == 'number')
        return value;
    var /** @type {?} */ matches = (/** @type {?} */ (value)).match(/^(-?[\.\d]+)(m?s)/);
    if (!matches || matches.length < 2)
        return 0;
    return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
}
/**
 * @param {?} value
 * @param {?} unit
 * @return {?}
 */
function _convertTimeValueToMS(value, unit) {
    switch (unit) {
        case 's':
            return value * ONE_SECOND;
        default:
            // ms or something else
            return value;
    }
}
/**
 * @param {?} timings
 * @param {?} errors
 * @param {?=} allowNegativeValues
 * @return {?}
 */
function resolveTiming(timings, errors, allowNegativeValues) {
    return timings.hasOwnProperty('duration') ? /** @type {?} */ (timings) :
        parseTimeExpression(/** @type {?} */ (timings), errors, allowNegativeValues);
}
/**
 * @param {?} exp
 * @param {?} errors
 * @param {?=} allowNegativeValues
 * @return {?}
 */
function parseTimeExpression(exp, errors, allowNegativeValues) {
    var /** @type {?} */ regex = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i;
    var /** @type {?} */ duration;
    var /** @type {?} */ delay = 0;
    var /** @type {?} */ easing = '';
    if (typeof exp === 'string') {
        var /** @type {?} */ matches = exp.match(regex);
        if (matches === null) {
            errors.push("The provided timing value \"" + exp + "\" is invalid.");
            return { duration: 0, delay: 0, easing: '' };
        }
        duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
        var /** @type {?} */ delayMatch = matches[3];
        if (delayMatch != null) {
            delay = _convertTimeValueToMS(Math.floor(parseFloat(delayMatch)), matches[4]);
        }
        var /** @type {?} */ easingVal = matches[5];
        if (easingVal) {
            easing = easingVal;
        }
    }
    else {
        duration = /** @type {?} */ (exp);
    }
    if (!allowNegativeValues) {
        var /** @type {?} */ containsErrors = false;
        var /** @type {?} */ startIndex = errors.length;
        if (duration < 0) {
            errors.push("Duration values below 0 are not allowed for this animation step.");
            containsErrors = true;
        }
        if (delay < 0) {
            errors.push("Delay values below 0 are not allowed for this animation step.");
            containsErrors = true;
        }
        if (containsErrors) {
            errors.splice(startIndex, 0, "The provided timing value \"" + exp + "\" is invalid.");
        }
    }
    return { duration: duration, delay: delay, easing: easing };
}
/**
 * @param {?} obj
 * @param {?=} destination
 * @return {?}
 */
function copyObj(obj, destination) {
    if (destination === void 0) { destination = {}; }
    Object.keys(obj).forEach(function (prop) { destination[prop] = obj[prop]; });
    return destination;
}
/**
 * @param {?} styles
 * @return {?}
 */
function normalizeStyles(styles) {
    var /** @type {?} */ normalizedStyles = {};
    if (Array.isArray(styles)) {
        styles.forEach(function (data) { return copyStyles(data, false, normalizedStyles); });
    }
    else {
        copyStyles(styles, false, normalizedStyles);
    }
    return normalizedStyles;
}
/**
 * @param {?} styles
 * @param {?} readPrototype
 * @param {?=} destination
 * @return {?}
 */
function copyStyles(styles, readPrototype, destination) {
    if (destination === void 0) { destination = {}; }
    if (readPrototype) {
        // we make use of a for-in loop so that the
        // prototypically inherited properties are
        // revealed from the backFill map
        for (var /** @type {?} */ prop in styles) {
            destination[prop] = styles[prop];
        }
    }
    else {
        copyObj(styles, destination);
    }
    return destination;
}
/**
 * @param {?} element
 * @param {?} styles
 * @return {?}
 */
function setStyles(element, styles) {
    if (element['style']) {
        Object.keys(styles).forEach(function (prop) {
            var /** @type {?} */ camelProp = dashCaseToCamelCase(prop);
            element.style[camelProp] = styles[prop];
        });
    }
}
/**
 * @param {?} element
 * @param {?} styles
 * @return {?}
 */
function eraseStyles(element, styles) {
    if (element['style']) {
        Object.keys(styles).forEach(function (prop) {
            var /** @type {?} */ camelProp = dashCaseToCamelCase(prop);
            element.style[camelProp] = '';
        });
    }
}
/**
 * @param {?} steps
 * @return {?}
 */
function normalizeAnimationEntry(steps) {
    if (Array.isArray(steps)) {
        if (steps.length == 1)
            return steps[0];
        return _angular_animations.sequence(steps);
    }
    return /** @type {?} */ (steps);
}
/**
 * @param {?} value
 * @param {?} options
 * @param {?} errors
 * @return {?}
 */
function validateStyleParams(value, options, errors) {
    var /** @type {?} */ params = options.params || {};
    var /** @type {?} */ matches = extractStyleParams(value);
    if (matches.length) {
        matches.forEach(function (varName) {
            if (!params.hasOwnProperty(varName)) {
                errors.push("Unable to resolve the local animation param " + varName + " in the given list of values");
            }
        });
    }
}
var PARAM_REGEX = new RegExp(SUBSTITUTION_EXPR_START + "\\s*(.+?)\\s*" + SUBSTITUTION_EXPR_END, 'g');
/**
 * @param {?} value
 * @return {?}
 */
function extractStyleParams(value) {
    var /** @type {?} */ params = [];
    if (typeof value === 'string') {
        var /** @type {?} */ val = value.toString();
        var /** @type {?} */ match = void 0;
        while (match = PARAM_REGEX.exec(val)) {
            params.push(/** @type {?} */ (match[1]));
        }
        PARAM_REGEX.lastIndex = 0;
    }
    return params;
}
/**
 * @param {?} value
 * @param {?} params
 * @param {?} errors
 * @return {?}
 */
function interpolateParams(value, params, errors) {
    var /** @type {?} */ original = value.toString();
    var /** @type {?} */ str = original.replace(PARAM_REGEX, function (_, varName) {
        var /** @type {?} */ localVal = params[varName];
        // this means that the value was never overidden by the data passed in by the user
        if (!params.hasOwnProperty(varName)) {
            errors.push("Please provide a value for the animation param " + varName);
            localVal = '';
        }
        return localVal.toString();
    });
    // we do this to assert that numeric values stay as they are
    return str == original ? value : str;
}
/**
 * @param {?} iterator
 * @return {?}
 */
function iteratorToArray(iterator) {
    var /** @type {?} */ arr = [];
    var /** @type {?} */ item = iterator.next();
    while (!item.done) {
        arr.push(item.value);
        item = iterator.next();
    }
    return arr;
}
/**
 * @param {?} source
 * @param {?} destination
 * @return {?}
 */

var DASH_CASE_REGEXP = /-+([a-z0-9])/g;
/**
 * @param {?} input
 * @return {?}
 */
function dashCaseToCamelCase(input) {
    return input.replace(DASH_CASE_REGEXP, function () {
        var m = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            m[_i] = arguments[_i];
        }
        return m[1].toUpperCase();
    });
}
/**
 * @param {?} duration
 * @param {?} delay
 * @return {?}
 */
function allowPreviousPlayerStylesMerge(duration, delay) {
    return duration === 0 || delay === 0;
}
/**
 * @param {?} visitor
 * @param {?} node
 * @param {?} context
 * @return {?}
 */
function visitDslNode(visitor, node, context) {
    switch (node.type) {
        case 7 /* Trigger */:
            return visitor.visitTrigger(node, context);
        case 0 /* State */:
            return visitor.visitState(node, context);
        case 1 /* Transition */:
            return visitor.visitTransition(node, context);
        case 2 /* Sequence */:
            return visitor.visitSequence(node, context);
        case 3 /* Group */:
            return visitor.visitGroup(node, context);
        case 4 /* Animate */:
            return visitor.visitAnimate(node, context);
        case 5 /* Keyframes */:
            return visitor.visitKeyframes(node, context);
        case 6 /* Style */:
            return visitor.visitStyle(node, context);
        case 8 /* Reference */:
            return visitor.visitReference(node, context);
        case 9 /* AnimateChild */:
            return visitor.visitAnimateChild(node, context);
        case 10 /* AnimateRef */:
            return visitor.visitAnimateRef(node, context);
        case 11 /* Query */:
            return visitor.visitQuery(node, context);
        case 12 /* Stagger */:
            return visitor.visitStagger(node, context);
        default:
            throw new Error("Unable to resolve animation metadata node #" + node.type);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ANY_STATE = '*';
/**
 * @param {?} transitionValue
 * @param {?} errors
 * @return {?}
 */
function parseTransitionExpr(transitionValue, errors) {
    var /** @type {?} */ expressions = [];
    if (typeof transitionValue == 'string') {
        (/** @type {?} */ (transitionValue))
            .split(/\s*,\s*/)
            .forEach(function (str) { return parseInnerTransitionStr(str, expressions, errors); });
    }
    else {
        expressions.push(/** @type {?} */ (transitionValue));
    }
    return expressions;
}
/**
 * @param {?} eventStr
 * @param {?} expressions
 * @param {?} errors
 * @return {?}
 */
function parseInnerTransitionStr(eventStr, expressions, errors) {
    if (eventStr[0] == ':') {
        var /** @type {?} */ result = parseAnimationAlias(eventStr, errors);
        if (typeof result == 'function') {
            expressions.push(result);
            return;
        }
        eventStr = /** @type {?} */ (result);
    }
    var /** @type {?} */ match = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
    if (match == null || match.length < 4) {
        errors.push("The provided transition expression \"" + eventStr + "\" is not supported");
        return expressions;
    }
    var /** @type {?} */ fromState = match[1];
    var /** @type {?} */ separator = match[2];
    var /** @type {?} */ toState = match[3];
    expressions.push(makeLambdaFromStates(fromState, toState));
    var /** @type {?} */ isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;
    if (separator[0] == '<' && !isFullAnyStateExpr) {
        expressions.push(makeLambdaFromStates(toState, fromState));
    }
}
/**
 * @param {?} alias
 * @param {?} errors
 * @return {?}
 */
function parseAnimationAlias(alias, errors) {
    switch (alias) {
        case ':enter':
            return 'void => *';
        case ':leave':
            return '* => void';
        case ':increment':
            return function (fromState, toState) { return parseFloat(toState) > parseFloat(fromState); };
        case ':decrement':
            return function (fromState, toState) { return parseFloat(toState) < parseFloat(fromState); };
        default:
            errors.push("The transition alias value \"" + alias + "\" is not supported");
            return '* => *';
    }
}
// DO NOT REFACTOR ... keep the follow set instantiations
// with the values intact (closure compiler for some reason
// removes follow-up lines that add the values outside of
// the constructor...
var TRUE_BOOLEAN_VALUES = new Set(['true', '1']);
var FALSE_BOOLEAN_VALUES = new Set(['false', '0']);
/**
 * @param {?} lhs
 * @param {?} rhs
 * @return {?}
 */
function makeLambdaFromStates(lhs, rhs) {
    var /** @type {?} */ LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs);
    var /** @type {?} */ RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);
    return function (fromState, toState) {
        var /** @type {?} */ lhsMatch = lhs == ANY_STATE || lhs == fromState;
        var /** @type {?} */ rhsMatch = rhs == ANY_STATE || rhs == toState;
        if (!lhsMatch && LHS_MATCH_BOOLEAN && typeof fromState === 'boolean') {
            lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs);
        }
        if (!rhsMatch && RHS_MATCH_BOOLEAN && typeof toState === 'boolean') {
            rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs);
        }
        return lhsMatch && rhsMatch;
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SELF_TOKEN = ':self';
var SELF_TOKEN_REGEX = new RegExp("s*" + SELF_TOKEN + "s*,?", 'g');
/**
 * @param {?} driver
 * @param {?} metadata
 * @param {?} errors
 * @return {?}
 */
function buildAnimationAst(driver, metadata, errors) {
    return new AnimationAstBuilderVisitor(driver).build(metadata, errors);
}
var ROOT_SELECTOR = '';
var AnimationAstBuilderVisitor = /** @class */ (function () {
    function AnimationAstBuilderVisitor(_driver) {
        this._driver = _driver;
    }
    /**
     * @param {?} metadata
     * @param {?} errors
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.build = /**
     * @param {?} metadata
     * @param {?} errors
     * @return {?}
     */
    function (metadata, errors) {
        var /** @type {?} */ context = new AnimationAstBuilderContext(errors);
        this._resetContextStyleTimingState(context);
        return /** @type {?} */ (visitDslNode(this, normalizeAnimationEntry(metadata), context));
    };
    /**
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype._resetContextStyleTimingState = /**
     * @param {?} context
     * @return {?}
     */
    function (context) {
        context.currentQuerySelector = ROOT_SELECTOR;
        context.collectedStyles = {};
        context.collectedStyles[ROOT_SELECTOR] = {};
        context.currentTime = 0;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitTrigger = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var _this = this;
        var /** @type {?} */ queryCount = context.queryCount = 0;
        var /** @type {?} */ depCount = context.depCount = 0;
        var /** @type {?} */ states = [];
        var /** @type {?} */ transitions = [];
        if (metadata.name.charAt(0) == '@') {
            context.errors.push('animation triggers cannot be prefixed with an `@` sign (e.g. trigger(\'@foo\', [...]))');
        }
        metadata.definitions.forEach(function (def) {
            _this._resetContextStyleTimingState(context);
            if (def.type == 0 /* State */) {
                var /** @type {?} */ stateDef_1 = /** @type {?} */ (def);
                var /** @type {?} */ name_1 = stateDef_1.name;
                name_1.split(/\s*,\s*/).forEach(function (n) {
                    stateDef_1.name = n;
                    states.push(_this.visitState(stateDef_1, context));
                });
                stateDef_1.name = name_1;
            }
            else if (def.type == 1 /* Transition */) {
                var /** @type {?} */ transition = _this.visitTransition(/** @type {?} */ (def), context);
                queryCount += transition.queryCount;
                depCount += transition.depCount;
                transitions.push(transition);
            }
            else {
                context.errors.push('only state() and transition() definitions can sit inside of a trigger()');
            }
        });
        return {
            type: 7 /* Trigger */,
            name: metadata.name, states: states, transitions: transitions, queryCount: queryCount, depCount: depCount,
            options: null
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitState = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ styleAst = this.visitStyle(metadata.styles, context);
        var /** @type {?} */ astParams = (metadata.options && metadata.options.params) || null;
        if (styleAst.containsDynamicStyles) {
            var /** @type {?} */ missingSubs_1 = new Set();
            var /** @type {?} */ params_1 = astParams || {};
            styleAst.styles.forEach(function (value) {
                if (isObject(value)) {
                    var /** @type {?} */ stylesObj_1 = /** @type {?} */ (value);
                    Object.keys(stylesObj_1).forEach(function (prop) {
                        extractStyleParams(stylesObj_1[prop]).forEach(function (sub) {
                            if (!params_1.hasOwnProperty(sub)) {
                                missingSubs_1.add(sub);
                            }
                        });
                    });
                }
            });
            if (missingSubs_1.size) {
                var /** @type {?} */ missingSubsArr = iteratorToArray(missingSubs_1.values());
                context.errors.push("state(\"" + metadata.name + "\", ...) must define default values for all the following style substitutions: " + missingSubsArr.join(', '));
            }
        }
        return {
            type: 0 /* State */,
            name: metadata.name,
            style: styleAst,
            options: astParams ? { params: astParams } : null
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitTransition = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        context.queryCount = 0;
        context.depCount = 0;
        var /** @type {?} */ animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
        var /** @type {?} */ matchers = parseTransitionExpr(metadata.expr, context.errors);
        return {
            type: 1 /* Transition */,
            matchers: matchers,
            animation: animation,
            queryCount: context.queryCount,
            depCount: context.depCount,
            options: normalizeAnimationOptions(metadata.options)
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitSequence = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var _this = this;
        return {
            type: 2 /* Sequence */,
            steps: metadata.steps.map(function (s) { return visitDslNode(_this, s, context); }),
            options: normalizeAnimationOptions(metadata.options)
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitGroup = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var _this = this;
        var /** @type {?} */ currentTime = context.currentTime;
        var /** @type {?} */ furthestTime = 0;
        var /** @type {?} */ steps = metadata.steps.map(function (step) {
            context.currentTime = currentTime;
            var /** @type {?} */ innerAst = visitDslNode(_this, step, context);
            furthestTime = Math.max(furthestTime, context.currentTime);
            return innerAst;
        });
        context.currentTime = furthestTime;
        return {
            type: 3 /* Group */,
            steps: steps,
            options: normalizeAnimationOptions(metadata.options)
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitAnimate = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ timingAst = constructTimingAst(metadata.timings, context.errors);
        context.currentAnimateTimings = timingAst;
        var /** @type {?} */ styleAst;
        var /** @type {?} */ styleMetadata = metadata.styles ? metadata.styles : _angular_animations.style({});
        if (styleMetadata.type == 5 /* Keyframes */) {
            styleAst = this.visitKeyframes(/** @type {?} */ (styleMetadata), context);
        }
        else {
            var /** @type {?} */ styleMetadata_1 = /** @type {?} */ (metadata.styles);
            var /** @type {?} */ isEmpty = false;
            if (!styleMetadata_1) {
                isEmpty = true;
                var /** @type {?} */ newStyleData = {};
                if (timingAst.easing) {
                    newStyleData['easing'] = timingAst.easing;
                }
                styleMetadata_1 = _angular_animations.style(newStyleData);
            }
            context.currentTime += timingAst.duration + timingAst.delay;
            var /** @type {?} */ _styleAst = this.visitStyle(styleMetadata_1, context);
            _styleAst.isEmptyStep = isEmpty;
            styleAst = _styleAst;
        }
        context.currentAnimateTimings = null;
        return {
            type: 4 /* Animate */,
            timings: timingAst,
            style: styleAst,
            options: null
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitStyle = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ ast = this._makeStyleAst(metadata, context);
        this._validateStyleAst(ast, context);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype._makeStyleAst = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ styles = [];
        if (Array.isArray(metadata.styles)) {
            (/** @type {?} */ (metadata.styles)).forEach(function (styleTuple) {
                if (typeof styleTuple == 'string') {
                    if (styleTuple == _angular_animations.AUTO_STYLE) {
                        styles.push(/** @type {?} */ (styleTuple));
                    }
                    else {
                        context.errors.push("The provided style string value " + styleTuple + " is not allowed.");
                    }
                }
                else {
                    styles.push(/** @type {?} */ (styleTuple));
                }
            });
        }
        else {
            styles.push(metadata.styles);
        }
        var /** @type {?} */ containsDynamicStyles = false;
        var /** @type {?} */ collectedEasing = null;
        styles.forEach(function (styleData) {
            if (isObject(styleData)) {
                var /** @type {?} */ styleMap = /** @type {?} */ (styleData);
                var /** @type {?} */ easing = styleMap['easing'];
                if (easing) {
                    collectedEasing = /** @type {?} */ (easing);
                    delete styleMap['easing'];
                }
                if (!containsDynamicStyles) {
                    for (var /** @type {?} */ prop in styleMap) {
                        var /** @type {?} */ value = styleMap[prop];
                        if (value.toString().indexOf(SUBSTITUTION_EXPR_START) >= 0) {
                            containsDynamicStyles = true;
                            break;
                        }
                    }
                }
            }
        });
        return {
            type: 6 /* Style */,
            styles: styles,
            easing: collectedEasing,
            offset: metadata.offset, containsDynamicStyles: containsDynamicStyles,
            options: null
        };
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype._validateStyleAst = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var _this = this;
        var /** @type {?} */ timings = context.currentAnimateTimings;
        var /** @type {?} */ endTime = context.currentTime;
        var /** @type {?} */ startTime = context.currentTime;
        if (timings && startTime > 0) {
            startTime -= timings.duration + timings.delay;
        }
        ast.styles.forEach(function (tuple) {
            if (typeof tuple == 'string')
                return;
            Object.keys(tuple).forEach(function (prop) {
                if (!_this._driver.validateStyleProperty(prop)) {
                    context.errors.push("The provided animation property \"" + prop + "\" is not a supported CSS property for animations");
                    return;
                }
                var /** @type {?} */ collectedStyles = context.collectedStyles[/** @type {?} */ ((context.currentQuerySelector))];
                var /** @type {?} */ collectedEntry = collectedStyles[prop];
                var /** @type {?} */ updateCollectedStyle = true;
                if (collectedEntry) {
                    if (startTime != endTime && startTime >= collectedEntry.startTime &&
                        endTime <= collectedEntry.endTime) {
                        context.errors.push("The CSS property \"" + prop + "\" that exists between the times of \"" + collectedEntry.startTime + "ms\" and \"" + collectedEntry.endTime + "ms\" is also being animated in a parallel animation between the times of \"" + startTime + "ms\" and \"" + endTime + "ms\"");
                        updateCollectedStyle = false;
                    }
                    // we always choose the smaller start time value since we
                    // want to have a record of the entire animation window where
                    // the style property is being animated in between
                    startTime = collectedEntry.startTime;
                }
                if (updateCollectedStyle) {
                    collectedStyles[prop] = { startTime: startTime, endTime: endTime };
                }
                if (context.options) {
                    validateStyleParams(tuple[prop], context.options, context.errors);
                }
            });
        });
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitKeyframes = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var _this = this;
        var /** @type {?} */ ast = { type: 5 /* Keyframes */, styles: [], options: null };
        if (!context.currentAnimateTimings) {
            context.errors.push("keyframes() must be placed inside of a call to animate()");
            return ast;
        }
        var /** @type {?} */ MAX_KEYFRAME_OFFSET = 1;
        var /** @type {?} */ totalKeyframesWithOffsets = 0;
        var /** @type {?} */ offsets = [];
        var /** @type {?} */ offsetsOutOfOrder = false;
        var /** @type {?} */ keyframesOutOfRange = false;
        var /** @type {?} */ previousOffset = 0;
        var /** @type {?} */ keyframes = metadata.steps.map(function (styles) {
            var /** @type {?} */ style$$1 = _this._makeStyleAst(styles, context);
            var /** @type {?} */ offsetVal = style$$1.offset != null ? style$$1.offset : consumeOffset(style$$1.styles);
            var /** @type {?} */ offset = 0;
            if (offsetVal != null) {
                totalKeyframesWithOffsets++;
                offset = style$$1.offset = offsetVal;
            }
            keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;
            offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;
            previousOffset = offset;
            offsets.push(offset);
            return style$$1;
        });
        if (keyframesOutOfRange) {
            context.errors.push("Please ensure that all keyframe offsets are between 0 and 1");
        }
        if (offsetsOutOfOrder) {
            context.errors.push("Please ensure that all keyframe offsets are in order");
        }
        var /** @type {?} */ length = metadata.steps.length;
        var /** @type {?} */ generatedOffset = 0;
        if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {
            context.errors.push("Not all style() steps within the declared keyframes() contain offsets");
        }
        else if (totalKeyframesWithOffsets == 0) {
            generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);
        }
        var /** @type {?} */ limit = length - 1;
        var /** @type {?} */ currentTime = context.currentTime;
        var /** @type {?} */ currentAnimateTimings = /** @type {?} */ ((context.currentAnimateTimings));
        var /** @type {?} */ animateDuration = currentAnimateTimings.duration;
        keyframes.forEach(function (kf, i) {
            var /** @type {?} */ offset = generatedOffset > 0 ? (i == limit ? 1 : (generatedOffset * i)) : offsets[i];
            var /** @type {?} */ durationUpToThisFrame = offset * animateDuration;
            context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;
            currentAnimateTimings.duration = durationUpToThisFrame;
            _this._validateStyleAst(kf, context);
            kf.offset = offset;
            ast.styles.push(kf);
        });
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitReference = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        return {
            type: 8 /* Reference */,
            animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),
            options: normalizeAnimationOptions(metadata.options)
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitAnimateChild = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        context.depCount++;
        return {
            type: 9 /* AnimateChild */,
            options: normalizeAnimationOptions(metadata.options)
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitAnimateRef = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        return {
            type: 10 /* AnimateRef */,
            animation: this.visitReference(metadata.animation, context),
            options: normalizeAnimationOptions(metadata.options)
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitQuery = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ parentSelector = /** @type {?} */ ((context.currentQuerySelector));
        var /** @type {?} */ options = /** @type {?} */ ((metadata.options || {}));
        context.queryCount++;
        context.currentQuery = metadata;
        var _a = normalizeSelector(metadata.selector), selector = _a[0], includeSelf = _a[1];
        context.currentQuerySelector =
            parentSelector.length ? (parentSelector + ' ' + selector) : selector;
        getOrSetAsInMap(context.collectedStyles, context.currentQuerySelector, {});
        var /** @type {?} */ animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
        context.currentQuery = null;
        context.currentQuerySelector = parentSelector;
        return {
            type: 11 /* Query */,
            selector: selector,
            limit: options.limit || 0,
            optional: !!options.optional, includeSelf: includeSelf, animation: animation,
            originalSelector: metadata.selector,
            options: normalizeAnimationOptions(metadata.options)
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitStagger = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        if (!context.currentQuery) {
            context.errors.push("stagger() can only be used inside of query()");
        }
        var /** @type {?} */ timings = metadata.timings === 'full' ?
            { duration: 0, delay: 0, easing: 'full' } :
            resolveTiming(metadata.timings, context.errors, true);
        return {
            type: 12 /* Stagger */,
            animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context), timings: timings,
            options: null
        };
    };
    return AnimationAstBuilderVisitor;
}());
/**
 * @param {?} selector
 * @return {?}
 */
function normalizeSelector(selector) {
    var /** @type {?} */ hasAmpersand = selector.split(/\s*,\s*/).find(function (token) { return token == SELF_TOKEN; }) ? true : false;
    if (hasAmpersand) {
        selector = selector.replace(SELF_TOKEN_REGEX, '');
    }
    // the :enter and :leave selectors are filled in at runtime during timeline building
    selector = selector.replace(/@\*/g, NG_TRIGGER_SELECTOR)
        .replace(/@\w+/g, function (match) { return NG_TRIGGER_SELECTOR + '-' + match.substr(1); })
        .replace(/:animating/g, NG_ANIMATING_SELECTOR);
    return [selector, hasAmpersand];
}
/**
 * @param {?} obj
 * @return {?}
 */
function normalizeParams(obj) {
    return obj ? copyObj(obj) : null;
}
var AnimationAstBuilderContext = /** @class */ (function () {
    function AnimationAstBuilderContext(errors) {
        this.errors = errors;
        this.queryCount = 0;
        this.depCount = 0;
        this.currentTransition = null;
        this.currentQuery = null;
        this.currentQuerySelector = null;
        this.currentAnimateTimings = null;
        this.currentTime = 0;
        this.collectedStyles = {};
        this.options = null;
    }
    return AnimationAstBuilderContext;
}());
/**
 * @param {?} styles
 * @return {?}
 */
function consumeOffset(styles) {
    if (typeof styles == 'string')
        return null;
    var /** @type {?} */ offset = null;
    if (Array.isArray(styles)) {
        styles.forEach(function (styleTuple) {
            if (isObject(styleTuple) && styleTuple.hasOwnProperty('offset')) {
                var /** @type {?} */ obj = /** @type {?} */ (styleTuple);
                offset = parseFloat(/** @type {?} */ (obj['offset']));
                delete obj['offset'];
            }
        });
    }
    else if (isObject(styles) && styles.hasOwnProperty('offset')) {
        var /** @type {?} */ obj = /** @type {?} */ (styles);
        offset = parseFloat(/** @type {?} */ (obj['offset']));
        delete obj['offset'];
    }
    return offset;
}
/**
 * @param {?} value
 * @return {?}
 */
function isObject(value) {
    return !Array.isArray(value) && typeof value == 'object';
}
/**
 * @param {?} value
 * @param {?} errors
 * @return {?}
 */
function constructTimingAst(value, errors) {
    var /** @type {?} */ timings = null;
    if (value.hasOwnProperty('duration')) {
        timings = /** @type {?} */ (value);
    }
    else if (typeof value == 'number') {
        var /** @type {?} */ duration = resolveTiming(/** @type {?} */ (value), errors).duration;
        return makeTimingAst(/** @type {?} */ (duration), 0, '');
    }
    var /** @type {?} */ strValue = /** @type {?} */ (value);
    var /** @type {?} */ isDynamic = strValue.split(/\s+/).some(function (v) { return v.charAt(0) == '{' && v.charAt(1) == '{'; });
    if (isDynamic) {
        var /** @type {?} */ ast = /** @type {?} */ (makeTimingAst(0, 0, ''));
        ast.dynamic = true;
        ast.strValue = strValue;
        return /** @type {?} */ (ast);
    }
    timings = timings || resolveTiming(strValue, errors);
    return makeTimingAst(timings.duration, timings.delay, timings.easing);
}
/**
 * @param {?} options
 * @return {?}
 */
function normalizeAnimationOptions(options) {
    if (options) {
        options = copyObj(options);
        if (options['params']) {
            options['params'] = /** @type {?} */ ((normalizeParams(options['params'])));
        }
    }
    else {
        options = {};
    }
    return options;
}
/**
 * @param {?} duration
 * @param {?} delay
 * @param {?} easing
 * @return {?}
 */
function makeTimingAst(duration, delay, easing) {
    return { duration: duration, delay: delay, easing: easing };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

/**
 * @param {?} element
 * @param {?} keyframes
 * @param {?} preStyleProps
 * @param {?} postStyleProps
 * @param {?} duration
 * @param {?} delay
 * @param {?=} easing
 * @param {?=} subTimeline
 * @return {?}
 */
function createTimelineInstruction(element, keyframes, preStyleProps, postStyleProps, duration, delay, easing, subTimeline) {
    if (easing === void 0) { easing = null; }
    if (subTimeline === void 0) { subTimeline = false; }
    return {
        type: 1 /* TimelineAnimation */,
        element: element,
        keyframes: keyframes,
        preStyleProps: preStyleProps,
        postStyleProps: postStyleProps,
        duration: duration,
        delay: delay,
        totalTime: duration + delay, easing: easing, subTimeline: subTimeline
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ElementInstructionMap = /** @class */ (function () {
    function ElementInstructionMap() {
        this._map = new Map();
    }
    /**
     * @param {?} element
     * @return {?}
     */
    ElementInstructionMap.prototype.consume = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ instructions = this._map.get(element);
        if (instructions) {
            this._map.delete(element);
        }
        else {
            instructions = [];
        }
        return instructions;
    };
    /**
     * @param {?} element
     * @param {?} instructions
     * @return {?}
     */
    ElementInstructionMap.prototype.append = /**
     * @param {?} element
     * @param {?} instructions
     * @return {?}
     */
    function (element, instructions) {
        var /** @type {?} */ existingInstructions = this._map.get(element);
        if (!existingInstructions) {
            this._map.set(element, existingInstructions = []);
        }
        existingInstructions.push.apply(existingInstructions, instructions);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    ElementInstructionMap.prototype.has = /**
     * @param {?} element
     * @return {?}
     */
    function (element) { return this._map.has(element); };
    /**
     * @return {?}
     */
    ElementInstructionMap.prototype.clear = /**
     * @return {?}
     */
    function () { this._map.clear(); };
    return ElementInstructionMap;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ONE_FRAME_IN_MILLISECONDS = 1;
var ENTER_TOKEN = ':enter';
var ENTER_TOKEN_REGEX = new RegExp(ENTER_TOKEN, 'g');
var LEAVE_TOKEN = ':leave';
var LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, 'g');
/**
 * @param {?} driver
 * @param {?} rootElement
 * @param {?} ast
 * @param {?} enterClassName
 * @param {?} leaveClassName
 * @param {?=} startingStyles
 * @param {?=} finalStyles
 * @param {?=} options
 * @param {?=} subInstructions
 * @param {?=} errors
 * @return {?}
 */
function buildAnimationTimelines(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors) {
    if (startingStyles === void 0) { startingStyles = {}; }
    if (finalStyles === void 0) { finalStyles = {}; }
    if (errors === void 0) { errors = []; }
    return new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors);
}
var AnimationTimelineBuilderVisitor = /** @class */ (function () {
    function AnimationTimelineBuilderVisitor() {
    }
    /**
     * @param {?} driver
     * @param {?} rootElement
     * @param {?} ast
     * @param {?} enterClassName
     * @param {?} leaveClassName
     * @param {?} startingStyles
     * @param {?} finalStyles
     * @param {?} options
     * @param {?=} subInstructions
     * @param {?=} errors
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.buildKeyframes = /**
     * @param {?} driver
     * @param {?} rootElement
     * @param {?} ast
     * @param {?} enterClassName
     * @param {?} leaveClassName
     * @param {?} startingStyles
     * @param {?} finalStyles
     * @param {?} options
     * @param {?=} subInstructions
     * @param {?=} errors
     * @return {?}
     */
    function (driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors) {
        if (errors === void 0) { errors = []; }
        subInstructions = subInstructions || new ElementInstructionMap();
        var /** @type {?} */ context = new AnimationTimelineContext(driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);
        context.options = options;
        context.currentTimeline.setStyles([startingStyles], null, context.errors, options);
        visitDslNode(this, ast, context);
        // this checks to see if an actual animation happened
        var /** @type {?} */ timelines = context.timelines.filter(function (timeline) { return timeline.containsAnimation(); });
        if (timelines.length && Object.keys(finalStyles).length) {
            var /** @type {?} */ tl = timelines[timelines.length - 1];
            if (!tl.allowOnlyTimelineStyles()) {
                tl.setStyles([finalStyles], null, context.errors, options);
            }
        }
        return timelines.length ? timelines.map(function (timeline) { return timeline.buildKeyframes(); }) :
            [createTimelineInstruction(rootElement, [], [], [], 0, 0, '', false)];
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitTrigger = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        // these values are not visited in this AST
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitState = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        // these values are not visited in this AST
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitTransition = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        // these values are not visited in this AST
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitAnimateChild = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ elementInstructions = context.subInstructions.consume(context.element);
        if (elementInstructions) {
            var /** @type {?} */ innerContext = context.createSubContext(ast.options);
            var /** @type {?} */ startTime = context.currentTimeline.currentTime;
            var /** @type {?} */ endTime = this._visitSubInstructions(elementInstructions, innerContext, /** @type {?} */ (innerContext.options));
            if (startTime != endTime) {
                // we do this on the upper context because we created a sub context for
                // the sub child animations
                context.transformIntoNewTimeline(endTime);
            }
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitAnimateRef = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ innerContext = context.createSubContext(ast.options);
        innerContext.transformIntoNewTimeline();
        this.visitReference(ast.animation, innerContext);
        context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);
        context.previousNode = ast;
    };
    /**
     * @param {?} instructions
     * @param {?} context
     * @param {?} options
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype._visitSubInstructions = /**
     * @param {?} instructions
     * @param {?} context
     * @param {?} options
     * @return {?}
     */
    function (instructions, context, options) {
        var /** @type {?} */ startTime = context.currentTimeline.currentTime;
        var /** @type {?} */ furthestTime = startTime;
        // this is a special-case for when a user wants to skip a sub
        // animation from being fired entirely.
        var /** @type {?} */ duration = options.duration != null ? resolveTimingValue(options.duration) : null;
        var /** @type {?} */ delay = options.delay != null ? resolveTimingValue(options.delay) : null;
        if (duration !== 0) {
            instructions.forEach(function (instruction) {
                var /** @type {?} */ instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay);
                furthestTime =
                    Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);
            });
        }
        return furthestTime;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitReference = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        context.updateOptions(ast.options, true);
        visitDslNode(this, ast.animation, context);
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitSequence = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var _this = this;
        var /** @type {?} */ subContextCount = context.subContextCount;
        var /** @type {?} */ ctx = context;
        var /** @type {?} */ options = ast.options;
        if (options && (options.params || options.delay)) {
            ctx = context.createSubContext(options);
            ctx.transformIntoNewTimeline();
            if (options.delay != null) {
                if (ctx.previousNode.type == 6 /* Style */) {
                    ctx.currentTimeline.snapshotCurrentStyles();
                    ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
                }
                var /** @type {?} */ delay = resolveTimingValue(options.delay);
                ctx.delayNextStep(delay);
            }
        }
        if (ast.steps.length) {
            ast.steps.forEach(function (s) { return visitDslNode(_this, s, ctx); });
            // this is here just incase the inner steps only contain or end with a style() call
            ctx.currentTimeline.applyStylesToKeyframe();
            // this means that some animation function within the sequence
            // ended up creating a sub timeline (which means the current
            // timeline cannot overlap with the contents of the sequence)
            if (ctx.subContextCount > subContextCount) {
                ctx.transformIntoNewTimeline();
            }
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitGroup = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var _this = this;
        var /** @type {?} */ innerTimelines = [];
        var /** @type {?} */ furthestTime = context.currentTimeline.currentTime;
        var /** @type {?} */ delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;
        ast.steps.forEach(function (s) {
            var /** @type {?} */ innerContext = context.createSubContext(ast.options);
            if (delay) {
                innerContext.delayNextStep(delay);
            }
            visitDslNode(_this, s, innerContext);
            furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);
            innerTimelines.push(innerContext.currentTimeline);
        });
        // this operation is run after the AST loop because otherwise
        // if the parent timeline's collected styles were updated then
        // it would pass in invalid data into the new-to-be forked items
        innerTimelines.forEach(function (timeline) { return context.currentTimeline.mergeTimelineCollectedStyles(timeline); });
        context.transformIntoNewTimeline(furthestTime);
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype._visitTiming = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        if ((/** @type {?} */ (ast)).dynamic) {
            var /** @type {?} */ strValue = (/** @type {?} */ (ast)).strValue;
            var /** @type {?} */ timingValue = context.params ? interpolateParams(strValue, context.params, context.errors) : strValue;
            return resolveTiming(timingValue, context.errors);
        }
        else {
            return { duration: ast.duration, delay: ast.delay, easing: ast.easing };
        }
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitAnimate = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ timings = context.currentAnimateTimings = this._visitTiming(ast.timings, context);
        var /** @type {?} */ timeline = context.currentTimeline;
        if (timings.delay) {
            context.incrementTime(timings.delay);
            timeline.snapshotCurrentStyles();
        }
        var /** @type {?} */ style$$1 = ast.style;
        if (style$$1.type == 5 /* Keyframes */) {
            this.visitKeyframes(style$$1, context);
        }
        else {
            context.incrementTime(timings.duration);
            this.visitStyle(/** @type {?} */ (style$$1), context);
            timeline.applyStylesToKeyframe();
        }
        context.currentAnimateTimings = null;
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitStyle = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ timeline = context.currentTimeline;
        var /** @type {?} */ timings = /** @type {?} */ ((context.currentAnimateTimings));
        // this is a special case for when a style() call
        // directly follows  an animate() call (but not inside of an animate() call)
        if (!timings && timeline.getCurrentStyleProperties().length) {
            timeline.forwardFrame();
        }
        var /** @type {?} */ easing = (timings && timings.easing) || ast.easing;
        if (ast.isEmptyStep) {
            timeline.applyEmptyStep(easing);
        }
        else {
            timeline.setStyles(ast.styles, easing, context.errors, context.options);
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitKeyframes = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ currentAnimateTimings = /** @type {?} */ ((context.currentAnimateTimings));
        var /** @type {?} */ startTime = (/** @type {?} */ ((context.currentTimeline))).duration;
        var /** @type {?} */ duration = currentAnimateTimings.duration;
        var /** @type {?} */ innerContext = context.createSubContext();
        var /** @type {?} */ innerTimeline = innerContext.currentTimeline;
        innerTimeline.easing = currentAnimateTimings.easing;
        ast.styles.forEach(function (step) {
            var /** @type {?} */ offset = step.offset || 0;
            innerTimeline.forwardTime(offset * duration);
            innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);
            innerTimeline.applyStylesToKeyframe();
        });
        // this will ensure that the parent timeline gets all the styles from
        // the child even if the new timeline below is not used
        context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);
        // we do this because the window between this timeline and the sub timeline
        // should ensure that the styles within are exactly the same as they were before
        context.transformIntoNewTimeline(startTime + duration);
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitQuery = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var _this = this;
        // in the event that the first step before this is a style step we need
        // to ensure the styles are applied before the children are animated
        var /** @type {?} */ startTime = context.currentTimeline.currentTime;
        var /** @type {?} */ options = /** @type {?} */ ((ast.options || {}));
        var /** @type {?} */ delay = options.delay ? resolveTimingValue(options.delay) : 0;
        if (delay && (context.previousNode.type === 6 /* Style */ ||
            (startTime == 0 && context.currentTimeline.getCurrentStyleProperties().length))) {
            context.currentTimeline.snapshotCurrentStyles();
            context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        }
        var /** @type {?} */ furthestTime = startTime;
        var /** @type {?} */ elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, options.optional ? true : false, context.errors);
        context.currentQueryTotal = elms.length;
        var /** @type {?} */ sameElementTimeline = null;
        elms.forEach(function (element, i) {
            context.currentQueryIndex = i;
            var /** @type {?} */ innerContext = context.createSubContext(ast.options, element);
            if (delay) {
                innerContext.delayNextStep(delay);
            }
            if (element === context.element) {
                sameElementTimeline = innerContext.currentTimeline;
            }
            visitDslNode(_this, ast.animation, innerContext);
            // this is here just incase the inner steps only contain or end
            // with a style() call (which is here to signal that this is a preparatory
            // call to style an element before it is animated again)
            innerContext.currentTimeline.applyStylesToKeyframe();
            var /** @type {?} */ endTime = innerContext.currentTimeline.currentTime;
            furthestTime = Math.max(furthestTime, endTime);
        });
        context.currentQueryIndex = 0;
        context.currentQueryTotal = 0;
        context.transformIntoNewTimeline(furthestTime);
        if (sameElementTimeline) {
            context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);
            context.currentTimeline.snapshotCurrentStyles();
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitStagger = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ parentContext = /** @type {?} */ ((context.parentContext));
        var /** @type {?} */ tl = context.currentTimeline;
        var /** @type {?} */ timings = ast.timings;
        var /** @type {?} */ duration = Math.abs(timings.duration);
        var /** @type {?} */ maxTime = duration * (context.currentQueryTotal - 1);
        var /** @type {?} */ delay = duration * context.currentQueryIndex;
        var /** @type {?} */ staggerTransformer = timings.duration < 0 ? 'reverse' : timings.easing;
        switch (staggerTransformer) {
            case 'reverse':
                delay = maxTime - delay;
                break;
            case 'full':
                delay = parentContext.currentStaggerTime;
                break;
        }
        var /** @type {?} */ timeline = context.currentTimeline;
        if (delay) {
            timeline.delayNextStep(delay);
        }
        var /** @type {?} */ startingTime = timeline.currentTime;
        visitDslNode(this, ast.animation, context);
        context.previousNode = ast;
        // time = duration + delay
        // the reason why this computation is so complex is because
        // the inner timeline may either have a delay value or a stretched
        // keyframe depending on if a subtimeline is not used or is used.
        parentContext.currentStaggerTime =
            (tl.currentTime - startingTime) + (tl.startTime - parentContext.currentTimeline.startTime);
    };
    return AnimationTimelineBuilderVisitor;
}());
var DEFAULT_NOOP_PREVIOUS_NODE = /** @type {?} */ ({});
var AnimationTimelineContext = /** @class */ (function () {
    function AnimationTimelineContext(_driver, element, subInstructions, _enterClassName, _leaveClassName, errors, timelines, initialTimeline) {
        this._driver = _driver;
        this.element = element;
        this.subInstructions = subInstructions;
        this._enterClassName = _enterClassName;
        this._leaveClassName = _leaveClassName;
        this.errors = errors;
        this.timelines = timelines;
        this.parentContext = null;
        this.currentAnimateTimings = null;
        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        this.subContextCount = 0;
        this.options = {};
        this.currentQueryIndex = 0;
        this.currentQueryTotal = 0;
        this.currentStaggerTime = 0;
        this.currentTimeline = initialTimeline || new TimelineBuilder(this._driver, element, 0);
        timelines.push(this.currentTimeline);
    }
    Object.defineProperty(AnimationTimelineContext.prototype, "params", {
        get: /**
         * @return {?}
         */
        function () { return this.options.params; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} options
     * @param {?=} skipIfExists
     * @return {?}
     */
    AnimationTimelineContext.prototype.updateOptions = /**
     * @param {?} options
     * @param {?=} skipIfExists
     * @return {?}
     */
    function (options, skipIfExists) {
        var _this = this;
        if (!options)
            return;
        var /** @type {?} */ newOptions = /** @type {?} */ (options);
        var /** @type {?} */ optionsToUpdate = this.options;
        // NOTE: this will get patched up when other animation methods support duration overrides
        if (newOptions.duration != null) {
            (/** @type {?} */ (optionsToUpdate)).duration = resolveTimingValue(newOptions.duration);
        }
        if (newOptions.delay != null) {
            optionsToUpdate.delay = resolveTimingValue(newOptions.delay);
        }
        var /** @type {?} */ newParams = newOptions.params;
        if (newParams) {
            var /** @type {?} */ paramsToUpdate_1 = /** @type {?} */ ((optionsToUpdate.params));
            if (!paramsToUpdate_1) {
                paramsToUpdate_1 = this.options.params = {};
            }
            Object.keys(newParams).forEach(function (name) {
                if (!skipIfExists || !paramsToUpdate_1.hasOwnProperty(name)) {
                    paramsToUpdate_1[name] = interpolateParams(newParams[name], paramsToUpdate_1, _this.errors);
                }
            });
        }
    };
    /**
     * @return {?}
     */
    AnimationTimelineContext.prototype._copyOptions = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ options = {};
        if (this.options) {
            var /** @type {?} */ oldParams_1 = this.options.params;
            if (oldParams_1) {
                var /** @type {?} */ params_1 = options['params'] = {};
                Object.keys(oldParams_1).forEach(function (name) { params_1[name] = oldParams_1[name]; });
            }
        }
        return options;
    };
    /**
     * @param {?=} options
     * @param {?=} element
     * @param {?=} newTime
     * @return {?}
     */
    AnimationTimelineContext.prototype.createSubContext = /**
     * @param {?=} options
     * @param {?=} element
     * @param {?=} newTime
     * @return {?}
     */
    function (options, element, newTime) {
        if (options === void 0) { options = null; }
        var /** @type {?} */ target = element || this.element;
        var /** @type {?} */ context = new AnimationTimelineContext(this._driver, target, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));
        context.previousNode = this.previousNode;
        context.currentAnimateTimings = this.currentAnimateTimings;
        context.options = this._copyOptions();
        context.updateOptions(options);
        context.currentQueryIndex = this.currentQueryIndex;
        context.currentQueryTotal = this.currentQueryTotal;
        context.parentContext = this;
        this.subContextCount++;
        return context;
    };
    /**
     * @param {?=} newTime
     * @return {?}
     */
    AnimationTimelineContext.prototype.transformIntoNewTimeline = /**
     * @param {?=} newTime
     * @return {?}
     */
    function (newTime) {
        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        this.currentTimeline = this.currentTimeline.fork(this.element, newTime);
        this.timelines.push(this.currentTimeline);
        return this.currentTimeline;
    };
    /**
     * @param {?} instruction
     * @param {?} duration
     * @param {?} delay
     * @return {?}
     */
    AnimationTimelineContext.prototype.appendInstructionToTimeline = /**
     * @param {?} instruction
     * @param {?} duration
     * @param {?} delay
     * @return {?}
     */
    function (instruction, duration, delay) {
        var /** @type {?} */ updatedTimings = {
            duration: duration != null ? duration : instruction.duration,
            delay: this.currentTimeline.currentTime + (delay != null ? delay : 0) + instruction.delay,
            easing: ''
        };
        var /** @type {?} */ builder = new SubTimelineBuilder(this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);
        this.timelines.push(builder);
        return updatedTimings;
    };
    /**
     * @param {?} time
     * @return {?}
     */
    AnimationTimelineContext.prototype.incrementTime = /**
     * @param {?} time
     * @return {?}
     */
    function (time) {
        this.currentTimeline.forwardTime(this.currentTimeline.duration + time);
    };
    /**
     * @param {?} delay
     * @return {?}
     */
    AnimationTimelineContext.prototype.delayNextStep = /**
     * @param {?} delay
     * @return {?}
     */
    function (delay) {
        // negative delays are not yet supported
        if (delay > 0) {
            this.currentTimeline.delayNextStep(delay);
        }
    };
    /**
     * @param {?} selector
     * @param {?} originalSelector
     * @param {?} limit
     * @param {?} includeSelf
     * @param {?} optional
     * @param {?} errors
     * @return {?}
     */
    AnimationTimelineContext.prototype.invokeQuery = /**
     * @param {?} selector
     * @param {?} originalSelector
     * @param {?} limit
     * @param {?} includeSelf
     * @param {?} optional
     * @param {?} errors
     * @return {?}
     */
    function (selector, originalSelector, limit, includeSelf, optional, errors) {
        var /** @type {?} */ results = [];
        if (includeSelf) {
            results.push(this.element);
        }
        if (selector.length > 0) {
            // if :self is only used then the selector is empty
            selector = selector.replace(ENTER_TOKEN_REGEX, '.' + this._enterClassName);
            selector = selector.replace(LEAVE_TOKEN_REGEX, '.' + this._leaveClassName);
            var /** @type {?} */ multi = limit != 1;
            var /** @type {?} */ elements = this._driver.query(this.element, selector, multi);
            if (limit !== 0) {
                elements = limit < 0 ? elements.slice(elements.length + limit, elements.length) :
                    elements.slice(0, limit);
            }
            results.push.apply(results, elements);
        }
        if (!optional && results.length == 0) {
            errors.push("`query(\"" + originalSelector + "\")` returned zero elements. (Use `query(\"" + originalSelector + "\", { optional: true })` if you wish to allow this.)");
        }
        return results;
    };
    return AnimationTimelineContext;
}());
var TimelineBuilder = /** @class */ (function () {
    function TimelineBuilder(_driver, element, startTime, _elementTimelineStylesLookup) {
        this._driver = _driver;
        this.element = element;
        this.startTime = startTime;
        this._elementTimelineStylesLookup = _elementTimelineStylesLookup;
        this.duration = 0;
        this._previousKeyframe = {};
        this._currentKeyframe = {};
        this._keyframes = new Map();
        this._styleSummary = {};
        this._pendingStyles = {};
        this._backFill = {};
        this._currentEmptyStepKeyframe = null;
        if (!this._elementTimelineStylesLookup) {
            this._elementTimelineStylesLookup = new Map();
        }
        this._localTimelineStyles = Object.create(this._backFill, {});
        this._globalTimelineStyles = /** @type {?} */ ((this._elementTimelineStylesLookup.get(element)));
        if (!this._globalTimelineStyles) {
            this._globalTimelineStyles = this._localTimelineStyles;
            this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);
        }
        this._loadKeyframe();
    }
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.containsAnimation = /**
     * @return {?}
     */
    function () {
        switch (this._keyframes.size) {
            case 0:
                return false;
            case 1:
                return this.getCurrentStyleProperties().length > 0;
            default:
                return true;
        }
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.getCurrentStyleProperties = /**
     * @return {?}
     */
    function () { return Object.keys(this._currentKeyframe); };
    Object.defineProperty(TimelineBuilder.prototype, "currentTime", {
        get: /**
         * @return {?}
         */
        function () { return this.startTime + this.duration; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} delay
     * @return {?}
     */
    TimelineBuilder.prototype.delayNextStep = /**
     * @param {?} delay
     * @return {?}
     */
    function (delay) {
        // in the event that a style() step is placed right before a stagger()
        // and that style() step is the very first style() value in the animation
        // then we need to make a copy of the keyframe [0, copy, 1] so that the delay
        // properly applies the style() values to work with the stagger...
        var /** @type {?} */ hasPreStyleStep = this._keyframes.size == 1 && Object.keys(this._pendingStyles).length;
        if (this.duration || hasPreStyleStep) {
            this.forwardTime(this.currentTime + delay);
            if (hasPreStyleStep) {
                this.snapshotCurrentStyles();
            }
        }
        else {
            this.startTime += delay;
        }
    };
    /**
     * @param {?} element
     * @param {?=} currentTime
     * @return {?}
     */
    TimelineBuilder.prototype.fork = /**
     * @param {?} element
     * @param {?=} currentTime
     * @return {?}
     */
    function (element, currentTime) {
        this.applyStylesToKeyframe();
        return new TimelineBuilder(this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype._loadKeyframe = /**
     * @return {?}
     */
    function () {
        if (this._currentKeyframe) {
            this._previousKeyframe = this._currentKeyframe;
        }
        this._currentKeyframe = /** @type {?} */ ((this._keyframes.get(this.duration)));
        if (!this._currentKeyframe) {
            this._currentKeyframe = Object.create(this._backFill, {});
            this._keyframes.set(this.duration, this._currentKeyframe);
        }
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.forwardFrame = /**
     * @return {?}
     */
    function () {
        this.duration += ONE_FRAME_IN_MILLISECONDS;
        this._loadKeyframe();
    };
    /**
     * @param {?} time
     * @return {?}
     */
    TimelineBuilder.prototype.forwardTime = /**
     * @param {?} time
     * @return {?}
     */
    function (time) {
        this.applyStylesToKeyframe();
        this.duration = time;
        this._loadKeyframe();
    };
    /**
     * @param {?} prop
     * @param {?} value
     * @return {?}
     */
    TimelineBuilder.prototype._updateStyle = /**
     * @param {?} prop
     * @param {?} value
     * @return {?}
     */
    function (prop, value) {
        this._localTimelineStyles[prop] = value;
        this._globalTimelineStyles[prop] = value;
        this._styleSummary[prop] = { time: this.currentTime, value: value };
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.allowOnlyTimelineStyles = /**
     * @return {?}
     */
    function () { return this._currentEmptyStepKeyframe !== this._currentKeyframe; };
    /**
     * @param {?} easing
     * @return {?}
     */
    TimelineBuilder.prototype.applyEmptyStep = /**
     * @param {?} easing
     * @return {?}
     */
    function (easing) {
        var _this = this;
        if (easing) {
            this._previousKeyframe['easing'] = easing;
        }
        // special case for animate(duration):
        // all missing styles are filled with a `*` value then
        // if any destination styles are filled in later on the same
        // keyframe then they will override the overridden styles
        // We use `_globalTimelineStyles` here because there may be
        // styles in previous keyframes that are not present in this timeline
        Object.keys(this._globalTimelineStyles).forEach(function (prop) {
            _this._backFill[prop] = _this._globalTimelineStyles[prop] || _angular_animations.AUTO_STYLE;
            _this._currentKeyframe[prop] = _angular_animations.AUTO_STYLE;
        });
        this._currentEmptyStepKeyframe = this._currentKeyframe;
    };
    /**
     * @param {?} input
     * @param {?} easing
     * @param {?} errors
     * @param {?=} options
     * @return {?}
     */
    TimelineBuilder.prototype.setStyles = /**
     * @param {?} input
     * @param {?} easing
     * @param {?} errors
     * @param {?=} options
     * @return {?}
     */
    function (input, easing, errors, options) {
        var _this = this;
        if (easing) {
            this._previousKeyframe['easing'] = easing;
        }
        var /** @type {?} */ params = (options && options.params) || {};
        var /** @type {?} */ styles = flattenStyles(input, this._globalTimelineStyles);
        Object.keys(styles).forEach(function (prop) {
            var /** @type {?} */ val = interpolateParams(styles[prop], params, errors);
            _this._pendingStyles[prop] = val;
            if (!_this._localTimelineStyles.hasOwnProperty(prop)) {
                _this._backFill[prop] = _this._globalTimelineStyles.hasOwnProperty(prop) ?
                    _this._globalTimelineStyles[prop] :
                    _angular_animations.AUTO_STYLE;
            }
            _this._updateStyle(prop, val);
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.applyStylesToKeyframe = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ styles = this._pendingStyles;
        var /** @type {?} */ props = Object.keys(styles);
        if (props.length == 0)
            return;
        this._pendingStyles = {};
        props.forEach(function (prop) {
            var /** @type {?} */ val = styles[prop];
            _this._currentKeyframe[prop] = val;
        });
        Object.keys(this._localTimelineStyles).forEach(function (prop) {
            if (!_this._currentKeyframe.hasOwnProperty(prop)) {
                _this._currentKeyframe[prop] = _this._localTimelineStyles[prop];
            }
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.snapshotCurrentStyles = /**
     * @return {?}
     */
    function () {
        var _this = this;
        Object.keys(this._localTimelineStyles).forEach(function (prop) {
            var /** @type {?} */ val = _this._localTimelineStyles[prop];
            _this._pendingStyles[prop] = val;
            _this._updateStyle(prop, val);
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.getFinalKeyframe = /**
     * @return {?}
     */
    function () { return this._keyframes.get(this.duration); };
    Object.defineProperty(TimelineBuilder.prototype, "properties", {
        get: /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ properties = [];
            for (var /** @type {?} */ prop in this._currentKeyframe) {
                properties.push(prop);
            }
            return properties;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} timeline
     * @return {?}
     */
    TimelineBuilder.prototype.mergeTimelineCollectedStyles = /**
     * @param {?} timeline
     * @return {?}
     */
    function (timeline) {
        var _this = this;
        Object.keys(timeline._styleSummary).forEach(function (prop) {
            var /** @type {?} */ details0 = _this._styleSummary[prop];
            var /** @type {?} */ details1 = timeline._styleSummary[prop];
            if (!details0 || details1.time > details0.time) {
                _this._updateStyle(prop, details1.value);
            }
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.buildKeyframes = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.applyStylesToKeyframe();
        var /** @type {?} */ preStyleProps = new Set();
        var /** @type {?} */ postStyleProps = new Set();
        var /** @type {?} */ isEmpty = this._keyframes.size === 1 && this.duration === 0;
        var /** @type {?} */ finalKeyframes = [];
        this._keyframes.forEach(function (keyframe, time) {
            var /** @type {?} */ finalKeyframe = copyStyles(keyframe, true);
            Object.keys(finalKeyframe).forEach(function (prop) {
                var /** @type {?} */ value = finalKeyframe[prop];
                if (value == _angular_animations.ɵPRE_STYLE) {
                    preStyleProps.add(prop);
                }
                else if (value == _angular_animations.AUTO_STYLE) {
                    postStyleProps.add(prop);
                }
            });
            if (!isEmpty) {
                finalKeyframe['offset'] = time / _this.duration;
            }
            finalKeyframes.push(finalKeyframe);
        });
        var /** @type {?} */ preProps = preStyleProps.size ? iteratorToArray(preStyleProps.values()) : [];
        var /** @type {?} */ postProps = postStyleProps.size ? iteratorToArray(postStyleProps.values()) : [];
        // special case for a 0-second animation (which is designed just to place styles onscreen)
        if (isEmpty) {
            var /** @type {?} */ kf0 = finalKeyframes[0];
            var /** @type {?} */ kf1 = copyObj(kf0);
            kf0['offset'] = 0;
            kf1['offset'] = 1;
            finalKeyframes = [kf0, kf1];
        }
        return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, false);
    };
    return TimelineBuilder;
}());
var SubTimelineBuilder = /** @class */ (function (_super) {
    __extends(SubTimelineBuilder, _super);
    function SubTimelineBuilder(driver, element, keyframes, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe) {
        if (_stretchStartingKeyframe === void 0) { _stretchStartingKeyframe = false; }
        var _this = _super.call(this, driver, element, timings.delay) || this;
        _this.element = element;
        _this.keyframes = keyframes;
        _this.preStyleProps = preStyleProps;
        _this.postStyleProps = postStyleProps;
        _this._stretchStartingKeyframe = _stretchStartingKeyframe;
        _this.timings = { duration: timings.duration, delay: timings.delay, easing: timings.easing };
        return _this;
    }
    /**
     * @return {?}
     */
    SubTimelineBuilder.prototype.containsAnimation = /**
     * @return {?}
     */
    function () { return this.keyframes.length > 1; };
    /**
     * @return {?}
     */
    SubTimelineBuilder.prototype.buildKeyframes = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ keyframes = this.keyframes;
        var _a = this.timings, delay = _a.delay, duration = _a.duration, easing = _a.easing;
        if (this._stretchStartingKeyframe && delay) {
            var /** @type {?} */ newKeyframes = [];
            var /** @type {?} */ totalTime = duration + delay;
            var /** @type {?} */ startingGap = delay / totalTime;
            // the original starting keyframe now starts once the delay is done
            var /** @type {?} */ newFirstKeyframe = copyStyles(keyframes[0], false);
            newFirstKeyframe['offset'] = 0;
            newKeyframes.push(newFirstKeyframe);
            var /** @type {?} */ oldFirstKeyframe = copyStyles(keyframes[0], false);
            oldFirstKeyframe['offset'] = roundOffset(startingGap);
            newKeyframes.push(oldFirstKeyframe);
            /*
                    When the keyframe is stretched then it means that the delay before the animation
                    starts is gone. Instead the first keyframe is placed at the start of the animation
                    and it is then copied to where it starts when the original delay is over. This basically
                    means nothing animates during that delay, but the styles are still renderered. For this
                    to work the original offset values that exist in the original keyframes must be "warped"
                    so that they can take the new keyframe + delay into account.
            
                    delay=1000, duration=1000, keyframes = 0 .5 1
            
                    turns into
            
                    delay=0, duration=2000, keyframes = 0 .33 .66 1
                   */
            // offsets between 1 ... n -1 are all warped by the keyframe stretch
            var /** @type {?} */ limit = keyframes.length - 1;
            for (var /** @type {?} */ i = 1; i <= limit; i++) {
                var /** @type {?} */ kf = copyStyles(keyframes[i], false);
                var /** @type {?} */ oldOffset = /** @type {?} */ (kf['offset']);
                var /** @type {?} */ timeAtKeyframe = delay + oldOffset * duration;
                kf['offset'] = roundOffset(timeAtKeyframe / totalTime);
                newKeyframes.push(kf);
            }
            // the new starting keyframe should be added at the start
            duration = totalTime;
            delay = 0;
            easing = '';
            keyframes = newKeyframes;
        }
        return createTimelineInstruction(this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing, true);
    };
    return SubTimelineBuilder;
}(TimelineBuilder));
/**
 * @param {?} offset
 * @param {?=} decimalPoints
 * @return {?}
 */
function roundOffset(offset, decimalPoints) {
    if (decimalPoints === void 0) { decimalPoints = 3; }
    var /** @type {?} */ mult = Math.pow(10, decimalPoints - 1);
    return Math.round(offset * mult) / mult;
}
/**
 * @param {?} input
 * @param {?} allStyles
 * @return {?}
 */
function flattenStyles(input, allStyles) {
    var /** @type {?} */ styles = {};
    var /** @type {?} */ allProperties;
    input.forEach(function (token) {
        if (token === '*') {
            allProperties = allProperties || Object.keys(allStyles);
            allProperties.forEach(function (prop) { styles[prop] = _angular_animations.AUTO_STYLE; });
        }
        else {
            copyStyles(/** @type {?} */ (token), false, styles);
        }
    });
    return styles;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Animation = /** @class */ (function () {
    function Animation(_driver, input) {
        this._driver = _driver;
        var /** @type {?} */ errors = [];
        var /** @type {?} */ ast = buildAnimationAst(_driver, input, errors);
        if (errors.length) {
            var /** @type {?} */ errorMessage = "animation validation failed:\n" + errors.join("\n");
            throw new Error(errorMessage);
        }
        this._animationAst = ast;
    }
    /**
     * @param {?} element
     * @param {?} startingStyles
     * @param {?} destinationStyles
     * @param {?} options
     * @param {?=} subInstructions
     * @return {?}
     */
    Animation.prototype.buildTimelines = /**
     * @param {?} element
     * @param {?} startingStyles
     * @param {?} destinationStyles
     * @param {?} options
     * @param {?=} subInstructions
     * @return {?}
     */
    function (element, startingStyles, destinationStyles, options, subInstructions) {
        var /** @type {?} */ start = Array.isArray(startingStyles) ? normalizeStyles(startingStyles) : /** @type {?} */ (startingStyles);
        var /** @type {?} */ dest = Array.isArray(destinationStyles) ? normalizeStyles(destinationStyles) : /** @type {?} */ (destinationStyles);
        var /** @type {?} */ errors = [];
        subInstructions = subInstructions || new ElementInstructionMap();
        var /** @type {?} */ result = buildAnimationTimelines(this._driver, element, this._animationAst, ENTER_CLASSNAME, LEAVE_CLASSNAME, start, dest, options, subInstructions, errors);
        if (errors.length) {
            var /** @type {?} */ errorMessage = "animation building failed:\n" + errors.join("\n");
            throw new Error(errorMessage);
        }
        return result;
    };
    return Animation;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@experimental Animation support is experimental.
 * @abstract
 */
var AnimationStyleNormalizer = /** @class */ (function () {
    function AnimationStyleNormalizer() {
    }
    return AnimationStyleNormalizer;
}());
/**
 * \@experimental Animation support is experimental.
 */
var NoopAnimationStyleNormalizer = /** @class */ (function () {
    function NoopAnimationStyleNormalizer() {
    }
    /**
     * @param {?} propertyName
     * @param {?} errors
     * @return {?}
     */
    NoopAnimationStyleNormalizer.prototype.normalizePropertyName = /**
     * @param {?} propertyName
     * @param {?} errors
     * @return {?}
     */
    function (propertyName, errors) { return propertyName; };
    /**
     * @param {?} userProvidedProperty
     * @param {?} normalizedProperty
     * @param {?} value
     * @param {?} errors
     * @return {?}
     */
    NoopAnimationStyleNormalizer.prototype.normalizeStyleValue = /**
     * @param {?} userProvidedProperty
     * @param {?} normalizedProperty
     * @param {?} value
     * @param {?} errors
     * @return {?}
     */
    function (userProvidedProperty, normalizedProperty, value, errors) {
        return /** @type {?} */ (value);
    };
    return NoopAnimationStyleNormalizer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var WebAnimationsStyleNormalizer = /** @class */ (function (_super) {
    __extends(WebAnimationsStyleNormalizer, _super);
    function WebAnimationsStyleNormalizer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} propertyName
     * @param {?} errors
     * @return {?}
     */
    WebAnimationsStyleNormalizer.prototype.normalizePropertyName = /**
     * @param {?} propertyName
     * @param {?} errors
     * @return {?}
     */
    function (propertyName, errors) {
        return dashCaseToCamelCase(propertyName);
    };
    /**
     * @param {?} userProvidedProperty
     * @param {?} normalizedProperty
     * @param {?} value
     * @param {?} errors
     * @return {?}
     */
    WebAnimationsStyleNormalizer.prototype.normalizeStyleValue = /**
     * @param {?} userProvidedProperty
     * @param {?} normalizedProperty
     * @param {?} value
     * @param {?} errors
     * @return {?}
     */
    function (userProvidedProperty, normalizedProperty, value, errors) {
        var /** @type {?} */ unit = '';
        var /** @type {?} */ strVal = value.toString().trim();
        if (DIMENSIONAL_PROP_MAP[normalizedProperty] && value !== 0 && value !== '0') {
            if (typeof value === 'number') {
                unit = 'px';
            }
            else {
                var /** @type {?} */ valAndSuffixMatch = value.match(/^[+-]?[\d\.]+([a-z]*)$/);
                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
                    errors.push("Please provide a CSS unit value for " + userProvidedProperty + ":" + value);
                }
            }
        }
        return strVal + unit;
    };
    return WebAnimationsStyleNormalizer;
}(AnimationStyleNormalizer));
var DIMENSIONAL_PROP_MAP = makeBooleanMap('width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective'
    .split(','));
/**
 * @param {?} keys
 * @return {?}
 */
function makeBooleanMap(keys) {
    var /** @type {?} */ map = {};
    keys.forEach(function (key) { return map[key] = true; });
    return map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

/**
 * @param {?} element
 * @param {?} triggerName
 * @param {?} fromState
 * @param {?} toState
 * @param {?} isRemovalTransition
 * @param {?} fromStyles
 * @param {?} toStyles
 * @param {?} timelines
 * @param {?} queriedElements
 * @param {?} preStyleProps
 * @param {?} postStyleProps
 * @param {?=} errors
 * @return {?}
 */
function createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, errors) {
    return {
        type: 0 /* TransitionAnimation */,
        element: element,
        triggerName: triggerName,
        isRemovalTransition: isRemovalTransition,
        fromState: fromState,
        fromStyles: fromStyles,
        toState: toState,
        toStyles: toStyles,
        timelines: timelines,
        queriedElements: queriedElements,
        preStyleProps: preStyleProps,
        postStyleProps: postStyleProps,
        errors: errors
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var EMPTY_OBJECT = {};
var AnimationTransitionFactory = /** @class */ (function () {
    function AnimationTransitionFactory(_triggerName, ast, _stateStyles) {
        this._triggerName = _triggerName;
        this.ast = ast;
        this._stateStyles = _stateStyles;
    }
    /**
     * @param {?} currentState
     * @param {?} nextState
     * @return {?}
     */
    AnimationTransitionFactory.prototype.match = /**
     * @param {?} currentState
     * @param {?} nextState
     * @return {?}
     */
    function (currentState, nextState) {
        return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState);
    };
    /**
     * @param {?} stateName
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    AnimationTransitionFactory.prototype.buildStyles = /**
     * @param {?} stateName
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    function (stateName, params, errors) {
        var /** @type {?} */ backupStateStyler = this._stateStyles['*'];
        var /** @type {?} */ stateStyler = this._stateStyles[stateName];
        var /** @type {?} */ backupStyles = backupStateStyler ? backupStateStyler.buildStyles(params, errors) : {};
        return stateStyler ? stateStyler.buildStyles(params, errors) : backupStyles;
    };
    /**
     * @param {?} driver
     * @param {?} element
     * @param {?} currentState
     * @param {?} nextState
     * @param {?} enterClassName
     * @param {?} leaveClassName
     * @param {?=} currentOptions
     * @param {?=} nextOptions
     * @param {?=} subInstructions
     * @return {?}
     */
    AnimationTransitionFactory.prototype.build = /**
     * @param {?} driver
     * @param {?} element
     * @param {?} currentState
     * @param {?} nextState
     * @param {?} enterClassName
     * @param {?} leaveClassName
     * @param {?=} currentOptions
     * @param {?=} nextOptions
     * @param {?=} subInstructions
     * @return {?}
     */
    function (driver, element, currentState, nextState, enterClassName, leaveClassName, currentOptions, nextOptions, subInstructions) {
        var /** @type {?} */ errors = [];
        var /** @type {?} */ transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT;
        var /** @type {?} */ currentAnimationParams = currentOptions && currentOptions.params || EMPTY_OBJECT;
        var /** @type {?} */ currentStateStyles = this.buildStyles(currentState, currentAnimationParams, errors);
        var /** @type {?} */ nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT;
        var /** @type {?} */ nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors);
        var /** @type {?} */ queriedElements = new Set();
        var /** @type {?} */ preStyleMap = new Map();
        var /** @type {?} */ postStyleMap = new Map();
        var /** @type {?} */ isRemoval = nextState === 'void';
        var /** @type {?} */ animationOptions = { params: __assign({}, transitionAnimationParams, nextAnimationParams) };
        var /** @type {?} */ timelines = buildAnimationTimelines(driver, element, this.ast.animation, enterClassName, leaveClassName, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);
        if (errors.length) {
            return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, errors);
        }
        timelines.forEach(function (tl) {
            var /** @type {?} */ elm = tl.element;
            var /** @type {?} */ preProps = getOrSetAsInMap(preStyleMap, elm, {});
            tl.preStyleProps.forEach(function (prop) { return preProps[prop] = true; });
            var /** @type {?} */ postProps = getOrSetAsInMap(postStyleMap, elm, {});
            tl.postStyleProps.forEach(function (prop) { return postProps[prop] = true; });
            if (elm !== element) {
                queriedElements.add(elm);
            }
        });
        var /** @type {?} */ queriedElementsList = iteratorToArray(queriedElements.values());
        return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, queriedElementsList, preStyleMap, postStyleMap);
    };
    return AnimationTransitionFactory;
}());
/**
 * @param {?} matchFns
 * @param {?} currentState
 * @param {?} nextState
 * @return {?}
 */
function oneOrMoreTransitionsMatch(matchFns, currentState, nextState) {
    return matchFns.some(function (fn) { return fn(currentState, nextState); });
}
var AnimationStateStyles = /** @class */ (function () {
    function AnimationStateStyles(styles, defaultParams) {
        this.styles = styles;
        this.defaultParams = defaultParams;
    }
    /**
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    AnimationStateStyles.prototype.buildStyles = /**
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    function (params, errors) {
        var /** @type {?} */ finalStyles = {};
        var /** @type {?} */ combinedParams = copyObj(this.defaultParams);
        Object.keys(params).forEach(function (key) {
            var /** @type {?} */ value = params[key];
            if (value != null) {
                combinedParams[key] = value;
            }
        });
        this.styles.styles.forEach(function (value) {
            if (typeof value !== 'string') {
                var /** @type {?} */ styleObj_1 = /** @type {?} */ (value);
                Object.keys(styleObj_1).forEach(function (prop) {
                    var /** @type {?} */ val = styleObj_1[prop];
                    if (val.length > 1) {
                        val = interpolateParams(val, combinedParams, errors);
                    }
                    finalStyles[prop] = val;
                });
            }
        });
        return finalStyles;
    };
    return AnimationStateStyles;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@experimental Animation support is experimental.
 * @param {?} name
 * @param {?} ast
 * @return {?}
 */
function buildTrigger(name, ast) {
    return new AnimationTrigger(name, ast);
}
/**
 * \@experimental Animation support is experimental.
 */
var AnimationTrigger = /** @class */ (function () {
    function AnimationTrigger(name, ast) {
        var _this = this;
        this.name = name;
        this.ast = ast;
        this.transitionFactories = [];
        this.states = {};
        ast.states.forEach(function (ast) {
            var /** @type {?} */ defaultParams = (ast.options && ast.options.params) || {};
            _this.states[ast.name] = new AnimationStateStyles(ast.style, defaultParams);
        });
        balanceProperties(this.states, 'true', '1');
        balanceProperties(this.states, 'false', '0');
        ast.transitions.forEach(function (ast) {
            _this.transitionFactories.push(new AnimationTransitionFactory(name, ast, _this.states));
        });
        this.fallbackTransition = createFallbackTransition(name, this.states);
    }
    Object.defineProperty(AnimationTrigger.prototype, "containsQueries", {
        get: /**
         * @return {?}
         */
        function () { return this.ast.queryCount > 0; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} currentState
     * @param {?} nextState
     * @return {?}
     */
    AnimationTrigger.prototype.matchTransition = /**
     * @param {?} currentState
     * @param {?} nextState
     * @return {?}
     */
    function (currentState, nextState) {
        var /** @type {?} */ entry = this.transitionFactories.find(function (f) { return f.match(currentState, nextState); });
        return entry || null;
    };
    /**
     * @param {?} currentState
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    AnimationTrigger.prototype.matchStyles = /**
     * @param {?} currentState
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    function (currentState, params, errors) {
        return this.fallbackTransition.buildStyles(currentState, params, errors);
    };
    return AnimationTrigger;
}());
/**
 * @param {?} triggerName
 * @param {?} states
 * @return {?}
 */
function createFallbackTransition(triggerName, states) {
    var /** @type {?} */ matchers = [function (fromState, toState) { return true; }];
    var /** @type {?} */ animation = { type: 2 /* Sequence */, steps: [], options: null };
    var /** @type {?} */ transition = {
        type: 1 /* Transition */,
        animation: animation,
        matchers: matchers,
        options: null,
        queryCount: 0,
        depCount: 0
    };
    return new AnimationTransitionFactory(triggerName, transition, states);
}
/**
 * @param {?} obj
 * @param {?} key1
 * @param {?} key2
 * @return {?}
 */
function balanceProperties(obj, key1, key2) {
    if (obj.hasOwnProperty(key1)) {
        if (!obj.hasOwnProperty(key2)) {
            obj[key2] = obj[key1];
        }
    }
    else if (obj.hasOwnProperty(key2)) {
        obj[key1] = obj[key2];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var EMPTY_INSTRUCTION_MAP = new ElementInstructionMap();
var TimelineAnimationEngine = /** @class */ (function () {
    function TimelineAnimationEngine(_driver, _normalizer) {
        this._driver = _driver;
        this._normalizer = _normalizer;
        this._animations = {};
        this._playersById = {};
        this.players = [];
    }
    /**
     * @param {?} id
     * @param {?} metadata
     * @return {?}
     */
    TimelineAnimationEngine.prototype.register = /**
     * @param {?} id
     * @param {?} metadata
     * @return {?}
     */
    function (id, metadata) {
        var /** @type {?} */ errors = [];
        var /** @type {?} */ ast = buildAnimationAst(this._driver, metadata, errors);
        if (errors.length) {
            throw new Error("Unable to build the animation due to the following errors: " + errors.join("\n"));
        }
        else {
            this._animations[id] = ast;
        }
    };
    /**
     * @param {?} i
     * @param {?} preStyles
     * @param {?=} postStyles
     * @return {?}
     */
    TimelineAnimationEngine.prototype._buildPlayer = /**
     * @param {?} i
     * @param {?} preStyles
     * @param {?=} postStyles
     * @return {?}
     */
    function (i, preStyles, postStyles) {
        var /** @type {?} */ element = i.element;
        var /** @type {?} */ keyframes = normalizeKeyframes(this._driver, this._normalizer, element, i.keyframes, preStyles, postStyles);
        return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, []);
    };
    /**
     * @param {?} id
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    TimelineAnimationEngine.prototype.create = /**
     * @param {?} id
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    function (id, element, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var /** @type {?} */ errors = [];
        var /** @type {?} */ ast = this._animations[id];
        var /** @type {?} */ instructions;
        var /** @type {?} */ autoStylesMap = new Map();
        if (ast) {
            instructions = buildAnimationTimelines(this._driver, element, ast, ENTER_CLASSNAME, LEAVE_CLASSNAME, {}, {}, options, EMPTY_INSTRUCTION_MAP, errors);
            instructions.forEach(function (inst) {
                var /** @type {?} */ styles = getOrSetAsInMap(autoStylesMap, inst.element, {});
                inst.postStyleProps.forEach(function (prop) { return styles[prop] = null; });
            });
        }
        else {
            errors.push('The requested animation doesn\'t exist or has already been destroyed');
            instructions = [];
        }
        if (errors.length) {
            throw new Error("Unable to create the animation due to the following errors: " + errors.join("\n"));
        }
        autoStylesMap.forEach(function (styles, element) {
            Object.keys(styles).forEach(function (prop) { styles[prop] = _this._driver.computeStyle(element, prop, _angular_animations.AUTO_STYLE); });
        });
        var /** @type {?} */ players = instructions.map(function (i) {
            var /** @type {?} */ styles = autoStylesMap.get(i.element);
            return _this._buildPlayer(i, {}, styles);
        });
        var /** @type {?} */ player = optimizeGroupPlayer(players);
        this._playersById[id] = player;
        player.onDestroy(function () { return _this.destroy(id); });
        this.players.push(player);
        return player;
    };
    /**
     * @param {?} id
     * @return {?}
     */
    TimelineAnimationEngine.prototype.destroy = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        var /** @type {?} */ player = this._getPlayer(id);
        player.destroy();
        delete this._playersById[id];
        var /** @type {?} */ index = this.players.indexOf(player);
        if (index >= 0) {
            this.players.splice(index, 1);
        }
    };
    /**
     * @param {?} id
     * @return {?}
     */
    TimelineAnimationEngine.prototype._getPlayer = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        var /** @type {?} */ player = this._playersById[id];
        if (!player) {
            throw new Error("Unable to find the timeline player referenced by " + id);
        }
        return player;
    };
    /**
     * @param {?} id
     * @param {?} element
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    TimelineAnimationEngine.prototype.listen = /**
     * @param {?} id
     * @param {?} element
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    function (id, element, eventName, callback) {
        // triggerName, fromState, toState are all ignored for timeline animations
        var /** @type {?} */ baseEvent = makeAnimationEvent(element, '', '', '');
        listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);
        return function () { };
    };
    /**
     * @param {?} id
     * @param {?} element
     * @param {?} command
     * @param {?} args
     * @return {?}
     */
    TimelineAnimationEngine.prototype.command = /**
     * @param {?} id
     * @param {?} element
     * @param {?} command
     * @param {?} args
     * @return {?}
     */
    function (id, element, command, args) {
        if (command == 'register') {
            this.register(id, /** @type {?} */ (args[0]));
            return;
        }
        if (command == 'create') {
            var /** @type {?} */ options = /** @type {?} */ ((args[0] || {}));
            this.create(id, element, options);
            return;
        }
        var /** @type {?} */ player = this._getPlayer(id);
        switch (command) {
            case 'play':
                player.play();
                break;
            case 'pause':
                player.pause();
                break;
            case 'reset':
                player.reset();
                break;
            case 'restart':
                player.restart();
                break;
            case 'finish':
                player.finish();
                break;
            case 'init':
                player.init();
                break;
            case 'setPosition':
                player.setPosition(parseFloat(/** @type {?} */ (args[0])));
                break;
            case 'destroy':
                this.destroy(id);
                break;
        }
    };
    return TimelineAnimationEngine;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var QUEUED_CLASSNAME = 'ng-animate-queued';
var QUEUED_SELECTOR = '.ng-animate-queued';
var DISABLED_CLASSNAME = 'ng-animate-disabled';
var DISABLED_SELECTOR = '.ng-animate-disabled';
var STAR_CLASSNAME = 'ng-star-inserted';
var STAR_SELECTOR = '.ng-star-inserted';
var EMPTY_PLAYER_ARRAY = [];
var NULL_REMOVAL_STATE = {
    namespaceId: '',
    setForRemoval: null,
    hasAnimation: false,
    removedBeforeQueried: false
};
var NULL_REMOVED_QUERIED_STATE = {
    namespaceId: '',
    setForRemoval: null,
    hasAnimation: false,
    removedBeforeQueried: true
};
/**
 * @record
 */

var REMOVAL_FLAG = '__ng_removed';
/**
 * @record
 */

var StateValue = /** @class */ (function () {
    function StateValue(input, namespaceId) {
        if (namespaceId === void 0) { namespaceId = ''; }
        this.namespaceId = namespaceId;
        var /** @type {?} */ isObj = input && input.hasOwnProperty('value');
        var /** @type {?} */ value = isObj ? input['value'] : input;
        this.value = normalizeTriggerValue(value);
        if (isObj) {
            var /** @type {?} */ options = copyObj(/** @type {?} */ (input));
            delete options['value'];
            this.options = /** @type {?} */ (options);
        }
        else {
            this.options = {};
        }
        if (!this.options.params) {
            this.options.params = {};
        }
    }
    Object.defineProperty(StateValue.prototype, "params", {
        get: /**
         * @return {?}
         */
        function () { return /** @type {?} */ (this.options.params); },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} options
     * @return {?}
     */
    StateValue.prototype.absorbOptions = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        var /** @type {?} */ newParams = options.params;
        if (newParams) {
            var /** @type {?} */ oldParams_1 = /** @type {?} */ ((this.options.params));
            Object.keys(newParams).forEach(function (prop) {
                if (oldParams_1[prop] == null) {
                    oldParams_1[prop] = newParams[prop];
                }
            });
        }
    };
    return StateValue;
}());
var VOID_VALUE = 'void';
var DEFAULT_STATE_VALUE = new StateValue(VOID_VALUE);
var DELETED_STATE_VALUE = new StateValue('DELETED');
var AnimationTransitionNamespace = /** @class */ (function () {
    function AnimationTransitionNamespace(id, hostElement, _engine) {
        this.id = id;
        this.hostElement = hostElement;
        this._engine = _engine;
        this.players = [];
        this._triggers = {};
        this._queue = [];
        this._elementListeners = new Map();
        this._hostClassName = 'ng-tns-' + id;
        addClass(hostElement, this._hostClassName);
    }
    /**
     * @param {?} element
     * @param {?} name
     * @param {?} phase
     * @param {?} callback
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.listen = /**
     * @param {?} element
     * @param {?} name
     * @param {?} phase
     * @param {?} callback
     * @return {?}
     */
    function (element, name, phase, callback) {
        var _this = this;
        if (!this._triggers.hasOwnProperty(name)) {
            throw new Error("Unable to listen on the animation trigger event \"" + phase + "\" because the animation trigger \"" + name + "\" doesn't exist!");
        }
        if (phase == null || phase.length == 0) {
            throw new Error("Unable to listen on the animation trigger \"" + name + "\" because the provided event is undefined!");
        }
        if (!isTriggerEventValid(phase)) {
            throw new Error("The provided animation trigger event \"" + phase + "\" for the animation trigger \"" + name + "\" is not supported!");
        }
        var /** @type {?} */ listeners = getOrSetAsInMap(this._elementListeners, element, []);
        var /** @type {?} */ data = { name: name, phase: phase, callback: callback };
        listeners.push(data);
        var /** @type {?} */ triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});
        if (!triggersWithStates.hasOwnProperty(name)) {
            addClass(element, NG_TRIGGER_CLASSNAME);
            addClass(element, NG_TRIGGER_CLASSNAME + '-' + name);
            triggersWithStates[name] = DEFAULT_STATE_VALUE;
        }
        return function () {
            // the event listener is removed AFTER the flush has occurred such
            // that leave animations callbacks can fire (otherwise if the node
            // is removed in between then the listeners would be deregistered)
            // the event listener is removed AFTER the flush has occurred such
            // that leave animations callbacks can fire (otherwise if the node
            // is removed in between then the listeners would be deregistered)
            _this._engine.afterFlush(function () {
                var /** @type {?} */ index = listeners.indexOf(data);
                if (index >= 0) {
                    listeners.splice(index, 1);
                }
                if (!_this._triggers[name]) {
                    delete triggersWithStates[name];
                }
            });
        };
    };
    /**
     * @param {?} name
     * @param {?} ast
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.register = /**
     * @param {?} name
     * @param {?} ast
     * @return {?}
     */
    function (name, ast) {
        if (this._triggers[name]) {
            // throw
            return false;
        }
        else {
            this._triggers[name] = ast;
            return true;
        }
    };
    /**
     * @param {?} name
     * @return {?}
     */
    AnimationTransitionNamespace.prototype._getTrigger = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        var /** @type {?} */ trigger = this._triggers[name];
        if (!trigger) {
            throw new Error("The provided animation trigger \"" + name + "\" has not been registered!");
        }
        return trigger;
    };
    /**
     * @param {?} element
     * @param {?} triggerName
     * @param {?} value
     * @param {?=} defaultToFallback
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.trigger = /**
     * @param {?} element
     * @param {?} triggerName
     * @param {?} value
     * @param {?=} defaultToFallback
     * @return {?}
     */
    function (element, triggerName, value, defaultToFallback) {
        var _this = this;
        if (defaultToFallback === void 0) { defaultToFallback = true; }
        var /** @type {?} */ trigger = this._getTrigger(triggerName);
        var /** @type {?} */ player = new TransitionAnimationPlayer(this.id, triggerName, element);
        var /** @type {?} */ triggersWithStates = this._engine.statesByElement.get(element);
        if (!triggersWithStates) {
            addClass(element, NG_TRIGGER_CLASSNAME);
            addClass(element, NG_TRIGGER_CLASSNAME + '-' + triggerName);
            this._engine.statesByElement.set(element, triggersWithStates = {});
        }
        var /** @type {?} */ fromState = triggersWithStates[triggerName];
        var /** @type {?} */ toState = new StateValue(value, this.id);
        var /** @type {?} */ isObj = value && value.hasOwnProperty('value');
        if (!isObj && fromState) {
            toState.absorbOptions(fromState.options);
        }
        triggersWithStates[triggerName] = toState;
        if (!fromState) {
            fromState = DEFAULT_STATE_VALUE;
        }
        else if (fromState === DELETED_STATE_VALUE) {
            return player;
        }
        var /** @type {?} */ isRemoval = toState.value === VOID_VALUE;
        // normally this isn't reached by here, however, if an object expression
        // is passed in then it may be a new object each time. Comparing the value
        // is important since that will stay the same despite there being a new object.
        // The removal arc here is special cased because the same element is triggered
        // twice in the event that it contains animations on the outer/inner portions
        // of the host container
        if (!isRemoval && fromState.value === toState.value) {
            // this means that despite the value not changing, some inner params
            // have changed which means that the animation final styles need to be applied
            if (!objEquals(fromState.params, toState.params)) {
                var /** @type {?} */ errors = [];
                var /** @type {?} */ fromStyles_1 = trigger.matchStyles(fromState.value, fromState.params, errors);
                var /** @type {?} */ toStyles_1 = trigger.matchStyles(toState.value, toState.params, errors);
                if (errors.length) {
                    this._engine.reportError(errors);
                }
                else {
                    this._engine.afterFlush(function () {
                        eraseStyles(element, fromStyles_1);
                        setStyles(element, toStyles_1);
                    });
                }
            }
            return;
        }
        var /** @type {?} */ playersOnElement = getOrSetAsInMap(this._engine.playersByElement, element, []);
        playersOnElement.forEach(function (player) {
            // only remove the player if it is queued on the EXACT same trigger/namespace
            // we only also deal with queued players here because if the animation has
            // started then we want to keep the player alive until the flush happens
            // (which is where the previousPlayers are passed into the new palyer)
            if (player.namespaceId == _this.id && player.triggerName == triggerName && player.queued) {
                player.destroy();
            }
        });
        var /** @type {?} */ transition = trigger.matchTransition(fromState.value, toState.value);
        var /** @type {?} */ isFallbackTransition = false;
        if (!transition) {
            if (!defaultToFallback)
                return;
            transition = trigger.fallbackTransition;
            isFallbackTransition = true;
        }
        this._engine.totalQueuedPlayers++;
        this._queue.push({ element: element, triggerName: triggerName, transition: transition, fromState: fromState, toState: toState, player: player, isFallbackTransition: isFallbackTransition });
        if (!isFallbackTransition) {
            addClass(element, QUEUED_CLASSNAME);
            player.onStart(function () { removeClass(element, QUEUED_CLASSNAME); });
        }
        player.onDone(function () {
            var /** @type {?} */ index = _this.players.indexOf(player);
            if (index >= 0) {
                _this.players.splice(index, 1);
            }
            var /** @type {?} */ players = _this._engine.playersByElement.get(element);
            if (players) {
                var /** @type {?} */ index_1 = players.indexOf(player);
                if (index_1 >= 0) {
                    players.splice(index_1, 1);
                }
            }
        });
        this.players.push(player);
        playersOnElement.push(player);
        return player;
    };
    /**
     * @param {?} name
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.deregister = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        var _this = this;
        delete this._triggers[name];
        this._engine.statesByElement.forEach(function (stateMap, element) { delete stateMap[name]; });
        this._elementListeners.forEach(function (listeners, element) {
            _this._elementListeners.set(element, listeners.filter(function (entry) { return entry.name != name; }));
        });
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.clearElementCache = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        this._engine.statesByElement.delete(element);
        this._elementListeners.delete(element);
        var /** @type {?} */ elementPlayers = this._engine.playersByElement.get(element);
        if (elementPlayers) {
            elementPlayers.forEach(function (player) { return player.destroy(); });
            this._engine.playersByElement.delete(element);
        }
    };
    /**
     * @param {?} rootElement
     * @param {?} context
     * @param {?=} animate
     * @return {?}
     */
    AnimationTransitionNamespace.prototype._signalRemovalForInnerTriggers = /**
     * @param {?} rootElement
     * @param {?} context
     * @param {?=} animate
     * @return {?}
     */
    function (rootElement, context, animate) {
        var _this = this;
        if (animate === void 0) { animate = false; }
        // emulate a leave animation for all inner nodes within this node.
        // If there are no animations found for any of the nodes then clear the cache
        // for the element.
        this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true).forEach(function (elm) {
            // this means that an inner remove() operation has already kicked off
            // the animation on this element...
            if (elm[REMOVAL_FLAG])
                return;
            var /** @type {?} */ namespaces = _this._engine.fetchNamespacesByElement(elm);
            if (namespaces.size) {
                namespaces.forEach(function (ns) { return ns.triggerLeaveAnimation(elm, context, false, true); });
            }
            else {
                _this.clearElementCache(elm);
            }
        });
    };
    /**
     * @param {?} element
     * @param {?} context
     * @param {?=} destroyAfterComplete
     * @param {?=} defaultToFallback
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.triggerLeaveAnimation = /**
     * @param {?} element
     * @param {?} context
     * @param {?=} destroyAfterComplete
     * @param {?=} defaultToFallback
     * @return {?}
     */
    function (element, context, destroyAfterComplete, defaultToFallback) {
        var _this = this;
        var /** @type {?} */ triggerStates = this._engine.statesByElement.get(element);
        if (triggerStates) {
            var /** @type {?} */ players_1 = [];
            Object.keys(triggerStates).forEach(function (triggerName) {
                // this check is here in the event that an element is removed
                // twice (both on the host level and the component level)
                if (_this._triggers[triggerName]) {
                    var /** @type {?} */ player = _this.trigger(element, triggerName, VOID_VALUE, defaultToFallback);
                    if (player) {
                        players_1.push(player);
                    }
                }
            });
            if (players_1.length) {
                this._engine.markElementAsRemoved(this.id, element, true, context);
                if (destroyAfterComplete) {
                    optimizeGroupPlayer(players_1).onDone(function () { return _this._engine.processLeaveNode(element); });
                }
                return true;
            }
        }
        return false;
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.prepareLeaveAnimationListeners = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var _this = this;
        var /** @type {?} */ listeners = this._elementListeners.get(element);
        if (listeners) {
            var /** @type {?} */ visitedTriggers_1 = new Set();
            listeners.forEach(function (listener) {
                var /** @type {?} */ triggerName = listener.name;
                if (visitedTriggers_1.has(triggerName))
                    return;
                visitedTriggers_1.add(triggerName);
                var /** @type {?} */ trigger = _this._triggers[triggerName];
                var /** @type {?} */ transition = trigger.fallbackTransition;
                var /** @type {?} */ elementStates = /** @type {?} */ ((_this._engine.statesByElement.get(element)));
                var /** @type {?} */ fromState = elementStates[triggerName] || DEFAULT_STATE_VALUE;
                var /** @type {?} */ toState = new StateValue(VOID_VALUE);
                var /** @type {?} */ player = new TransitionAnimationPlayer(_this.id, triggerName, element);
                _this._engine.totalQueuedPlayers++;
                _this._queue.push({
                    element: element,
                    triggerName: triggerName,
                    transition: transition,
                    fromState: fromState,
                    toState: toState,
                    player: player,
                    isFallbackTransition: true
                });
            });
        }
    };
    /**
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.removeNode = /**
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    function (element, context) {
        var _this = this;
        var /** @type {?} */ engine = this._engine;
        if (element.childElementCount) {
            this._signalRemovalForInnerTriggers(element, context, true);
        }
        // this means that a * => VOID animation was detected and kicked off
        if (this.triggerLeaveAnimation(element, context, true))
            return;
        // find the player that is animating and make sure that the
        // removal is delayed until that player has completed
        var /** @type {?} */ containsPotentialParentTransition = false;
        if (engine.totalAnimations) {
            var /** @type {?} */ currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];
            // when this `if statement` does not continue forward it means that
            // a previous animation query has selected the current element and
            // is animating it. In this situation want to continue fowards and
            // allow the element to be queued up for animation later.
            if (currentPlayers && currentPlayers.length) {
                containsPotentialParentTransition = true;
            }
            else {
                var /** @type {?} */ parent_1 = element;
                while (parent_1 = parent_1.parentNode) {
                    var /** @type {?} */ triggers = engine.statesByElement.get(parent_1);
                    if (triggers) {
                        containsPotentialParentTransition = true;
                        break;
                    }
                }
            }
        }
        // at this stage we know that the element will either get removed
        // during flush or will be picked up by a parent query. Either way
        // we need to fire the listeners for this element when it DOES get
        // removed (once the query parent animation is done or after flush)
        this.prepareLeaveAnimationListeners(element);
        // whether or not a parent has an animation we need to delay the deferral of the leave
        // operation until we have more information (which we do after flush() has been called)
        if (containsPotentialParentTransition) {
            engine.markElementAsRemoved(this.id, element, false, context);
        }
        else {
            // we do this after the flush has occurred such
            // that the callbacks can be fired
            engine.afterFlush(function () { return _this.clearElementCache(element); });
            engine.destroyInnerAnimations(element);
            engine._onRemovalComplete(element, context);
        }
    };
    /**
     * @param {?} element
     * @param {?} parent
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.insertNode = /**
     * @param {?} element
     * @param {?} parent
     * @return {?}
     */
    function (element, parent) { addClass(element, this._hostClassName); };
    /**
     * @param {?} microtaskId
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.drainQueuedTransitions = /**
     * @param {?} microtaskId
     * @return {?}
     */
    function (microtaskId) {
        var _this = this;
        var /** @type {?} */ instructions = [];
        this._queue.forEach(function (entry) {
            var /** @type {?} */ player = entry.player;
            if (player.destroyed)
                return;
            var /** @type {?} */ element = entry.element;
            var /** @type {?} */ listeners = _this._elementListeners.get(element);
            if (listeners) {
                listeners.forEach(function (listener) {
                    if (listener.name == entry.triggerName) {
                        var /** @type {?} */ baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);
                        (/** @type {?} */ (baseEvent))['_data'] = microtaskId;
                        listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);
                    }
                });
            }
            if (player.markedForDestroy) {
                _this._engine.afterFlush(function () {
                    // now we can destroy the element properly since the event listeners have
                    // been bound to the player
                    player.destroy();
                });
            }
            else {
                instructions.push(entry);
            }
        });
        this._queue = [];
        return instructions.sort(function (a, b) {
            // if depCount == 0 them move to front
            // otherwise if a contains b then move back
            var /** @type {?} */ d0 = a.transition.ast.depCount;
            var /** @type {?} */ d1 = b.transition.ast.depCount;
            if (d0 == 0 || d1 == 0) {
                return d0 - d1;
            }
            return _this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;
        });
    };
    /**
     * @param {?} context
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.destroy = /**
     * @param {?} context
     * @return {?}
     */
    function (context) {
        this.players.forEach(function (p) { return p.destroy(); });
        this._signalRemovalForInnerTriggers(this.hostElement, context);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.elementContainsData = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ containsData = false;
        if (this._elementListeners.has(element))
            containsData = true;
        containsData =
            (this._queue.find(function (entry) { return entry.element === element; }) ? true : false) || containsData;
        return containsData;
    };
    return AnimationTransitionNamespace;
}());
/**
 * @record
 */

var TransitionAnimationEngine = /** @class */ (function () {
    function TransitionAnimationEngine(driver, _normalizer) {
        this.driver = driver;
        this._normalizer = _normalizer;
        this.players = [];
        this.newHostElements = new Map();
        this.playersByElement = new Map();
        this.playersByQueriedElement = new Map();
        this.statesByElement = new Map();
        this.disabledNodes = new Set();
        this.totalAnimations = 0;
        this.totalQueuedPlayers = 0;
        this._namespaceLookup = {};
        this._namespaceList = [];
        this._flushFns = [];
        this._whenQuietFns = [];
        this.namespacesByHostElement = new Map();
        this.collectedEnterElements = [];
        this.collectedLeaveElements = [];
        this.onRemovalComplete = function (element, context) { };
    }
    /** @internal */
    /**
     * \@internal
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype._onRemovalComplete = /**
     * \@internal
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    function (element, context) { this.onRemovalComplete(element, context); };
    Object.defineProperty(TransitionAnimationEngine.prototype, "queuedPlayers", {
        get: /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ players = [];
            this._namespaceList.forEach(function (ns) {
                ns.players.forEach(function (player) {
                    if (player.queued) {
                        players.push(player);
                    }
                });
            });
            return players;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype.createNamespace = /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    function (namespaceId, hostElement) {
        var /** @type {?} */ ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);
        if (hostElement.parentNode) {
            this._balanceNamespaceList(ns, hostElement);
        }
        else {
            // defer this later until flush during when the host element has
            // been inserted so that we know exactly where to place it in
            // the namespace list
            this.newHostElements.set(hostElement, ns);
            // given that this host element is apart of the animation code, it
            // may or may not be inserted by a parent node that is an of an
            // animation renderer type. If this happens then we can still have
            // access to this item when we query for :enter nodes. If the parent
            // is a renderer then the set data-structure will normalize the entry
            this.collectEnterElement(hostElement);
        }
        return this._namespaceLookup[namespaceId] = ns;
    };
    /**
     * @param {?} ns
     * @param {?} hostElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype._balanceNamespaceList = /**
     * @param {?} ns
     * @param {?} hostElement
     * @return {?}
     */
    function (ns, hostElement) {
        var /** @type {?} */ limit = this._namespaceList.length - 1;
        if (limit >= 0) {
            var /** @type {?} */ found = false;
            for (var /** @type {?} */ i = limit; i >= 0; i--) {
                var /** @type {?} */ nextNamespace = this._namespaceList[i];
                if (this.driver.containsElement(nextNamespace.hostElement, hostElement)) {
                    this._namespaceList.splice(i + 1, 0, ns);
                    found = true;
                    break;
                }
            }
            if (!found) {
                this._namespaceList.splice(0, 0, ns);
            }
        }
        else {
            this._namespaceList.push(ns);
        }
        this.namespacesByHostElement.set(hostElement, ns);
        return ns;
    };
    /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype.register = /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    function (namespaceId, hostElement) {
        var /** @type {?} */ ns = this._namespaceLookup[namespaceId];
        if (!ns) {
            ns = this.createNamespace(namespaceId, hostElement);
        }
        return ns;
    };
    /**
     * @param {?} namespaceId
     * @param {?} name
     * @param {?} trigger
     * @return {?}
     */
    TransitionAnimationEngine.prototype.registerTrigger = /**
     * @param {?} namespaceId
     * @param {?} name
     * @param {?} trigger
     * @return {?}
     */
    function (namespaceId, name, trigger) {
        var /** @type {?} */ ns = this._namespaceLookup[namespaceId];
        if (ns && ns.register(name, trigger)) {
            this.totalAnimations++;
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype.destroy = /**
     * @param {?} namespaceId
     * @param {?} context
     * @return {?}
     */
    function (namespaceId, context) {
        var _this = this;
        if (!namespaceId)
            return;
        var /** @type {?} */ ns = this._fetchNamespace(namespaceId);
        this.afterFlush(function () {
            _this.namespacesByHostElement.delete(ns.hostElement);
            delete _this._namespaceLookup[namespaceId];
            var /** @type {?} */ index = _this._namespaceList.indexOf(ns);
            if (index >= 0) {
                _this._namespaceList.splice(index, 1);
            }
        });
        this.afterFlushAnimationsDone(function () { return ns.destroy(context); });
    };
    /**
     * @param {?} id
     * @return {?}
     */
    TransitionAnimationEngine.prototype._fetchNamespace = /**
     * @param {?} id
     * @return {?}
     */
    function (id) { return this._namespaceLookup[id]; };
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.fetchNamespacesByElement = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        // normally there should only be one namespace per element, however
        // if @triggers are placed on both the component element and then
        // its host element (within the component code) then there will be
        // two namespaces returned. We use a set here to simply the dedupe
        // of namespaces incase there are multiple triggers both the elm and host
        var /** @type {?} */ namespaces = new Set();
        var /** @type {?} */ elementStates = this.statesByElement.get(element);
        if (elementStates) {
            var /** @type {?} */ keys = Object.keys(elementStates);
            for (var /** @type {?} */ i = 0; i < keys.length; i++) {
                var /** @type {?} */ nsId = elementStates[keys[i]].namespaceId;
                if (nsId) {
                    var /** @type {?} */ ns = this._fetchNamespace(nsId);
                    if (ns) {
                        namespaces.add(ns);
                    }
                }
            }
        }
        return namespaces;
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    TransitionAnimationEngine.prototype.trigger = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (namespaceId, element, name, value) {
        if (isElementNode(element)) {
            this._fetchNamespace(namespaceId).trigger(element, name, value);
            return true;
        }
        return false;
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} parent
     * @param {?} insertBefore
     * @return {?}
     */
    TransitionAnimationEngine.prototype.insertNode = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} parent
     * @param {?} insertBefore
     * @return {?}
     */
    function (namespaceId, element, parent, insertBefore) {
        if (!isElementNode(element))
            return;
        // special case for when an element is removed and reinserted (move operation)
        // when this occurs we do not want to use the element for deletion later
        var /** @type {?} */ details = /** @type {?} */ (element[REMOVAL_FLAG]);
        if (details && details.setForRemoval) {
            details.setForRemoval = false;
        }
        // in the event that the namespaceId is blank then the caller
        // code does not contain any animation code in it, but it is
        // just being called so that the node is marked as being inserted
        if (namespaceId) {
            this._fetchNamespace(namespaceId).insertNode(element, parent);
        }
        // only *directives and host elements are inserted before
        if (insertBefore) {
            this.collectEnterElement(element);
        }
    };
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.collectEnterElement = /**
     * @param {?} element
     * @return {?}
     */
    function (element) { this.collectedEnterElements.push(element); };
    /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    TransitionAnimationEngine.prototype.markElementAsDisabled = /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    function (element, value) {
        if (value) {
            if (!this.disabledNodes.has(element)) {
                this.disabledNodes.add(element);
                addClass(element, DISABLED_CLASSNAME);
            }
        }
        else if (this.disabledNodes.has(element)) {
            this.disabledNodes.delete(element);
            removeClass(element, DISABLED_CLASSNAME);
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype.removeNode = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    function (namespaceId, element, context) {
        if (!isElementNode(element)) {
            this._onRemovalComplete(element, context);
            return;
        }
        var /** @type {?} */ ns = namespaceId ? this._fetchNamespace(namespaceId) : null;
        if (ns) {
            ns.removeNode(element, context);
        }
        else {
            this.markElementAsRemoved(namespaceId, element, false, context);
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?=} hasAnimation
     * @param {?=} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype.markElementAsRemoved = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?=} hasAnimation
     * @param {?=} context
     * @return {?}
     */
    function (namespaceId, element, hasAnimation, context) {
        this.collectedLeaveElements.push(element);
        element[REMOVAL_FLAG] = {
            namespaceId: namespaceId,
            setForRemoval: context, hasAnimation: hasAnimation,
            removedBeforeQueried: false
        };
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} name
     * @param {?} phase
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationEngine.prototype.listen = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} name
     * @param {?} phase
     * @param {?} callback
     * @return {?}
     */
    function (namespaceId, element, name, phase, callback) {
        if (isElementNode(element)) {
            return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);
        }
        return function () { };
    };
    /**
     * @param {?} entry
     * @param {?} subTimelines
     * @param {?} enterClassName
     * @param {?} leaveClassName
     * @return {?}
     */
    TransitionAnimationEngine.prototype._buildInstruction = /**
     * @param {?} entry
     * @param {?} subTimelines
     * @param {?} enterClassName
     * @param {?} leaveClassName
     * @return {?}
     */
    function (entry, subTimelines, enterClassName, leaveClassName) {
        return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName, leaveClassName, entry.fromState.options, entry.toState.options, subTimelines);
    };
    /**
     * @param {?} containerElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype.destroyInnerAnimations = /**
     * @param {?} containerElement
     * @return {?}
     */
    function (containerElement) {
        var _this = this;
        var /** @type {?} */ elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);
        elements.forEach(function (element) { return _this.destroyActiveAnimationsForElement(element); });
        if (this.playersByQueriedElement.size == 0)
            return;
        elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);
        elements.forEach(function (element) { return _this.finishActiveQueriedAnimationOnElement(element); });
    };
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.destroyActiveAnimationsForElement = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ players = this.playersByElement.get(element);
        if (players) {
            players.forEach(function (player) {
                // special case for when an element is set for destruction, but hasn't started.
                // in this situation we want to delay the destruction until the flush occurs
                // so that any event listeners attached to the player are triggered.
                if (player.queued) {
                    player.markedForDestroy = true;
                }
                else {
                    player.destroy();
                }
            });
        }
        var /** @type {?} */ stateMap = this.statesByElement.get(element);
        if (stateMap) {
            Object.keys(stateMap).forEach(function (triggerName) { return stateMap[triggerName] = DELETED_STATE_VALUE; });
        }
    };
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.finishActiveQueriedAnimationOnElement = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ players = this.playersByQueriedElement.get(element);
        if (players) {
            players.forEach(function (player) { return player.finish(); });
        }
    };
    /**
     * @return {?}
     */
    TransitionAnimationEngine.prototype.whenRenderingDone = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return new Promise(function (resolve) {
            if (_this.players.length) {
                return optimizeGroupPlayer(_this.players).onDone(function () { return resolve(); });
            }
            else {
                resolve();
            }
        });
    };
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.processLeaveNode = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var _this = this;
        var /** @type {?} */ details = /** @type {?} */ (element[REMOVAL_FLAG]);
        if (details && details.setForRemoval) {
            // this will prevent it from removing it twice
            element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;
            if (details.namespaceId) {
                this.destroyInnerAnimations(element);
                var /** @type {?} */ ns = this._fetchNamespace(details.namespaceId);
                if (ns) {
                    ns.clearElementCache(element);
                }
            }
            this._onRemovalComplete(element, details.setForRemoval);
        }
        if (this.driver.matchesElement(element, DISABLED_SELECTOR)) {
            this.markElementAsDisabled(element, false);
        }
        this.driver.query(element, DISABLED_SELECTOR, true).forEach(function (node) {
            _this.markElementAsDisabled(element, false);
        });
    };
    /**
     * @param {?=} microtaskId
     * @return {?}
     */
    TransitionAnimationEngine.prototype.flush = /**
     * @param {?=} microtaskId
     * @return {?}
     */
    function (microtaskId) {
        var _this = this;
        if (microtaskId === void 0) { microtaskId = -1; }
        var /** @type {?} */ players = [];
        if (this.newHostElements.size) {
            this.newHostElements.forEach(function (ns, element) { return _this._balanceNamespaceList(ns, element); });
            this.newHostElements.clear();
        }
        if (this.totalAnimations && this.collectedEnterElements.length) {
            for (var /** @type {?} */ i = 0; i < this.collectedEnterElements.length; i++) {
                var /** @type {?} */ elm = this.collectedEnterElements[i];
                addClass(elm, STAR_CLASSNAME);
            }
        }
        if (this._namespaceList.length &&
            (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
            var /** @type {?} */ cleanupFns = [];
            try {
                players = this._flushAnimations(cleanupFns, microtaskId);
            }
            finally {
                for (var /** @type {?} */ i = 0; i < cleanupFns.length; i++) {
                    cleanupFns[i]();
                }
            }
        }
        else {
            for (var /** @type {?} */ i = 0; i < this.collectedLeaveElements.length; i++) {
                var /** @type {?} */ element = this.collectedLeaveElements[i];
                this.processLeaveNode(element);
            }
        }
        this.totalQueuedPlayers = 0;
        this.collectedEnterElements.length = 0;
        this.collectedLeaveElements.length = 0;
        this._flushFns.forEach(function (fn) { return fn(); });
        this._flushFns = [];
        if (this._whenQuietFns.length) {
            // we move these over to a variable so that
            // if any new callbacks are registered in another
            // flush they do not populate the existing set
            var /** @type {?} */ quietFns_1 = this._whenQuietFns;
            this._whenQuietFns = [];
            if (players.length) {
                optimizeGroupPlayer(players).onDone(function () { quietFns_1.forEach(function (fn) { return fn(); }); });
            }
            else {
                quietFns_1.forEach(function (fn) { return fn(); });
            }
        }
    };
    /**
     * @param {?} errors
     * @return {?}
     */
    TransitionAnimationEngine.prototype.reportError = /**
     * @param {?} errors
     * @return {?}
     */
    function (errors) {
        throw new Error("Unable to process animations due to the following failed trigger transitions\n " + errors.join('\n'));
    };
    /**
     * @param {?} cleanupFns
     * @param {?} microtaskId
     * @return {?}
     */
    TransitionAnimationEngine.prototype._flushAnimations = /**
     * @param {?} cleanupFns
     * @param {?} microtaskId
     * @return {?}
     */
    function (cleanupFns, microtaskId) {
        var _this = this;
        var /** @type {?} */ subTimelines = new ElementInstructionMap();
        var /** @type {?} */ skippedPlayers = [];
        var /** @type {?} */ skippedPlayersMap = new Map();
        var /** @type {?} */ queuedInstructions = [];
        var /** @type {?} */ queriedElements = new Map();
        var /** @type {?} */ allPreStyleElements = new Map();
        var /** @type {?} */ allPostStyleElements = new Map();
        var /** @type {?} */ disabledElementsSet = new Set();
        this.disabledNodes.forEach(function (node) {
            disabledElementsSet.add(node);
            var /** @type {?} */ nodesThatAreDisabled = _this.driver.query(node, QUEUED_SELECTOR, true);
            for (var /** @type {?} */ i_1 = 0; i_1 < nodesThatAreDisabled.length; i_1++) {
                disabledElementsSet.add(nodesThatAreDisabled[i_1]);
            }
        });
        var /** @type {?} */ bodyNode = getBodyNode();
        var /** @type {?} */ allTriggerElements = Array.from(this.statesByElement.keys());
        var /** @type {?} */ enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements);
        // this must occur before the instructions are built below such that
        // the :enter queries match the elements (since the timeline queries
        // are fired during instruction building).
        var /** @type {?} */ enterNodeMapIds = new Map();
        var /** @type {?} */ i = 0;
        enterNodeMap.forEach(function (nodes, root) {
            var /** @type {?} */ className = ENTER_CLASSNAME + i++;
            enterNodeMapIds.set(root, className);
            nodes.forEach(function (node) { return addClass(node, className); });
        });
        var /** @type {?} */ allLeaveNodes = [];
        var /** @type {?} */ mergedLeaveNodes = new Set();
        var /** @type {?} */ leaveNodesWithoutAnimations = new Set();
        for (var /** @type {?} */ i_2 = 0; i_2 < this.collectedLeaveElements.length; i_2++) {
            var /** @type {?} */ element = this.collectedLeaveElements[i_2];
            var /** @type {?} */ details = /** @type {?} */ (element[REMOVAL_FLAG]);
            if (details && details.setForRemoval) {
                allLeaveNodes.push(element);
                mergedLeaveNodes.add(element);
                if (details.hasAnimation) {
                    this.driver.query(element, STAR_SELECTOR, true).forEach(function (elm) { return mergedLeaveNodes.add(elm); });
                }
                else {
                    leaveNodesWithoutAnimations.add(element);
                }
            }
        }
        var /** @type {?} */ leaveNodeMapIds = new Map();
        var /** @type {?} */ leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));
        leaveNodeMap.forEach(function (nodes, root) {
            var /** @type {?} */ className = LEAVE_CLASSNAME + i++;
            leaveNodeMapIds.set(root, className);
            nodes.forEach(function (node) { return addClass(node, className); });
        });
        cleanupFns.push(function () {
            enterNodeMap.forEach(function (nodes, root) {
                var /** @type {?} */ className = /** @type {?} */ ((enterNodeMapIds.get(root)));
                nodes.forEach(function (node) { return removeClass(node, className); });
            });
            leaveNodeMap.forEach(function (nodes, root) {
                var /** @type {?} */ className = /** @type {?} */ ((leaveNodeMapIds.get(root)));
                nodes.forEach(function (node) { return removeClass(node, className); });
            });
            allLeaveNodes.forEach(function (element) { _this.processLeaveNode(element); });
        });
        var /** @type {?} */ allPlayers = [];
        var /** @type {?} */ erroneousTransitions = [];
        for (var /** @type {?} */ i_3 = this._namespaceList.length - 1; i_3 >= 0; i_3--) {
            var /** @type {?} */ ns = this._namespaceList[i_3];
            ns.drainQueuedTransitions(microtaskId).forEach(function (entry) {
                var /** @type {?} */ player = entry.player;
                allPlayers.push(player);
                var /** @type {?} */ element = entry.element;
                if (!bodyNode || !_this.driver.containsElement(bodyNode, element)) {
                    player.destroy();
                    return;
                }
                var /** @type {?} */ leaveClassName = /** @type {?} */ ((leaveNodeMapIds.get(element)));
                var /** @type {?} */ enterClassName = /** @type {?} */ ((enterNodeMapIds.get(element)));
                var /** @type {?} */ instruction = /** @type {?} */ ((_this._buildInstruction(entry, subTimelines, enterClassName, leaveClassName)));
                if (instruction.errors && instruction.errors.length) {
                    erroneousTransitions.push(instruction);
                    return;
                }
                // if a unmatched transition is queued to go then it SHOULD NOT render
                // an animation and cancel the previously running animations.
                if (entry.isFallbackTransition) {
                    player.onStart(function () { return eraseStyles(element, instruction.fromStyles); });
                    player.onDestroy(function () { return setStyles(element, instruction.toStyles); });
                    skippedPlayers.push(player);
                    return;
                }
                // this means that if a parent animation uses this animation as a sub trigger
                // then it will instruct the timeline builder to not add a player delay, but
                // instead stretch the first keyframe gap up until the animation starts. The
                // reason this is important is to prevent extra initialization styles from being
                // required by the user in the animation.
                instruction.timelines.forEach(function (tl) { return tl.stretchStartingKeyframe = true; });
                subTimelines.append(element, instruction.timelines);
                var /** @type {?} */ tuple = { instruction: instruction, player: player, element: element };
                queuedInstructions.push(tuple);
                instruction.queriedElements.forEach(function (element) { return getOrSetAsInMap(queriedElements, element, []).push(player); });
                instruction.preStyleProps.forEach(function (stringMap, element) {
                    var /** @type {?} */ props = Object.keys(stringMap);
                    if (props.length) {
                        var /** @type {?} */ setVal_1 = /** @type {?} */ ((allPreStyleElements.get(element)));
                        if (!setVal_1) {
                            allPreStyleElements.set(element, setVal_1 = new Set());
                        }
                        props.forEach(function (prop) { return setVal_1.add(prop); });
                    }
                });
                instruction.postStyleProps.forEach(function (stringMap, element) {
                    var /** @type {?} */ props = Object.keys(stringMap);
                    var /** @type {?} */ setVal = /** @type {?} */ ((allPostStyleElements.get(element)));
                    if (!setVal) {
                        allPostStyleElements.set(element, setVal = new Set());
                    }
                    props.forEach(function (prop) { return setVal.add(prop); });
                });
            });
        }
        if (erroneousTransitions.length) {
            var /** @type {?} */ errors_1 = [];
            erroneousTransitions.forEach(function (instruction) {
                errors_1.push("@" + instruction.triggerName + " has failed due to:\n"); /** @type {?} */
                ((instruction.errors)).forEach(function (error) { return errors_1.push("- " + error + "\n"); });
            });
            allPlayers.forEach(function (player) { return player.destroy(); });
            this.reportError(errors_1);
        }
        var /** @type {?} */ allPreviousPlayersMap = new Map();
        // this map works to tell which element in the DOM tree is contained by
        // which animation. Further down below this map will get populated once
        // the players are built and in doing so it can efficiently figure out
        // if a sub player is skipped due to a parent player having priority.
        var /** @type {?} */ animationElementMap = new Map();
        queuedInstructions.forEach(function (entry) {
            var /** @type {?} */ element = entry.element;
            if (subTimelines.has(element)) {
                animationElementMap.set(element, element);
                _this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);
            }
        });
        skippedPlayers.forEach(function (player) {
            var /** @type {?} */ element = player.element;
            var /** @type {?} */ previousPlayers = _this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);
            previousPlayers.forEach(function (prevPlayer) {
                getOrSetAsInMap(allPreviousPlayersMap, element, []).push(prevPlayer);
                prevPlayer.destroy();
            });
        });
        // this is a special case for nodes that will be removed (either by)
        // having their own leave animations or by being queried in a container
        // that will be removed once a parent animation is complete. The idea
        // here is that * styles must be identical to ! styles because of
        // backwards compatibility (* is also filled in by default in many places).
        // Otherwise * styles will return an empty value or auto since the element
        // that is being getComputedStyle'd will not be visible (since * = destination)
        var /** @type {?} */ replaceNodes = allLeaveNodes.filter(function (node) {
            return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);
        });
        // POST STAGE: fill the * styles
        var /** @type {?} */ postStylesMap = new Map();
        var /** @type {?} */ allLeaveQueriedNodes = cloakAndComputeStyles(postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, _angular_animations.AUTO_STYLE);
        allLeaveQueriedNodes.forEach(function (node) {
            if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {
                replaceNodes.push(node);
            }
        });
        // PRE STAGE: fill the ! styles
        var /** @type {?} */ preStylesMap = new Map();
        enterNodeMap.forEach(function (nodes, root) {
            cloakAndComputeStyles(preStylesMap, _this.driver, new Set(nodes), allPreStyleElements, _angular_animations.ɵPRE_STYLE);
        });
        replaceNodes.forEach(function (node) {
            var /** @type {?} */ post = postStylesMap.get(node);
            var /** @type {?} */ pre = preStylesMap.get(node);
            postStylesMap.set(node, /** @type {?} */ (__assign({}, post, pre)));
        });
        var /** @type {?} */ rootPlayers = [];
        var /** @type {?} */ subPlayers = [];
        var /** @type {?} */ NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};
        queuedInstructions.forEach(function (entry) {
            var element = entry.element, player = entry.player, instruction = entry.instruction;
            // this means that it was never consumed by a parent animation which
            // means that it is independent and therefore should be set for animation
            if (subTimelines.has(element)) {
                if (disabledElementsSet.has(element)) {
                    player.onDestroy(function () { return setStyles(element, instruction.toStyles); });
                    skippedPlayers.push(player);
                    return;
                }
                // this will flow up the DOM and query the map to figure out
                // if a parent animation has priority over it. In the situation
                // that a parent is detected then it will cancel the loop. If
                // nothing is detected, or it takes a few hops to find a parent,
                // then it will fill in the missing nodes and signal them as having
                // a detected parent (or a NO_PARENT value via a special constant).
                var /** @type {?} */ parentWithAnimation_1 = NO_PARENT_ANIMATION_ELEMENT_DETECTED;
                if (animationElementMap.size > 1) {
                    var /** @type {?} */ elm = element;
                    var /** @type {?} */ parentsToAdd = [];
                    while (elm = elm.parentNode) {
                        var /** @type {?} */ detectedParent = animationElementMap.get(elm);
                        if (detectedParent) {
                            parentWithAnimation_1 = detectedParent;
                            break;
                        }
                        parentsToAdd.push(elm);
                    }
                    parentsToAdd.forEach(function (parent) { return animationElementMap.set(parent, parentWithAnimation_1); });
                }
                var /** @type {?} */ innerPlayer = _this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);
                player.setRealPlayer(innerPlayer);
                if (parentWithAnimation_1 === NO_PARENT_ANIMATION_ELEMENT_DETECTED) {
                    rootPlayers.push(player);
                }
                else {
                    var /** @type {?} */ parentPlayers = _this.playersByElement.get(parentWithAnimation_1);
                    if (parentPlayers && parentPlayers.length) {
                        player.parentPlayer = optimizeGroupPlayer(parentPlayers);
                    }
                    skippedPlayers.push(player);
                }
            }
            else {
                eraseStyles(element, instruction.fromStyles);
                player.onDestroy(function () { return setStyles(element, instruction.toStyles); });
                // there still might be a ancestor player animating this
                // element therefore we will still add it as a sub player
                // even if its animation may be disabled
                subPlayers.push(player);
                if (disabledElementsSet.has(element)) {
                    skippedPlayers.push(player);
                }
            }
        });
        // find all of the sub players' corresponding inner animation player
        subPlayers.forEach(function (player) {
            // even if any players are not found for a sub animation then it
            // will still complete itself after the next tick since it's Noop
            var /** @type {?} */ playersForElement = skippedPlayersMap.get(player.element);
            if (playersForElement && playersForElement.length) {
                var /** @type {?} */ innerPlayer = optimizeGroupPlayer(playersForElement);
                player.setRealPlayer(innerPlayer);
            }
        });
        // the reason why we don't actually play the animation is
        // because all that a skipped player is designed to do is to
        // fire the start/done transition callback events
        skippedPlayers.forEach(function (player) {
            if (player.parentPlayer) {
                player.syncPlayerEvents(player.parentPlayer);
            }
            else {
                player.destroy();
            }
        });
        // run through all of the queued removals and see if they
        // were picked up by a query. If not then perform the removal
        // operation right away unless a parent animation is ongoing.
        for (var /** @type {?} */ i_4 = 0; i_4 < allLeaveNodes.length; i_4++) {
            var /** @type {?} */ element = allLeaveNodes[i_4];
            var /** @type {?} */ details = /** @type {?} */ (element[REMOVAL_FLAG]);
            removeClass(element, LEAVE_CLASSNAME);
            // this means the element has a removal animation that is being
            // taken care of and therefore the inner elements will hang around
            // until that animation is over (or the parent queried animation)
            if (details && details.hasAnimation)
                continue;
            var /** @type {?} */ players = [];
            // if this element is queried or if it contains queried children
            // then we want for the element not to be removed from the page
            // until the queried animations have finished
            if (queriedElements.size) {
                var /** @type {?} */ queriedPlayerResults = queriedElements.get(element);
                if (queriedPlayerResults && queriedPlayerResults.length) {
                    players.push.apply(players, queriedPlayerResults);
                }
                var /** @type {?} */ queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);
                for (var /** @type {?} */ j = 0; j < queriedInnerElements.length; j++) {
                    var /** @type {?} */ queriedPlayers = queriedElements.get(queriedInnerElements[j]);
                    if (queriedPlayers && queriedPlayers.length) {
                        players.push.apply(players, queriedPlayers);
                    }
                }
            }
            var /** @type {?} */ activePlayers = players.filter(function (p) { return !p.destroyed; });
            if (activePlayers.length) {
                removeNodesAfterAnimationDone(this, element, activePlayers);
            }
            else {
                this.processLeaveNode(element);
            }
        }
        // this is required so the cleanup method doesn't remove them
        allLeaveNodes.length = 0;
        rootPlayers.forEach(function (player) {
            _this.players.push(player);
            player.onDone(function () {
                player.destroy();
                var /** @type {?} */ index = _this.players.indexOf(player);
                _this.players.splice(index, 1);
            });
            player.play();
        });
        return rootPlayers;
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.elementContainsData = /**
     * @param {?} namespaceId
     * @param {?} element
     * @return {?}
     */
    function (namespaceId, element) {
        var /** @type {?} */ containsData = false;
        var /** @type {?} */ details = /** @type {?} */ (element[REMOVAL_FLAG]);
        if (details && details.setForRemoval)
            containsData = true;
        if (this.playersByElement.has(element))
            containsData = true;
        if (this.playersByQueriedElement.has(element))
            containsData = true;
        if (this.statesByElement.has(element))
            containsData = true;
        return this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;
    };
    /**
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationEngine.prototype.afterFlush = /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) { this._flushFns.push(callback); };
    /**
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationEngine.prototype.afterFlushAnimationsDone = /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) { this._whenQuietFns.push(callback); };
    /**
     * @param {?} element
     * @param {?} isQueriedElement
     * @param {?=} namespaceId
     * @param {?=} triggerName
     * @param {?=} toStateValue
     * @return {?}
     */
    TransitionAnimationEngine.prototype._getPreviousPlayers = /**
     * @param {?} element
     * @param {?} isQueriedElement
     * @param {?=} namespaceId
     * @param {?=} triggerName
     * @param {?=} toStateValue
     * @return {?}
     */
    function (element, isQueriedElement, namespaceId, triggerName, toStateValue) {
        var /** @type {?} */ players = [];
        if (isQueriedElement) {
            var /** @type {?} */ queriedElementPlayers = this.playersByQueriedElement.get(element);
            if (queriedElementPlayers) {
                players = queriedElementPlayers;
            }
        }
        else {
            var /** @type {?} */ elementPlayers = this.playersByElement.get(element);
            if (elementPlayers) {
                var /** @type {?} */ isRemovalAnimation_1 = !toStateValue || toStateValue == VOID_VALUE;
                elementPlayers.forEach(function (player) {
                    if (player.queued)
                        return;
                    if (!isRemovalAnimation_1 && player.triggerName != triggerName)
                        return;
                    players.push(player);
                });
            }
        }
        if (namespaceId || triggerName) {
            players = players.filter(function (player) {
                if (namespaceId && namespaceId != player.namespaceId)
                    return false;
                if (triggerName && triggerName != player.triggerName)
                    return false;
                return true;
            });
        }
        return players;
    };
    /**
     * @param {?} namespaceId
     * @param {?} instruction
     * @param {?} allPreviousPlayersMap
     * @return {?}
     */
    TransitionAnimationEngine.prototype._beforeAnimationBuild = /**
     * @param {?} namespaceId
     * @param {?} instruction
     * @param {?} allPreviousPlayersMap
     * @return {?}
     */
    function (namespaceId, instruction, allPreviousPlayersMap) {
        var /** @type {?} */ triggerName = instruction.triggerName;
        var /** @type {?} */ rootElement = instruction.element;
        // when a removal animation occurs, ALL previous players are collected
        // and destroyed (even if they are outside of the current namespace)
        var /** @type {?} */ targetNameSpaceId = instruction.isRemovalTransition ? undefined : namespaceId;
        var /** @type {?} */ targetTriggerName = instruction.isRemovalTransition ? undefined : triggerName;
        var _loop_1 = function (timelineInstruction) {
            var /** @type {?} */ element = timelineInstruction.element;
            var /** @type {?} */ isQueriedElement = element !== rootElement;
            var /** @type {?} */ players = getOrSetAsInMap(allPreviousPlayersMap, element, []);
            var /** @type {?} */ previousPlayers = this_1._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);
            previousPlayers.forEach(function (player) {
                var /** @type {?} */ realPlayer = /** @type {?} */ (player.getRealPlayer());
                if (realPlayer.beforeDestroy) {
                    realPlayer.beforeDestroy();
                }
                player.destroy();
                players.push(player);
            });
        };
        var this_1 = this;
        for (var _i = 0, _a = instruction.timelines; _i < _a.length; _i++) {
            var timelineInstruction = _a[_i];
            _loop_1(timelineInstruction);
        }
        // this needs to be done so that the PRE/POST styles can be
        // computed properly without interfering with the previous animation
        eraseStyles(rootElement, instruction.fromStyles);
    };
    /**
     * @param {?} namespaceId
     * @param {?} instruction
     * @param {?} allPreviousPlayersMap
     * @param {?} skippedPlayersMap
     * @param {?} preStylesMap
     * @param {?} postStylesMap
     * @return {?}
     */
    TransitionAnimationEngine.prototype._buildAnimation = /**
     * @param {?} namespaceId
     * @param {?} instruction
     * @param {?} allPreviousPlayersMap
     * @param {?} skippedPlayersMap
     * @param {?} preStylesMap
     * @param {?} postStylesMap
     * @return {?}
     */
    function (namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {
        var _this = this;
        var /** @type {?} */ triggerName = instruction.triggerName;
        var /** @type {?} */ rootElement = instruction.element;
        // we first run this so that the previous animation player
        // data can be passed into the successive animation players
        var /** @type {?} */ allQueriedPlayers = [];
        var /** @type {?} */ allConsumedElements = new Set();
        var /** @type {?} */ allSubElements = new Set();
        var /** @type {?} */ allNewPlayers = instruction.timelines.map(function (timelineInstruction) {
            var /** @type {?} */ element = timelineInstruction.element;
            allConsumedElements.add(element);
            // FIXME (matsko): make sure to-be-removed animations are removed properly
            var /** @type {?} */ details = element[REMOVAL_FLAG];
            if (details && details.removedBeforeQueried)
                return new _angular_animations.NoopAnimationPlayer();
            var /** @type {?} */ isQueriedElement = element !== rootElement;
            var /** @type {?} */ previousPlayers = flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY)
                .map(function (p) { return p.getRealPlayer(); }))
                .filter(function (p) {
                // the `element` is not apart of the AnimationPlayer definition, but
                // Mock/WebAnimations
                // use the element within their implementation. This will be added in Angular5 to
                // AnimationPlayer
                var /** @type {?} */ pp = /** @type {?} */ (p);
                return pp.element ? pp.element === element : false;
            });
            var /** @type {?} */ preStyles = preStylesMap.get(element);
            var /** @type {?} */ postStyles = postStylesMap.get(element);
            var /** @type {?} */ keyframes = normalizeKeyframes(_this.driver, _this._normalizer, element, timelineInstruction.keyframes, preStyles, postStyles);
            var /** @type {?} */ player = _this._buildPlayer(timelineInstruction, keyframes, previousPlayers);
            // this means that this particular player belongs to a sub trigger. It is
            // important that we match this player up with the corresponding (@trigger.listener)
            if (timelineInstruction.subTimeline && skippedPlayersMap) {
                allSubElements.add(element);
            }
            if (isQueriedElement) {
                var /** @type {?} */ wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);
                wrappedPlayer.setRealPlayer(player);
                allQueriedPlayers.push(wrappedPlayer);
            }
            return player;
        });
        allQueriedPlayers.forEach(function (player) {
            getOrSetAsInMap(_this.playersByQueriedElement, player.element, []).push(player);
            player.onDone(function () { return deleteOrUnsetInMap(_this.playersByQueriedElement, player.element, player); });
        });
        allConsumedElements.forEach(function (element) { return addClass(element, NG_ANIMATING_CLASSNAME); });
        var /** @type {?} */ player = optimizeGroupPlayer(allNewPlayers);
        player.onDestroy(function () {
            allConsumedElements.forEach(function (element) { return removeClass(element, NG_ANIMATING_CLASSNAME); });
            setStyles(rootElement, instruction.toStyles);
        });
        // this basically makes all of the callbacks for sub element animations
        // be dependent on the upper players for when they finish
        allSubElements.forEach(function (element) { getOrSetAsInMap(skippedPlayersMap, element, []).push(player); });
        return player;
    };
    /**
     * @param {?} instruction
     * @param {?} keyframes
     * @param {?} previousPlayers
     * @return {?}
     */
    TransitionAnimationEngine.prototype._buildPlayer = /**
     * @param {?} instruction
     * @param {?} keyframes
     * @param {?} previousPlayers
     * @return {?}
     */
    function (instruction, keyframes, previousPlayers) {
        if (keyframes.length > 0) {
            return this.driver.animate(instruction.element, keyframes, instruction.duration, instruction.delay, instruction.easing, previousPlayers);
        }
        // special case for when an empty transition|definition is provided
        // ... there is no point in rendering an empty animation
        return new _angular_animations.NoopAnimationPlayer();
    };
    return TransitionAnimationEngine;
}());
var TransitionAnimationPlayer = /** @class */ (function () {
    function TransitionAnimationPlayer(namespaceId, triggerName, element) {
        this.namespaceId = namespaceId;
        this.triggerName = triggerName;
        this.element = element;
        this._player = new _angular_animations.NoopAnimationPlayer();
        this._containsRealPlayer = false;
        this._queuedCallbacks = {};
        this.destroyed = false;
        this.markedForDestroy = false;
        this.queued = true;
    }
    /**
     * @param {?} player
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.setRealPlayer = /**
     * @param {?} player
     * @return {?}
     */
    function (player) {
        var _this = this;
        if (this._containsRealPlayer)
            return;
        this._player = player;
        Object.keys(this._queuedCallbacks).forEach(function (phase) {
            _this._queuedCallbacks[phase].forEach(function (callback) { return listenOnPlayer(player, phase, undefined, callback); });
        });
        this._queuedCallbacks = {};
        this._containsRealPlayer = true;
        (/** @type {?} */ (this)).queued = false;
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.getRealPlayer = /**
     * @return {?}
     */
    function () { return this._player; };
    /**
     * @param {?} player
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.syncPlayerEvents = /**
     * @param {?} player
     * @return {?}
     */
    function (player) {
        var _this = this;
        var /** @type {?} */ p = /** @type {?} */ (this._player);
        if (p.triggerCallback) {
            player.onStart(function () { return p.triggerCallback('start'); });
        }
        player.onDone(function () { return _this.finish(); });
        player.onDestroy(function () { return _this.destroy(); });
    };
    /**
     * @param {?} name
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationPlayer.prototype._queueEvent = /**
     * @param {?} name
     * @param {?} callback
     * @return {?}
     */
    function (name, callback) {
        getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.onDone = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        if (this.queued) {
            this._queueEvent('done', fn);
        }
        this._player.onDone(fn);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.onStart = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        if (this.queued) {
            this._queueEvent('start', fn);
        }
        this._player.onStart(fn);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.onDestroy = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        if (this.queued) {
            this._queueEvent('destroy', fn);
        }
        this._player.onDestroy(fn);
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.init = /**
     * @return {?}
     */
    function () { this._player.init(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.hasStarted = /**
     * @return {?}
     */
    function () { return this.queued ? false : this._player.hasStarted(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.play = /**
     * @return {?}
     */
    function () { !this.queued && this._player.play(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.pause = /**
     * @return {?}
     */
    function () { !this.queued && this._player.pause(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.restart = /**
     * @return {?}
     */
    function () { !this.queued && this._player.restart(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.finish = /**
     * @return {?}
     */
    function () { this._player.finish(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.destroy = /**
     * @return {?}
     */
    function () {
        (/** @type {?} */ (this)).destroyed = true;
        this._player.destroy();
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.reset = /**
     * @return {?}
     */
    function () { !this.queued && this._player.reset(); };
    /**
     * @param {?} p
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.setPosition = /**
     * @param {?} p
     * @return {?}
     */
    function (p) {
        if (!this.queued) {
            this._player.setPosition(p);
        }
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.getPosition = /**
     * @return {?}
     */
    function () { return this.queued ? 0 : this._player.getPosition(); };
    Object.defineProperty(TransitionAnimationPlayer.prototype, "totalTime", {
        get: /**
         * @return {?}
         */
        function () { return this._player.totalTime; },
        enumerable: true,
        configurable: true
    });
    /* @internal */
    /**
     * @param {?} phaseName
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.triggerCallback = /**
     * @param {?} phaseName
     * @return {?}
     */
    function (phaseName) {
        var /** @type {?} */ p = /** @type {?} */ (this._player);
        if (p.triggerCallback) {
            p.triggerCallback(phaseName);
        }
    };
    return TransitionAnimationPlayer;
}());
/**
 * @param {?} map
 * @param {?} key
 * @param {?} value
 * @return {?}
 */
function deleteOrUnsetInMap(map, key, value) {
    var /** @type {?} */ currentValues;
    if (map instanceof Map) {
        currentValues = map.get(key);
        if (currentValues) {
            if (currentValues.length) {
                var /** @type {?} */ index = currentValues.indexOf(value);
                currentValues.splice(index, 1);
            }
            if (currentValues.length == 0) {
                map.delete(key);
            }
        }
    }
    else {
        currentValues = map[key];
        if (currentValues) {
            if (currentValues.length) {
                var /** @type {?} */ index = currentValues.indexOf(value);
                currentValues.splice(index, 1);
            }
            if (currentValues.length == 0) {
                delete map[key];
            }
        }
    }
    return currentValues;
}
/**
 * @param {?} value
 * @return {?}
 */
function normalizeTriggerValue(value) {
    // we use `!= null` here because it's the most simple
    // way to test against a "falsy" value without mixing
    // in empty strings or a zero value. DO NOT OPTIMIZE.
    return value != null ? value : null;
}
/**
 * @param {?} node
 * @return {?}
 */
function isElementNode(node) {
    return node && node['nodeType'] === 1;
}
/**
 * @param {?} eventName
 * @return {?}
 */
function isTriggerEventValid(eventName) {
    return eventName == 'start' || eventName == 'done';
}
/**
 * @param {?} element
 * @param {?=} value
 * @return {?}
 */
function cloakElement(element, value) {
    var /** @type {?} */ oldValue = element.style.display;
    element.style.display = value != null ? value : 'none';
    return oldValue;
}
/**
 * @param {?} valuesMap
 * @param {?} driver
 * @param {?} elements
 * @param {?} elementPropsMap
 * @param {?} defaultStyle
 * @return {?}
 */
function cloakAndComputeStyles(valuesMap, driver, elements, elementPropsMap, defaultStyle) {
    var /** @type {?} */ cloakVals = [];
    elements.forEach(function (element) { return cloakVals.push(cloakElement(element)); });
    var /** @type {?} */ failedElements = [];
    elementPropsMap.forEach(function (props, element) {
        var /** @type {?} */ styles = {};
        props.forEach(function (prop) {
            var /** @type {?} */ value = styles[prop] = driver.computeStyle(element, prop, defaultStyle);
            // there is no easy way to detect this because a sub element could be removed
            // by a parent animation element being detached.
            if (!value || value.length == 0) {
                element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;
                failedElements.push(element);
            }
        });
        valuesMap.set(element, styles);
    });
    // we use a index variable here since Set.forEach(a, i) does not return
    // an index value for the closure (but instead just the value)
    var /** @type {?} */ i = 0;
    elements.forEach(function (element) { return cloakElement(element, cloakVals[i++]); });
    return failedElements;
}
/**
 * @param {?} roots
 * @param {?} nodes
 * @return {?}
 */
function buildRootMap(roots, nodes) {
    var /** @type {?} */ rootMap = new Map();
    roots.forEach(function (root) { return rootMap.set(root, []); });
    if (nodes.length == 0)
        return rootMap;
    var /** @type {?} */ NULL_NODE = 1;
    var /** @type {?} */ nodeSet = new Set(nodes);
    var /** @type {?} */ localRootMap = new Map();
    /**
     * @param {?} node
     * @return {?}
     */
    function getRoot(node) {
        if (!node)
            return NULL_NODE;
        var /** @type {?} */ root = localRootMap.get(node);
        if (root)
            return root;
        var /** @type {?} */ parent = node.parentNode;
        if (rootMap.has(parent)) {
            // ngIf inside @trigger
            root = parent;
        }
        else if (nodeSet.has(parent)) {
            // ngIf inside ngIf
            root = NULL_NODE;
        }
        else {
            // recurse upwards
            root = getRoot(parent);
        }
        localRootMap.set(node, root);
        return root;
    }
    nodes.forEach(function (node) {
        var /** @type {?} */ root = getRoot(node);
        if (root !== NULL_NODE) {
            /** @type {?} */ ((rootMap.get(root))).push(node);
        }
    });
    return rootMap;
}
var CLASSES_CACHE_KEY = '$$classes';
/**
 * @param {?} element
 * @param {?} className
 * @return {?}
 */
function addClass(element, className) {
    if (element.classList) {
        element.classList.add(className);
    }
    else {
        var /** @type {?} */ classes = element[CLASSES_CACHE_KEY];
        if (!classes) {
            classes = element[CLASSES_CACHE_KEY] = {};
        }
        classes[className] = true;
    }
}
/**
 * @param {?} element
 * @param {?} className
 * @return {?}
 */
function removeClass(element, className) {
    if (element.classList) {
        element.classList.remove(className);
    }
    else {
        var /** @type {?} */ classes = element[CLASSES_CACHE_KEY];
        if (classes) {
            delete classes[className];
        }
    }
}
/**
 * @param {?} engine
 * @param {?} element
 * @param {?} players
 * @return {?}
 */
function removeNodesAfterAnimationDone(engine, element, players) {
    optimizeGroupPlayer(players).onDone(function () { return engine.processLeaveNode(element); });
}
/**
 * @param {?} players
 * @return {?}
 */
function flattenGroupPlayers(players) {
    var /** @type {?} */ finalPlayers = [];
    _flattenGroupPlayersRecur(players, finalPlayers);
    return finalPlayers;
}
/**
 * @param {?} players
 * @param {?} finalPlayers
 * @return {?}
 */
function _flattenGroupPlayersRecur(players, finalPlayers) {
    for (var /** @type {?} */ i = 0; i < players.length; i++) {
        var /** @type {?} */ player = players[i];
        if (player instanceof _angular_animations.ɵAnimationGroupPlayer) {
            _flattenGroupPlayersRecur(player.players, finalPlayers);
        }
        else {
            finalPlayers.push(/** @type {?} */ (player));
        }
    }
}
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
function objEquals(a, b) {
    var /** @type {?} */ k1 = Object.keys(a);
    var /** @type {?} */ k2 = Object.keys(b);
    if (k1.length != k2.length)
        return false;
    for (var /** @type {?} */ i = 0; i < k1.length; i++) {
        var /** @type {?} */ prop = k1[i];
        if (!b.hasOwnProperty(prop) || a[prop] !== b[prop])
            return false;
    }
    return true;
}
/**
 * @param {?} element
 * @param {?} allPreStyleElements
 * @param {?} allPostStyleElements
 * @return {?}
 */
function replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {
    var /** @type {?} */ postEntry = allPostStyleElements.get(element);
    if (!postEntry)
        return false;
    var /** @type {?} */ preEntry = allPreStyleElements.get(element);
    if (preEntry) {
        postEntry.forEach(function (data) { return ((preEntry)).add(data); });
    }
    else {
        allPreStyleElements.set(element, postEntry);
    }
    allPostStyleElements.delete(element);
    return true;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AnimationEngine = /** @class */ (function () {
    function AnimationEngine(_driver, normalizer) {
        var _this = this;
        this._driver = _driver;
        this._triggerCache = {};
        this.onRemovalComplete = function (element, context) { };
        this._transitionEngine = new TransitionAnimationEngine(_driver, normalizer);
        this._timelineEngine = new TimelineAnimationEngine(_driver, normalizer);
        this._transitionEngine.onRemovalComplete = function (element, context) {
            return _this.onRemovalComplete(element, context);
        };
    }
    /**
     * @param {?} componentId
     * @param {?} namespaceId
     * @param {?} hostElement
     * @param {?} name
     * @param {?} metadata
     * @return {?}
     */
    AnimationEngine.prototype.registerTrigger = /**
     * @param {?} componentId
     * @param {?} namespaceId
     * @param {?} hostElement
     * @param {?} name
     * @param {?} metadata
     * @return {?}
     */
    function (componentId, namespaceId, hostElement, name, metadata) {
        var /** @type {?} */ cacheKey = componentId + '-' + name;
        var /** @type {?} */ trigger = this._triggerCache[cacheKey];
        if (!trigger) {
            var /** @type {?} */ errors = [];
            var /** @type {?} */ ast = /** @type {?} */ (buildAnimationAst(this._driver, /** @type {?} */ (metadata), errors));
            if (errors.length) {
                throw new Error("The animation trigger \"" + name + "\" has failed to build due to the following errors:\n - " + errors.join("\n - "));
            }
            trigger = buildTrigger(name, ast);
            this._triggerCache[cacheKey] = trigger;
        }
        this._transitionEngine.registerTrigger(namespaceId, name, trigger);
    };
    /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    AnimationEngine.prototype.register = /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    function (namespaceId, hostElement) {
        this._transitionEngine.register(namespaceId, hostElement);
    };
    /**
     * @param {?} namespaceId
     * @param {?} context
     * @return {?}
     */
    AnimationEngine.prototype.destroy = /**
     * @param {?} namespaceId
     * @param {?} context
     * @return {?}
     */
    function (namespaceId, context) {
        this._transitionEngine.destroy(namespaceId, context);
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} parent
     * @param {?} insertBefore
     * @return {?}
     */
    AnimationEngine.prototype.onInsert = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} parent
     * @param {?} insertBefore
     * @return {?}
     */
    function (namespaceId, element, parent, insertBefore) {
        this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    AnimationEngine.prototype.onRemove = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    function (namespaceId, element, context) {
        this._transitionEngine.removeNode(namespaceId, element, context);
    };
    /**
     * @param {?} element
     * @param {?} disable
     * @return {?}
     */
    AnimationEngine.prototype.disableAnimations = /**
     * @param {?} element
     * @param {?} disable
     * @return {?}
     */
    function (element, disable) {
        this._transitionEngine.markElementAsDisabled(element, disable);
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} property
     * @param {?} value
     * @return {?}
     */
    AnimationEngine.prototype.process = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} property
     * @param {?} value
     * @return {?}
     */
    function (namespaceId, element, property, value) {
        if (property.charAt(0) == '@') {
            var _a = parseTimelineCommand(property), id = _a[0], action = _a[1];
            var /** @type {?} */ args = /** @type {?} */ (value);
            this._timelineEngine.command(id, element, action, args);
        }
        else {
            this._transitionEngine.trigger(namespaceId, element, property, value);
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} eventName
     * @param {?} eventPhase
     * @param {?} callback
     * @return {?}
     */
    AnimationEngine.prototype.listen = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} eventName
     * @param {?} eventPhase
     * @param {?} callback
     * @return {?}
     */
    function (namespaceId, element, eventName, eventPhase, callback) {
        // @@listen
        if (eventName.charAt(0) == '@') {
            var _a = parseTimelineCommand(eventName), id = _a[0], action = _a[1];
            return this._timelineEngine.listen(id, element, action, callback);
        }
        return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);
    };
    /**
     * @param {?=} microtaskId
     * @return {?}
     */
    AnimationEngine.prototype.flush = /**
     * @param {?=} microtaskId
     * @return {?}
     */
    function (microtaskId) {
        if (microtaskId === void 0) { microtaskId = -1; }
        this._transitionEngine.flush(microtaskId);
    };
    Object.defineProperty(AnimationEngine.prototype, "players", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (this._transitionEngine.players))
                .concat(/** @type {?} */ (this._timelineEngine.players));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AnimationEngine.prototype.whenRenderingDone = /**
     * @return {?}
     */
    function () { return this._transitionEngine.whenRenderingDone(); };
    return AnimationEngine;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var WebAnimationsPlayer = /** @class */ (function () {
    function WebAnimationsPlayer(element, keyframes, options, previousPlayers) {
        if (previousPlayers === void 0) { previousPlayers = []; }
        var _this = this;
        this.element = element;
        this.keyframes = keyframes;
        this.options = options;
        this.previousPlayers = previousPlayers;
        this._onDoneFns = [];
        this._onStartFns = [];
        this._onDestroyFns = [];
        this._initialized = false;
        this._finished = false;
        this._started = false;
        this._destroyed = false;
        this.time = 0;
        this.parentPlayer = null;
        this.previousStyles = {};
        this.currentSnapshot = {};
        this._duration = /** @type {?} */ (options['duration']);
        this._delay = /** @type {?} */ (options['delay']) || 0;
        this.time = this._duration + this._delay;
        if (allowPreviousPlayerStylesMerge(this._duration, this._delay)) {
            previousPlayers.forEach(function (player) {
                var /** @type {?} */ styles = player.currentSnapshot;
                Object.keys(styles).forEach(function (prop) { return _this.previousStyles[prop] = styles[prop]; });
            });
        }
    }
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._onFinish = /**
     * @return {?}
     */
    function () {
        if (!this._finished) {
            this._finished = true;
            this._onDoneFns.forEach(function (fn) { return fn(); });
            this._onDoneFns = [];
        }
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.init = /**
     * @return {?}
     */
    function () {
        this._buildPlayer();
        this._preparePlayerBeforeStart();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._buildPlayer = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._initialized)
            return;
        this._initialized = true;
        var /** @type {?} */ keyframes = this.keyframes.map(function (styles) { return copyStyles(styles, false); });
        var /** @type {?} */ previousStyleProps = Object.keys(this.previousStyles);
        if (previousStyleProps.length && keyframes.length) {
            var /** @type {?} */ startingKeyframe_1 = keyframes[0];
            var /** @type {?} */ missingStyleProps_1 = [];
            previousStyleProps.forEach(function (prop) {
                if (!startingKeyframe_1.hasOwnProperty(prop)) {
                    missingStyleProps_1.push(prop);
                }
                startingKeyframe_1[prop] = _this.previousStyles[prop];
            });
            if (missingStyleProps_1.length) {
                var /** @type {?} */ self_1 = this;
                var _loop_1 = function () {
                    var /** @type {?} */ kf = keyframes[i];
                    missingStyleProps_1.forEach(function (prop) {
                        kf[prop] = _computeStyle(self_1.element, prop);
                    });
                };
                // tslint:disable-next-line
                for (var /** @type {?} */ i = 1; i < keyframes.length; i++) {
                    _loop_1();
                }
            }
        }
        (/** @type {?} */ (this)).domPlayer =
            this._triggerWebAnimation(this.element, keyframes, this.options);
        this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : {};
        this.domPlayer.addEventListener('finish', function () { return _this._onFinish(); });
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._preparePlayerBeforeStart = /**
     * @return {?}
     */
    function () {
        // this is required so that the player doesn't start to animate right away
        if (this._delay) {
            this._resetDomPlayerState();
        }
        else {
            this.domPlayer.pause();
        }
    };
    /** @internal */
    /**
     * \@internal
     * @param {?} element
     * @param {?} keyframes
     * @param {?} options
     * @return {?}
     */
    WebAnimationsPlayer.prototype._triggerWebAnimation = /**
     * \@internal
     * @param {?} element
     * @param {?} keyframes
     * @param {?} options
     * @return {?}
     */
    function (element, keyframes, options) {
        // jscompiler doesn't seem to know animate is a native property because it's not fully
        // supported yet across common browsers (we polyfill it for Edge/Safari) [CL #143630929]
        return /** @type {?} */ (element['animate'](keyframes, options));
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    WebAnimationsPlayer.prototype.onStart = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onStartFns.push(fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    WebAnimationsPlayer.prototype.onDone = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onDoneFns.push(fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    WebAnimationsPlayer.prototype.onDestroy = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onDestroyFns.push(fn); };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.play = /**
     * @return {?}
     */
    function () {
        this._buildPlayer();
        if (!this.hasStarted()) {
            this._onStartFns.forEach(function (fn) { return fn(); });
            this._onStartFns = [];
            this._started = true;
        }
        this.domPlayer.play();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.pause = /**
     * @return {?}
     */
    function () {
        this.init();
        this.domPlayer.pause();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.finish = /**
     * @return {?}
     */
    function () {
        this.init();
        this._onFinish();
        this.domPlayer.finish();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.reset = /**
     * @return {?}
     */
    function () {
        this._resetDomPlayerState();
        this._destroyed = false;
        this._finished = false;
        this._started = false;
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._resetDomPlayerState = /**
     * @return {?}
     */
    function () {
        if (this.domPlayer) {
            this.domPlayer.cancel();
        }
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.restart = /**
     * @return {?}
     */
    function () {
        this.reset();
        this.play();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.hasStarted = /**
     * @return {?}
     */
    function () { return this._started; };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.destroy = /**
     * @return {?}
     */
    function () {
        if (!this._destroyed) {
            this._destroyed = true;
            this._resetDomPlayerState();
            this._onFinish();
            this._onDestroyFns.forEach(function (fn) { return fn(); });
            this._onDestroyFns = [];
        }
    };
    /**
     * @param {?} p
     * @return {?}
     */
    WebAnimationsPlayer.prototype.setPosition = /**
     * @param {?} p
     * @return {?}
     */
    function (p) { this.domPlayer.currentTime = p * this.time; };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.getPosition = /**
     * @return {?}
     */
    function () { return this.domPlayer.currentTime / this.time; };
    Object.defineProperty(WebAnimationsPlayer.prototype, "totalTime", {
        get: /**
         * @return {?}
         */
        function () { return this._delay + this._duration; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.beforeDestroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ styles = {};
        if (this.hasStarted()) {
            Object.keys(this._finalKeyframe).forEach(function (prop) {
                if (prop != 'offset') {
                    styles[prop] =
                        _this._finished ? _this._finalKeyframe[prop] : _computeStyle(_this.element, prop);
                }
            });
        }
        this.currentSnapshot = styles;
    };
    /* @internal */
    /**
     * @param {?} phaseName
     * @return {?}
     */
    WebAnimationsPlayer.prototype.triggerCallback = /**
     * @param {?} phaseName
     * @return {?}
     */
    function (phaseName) {
        var /** @type {?} */ methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
        methods.forEach(function (fn) { return fn(); });
        methods.length = 0;
    };
    return WebAnimationsPlayer;
}());
/**
 * @param {?} element
 * @param {?} prop
 * @return {?}
 */
function _computeStyle(element, prop) {
    return (/** @type {?} */ (window.getComputedStyle(element)))[prop];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var WebAnimationsDriver = /** @class */ (function () {
    function WebAnimationsDriver() {
    }
    /**
     * @param {?} prop
     * @return {?}
     */
    WebAnimationsDriver.prototype.validateStyleProperty = /**
     * @param {?} prop
     * @return {?}
     */
    function (prop) { return validateStyleProperty(prop); };
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    WebAnimationsDriver.prototype.matchesElement = /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    function (element, selector) {
        return matchesElement(element, selector);
    };
    /**
     * @param {?} elm1
     * @param {?} elm2
     * @return {?}
     */
    WebAnimationsDriver.prototype.containsElement = /**
     * @param {?} elm1
     * @param {?} elm2
     * @return {?}
     */
    function (elm1, elm2) { return containsElement(elm1, elm2); };
    /**
     * @param {?} element
     * @param {?} selector
     * @param {?} multi
     * @return {?}
     */
    WebAnimationsDriver.prototype.query = /**
     * @param {?} element
     * @param {?} selector
     * @param {?} multi
     * @return {?}
     */
    function (element, selector, multi) {
        return invokeQuery(element, selector, multi);
    };
    /**
     * @param {?} element
     * @param {?} prop
     * @param {?=} defaultValue
     * @return {?}
     */
    WebAnimationsDriver.prototype.computeStyle = /**
     * @param {?} element
     * @param {?} prop
     * @param {?=} defaultValue
     * @return {?}
     */
    function (element, prop, defaultValue) {
        return /** @type {?} */ ((/** @type {?} */ (window.getComputedStyle(element)))[prop]);
    };
    /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} duration
     * @param {?} delay
     * @param {?} easing
     * @param {?=} previousPlayers
     * @return {?}
     */
    WebAnimationsDriver.prototype.animate = /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} duration
     * @param {?} delay
     * @param {?} easing
     * @param {?=} previousPlayers
     * @return {?}
     */
    function (element, keyframes, duration, delay, easing, previousPlayers) {
        if (previousPlayers === void 0) { previousPlayers = []; }
        var /** @type {?} */ fill = delay == 0 ? 'both' : 'forwards';
        var /** @type {?} */ playerOptions = { duration: duration, delay: delay, fill: fill };
        // we check for this to avoid having a null|undefined value be present
        // for the easing (which results in an error for certain browsers #9752)
        if (easing) {
            playerOptions['easing'] = easing;
        }
        var /** @type {?} */ previousWebAnimationPlayers = /** @type {?} */ (previousPlayers.filter(function (player) { return player instanceof WebAnimationsPlayer; }));
        return new WebAnimationsPlayer(element, keyframes, playerOptions, previousWebAnimationPlayers);
    };
    return WebAnimationsDriver;
}());
/**
 * @return {?}
 */
function supportsWebAnimations() {
    return typeof Element !== 'undefined' && typeof (/** @type {?} */ (Element)).prototype['animate'] === 'function';
}

exports.AnimationDriver = AnimationDriver;
exports.ɵAnimation = Animation;
exports.ɵAnimationStyleNormalizer = AnimationStyleNormalizer;
exports.ɵNoopAnimationStyleNormalizer = NoopAnimationStyleNormalizer;
exports.ɵWebAnimationsStyleNormalizer = WebAnimationsStyleNormalizer;
exports.ɵNoopAnimationDriver = NoopAnimationDriver;
exports.ɵAnimationEngine = AnimationEngine;
exports.ɵWebAnimationsDriver = WebAnimationsDriver;
exports.ɵsupportsWebAnimations = supportsWebAnimations;
exports.ɵWebAnimationsPlayer = WebAnimationsPlayer;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=animations-browser.umd.js.map


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var AppComponent = /** @class */ (function () {
    function AppComponent() {
    }
    AppComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'app',
            template: __webpack_require__(77),
            styles: [__webpack_require__(84)]
        })
    ], AppComponent);
    return AppComponent;
}());



/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Comment;

var Node = __webpack_require__(2);
var CharacterData = __webpack_require__(6);

function Comment(doc, data) {
  this.nodeType = Node.COMMENT_NODE;
  this.ownerDocument = doc;
  this._data = data;
  this._index = undefined;
}

var nodeValue = {
  get: function() { return this._data; },
  set: function(v) {
    this._data = v;
    if (this.rooted)
      this.ownerDocument.mutateValue(this);
  }
};

Comment.prototype = Object.create(CharacterData.prototype, {
  nodeName: { value: '#comment' },
  nodeValue: nodeValue,
  textContent: nodeValue,
  data: nodeValue,

  // Utility methods
  clone: { value: function clone() {
    return new Comment(this.ownerDocument, this._data);
  }},
});


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = DOMException;

var INDEX_SIZE_ERR = 1;
var HIERARCHY_REQUEST_ERR = 3;
var WRONG_DOCUMENT_ERR = 4;
var INVALID_CHARACTER_ERR = 5;
var NO_MODIFICATION_ALLOWED_ERR = 7;
var NOT_FOUND_ERR = 8;
var NOT_SUPPORTED_ERR = 9;
var INVALID_STATE_ERR = 11;
var SYNTAX_ERR = 12;
var INVALID_MODIFICATION_ERR = 13;
var NAMESPACE_ERR = 14;
var INVALID_ACCESS_ERR = 15;
var TYPE_MISMATCH_ERR = 17;
var SECURITY_ERR = 18;
var NETWORK_ERR = 19;
var ABORT_ERR = 20;
var URL_MISMATCH_ERR = 21;
var QUOTA_EXCEEDED_ERR = 22;
var TIMEOUT_ERR = 23;
var INVALID_NODE_TYPE_ERR = 24;
var DATA_CLONE_ERR = 25;

// Code to name
var names = [
  null,  // No error with code 0
  'INDEX_SIZE_ERR',
  null, // historical
  'HIERARCHY_REQUEST_ERR',
  'WRONG_DOCUMENT_ERR',
  'INVALID_CHARACTER_ERR',
  null, // historical
  'NO_MODIFICATION_ALLOWED_ERR',
  'NOT_FOUND_ERR',
  'NOT_SUPPORTED_ERR',
  null, // historical
  'INVALID_STATE_ERR',
  'SYNTAX_ERR',
  'INVALID_MODIFICATION_ERR',
  'NAMESPACE_ERR',
  'INVALID_ACCESS_ERR',
  null, // historical
  'TYPE_MISMATCH_ERR',
  'SECURITY_ERR',
  'NETWORK_ERR',
  'ABORT_ERR',
  'URL_MISMATCH_ERR',
  'QUOTA_EXCEEDED_ERR',
  'TIMEOUT_ERR',
  'INVALID_NODE_TYPE_ERR',
  'DATA_CLONE_ERR',
];

// Code to message
// These strings are from the 13 May 2011 Editor's Draft of DOM Core.
// http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html
// Copyright © 2011 W3C® (MIT, ERCIM, Keio), All Rights Reserved.
// Used under the terms of the W3C Document License:
// http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231
var messages = [
  null,  // No error with code 0
  'INDEX_SIZE_ERR (1): the index is not in the allowed range',
  null,
  'HIERARCHY_REQUEST_ERR (3): the operation would yield an incorrect nodes model',
  'WRONG_DOCUMENT_ERR (4): the object is in the wrong Document, a call to importNode is required',
  'INVALID_CHARACTER_ERR (5): the string contains invalid characters',
  null,
  'NO_MODIFICATION_ALLOWED_ERR (7): the object can not be modified',
  'NOT_FOUND_ERR (8): the object can not be found here',
  'NOT_SUPPORTED_ERR (9): this operation is not supported',
  null,
  'INVALID_STATE_ERR (11): the object is in an invalid state',
  'SYNTAX_ERR (12): the string did not match the expected pattern',
  'INVALID_MODIFICATION_ERR (13): the object can not be modified in this way',
  'NAMESPACE_ERR (14): the operation is not allowed by Namespaces in XML',
  'INVALID_ACCESS_ERR (15): the object does not support the operation or argument',
  null,
  'TYPE_MISMATCH_ERR (17): the type of the object does not match the expected type',
  'SECURITY_ERR (18): the operation is insecure',
  'NETWORK_ERR (19): a network error occurred',
  'ABORT_ERR (20): the user aborted an operation',
  'URL_MISMATCH_ERR (21): the given URL does not match another URL',
  'QUOTA_EXCEEDED_ERR (22): the quota has been exceeded',
  'TIMEOUT_ERR (23): a timeout occurred',
  'INVALID_NODE_TYPE_ERR (24): the supplied node is invalid or has an invalid ancestor for this operation',
  'DATA_CLONE_ERR (25): the object can not be cloned.'
];

// Name to code
var constants = {
  INDEX_SIZE_ERR: INDEX_SIZE_ERR,
  DOMSTRING_SIZE_ERR: 2, // historical
  HIERARCHY_REQUEST_ERR: HIERARCHY_REQUEST_ERR,
  WRONG_DOCUMENT_ERR: WRONG_DOCUMENT_ERR,
  INVALID_CHARACTER_ERR: INVALID_CHARACTER_ERR,
  NO_DATA_ALLOWED_ERR: 6, // historical
  NO_MODIFICATION_ALLOWED_ERR: NO_MODIFICATION_ALLOWED_ERR,
  NOT_FOUND_ERR: NOT_FOUND_ERR,
  NOT_SUPPORTED_ERR: NOT_SUPPORTED_ERR,
  INUSE_ATTRIBUTE_ERR: 10, // historical
  INVALID_STATE_ERR: INVALID_STATE_ERR,
  SYNTAX_ERR: SYNTAX_ERR,
  INVALID_MODIFICATION_ERR: INVALID_MODIFICATION_ERR,
  NAMESPACE_ERR: NAMESPACE_ERR,
  INVALID_ACCESS_ERR: INVALID_ACCESS_ERR,
  VALIDATION_ERR: 16, // historical
  TYPE_MISMATCH_ERR: TYPE_MISMATCH_ERR,
  SECURITY_ERR: SECURITY_ERR,
  NETWORK_ERR: NETWORK_ERR,
  ABORT_ERR: ABORT_ERR,
  URL_MISMATCH_ERR: URL_MISMATCH_ERR,
  QUOTA_EXCEEDED_ERR: QUOTA_EXCEEDED_ERR,
  TIMEOUT_ERR: TIMEOUT_ERR,
  INVALID_NODE_TYPE_ERR: INVALID_NODE_TYPE_ERR,
  DATA_CLONE_ERR: DATA_CLONE_ERR
};

function DOMException(code) {
  Error.call(this);
  Error.captureStackTrace(this, this.constructor);
  this.code = code;
  this.message = messages[code];
  this.name = names[code];
}
DOMException.prototype.__proto__ = Error.prototype;

// Initialize the constants on DOMException and DOMException.prototype
for(var c in constants) {
  var v = { value: constants[c] };
  Object.defineProperty(DOMException, c, v);
  Object.defineProperty(DOMException.prototype, c, v);
}


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// DOMTokenList implementation based on https://github.com/Raynos/DOM-shim
var utils = __webpack_require__(1);

module.exports = DOMTokenList;

function DOMTokenList(getter, setter) {
  this._getString = getter;
  this._setString = setter;
  fixIndex(this, getList(this));
}

DOMTokenList.prototype = {
  item: function(index) {
    if (index >= this.length) {
      return null;
    }
    return this._getString().split(" ")[index];
  },

  contains: function(token) {
    token = String(token);
    handleErrors(token);
    var list = getList(this);
    return list.indexOf(token) > -1;
  },

  add: function(token) {
    handleErrors(token);
    var list = getList(this);
    if (list.indexOf(token) > -1) {
      return;
    }
    list.push(token);
    this._setString(list.join(" ").trim());
    fixIndex(this, list);
  },

  remove: function(token) {
    handleErrors(token);
    var list = getList(this);
    var index = list.indexOf(token);
    if (index > -1) {
      list.splice(index, 1);
      this._setString(list.join(" ").trim());
    }
    fixIndex(this, list);
  },

  toggle: function toggle(token) {
    if (this.contains(token)) {
      this.remove(token);
      return false;
    }
    else {
      this.add(token);
      return true;
    }
  },

  toString: function() {
    return this._getString();
  }
};

function fixIndex(clist, list) {
  clist.length = list.length;
  for (var i = 0; i < list.length; i++) {
    clist[i] = list[i];
  }
}

function handleErrors(token) {
  if (token === "" || token === undefined) {
    utils.SyntaxError();
  }
  if (token.indexOf(" ") > -1) {
    utils.InvalidCharacterError();
  }
}

function getList(clist) {
  var str = clist._getString();
  if (str === "") {
    return [];
  }
  else {
    return str.split(" ");
  }
}


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports =  DocumentFragment;

var Node = __webpack_require__(2);
var NodeList = __webpack_require__(9);
var Element = __webpack_require__(4);
var select = __webpack_require__(19);
var utils = __webpack_require__(1);

function DocumentFragment(doc) {
  this.nodeType = Node.DOCUMENT_FRAGMENT_NODE;
  this.ownerDocument = doc;
  this.childNodes = [];
}

DocumentFragment.prototype = Object.create(Node.prototype, {
  nodeName: { value: '#document-fragment' },
  nodeValue: { 
    get: function() { 
      return null;
    },
    set: function() {}
  },
  // Copy the text content getter/setter from Element
  textContent: Object.getOwnPropertyDescriptor(Element.prototype, 'textContent'),

  querySelector: { value: function(selector) {
    // implement in terms of querySelectorAll
    var nodes = this.querySelectorAll(selector);
    return nodes.length ? nodes[0] : null;
  }},
  querySelectorAll: { value: function(selector) {
    // create a context
    var context = Object.create(this);
    // add some methods to the context for zest implementation, without
    // adding them to the public DocumentFragment API
    context.isHTML = true; // in HTML namespace (case-insensitive match)
    context.getElementsByTagName = Element.prototype.getElementsByTagName;
    context.nextElement =
      Object.getOwnPropertyDescriptor(Element.prototype, 'firstElementChild').
      get;
    // invoke zest
    var nodes = select(selector, context);
    return nodes.item ? nodes : new NodeList(nodes);
  }},

  // Utility methods
  clone: { value: function clone() {
      return new DocumentFragment(this.ownerDocument);
  }},
  isEqual: { value: function isEqual(n) {
      // Any two document fragments are shallowly equal.
      // Node.isEqualNode() will test their children for equality
      return true;
  }},

  // Non-standard, but useful (github issue #73)
  innerHTML: {
    get: function() { return this.serialize(); },
    set: utils.nyi
  },
  outerHTML: {
    get: function() { return this.serialize(); },
    set: utils.nyi
  },

});


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Event = __webpack_require__(5);
var MouseEvent = __webpack_require__(34);
var utils = __webpack_require__(1);

module.exports = EventTarget;

function EventTarget() {}

EventTarget.prototype = {
  // XXX
  // See WebIDL §4.8 for details on object event handlers
  // and how they should behave.  We actually have to accept
  // any object to addEventListener... Can't type check it.
  // on registration.

  // XXX:
  // Capturing event listeners are sort of rare.  I think I can optimize
  // them so that dispatchEvent can skip the capturing phase (or much of
  // it).  Each time a capturing listener is added, increment a flag on
  // the target node and each of its ancestors.  Decrement when removed.
  // And update the counter when nodes are added and removed from the
  // tree as well.  Then, in dispatch event, the capturing phase can
  // abort if it sees any node with a zero count.
  addEventListener: function addEventListener(type, listener, capture) {
    if (!listener) return;
    if (capture === undefined) capture = false;
    if (!this._listeners) this._listeners = Object.create(null);
    if (!this._listeners[type]) this._listeners[type] = [];
    var list = this._listeners[type];

    // If this listener has already been registered, just return
    for(var i = 0, n = list.length; i < n; i++) {
      var l = list[i];
      if (l.listener === listener && l.capture === capture)
        return;
    }

    // Add an object to the list of listeners
    var obj = { listener: listener, capture: capture };
    if (typeof listener === 'function') obj.f = listener;
    list.push(obj);
  },

  removeEventListener: function removeEventListener(type,
                            listener,
                            capture) {
    if (capture === undefined) capture = false;
    if (this._listeners) {
      var list = this._listeners[type];
      if (list) {
        // Find the listener in the list and remove it
        for(var i = 0, n = list.length; i < n; i++) {
          var l = list[i];
          if (l.listener === listener && l.capture === capture) {
            if (list.length === 1) {
              this._listeners[type] = undefined;
            }
            else {
              list.splice(i, 1);
            }
            return;
          }
        }
      }
    }
  },

  // This is the public API for dispatching untrusted public events.
  // See _dispatchEvent for the implementation
  dispatchEvent: function dispatchEvent(event) {
    // Dispatch an untrusted event
    return this._dispatchEvent(event, false);
  },

  //
  // See DOMCore §4.4
  // XXX: I'll probably need another version of this method for
  // internal use, one that does not set isTrusted to false.
  // XXX: see Document._dispatchEvent: perhaps that and this could
  // call a common internal function with different settings of
  // a trusted boolean argument
  //
  // XXX:
  // The spec has changed in how to deal with handlers registered
  // on idl or content attributes rather than with addEventListener.
  // Used to say that they always ran first.  That's how webkit does it
  // Spec now says that they run in a position determined by
  // when they were first set.  FF does it that way.  See:
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#event-handlers
  //
  _dispatchEvent: function _dispatchEvent(event, trusted) {
    if (typeof trusted !== 'boolean') trusted = false;
    function invoke(target, event) {
      var type = event.type, phase = event.eventPhase;
      event.currentTarget = target;

      // If there was an individual handler defined, invoke it first
      // XXX: see comment above: this shouldn't always be first.
      if (phase !== Event.CAPTURING_PHASE &&
        target._handlers && target._handlers[type])
      {
        var handler = target._handlers[type];
        var rv;
        if (typeof handler === 'function') {
          rv=handler.call(event.currentTarget, event);
        }
        else {
          var f = handler.handleEvent;
          if (typeof f !== 'function')
            throw new TypeError('handleEvent property of ' +
                                'event handler object is' +
                                'not a function.');
          rv=f.call(handler, event);
        }

        switch(event.type) {
        case 'mouseover':
          if (rv === true)  // Historical baggage
            event.preventDefault();
          break;
        case 'beforeunload':
          // XXX: eventually we need a special case here
          /* falls through */
        default:
          if (rv === false)
            event.preventDefault();
          break;
        }
      }

      // Now invoke list list of listeners for this target and type
      var list = target._listeners && target._listeners[type];
      if (!list) return;
      list = list.slice();
      for(var i = 0, n = list.length; i < n; i++) {
        if (event._immediatePropagationStopped) return;
        var l = list[i];
        if ((phase === Event.CAPTURING_PHASE && !l.capture) ||
          (phase === Event.BUBBLING_PHASE && l.capture))
          continue;
        if (l.f) {
          l.f.call(event.currentTarget, event);
        }
        else {
          var fn = l.listener.handleEvent;
          if (typeof fn !== 'function')
            throw new TypeError('handleEvent property of event listener object is not a function.');
          fn.call(l.listener, event);
        }
      }
    }

    if (!event._initialized || event._dispatching) utils.InvalidStateError();
    event.isTrusted = trusted;

    // Begin dispatching the event now
    event._dispatching = true;
    event.target = this;

    // Build the list of targets for the capturing and bubbling phases
    // XXX: we'll eventually have to add Window to this list.
    var ancestors = [];
    for(var n = this.parentNode; n; n = n.parentNode)
      ancestors.push(n);

    // Capturing phase
    event.eventPhase = Event.CAPTURING_PHASE;
    for(var i = ancestors.length-1; i >= 0; i--) {
      invoke(ancestors[i], event);
      if (event._propagationStopped) break;
    }

    // At target phase
    if (!event._propagationStopped) {
      event.eventPhase = Event.AT_TARGET;
      invoke(this, event);
    }

    // Bubbling phase
    if (event.bubbles && !event._propagationStopped) {
      event.eventPhase = Event.BUBBLING_PHASE;
      for(var ii = 0, nn = ancestors.length; ii < nn; ii++) {
        invoke(ancestors[ii], event);
        if (event._propagationStopped) break;
      }
    }

    event._dispatching = false;
    event.eventPhase = Event.AT_TARGET;
    event.currentTarget = null;

    // Deal with mouse events and figure out when
    // a click has happened
    if (trusted && !event.defaultPrevented && event instanceof MouseEvent) {
      switch(event.type) {
      case 'mousedown':
        this._armed = {
          x: event.clientX,
          y: event.clientY,
          t: event.timeStamp
        };
        break;
      case 'mouseout':
      case 'mouseover':
        this._armed = null;
        break;
      case 'mouseup':
        if (this._isClick(event)) this._doClick(event);
        this._armed = null;
        break;
      }
    }



    return !event.defaultPrevented;
  },

  // Determine whether a click occurred
  // XXX We don't support double clicks for now
  _isClick: function(event) {
    return (this._armed !== null &&
        event.type === 'mouseup' &&
        event.isTrusted &&
        event.button === 0 &&
        event.timeStamp - this._armed.t < 1000 &&
        Math.abs(event.clientX - this._armed.x) < 10 &&
        Math.abs(event.clientY - this._armed.Y) < 10);
  },

  // Clicks are handled like this:
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#interactive-content-0
  //
  // Note that this method is similar to the HTMLElement.click() method
  // The event argument must be the trusted mouseup event
  _doClick: function(event) {
    if (this._click_in_progress) return;
    this._click_in_progress = true;

    // Find the nearest enclosing element that is activatable
    // An element is activatable if it has a
    // _post_click_activation_steps hook
    var activated = this;
    while(activated && !activated._post_click_activation_steps)
      activated = activated.parentNode;

    if (activated && activated._pre_click_activation_steps) {
      activated._pre_click_activation_steps();
    }

    var click = this.ownerDocument.createEvent('MouseEvent');
    click.initMouseEvent('click', true, true,
      this.ownerDocument.defaultView, 1,
      event.screenX, event.screenY,
      event.clientX, event.clientY,
      event.ctrlKey, event.altKey,
      event.shiftKey, event.metaKey,
      event.button, null);

    var result = this._dispatchEvent(click, true);

    if (activated) {
      if (result) {
        // This is where hyperlinks get followed, for example.
        if (activated._post_click_activation_steps)
          activated._post_click_activation_steps(click);
      }
      else {
        if (activated._cancelled_activation_steps)
          activated._cancelled_activation_steps();
      }
    }
  },

  //
  // An event handler is like an event listener, but it registered
  // by setting an IDL or content attribute like onload or onclick.
  // There can only be one of these at a time for any event type.
  // This is an internal method for the attribute accessors and
  // content attribute handlers that need to register events handlers.
  // The type argument is the same as in addEventListener().
  // The handler argument is the same as listeners in addEventListener:
  // it can be a function or an object. Pass null to remove any existing
  // handler.  Handlers are always invoked before any listeners of
  // the same type.  They are not invoked during the capturing phase
  // of event dispatch.
  //
  _setEventHandler: function _setEventHandler(type, handler) {
    if (!this._handlers) this._handlers = Object.create(null);
    this._handlers[type] = handler;
  },

  _getEventHandler: function _getEventHandler(type) {
    return (this._handlers && this._handlers[type]) || null;
  }

};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Leaf;

var Node = __webpack_require__(2);
var utils = __webpack_require__(1);
var HierarchyRequestError = utils.HierarchyRequestError;
var NotFoundError = utils.NotFoundError;

// This class defines common functionality for node subtypes that
// can never have children
function Leaf() {
}

Leaf.prototype = Object.create(Node.prototype, {
  hasChildNodes: { value: function() { return false; }},
  firstChild: { value: null },
  lastChild: { value: null },
  insertBefore: { value: function(node, child) {
    if (!node.nodeType) throw new TypeError('not a node');
    HierarchyRequestError();
  }},
  replaceChild: { value: function(node, child) {
    if (!node.nodeType) throw new TypeError('not a node');
    HierarchyRequestError();
  }},
  removeChild: { value: function(node) {
    if (!node.nodeType) throw new TypeError('not a node');
    NotFoundError();
  }},
  childNodes: { get: function() {
    if (!this._childNodes) this._childNodes = [];
    return this._childNodes;
  }}
});


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var UIEvent = __webpack_require__(39);

module.exports = MouseEvent;

function MouseEvent() {
  // Just use the superclass constructor to initialize
  UIEvent.call(this);

  this.screenX = this.screenY = this.clientX = this.clientY = 0;
  this.ctrlKey = this.altKey = this.shiftKey = this.metaKey = false;
  this.button = 0;
  this.buttons = 1;
  this.relatedTarget = null;
}
MouseEvent.prototype = Object.create(UIEvent.prototype, {
  constructor: { value: MouseEvent },
  initMouseEvent: { value: function(type, bubbles, cancelable,
    view, detail,
    screenX, screenY, clientX, clientY,
    ctrlKey, altKey, shiftKey, metaKey,
    button, relatedTarget) {

    this.initEvent(type, bubbles, cancelable, view, detail);
    this.screenX = screenX;
    this.screenY = screenY;
    this.clientX = clientX;
    this.clientY = clientY;
    this.ctrlKey = ctrlKey;
    this.altKey = altKey;
    this.shiftKey = shiftKey;
    this.metaKey = metaKey;
    this.button = button;
    switch(button) {
    case 0: this.buttons = 1; break;
    case 1: this.buttons = 4; break;
    case 2: this.buttons = 2; break;
    default: this.buttons = 0; break;
    }
    this.relatedTarget = relatedTarget;
  }},

  getModifierState: { value: function(key) {
    switch(key) {
    case "Alt": return this.altKey;
    case "Control": return this.ctrlKey;
    case "Shift": return this.shiftKey;
    case "Meta": return this.metaKey;
    default: return false;
    }
  }}
});


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* exported NodeTraversal */
var NodeTraversal = module.exports = {
  nextSkippingChildren: nextSkippingChildren,
  nextAncestorSibling: nextAncestorSibling,
  next: next,
  previous: previous,
  deepLastChild: deepLastChild
};

/**
 * @based on WebKit's NodeTraversal::nextSkippingChildren
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.h?rev=179143#L109
 */
function nextSkippingChildren(node, stayWithin) {
  if (node === stayWithin) {
    return null;
  }
  if (node.nextSibling !== null) {
    return node.nextSibling;
  }
  return nextAncestorSibling(node, stayWithin);
}

/**
 * @based on WebKit's NodeTraversal::nextAncestorSibling
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.cpp?rev=179143#L93
 */
function nextAncestorSibling(node, stayWithin) {
  for (node = node.parentNode; node !== null; node = node.parentNode) {
    if (node === stayWithin) {
      return null;
    }
    if (node.nextSibling !== null) {
      return node.nextSibling;
    }
  }
  return null;
}

/**
 * @based on WebKit's NodeTraversal::next
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.h?rev=179143#L99
 */
function next(node, stayWithin) {
  var n;
  n = node.firstChild;
  if (n !== null) {
    return n;
  }
  if (node === stayWithin) {
    return null;
  }
  n = node.nextSibling;
  if (n !== null) {
    return n;
  }
  return nextAncestorSibling(node, stayWithin);
}

/**
 * @based on WebKit's NodeTraversal::deepLastChild
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.cpp?rev=179143#L116
 */
function deepLastChild(node) {
  while (node.lastChild) {
    node = node.lastChild;
  }
  return node;
}

/**
 * @based on WebKit's NodeTraversal::previous
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.h?rev=179143#L121
 */
function previous(node, stayWithin) {
  var p;
  p = node.previousSibling;
  if (p !== null) {
    return deepLastChild(p);
  }
  p = node.parentNode;
  if (p === stayWithin) {
    return null;
  }
  return p;
}


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Node = __webpack_require__(2);

var NonDocumentTypeChildNode = {

  nextElementSibling: { get: function() {
    if (this.parentNode) {
      var sibs = this.parentNode.childNodes;
      for(var i = this.index+1, n = sibs.length; i < n; i++) {
        if (sibs[i].nodeType === Node.ELEMENT_NODE) return sibs[i];
      }
    }
    return null;
  }},

  previousElementSibling: { get: function() {
    if (this.parentNode) {
      var sibs = this.parentNode.childNodes;
      for(var i = this.index-1; i >= 0; i--) {
        if (sibs[i].nodeType === Node.ELEMENT_NODE) return sibs[i];
      }
    }
    return null;
  }}

};

module.exports = NonDocumentTypeChildNode;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = ProcessingInstruction;

var Node = __webpack_require__(2);
var CharacterData = __webpack_require__(6);

function ProcessingInstruction(doc, target, data) {
  this.nodeType = Node.PROCESSING_INSTRUCTION_NODE;
  this.ownerDocument = doc;
  this.target = target;
  this._data = data;
}

var nodeValue = {
  get: function() { return this._data; },
  set: function(v) {
    this._data = v;
    if (this.rooted) this.ownerDocument.mutateValue(this);
  }
};

ProcessingInstruction.prototype = Object.create(CharacterData.prototype, {
  nodeName: { get: function() { return this.target; }},
  nodeValue: nodeValue,
  textContent: nodeValue,
  data: nodeValue,

  // Utility methods
  clone: { value: function clone() {
      return new ProcessingInstruction(this.ownerDocument, this.target, this._data);
  }},
  isEqual: { value: function isEqual(n) {
      return this.target === n.target && this._data === n._data;
  }}

});


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Text;

var utils = __webpack_require__(1);
var Node = __webpack_require__(2);
var CharacterData = __webpack_require__(6);

function Text(doc, data) {
  this.nodeType = Node.TEXT_NODE;
  this.ownerDocument = doc;
  this._data = data;
  this._index = undefined;
}

var nodeValue = {
  get: function() { return this._data; },
  set: function(v) {
    if (v === this._data) return;
    this._data = v;
    if (this.rooted)
      this.ownerDocument.mutateValue(this);
    if (this.parentNode &&
      this.parentNode._textchangehook)
      this.parentNode._textchangehook(this);
  }
};

Text.prototype = Object.create(CharacterData.prototype, {
  nodeName: { value: "#text" },
  // These three attributes are all the same.
  // The data attribute has a [TreatNullAs=EmptyString] but we'll
  // implement that at the interface level
  nodeValue: nodeValue,
  textContent: nodeValue,
  data: nodeValue,

  splitText: { value: function splitText(offset) {
    if (offset > this._data.length || offset < 0) utils.IndexSizeError();

    var newdata = this._data.substring(offset),
      newnode = this.ownerDocument.createTextNode(newdata);
    this.data = this.data.substring(0, offset);

    var parent = this.parentNode;
    if (parent !== null)
      parent.insertBefore(newnode, this.nextSibling);

    return newnode;
  }},

  // XXX
  // wholeText and replaceWholeText() are not implemented yet because
  // the DOMCore specification is considering removing or altering them.
  wholeText: {get: utils.nyi },
  replaceWholeText: { value: utils.nyi },

  // Utility methods
  clone: { value: function clone() {
    return new Text(this.ownerDocument, this._data);
  }},

});


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Event = __webpack_require__(5);

module.exports = UIEvent;

function UIEvent() {
  // Just use the superclass constructor to initialize
  Event.call(this);
  this.view = null; // FF uses the current window
  this.detail = 0;
}
UIEvent.prototype = Object.create(Event.prototype, {
  constructor: { value: UIEvent },
  initUIEvent: { value: function(type, bubbles, cancelable, view, detail) {
    this.initEvent(type, bubbles, cancelable);
    this.view = view;
    this.detail = detail;
  }}
});


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var URL = __webpack_require__(16);

module.exports = URLUtils;

// This is an abstract superclass for Location, HTMLAnchorElement and
// other types that have the standard complement of "URL decomposition
// IDL attributes".  This is now standardized as URLUtils, see:
// https://url.spec.whatwg.org/#urlutils
// Subclasses must define a getter/setter on href.
// The getter and setter methods parse and rebuild the URL on each
// invocation; there is no attempt to cache the value and be more efficient
function URLUtils() {}
URLUtils.prototype = {
  constructor: URLUtils,

  get protocol() {
    var url = new URL(this.href);
    if (url.isAbsolute()) return url.scheme + ":";
    else return "";
  },

  get host() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.isAuthorityBased())
      return url.host + (url.port ? (":" + url.port) : "");
    else
      return "";
  },

  get hostname() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.isAuthorityBased())
      return url.host;
    else
      return "";
  },

  get port() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.isAuthorityBased() && url.port!==undefined)
      return url.port;
    else
      return "";
  },

  get pathname() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.isHierarchical())
      return url.path;
    else
      return "";
  },

  get search() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.isHierarchical() && url.query!==undefined)
      return "?" + url.query;
    else
      return "";
  },

  get hash() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.fragment !== undefined)
      return "#" + url.fragment;
    else
      return "";
  },

  get username() {
    var url = new URL(this.href);
    return url.username || '';
  },

  get password() {
    var url = new URL(this.href);
    return url.password || '';
  },

  get origin() {
    var url = new URL(this.href);
    var originForPort = function(defaultPort) {
      var origin = [url.scheme, url.host, +url.port || defaultPort];
      // XXX should be "unicode serialization"
      return origin[0] + '://' + origin[1] +
        (origin[2] === defaultPort ? '' : (':' + origin[2]));
    };
    switch (url.scheme) {
    case 'ftp':
      return originForPort(21);
    case 'gopher':
      return originForPort(70);
    case 'http':
    case 'ws':
      return originForPort(80);
    case 'https':
    case 'wss':
      return originForPort(443);
    default:
      // this is what chrome does
      return url.scheme + '://';
    }
  },

  /*
  get searchParams() {
    var url = new URL(this.href);
    // XXX
  },
  */

  set protocol(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute()) {
      v = v.replace(/:+$/, "");
      v = v.replace(/[^-+\.a-zA-Z0-9]/g, URL.percentEncode);
      if (v.length > 0) {
        url.scheme = v;
        output = url.toString();
      }
    }
    this.href = output;
  },

  set host(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute() && url.isAuthorityBased()) {
      v = v.replace(/[^-+\._~!$&'()*,;:=a-zA-Z0-9]/g, URL.percentEncode);
      if (v.length > 0) {
        url.host = v;
        delete url.port;
        output = url.toString();
      }
    }
    this.href = output;
  },

  set hostname(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute() && url.isAuthorityBased()) {
      v = v.replace(/^\/+/, "");
      v = v.replace(/[^-+\._~!$&'()*,;:=a-zA-Z0-9]/g, URL.percentEncode);
      if (v.length > 0) {
        url.host = v;
        output = url.toString();
      }
    }
    this.href = output;
  },

  set port(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute() && url.isAuthorityBased()) {
      v = '' + v;
      v = v.replace(/[^0-9].*$/, "");
      v = v.replace(/^0+/, "");
      if (v.length === 0) v = "0";
      if (parseInt(v, 10) <= 65535) {
        url.port = v;
        output = url.toString();
      }
    }
    this.href = output;
  },

  set pathname(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute() && url.isHierarchical()) {
      if (v.charAt(0) !== "/")
        v = "/" + v;
      v = v.replace(/[^-+\._~!$&'()*,;:=@\/a-zA-Z0-9]/g, URL.percentEncode);
      url.path = v;
      output = url.toString();
    }
    this.href = output;
  },

  set search(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute() && url.isHierarchical()) {
      if (v.charAt(0) === "?") v = v.substring(1);
      v = v.replace(/[^-+\._~!$&'()*,;:=@\/?a-zA-Z0-9]/g, URL.percentEncode);
      url.query = v;
      output = url.toString();
    }
    this.href = output;
  },

  set hash(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute()) {
      if (v.charAt(0) === "#") v = v.substring(1);
      v = v.replace(/[^-+\._~!$&'()*,;:=@\/?a-zA-Z0-9]/g, URL.percentEncode);
      url.fragment = v;
      output = url.toString();
    }
    this.href = output;
  },

  set username(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute()) {
      v = v.replace(/[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\:]/g, URL.percentEncode);
      url.username = v;
      output = url.toString();
    }
    this.href = output;
  },

  set password(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute()) {
      if (v==='') {
        url.password = null;
      } else {
        v = v.replace(/[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\]/g, URL.percentEncode);
        url.password = v;
      }
      output = url.toString();
    }
    this.href = output;
  }/*,

  set searchParams(v) {
    var output = this.href;
    var url = new URL(output);
    // XXX
    this.href = output;
  }
  */
};

URLUtils._inherit = function(proto) {
  // copy getters/setters from URLUtils to o.
  Object.getOwnPropertyNames(URLUtils.prototype).forEach(function(p) {
    if (p==='constructor' || p==='href') { return; }
    var desc = Object.getOwnPropertyDescriptor(URLUtils.prototype, p);
    Object.defineProperty(proto, p, desc);
  });
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var utils = __webpack_require__(1);

exports.property = function(attr) {
  if (Array.isArray(attr.type)) {
    var valid = Object.create(null);
    attr.type.forEach(function(val) {
      valid[val.value || val] = val.alias || val;
    });
    var missingValueDefault = attr.missing;
    if (missingValueDefault===undefined) { missingValueDefault = null; }
    var invalidValueDefault = attr.invalid;
    if (invalidValueDefault===undefined) { invalidValueDefault = missingValueDefault; }
    return {
      get: function() {
        var v = this._getattr(attr.name);
        if (v === null) return missingValueDefault;

        v = valid[v.toLowerCase()];
        if (v !== undefined) return v;
        if (invalidValueDefault !== null) return invalidValueDefault;
        return v;
      },
      set: function(v) {
        this._setattr(attr.name, v);
      }
    };
  }
  else if (attr.type === Boolean) {
    return {
      get: function() {
        return this.hasAttribute(attr.name);
      },
      set: function(v) {
        if (v) {
          this._setattr(attr.name, '');
        }
        else {
          this.removeAttribute(attr.name);
        }
      }
    };
  }
  else if (attr.type === Number ||
           attr.type === "long" ||
           attr.type === "unsigned long" ||
           attr.type === "limited unsigned long with fallback") {
    return numberPropDesc(attr);
  }
  else if (!attr.type || attr.type === String) {
    return {
      get: function() { return this._getattr(attr.name) || ''; },
      set: function(v) {
        if (attr.treatNullAsEmptyString && v === null) { v = ''; }
        this._setattr(attr.name, v);
      }
    };
  }
  else if (typeof attr.type === 'function') {
    return attr.type(attr.name, attr);
  }
  throw new Error('Invalid attribute definition');
};

// See http://www.whatwg.org/specs/web-apps/current-work/#reflect
//
// defval is the default value. If it is a function, then that function
// will be invoked as a method of the element to obtain the default.
// If no default is specified for a given attribute, then the default
// depends on the type of the attribute, but since this function handles
// 4 integer cases, you must specify the default value in each call
//
// min and max define a valid range for getting the attribute.
//
// setmin defines a minimum value when setting.  If the value is less
// than that, then throw INDEX_SIZE_ERR.
//
// Conveniently, JavaScript's parseInt function appears to be
// compatible with HTML's 'rules for parsing integers'
function numberPropDesc(a) {
  var def;
  if(typeof a.default === 'function') {
    def = a.default;
  }
  else if(typeof a.default === 'number') {
    def = function() { return a.default; };
  }
  else {
    def = function() { utils.assert(false, typeof a.default); };
  }
  var unsigned_long = (a.type === 'unsigned long');
  var signed_long = (a.type === 'long');
  var unsigned_fallback = (a.type === 'limited unsigned long with fallback');
  var min = a.min, max = a.max, setmin = a.setmin;
  if (min === undefined) {
    if (unsigned_long) min = 0;
    if (signed_long) min = -0x80000000;
    if (unsigned_fallback) min = 1;
  }
  if (max === undefined) {
    if (unsigned_long || signed_long || unsigned_fallback) max = 0x7FFFFFFF;
  }

  return {
    get: function() {
      var v = this._getattr(a.name);
      var n = a.float ? parseFloat(v) : parseInt(v, 10);
      if (v === null || !isFinite(n) || (min !== undefined && n < min) || (max !== undefined && n > max)) {
        return def.call(this);
      }
      if (unsigned_long || signed_long || unsigned_fallback) {
        if (!/^[ \t\n\f\r]*[-+]?[0-9]/.test(v)) { return def.call(this); }
        n = n|0; // jshint ignore:line
      }
      return n;
    },
    set: function(v) {
      if (!a.float) { v = Math.floor(v); }
      if (setmin !== undefined && v < setmin) {
        utils.IndexSizeError(a.name + ' set to ' + v);
      }
      if (unsigned_long) {
        v = (v < 0 || v > 0x7FFFFFFF) ? def.call(this) :
          (v|0);  // jshint ignore:line
      } else if (unsigned_fallback) {
        v = (v < 1 || v > 0x7FFFFFFF) ? def.call(this) :
          (v|0); // jshint ignore:line
      } else if (signed_long) {
        v = (v < -0x80000000 || v > 0x7FFFFFFF) ? def.call(this) :
          (v|0); // jshint ignore:line
      }
      this._setattr(a.name, String(v));
    }
  };
}

// This is a utility function for setting up change handler functions
// for attributes like 'id' that require special handling when they change.
exports.registerChangeHandler = function(c, name, handler) {
  var p = c.prototype;

  // If p does not already have its own _attributeChangeHandlers
  // then create one for it, inheriting from the inherited
  // _attributeChangeHandlers. At the top (for the Element class) the
  // _attributeChangeHandlers object will be created with a null prototype.
  if (!Object.prototype.hasOwnProperty.call(p, '_attributeChangeHandlers')) {
    p._attributeChangeHandlers =
      Object.create(p._attributeChangeHandlers || null);
  }

  p._attributeChangeHandlers[name] = handler;
};


/***/ }),
/* 42 */
/***/ (function(module, exports) {

/*
 * This file defines Domino behaviour that can be externally configured.
 * To change these settings, set the relevant global property *before*
 * you call `require("domino")`.
 */

exports.isApiWritable = !global.__domino_frozen__;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var attributes = __webpack_require__(41);
var sloppy = __webpack_require__(46);

module.exports = function(spec, defaultConstructor, tagList, tagNameToImpl) {
  var c = spec.ctor;
  if (c) {
    var props = spec.props || {};

    if (spec.attributes) {
      for (var n in spec.attributes) {
        var attr = spec.attributes[n];
        if (typeof attr !== 'object' || Array.isArray(attr)) attr = {type: attr};
        if (!attr.name) attr.name = n.toLowerCase();
        props[n] = attributes.property(attr);
      }
    }

    props.constructor = { value : c };
    c.prototype = Object.create((spec.superclass || defaultConstructor).prototype, props);
    if (spec.events) {
      addEventHandlers(c, spec.events);
    }
    tagList[c.name] = c;
  }
  else {
    c = defaultConstructor;
  }

  (spec.tags || spec.tag && [spec.tag] || []).forEach(function(tag) {
    tagNameToImpl[tag] = c;
  });

  return c;
};

function EventHandlerBuilder(body, document, form, element) {
  this.body = body;
  this.document = document;
  this.form = form;
  this.element = element;
}

EventHandlerBuilder.prototype.build = sloppy.EventHandlerBuilder_build;

function EventHandlerChangeHandler(elt, name, oldval, newval) {
  var doc = elt.ownerDocument || Object.create(null);
  var form = elt.form || Object.create(null);
  elt[name] = new EventHandlerBuilder(newval, doc, form, elt).build();
}

function addEventHandlers(c, eventHandlerTypes) {
  var p = c.prototype;
  eventHandlerTypes.forEach(function(type) {
    // Define the event handler registration IDL attribute for this type
    Object.defineProperty(p, "on" + type, {
      get: function() {
        return this._getEventHandler(type);
      },
      set: function(v) {
        this._setEventHandler(type, v);
      },
    });

    // Define special behavior for the content attribute as well
    attributes.registerChangeHandler(c, "on" + type, EventHandlerChangeHandler);
  });
}


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {
  Event: __webpack_require__(5),
  UIEvent: __webpack_require__(39),
  MouseEvent: __webpack_require__(34),
  CustomEvent: __webpack_require__(67)
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var utils = __webpack_require__(1);

exports = module.exports = {
  CSSStyleDeclaration: __webpack_require__(11),
  CharacterData: __webpack_require__(6),
  Comment: __webpack_require__(28),
  DOMException: __webpack_require__(29),
  DOMImplementation: __webpack_require__(7),
  DOMTokenList: __webpack_require__(30),
  Document: __webpack_require__(13),
  DocumentFragment: __webpack_require__(31),
  DocumentType: __webpack_require__(14),
  Element: __webpack_require__(4),
  HTMLParser: __webpack_require__(15),
  Node: __webpack_require__(2),
  NodeList: __webpack_require__(9),
  NodeFilter: __webpack_require__(8),
  ProcessingInstruction: __webpack_require__(37),
  Text: __webpack_require__(38),
  Window: __webpack_require__(17)
};

utils.merge(exports, __webpack_require__(44));
utils.merge(exports, __webpack_require__(18).elements);
utils.merge(exports, __webpack_require__(47).elements);


/***/ }),
/* 46 */
/***/ (function(module, exports) {

/* Domino uses sloppy-mode features (in particular, `with`) for a few
 * minor things.  This file encapsulates all the sloppiness; every
 * other module should be strict. */
/* jshint strict: false */
/* jshint evil: true */
/* jshint -W085 */
module.exports = {
  Window_run: function _run(code, file) {
    if (file) code += '\n//@ sourceURL=' + file;
    with(this) eval(code);
  },
  EventHandlerBuilder_build: function build() {
    try {
      with(this.document.defaultView || Object.create(null))
        with(this.document)
          with(this.form)
            with(this.element)
              return eval("(function(event){" + this.body + "})");
    }
    catch (err) {
      return function() { throw err; };
    }
  }
};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Element = __webpack_require__(4);
var defineElement = __webpack_require__(43);
var utils = __webpack_require__(1);
var CSSStyleDeclaration = __webpack_require__(11);

var svgElements = exports.elements = {};
var svgNameToImpl = Object.create(null);

exports.createElement = function(doc, localName, prefix) {
  var impl = svgNameToImpl[localName] || SVGElement;
  return new impl(doc, localName, prefix);
};

function define(spec) {
  return defineElement(spec, SVGElement, svgElements, svgNameToImpl);
}

var SVGElement = define({
  superclass: Element,
  ctor: function SVGElement(doc, localName, prefix) {
    Element.call(this, doc, localName, utils.NAMESPACE.SVG, prefix);
  },
  props: {
    style: { get: function() {
      if (!this._style)
        this._style = new CSSStyleDeclaration(this);
      return this._style;
    }}
  }
});

define({
  ctor: function SVGSVGElement(doc, localName, prefix) {
    SVGElement.call(this, doc, localName, prefix);
  },
  tag: 'svg',
  props: {
    createSVGRect: { value: function () {
      return exports.createElement(this.ownerDocument, 'rect', null);
    } }
  }
});

define({
  tags: [
    'a', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor', 'animateMotion', 'animateTransform',
    'circle', 'clipPath', 'color-profile', 'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColorMatrix',
    'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight',
    'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode',
    'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'filter',
    'font', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignObject', 'g',
    'glyph', 'glyphRef', 'hkern', 'image', 'line', 'linearGradient', 'marker', 'mask', 'metadata', 'missing-glyph',
    'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'script', 'set', 'stop',  'style',
    'switch', 'symbol', 'text', 'textPath', 'title', 'tref', 'tspan', 'use', 'view', 'vkern'
  ]
});


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(11);

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(133);

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_server__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_server___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_platform_server__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__app_shared_module__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_app_app_component__ = __webpack_require__(27);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




var AppModule = /** @class */ (function () {
    function AppModule() {
    }
    AppModule = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["NgModule"])({
            bootstrap: [__WEBPACK_IMPORTED_MODULE_3__components_app_app_component__["a" /* AppComponent */]],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_platform_server__["ServerModule"],
                __WEBPACK_IMPORTED_MODULE_2__app_shared_module__["a" /* AppModuleShared */]
            ]
        })
    ], AppModule);
    return AppModule;
}());



/***/ }),
/* 52 */
/***/ (function(module, exports) {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    // feature test for Symbol support
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var HashMap;
    (function (HashMap) {
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        // create an object in dictionary mode (a.k.a. "slow" mode in v8)
        HashMap.create = supportsCreate
            ? function () { return MakeDictionary(Object.create(null)); }
            : supportsProto
                ? function () { return MakeDictionary({ __proto__: null }); }
                : function () { return MakeDictionary({}); };
        HashMap.has = downLevel
            ? function (map, key) { return hasOwn.call(map, key); }
            : function (map, key) { return key in map; };
        HashMap.get = downLevel
            ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
            : function (map, key) { return map[key]; };
    })(HashMap || (HashMap = {}));
    // Load global or shim versions of Map, Set, and WeakMap
    var functionPrototype = Object.getPrototypeOf(Function);
    var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
    var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    // [[Metadata]] internal slot
    // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
    var Metadata = new _WeakMap();
    /**
      * Applies a set of decorators to a property of a target object.
      * @param decorators An array of decorators.
      * @param target The target object.
      * @param propertyKey (Optional) The property key to decorate.
      * @param attributes (Optional) The property descriptor for the target key.
      * @remarks Decorators are applied in reverse order.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     Example = Reflect.decorate(decoratorsArray, Example);
      *
      *     // property (on constructor)
      *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
      *
      *     // property (on prototype)
      *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
      *
      *     // method (on constructor)
      *     Object.defineProperty(Example, "staticMethod",
      *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
      *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
      *
      *     // method (on prototype)
      *     Object.defineProperty(Example.prototype, "method",
      *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
      *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
      *
      */
    function decorate(decorators, target, propertyKey, attributes) {
        if (!IsUndefined(propertyKey)) {
            if (!IsArray(decorators))
                throw new TypeError();
            if (!IsObject(target))
                throw new TypeError();
            if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                throw new TypeError();
            if (IsNull(attributes))
                attributes = undefined;
            propertyKey = ToPropertyKey(propertyKey);
            return DecorateProperty(decorators, target, propertyKey, attributes);
        }
        else {
            if (!IsArray(decorators))
                throw new TypeError();
            if (!IsConstructor(target))
                throw new TypeError();
            return DecorateConstructor(decorators, target);
        }
    }
    Reflect.decorate = decorate;
    // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
    // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
    /**
      * A default metadata decorator factory that can be used on a class, class member, or parameter.
      * @param metadataKey The key for the metadata entry.
      * @param metadataValue The value for the metadata entry.
      * @returns A decorator function.
      * @remarks
      * If `metadataKey` is already defined for the target and target key, the
      * metadataValue for that key will be overwritten.
      * @example
      *
      *     // constructor
      *     @Reflect.metadata(key, value)
      *     class Example {
      *     }
      *
      *     // property (on constructor, TypeScript only)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         static staticProperty;
      *     }
      *
      *     // property (on prototype, TypeScript only)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         property;
      *     }
      *
      *     // method (on constructor)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         static staticMethod() { }
      *     }
      *
      *     // method (on prototype)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         method() { }
      *     }
      *
      */
    function metadata(metadataKey, metadataValue) {
        function decorator(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                throw new TypeError();
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        return decorator;
    }
    Reflect.metadata = metadata;
    /**
      * Define a unique metadata entry on the target.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param metadataValue A value that contains attached metadata.
      * @param target The target object on which to define metadata.
      * @param propertyKey (Optional) The property key for the target.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     Reflect.defineMetadata("custom:annotation", options, Example);
      *
      *     // property (on constructor)
      *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
      *
      *     // property (on prototype)
      *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
      *
      *     // method (on constructor)
      *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
      *
      *     // method (on prototype)
      *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
      *
      *     // decorator factory as metadata-producing annotation.
      *     function MyAnnotation(options): Decorator {
      *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
      *     }
      *
      */
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    Reflect.defineMetadata = defineMetadata;
    /**
      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.hasMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function hasMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    Reflect.hasMetadata = hasMetadata;
    /**
      * Gets a value indicating whether the target object has the provided metadata key defined.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function hasOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    Reflect.hasOwnMetadata = hasOwnMetadata;
    /**
      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function getMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    Reflect.getMetadata = getMetadata;
    /**
      * Gets the metadata value for the provided metadata key on the target object.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getOwnMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function getOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    Reflect.getOwnMetadata = getOwnMetadata;
    /**
      * Gets the metadata keys defined on the target object or its prototype chain.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns An array of unique metadata keys.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getMetadataKeys(Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getMetadataKeys(Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getMetadataKeys(Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getMetadataKeys(Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getMetadataKeys(Example.prototype, "method");
      *
      */
    function getMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryMetadataKeys(target, propertyKey);
    }
    Reflect.getMetadataKeys = getMetadataKeys;
    /**
      * Gets the unique metadata keys defined on the target object.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns An array of unique metadata keys.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getOwnMetadataKeys(Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
      *
      */
    function getOwnMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;
    /**
      * Deletes the metadata entry from the target object with the provided key.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns `true` if the metadata entry was found and deleted; otherwise, false.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.deleteMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function deleteMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
        if (IsUndefined(metadataMap))
            return false;
        if (!metadataMap.delete(metadataKey))
            return false;
        if (metadataMap.size > 0)
            return true;
        var targetMetadata = Metadata.get(target);
        targetMetadata.delete(propertyKey);
        if (targetMetadata.size > 0)
            return true;
        Metadata.delete(target);
        return true;
    }
    Reflect.deleteMetadata = deleteMetadata;
    function DecorateConstructor(decorators, target) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsConstructor(decorated))
                    throw new TypeError();
                target = decorated;
            }
        }
        return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsObject(decorated))
                    throw new TypeError();
                descriptor = decorated;
            }
        }
        return descriptor;
    }
    function GetOrCreateMetadataMap(O, P, Create) {
        var targetMetadata = Metadata.get(O);
        if (IsUndefined(targetMetadata)) {
            if (!Create)
                return undefined;
            targetMetadata = new _Map();
            Metadata.set(O, targetMetadata);
        }
        var metadataMap = targetMetadata.get(P);
        if (IsUndefined(metadataMap)) {
            if (!Create)
                return undefined;
            metadataMap = new _Map();
            targetMetadata.set(P, metadataMap);
        }
        return metadataMap;
    }
    // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
    function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn)
            return true;
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
            return OrdinaryHasMetadata(MetadataKey, parent, P);
        return false;
    }
    // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
        if (IsUndefined(metadataMap))
            return false;
        return ToBoolean(metadataMap.has(MetadataKey));
    }
    // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
    function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn)
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
            return OrdinaryGetMetadata(MetadataKey, parent, P);
        return undefined;
    }
    // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
        if (IsUndefined(metadataMap))
            return undefined;
        return metadataMap.get(MetadataKey);
    }
    // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
        metadataMap.set(MetadataKey, MetadataValue);
    }
    // 3.1.6.1 OrdinaryMetadataKeys(O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
    function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (parent === null)
            return ownKeys;
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length <= 0)
            return ownKeys;
        if (ownKeys.length <= 0)
            return parentKeys;
        var set = new _Set();
        var keys = [];
        for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
            var key = ownKeys_1[_i];
            var hasKey = set.has(key);
            if (!hasKey) {
                set.add(key);
                keys.push(key);
            }
        }
        for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
            var key = parentKeys_1[_a];
            var hasKey = set.has(key);
            if (!hasKey) {
                set.add(key);
                keys.push(key);
            }
        }
        return keys;
    }
    // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
    function OrdinaryOwnMetadataKeys(O, P) {
        var keys = [];
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
        if (IsUndefined(metadataMap))
            return keys;
        var keysObj = metadataMap.keys();
        var iterator = GetIterator(keysObj);
        var k = 0;
        while (true) {
            var next = IteratorStep(iterator);
            if (!next) {
                keys.length = k;
                return keys;
            }
            var nextValue = IteratorValue(next);
            try {
                keys[k] = nextValue;
            }
            catch (e) {
                try {
                    IteratorClose(iterator);
                }
                finally {
                    throw e;
                }
            }
            k++;
        }
    }
    // 6 ECMAScript Data Typ0es and Values
    // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
    function Type(x) {
        if (x === null)
            return 1 /* Null */;
        switch (typeof x) {
            case "undefined": return 0 /* Undefined */;
            case "boolean": return 2 /* Boolean */;
            case "string": return 3 /* String */;
            case "symbol": return 4 /* Symbol */;
            case "number": return 5 /* Number */;
            case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
            default: return 6 /* Object */;
        }
    }
    // 6.1.1 The Undefined Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
    function IsUndefined(x) {
        return x === undefined;
    }
    // 6.1.2 The Null Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
    function IsNull(x) {
        return x === null;
    }
    // 6.1.5 The Symbol Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
    function IsSymbol(x) {
        return typeof x === "symbol";
    }
    // 6.1.7 The Object Type
    // https://tc39.github.io/ecma262/#sec-object-type
    function IsObject(x) {
        return typeof x === "object" ? x !== null : typeof x === "function";
    }
    // 7.1 Type Conversion
    // https://tc39.github.io/ecma262/#sec-type-conversion
    // 7.1.1 ToPrimitive(input [, PreferredType])
    // https://tc39.github.io/ecma262/#sec-toprimitive
    function ToPrimitive(input, PreferredType) {
        switch (Type(input)) {
            case 0 /* Undefined */: return input;
            case 1 /* Null */: return input;
            case 2 /* Boolean */: return input;
            case 3 /* String */: return input;
            case 4 /* Symbol */: return input;
            case 5 /* Number */: return input;
        }
        var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
        if (exoticToPrim !== undefined) {
            var result = exoticToPrim.call(input, hint);
            if (IsObject(result))
                throw new TypeError();
            return result;
        }
        return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    // 7.1.1.1 OrdinaryToPrimitive(O, hint)
    // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
    function OrdinaryToPrimitive(O, hint) {
        if (hint === "string") {
            var toString_1 = O.toString;
            if (IsCallable(toString_1)) {
                var result = toString_1.call(O);
                if (!IsObject(result))
                    return result;
            }
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
                var result = valueOf.call(O);
                if (!IsObject(result))
                    return result;
            }
        }
        else {
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
                var result = valueOf.call(O);
                if (!IsObject(result))
                    return result;
            }
            var toString_2 = O.toString;
            if (IsCallable(toString_2)) {
                var result = toString_2.call(O);
                if (!IsObject(result))
                    return result;
            }
        }
        throw new TypeError();
    }
    // 7.1.2 ToBoolean(argument)
    // https://tc39.github.io/ecma262/2016/#sec-toboolean
    function ToBoolean(argument) {
        return !!argument;
    }
    // 7.1.12 ToString(argument)
    // https://tc39.github.io/ecma262/#sec-tostring
    function ToString(argument) {
        return "" + argument;
    }
    // 7.1.14 ToPropertyKey(argument)
    // https://tc39.github.io/ecma262/#sec-topropertykey
    function ToPropertyKey(argument) {
        var key = ToPrimitive(argument, 3 /* String */);
        if (IsSymbol(key))
            return key;
        return ToString(key);
    }
    // 7.2 Testing and Comparison Operations
    // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
    // 7.2.2 IsArray(argument)
    // https://tc39.github.io/ecma262/#sec-isarray
    function IsArray(argument) {
        return Array.isArray
            ? Array.isArray(argument)
            : argument instanceof Object
                ? argument instanceof Array
                : Object.prototype.toString.call(argument) === "[object Array]";
    }
    // 7.2.3 IsCallable(argument)
    // https://tc39.github.io/ecma262/#sec-iscallable
    function IsCallable(argument) {
        // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
        return typeof argument === "function";
    }
    // 7.2.4 IsConstructor(argument)
    // https://tc39.github.io/ecma262/#sec-isconstructor
    function IsConstructor(argument) {
        // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
        return typeof argument === "function";
    }
    // 7.2.7 IsPropertyKey(argument)
    // https://tc39.github.io/ecma262/#sec-ispropertykey
    function IsPropertyKey(argument) {
        switch (Type(argument)) {
            case 3 /* String */: return true;
            case 4 /* Symbol */: return true;
            default: return false;
        }
    }
    // 7.3 Operations on Objects
    // https://tc39.github.io/ecma262/#sec-operations-on-objects
    // 7.3.9 GetMethod(V, P)
    // https://tc39.github.io/ecma262/#sec-getmethod
    function GetMethod(V, P) {
        var func = V[P];
        if (func === undefined || func === null)
            return undefined;
        if (!IsCallable(func))
            throw new TypeError();
        return func;
    }
    // 7.4 Operations on Iterator Objects
    // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
    function GetIterator(obj) {
        var method = GetMethod(obj, iteratorSymbol);
        if (!IsCallable(method))
            throw new TypeError(); // from Call
        var iterator = method.call(obj);
        if (!IsObject(iterator))
            throw new TypeError();
        return iterator;
    }
    // 7.4.4 IteratorValue(iterResult)
    // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
    function IteratorValue(iterResult) {
        return iterResult.value;
    }
    // 7.4.5 IteratorStep(iterator)
    // https://tc39.github.io/ecma262/#sec-iteratorstep
    function IteratorStep(iterator) {
        var result = iterator.next();
        return result.done ? false : result;
    }
    // 7.4.6 IteratorClose(iterator, completion)
    // https://tc39.github.io/ecma262/#sec-iteratorclose
    function IteratorClose(iterator) {
        var f = iterator["return"];
        if (f)
            f.call(iterator);
    }
    // 9.1 Ordinary Object Internal Methods and Internal Slots
    // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
    // 9.1.1.1 OrdinaryGetPrototypeOf(O)
    // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
    function OrdinaryGetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if (typeof O !== "function" || O === functionPrototype)
            return proto;
        // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
        // Try to determine the superclass constructor. Compatible implementations
        // must either set __proto__ on a subclass constructor to the superclass constructor,
        // or ensure each class has a valid `constructor` property on its prototype that
        // points back to the constructor.
        // If this is not the same as Function.[[Prototype]], then this is definately inherited.
        // This is the case when in ES6 or when using __proto__ in a compatible browser.
        if (proto !== functionPrototype)
            return proto;
        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
        var prototype = O.prototype;
        var prototypeProto = prototype && Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
        // If the constructor was not a function, then we cannot determine the heritage.
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== "function")
            return proto;
        // If we have some kind of self-reference, then we cannot determine the heritage.
        if (constructor === O)
            return proto;
        // we have a pretty good guess at the heritage.
        return constructor;
    }
    // naive Map shim
    function CreateMapPolyfill() {
        var cacheSentinel = {};
        var arraySentinel = [];
        var MapIterator = (function () {
            function MapIterator(keys, values, selector) {
                this._index = 0;
                this._keys = keys;
                this._values = values;
                this._selector = selector;
            }
            MapIterator.prototype["@@iterator"] = function () { return this; };
            MapIterator.prototype[iteratorSymbol] = function () { return this; };
            MapIterator.prototype.next = function () {
                var index = this._index;
                if (index >= 0 && index < this._keys.length) {
                    var result = this._selector(this._keys[index], this._values[index]);
                    if (index + 1 >= this._keys.length) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    else {
                        this._index++;
                    }
                    return { value: result, done: false };
                }
                return { value: undefined, done: true };
            };
            MapIterator.prototype.throw = function (error) {
                if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                }
                throw error;
            };
            MapIterator.prototype.return = function (value) {
                if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                }
                return { value: value, done: true };
            };
            return MapIterator;
        }());
        return (function () {
            function Map() {
                this._keys = [];
                this._values = [];
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
            }
            Object.defineProperty(Map.prototype, "size", {
                get: function () { return this._keys.length; },
                enumerable: true,
                configurable: true
            });
            Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
            Map.prototype.get = function (key) {
                var index = this._find(key, /*insert*/ false);
                return index >= 0 ? this._values[index] : undefined;
            };
            Map.prototype.set = function (key, value) {
                var index = this._find(key, /*insert*/ true);
                this._values[index] = value;
                return this;
            };
            Map.prototype.delete = function (key) {
                var index = this._find(key, /*insert*/ false);
                if (index >= 0) {
                    var size = this._keys.length;
                    for (var i = index + 1; i < size; i++) {
                        this._keys[i - 1] = this._keys[i];
                        this._values[i - 1] = this._values[i];
                    }
                    this._keys.length--;
                    this._values.length--;
                    if (key === this._cacheKey) {
                        this._cacheKey = cacheSentinel;
                        this._cacheIndex = -2;
                    }
                    return true;
                }
                return false;
            };
            Map.prototype.clear = function () {
                this._keys.length = 0;
                this._values.length = 0;
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
            };
            Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
            Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
            Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
            Map.prototype["@@iterator"] = function () { return this.entries(); };
            Map.prototype[iteratorSymbol] = function () { return this.entries(); };
            Map.prototype._find = function (key, insert) {
                if (this._cacheKey !== key) {
                    this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                }
                if (this._cacheIndex < 0 && insert) {
                    this._cacheIndex = this._keys.length;
                    this._keys.push(key);
                    this._values.push(undefined);
                }
                return this._cacheIndex;
            };
            return Map;
        }());
        function getKey(key, _) {
            return key;
        }
        function getValue(_, value) {
            return value;
        }
        function getEntry(key, value) {
            return [key, value];
        }
    }
    // naive Set shim
    function CreateSetPolyfill() {
        return (function () {
            function Set() {
                this._map = new _Map();
            }
            Object.defineProperty(Set.prototype, "size", {
                get: function () { return this._map.size; },
                enumerable: true,
                configurable: true
            });
            Set.prototype.has = function (value) { return this._map.has(value); };
            Set.prototype.add = function (value) { return this._map.set(value, value), this; };
            Set.prototype.delete = function (value) { return this._map.delete(value); };
            Set.prototype.clear = function () { this._map.clear(); };
            Set.prototype.keys = function () { return this._map.keys(); };
            Set.prototype.values = function () { return this._map.values(); };
            Set.prototype.entries = function () { return this._map.entries(); };
            Set.prototype["@@iterator"] = function () { return this.keys(); };
            Set.prototype[iteratorSymbol] = function () { return this.keys(); };
            return Set;
        }());
    }
    // naive WeakMap shim
    function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var keys = HashMap.create();
        var rootKey = CreateUniqueKey();
        return (function () {
            function WeakMap() {
                this._key = CreateUniqueKey();
            }
            WeakMap.prototype.has = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? HashMap.has(table, this._key) : false;
            };
            WeakMap.prototype.get = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? HashMap.get(table, this._key) : undefined;
            };
            WeakMap.prototype.set = function (target, value) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                table[this._key] = value;
                return this;
            };
            WeakMap.prototype.delete = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? delete table[this._key] : false;
            };
            WeakMap.prototype.clear = function () {
                // NOTE: not a real clear, just makes the previous data unreachable
                this._key = CreateUniqueKey();
            };
            return WeakMap;
        }());
        function CreateUniqueKey() {
            var key;
            do
                key = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys, key));
            keys[key] = true;
            return key;
        }
        function GetOrCreateWeakMapTable(target, create) {
            if (!hasOwn.call(target, rootKey)) {
                if (!create)
                    return undefined;
                Object.defineProperty(target, rootKey, { value: HashMap.create() });
            }
            return target[rootKey];
        }
        function FillRandomBytes(buffer, size) {
            for (var i = 0; i < size; ++i)
                buffer[i] = Math.random() * 0xff | 0;
            return buffer;
        }
        function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
                if (typeof crypto !== "undefined")
                    return crypto.getRandomValues(new Uint8Array(size));
                if (typeof msCrypto !== "undefined")
                    return msCrypto.getRandomValues(new Uint8Array(size));
                return FillRandomBytes(new Uint8Array(size), size);
            }
            return FillRandomBytes(new Array(size), size);
        }
        function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            // mark as random - RFC 4122 § 4.4
            data[6] = data[6] & 0x4f | 0x40;
            data[8] = data[8] & 0xbf | 0x80;
            var result = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
                var byte = data[offset];
                if (offset === 4 || offset === 6 || offset === 8)
                    result += "-";
                if (byte < 16)
                    result += "0";
                result += byte.toString(16).toLowerCase();
            }
            return result;
        }
    }
    // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
    function MakeDictionary(obj) {
        obj.__ = undefined;
        delete obj.__;
        return obj;
    }
    // patch global Reflect
    (function (__global) {
        if (typeof __global.Reflect !== "undefined") {
            if (__global.Reflect !== Reflect) {
                for (var p in Reflect) {
                    if (hasOwn.call(Reflect, p)) {
                        __global.Reflect[p] = Reflect[p];
                    }
                }
            }
        }
        else {
            __global.Reflect = Reflect;
        }
    })(typeof global !== "undefined" ? global :
        typeof self !== "undefined" ? self :
            Function("return this;")());
})(Reflect || (Reflect = {}));
//# sourceMappingURL=Reflect.js.map

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(21);
var first_1 = __webpack_require__(49);
Observable_1.Observable.prototype.first = first_1.first;
//# sourceMappingURL=first.js.map

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(77);

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(84);

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Angular v5.2.2
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
	 true ? factory(exports, __webpack_require__(3), __webpack_require__(48), __webpack_require__(22), __webpack_require__(26)) :
	typeof define === 'function' && define.amd ? define('@angular/platform-browser/animations', ['exports', '@angular/core', '@angular/platform-browser', '@angular/animations', '@angular/animations/browser'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.platformBrowser = global.ng.platformBrowser || {}, global.ng.platformBrowser.animations = {}),global.ng.core,global.ng.platformBrowser,global.ng.animations,global.ng.animations.browser));
}(this, (function (exports,_angular_core,_angular_platformBrowser,_angular_animations,_angular_animations_browser) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/**
 * @license Angular v5.2.2
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var BrowserAnimationBuilder = /** @class */ (function (_super) {
    __extends(BrowserAnimationBuilder, _super);
    function BrowserAnimationBuilder(rootRenderer, doc) {
        var _this = _super.call(this) || this;
        _this._nextAnimationId = 0;
        var /** @type {?} */ typeData = /** @type {?} */ ({
            id: '0',
            encapsulation: _angular_core.ViewEncapsulation.None,
            styles: [],
            data: { animation: [] }
        });
        _this._renderer = /** @type {?} */ (rootRenderer.createRenderer(doc.body, typeData));
        return _this;
    }
    /**
     * @param {?} animation
     * @return {?}
     */
    BrowserAnimationBuilder.prototype.build = /**
     * @param {?} animation
     * @return {?}
     */
    function (animation) {
        var /** @type {?} */ id = this._nextAnimationId.toString();
        this._nextAnimationId++;
        var /** @type {?} */ entry = Array.isArray(animation) ? _angular_animations.sequence(animation) : animation;
        issueAnimationCommand(this._renderer, null, id, 'register', [entry]);
        return new BrowserAnimationFactory(id, this._renderer);
    };
    BrowserAnimationBuilder.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    BrowserAnimationBuilder.ctorParameters = function () { return [
        { type: _angular_core.RendererFactory2, },
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
    ]; };
    return BrowserAnimationBuilder;
}(_angular_animations.AnimationBuilder));
var BrowserAnimationFactory = /** @class */ (function (_super) {
    __extends(BrowserAnimationFactory, _super);
    function BrowserAnimationFactory(_id, _renderer) {
        var _this = _super.call(this) || this;
        _this._id = _id;
        _this._renderer = _renderer;
        return _this;
    }
    /**
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    BrowserAnimationFactory.prototype.create = /**
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    function (element, options) {
        return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);
    };
    return BrowserAnimationFactory;
}(_angular_animations.AnimationFactory));
var RendererAnimationPlayer = /** @class */ (function () {
    function RendererAnimationPlayer(id, element, options, _renderer) {
        this.id = id;
        this.element = element;
        this._renderer = _renderer;
        this.parentPlayer = null;
        this._started = false;
        this.totalTime = 0;
        this._command('create', options);
    }
    /**
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    RendererAnimationPlayer.prototype._listen = /**
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    function (eventName, callback) {
        return this._renderer.listen(this.element, "@@" + this.id + ":" + eventName, callback);
    };
    /**
     * @param {?} command
     * @param {...?} args
     * @return {?}
     */
    RendererAnimationPlayer.prototype._command = /**
     * @param {?} command
     * @param {...?} args
     * @return {?}
     */
    function (command) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return issueAnimationCommand(this._renderer, this.element, this.id, command, args);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onDone = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._listen('done', fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onStart = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._listen('start', fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onDestroy = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._listen('destroy', fn); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.init = /**
     * @return {?}
     */
    function () { this._command('init'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.hasStarted = /**
     * @return {?}
     */
    function () { return this._started; };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.play = /**
     * @return {?}
     */
    function () {
        this._command('play');
        this._started = true;
    };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.pause = /**
     * @return {?}
     */
    function () { this._command('pause'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.restart = /**
     * @return {?}
     */
    function () { this._command('restart'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.finish = /**
     * @return {?}
     */
    function () { this._command('finish'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.destroy = /**
     * @return {?}
     */
    function () { this._command('destroy'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.reset = /**
     * @return {?}
     */
    function () { this._command('reset'); };
    /**
     * @param {?} p
     * @return {?}
     */
    RendererAnimationPlayer.prototype.setPosition = /**
     * @param {?} p
     * @return {?}
     */
    function (p) { this._command('setPosition', p); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.getPosition = /**
     * @return {?}
     */
    function () { return 0; };
    return RendererAnimationPlayer;
}());
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} id
 * @param {?} command
 * @param {?} args
 * @return {?}
 */
function issueAnimationCommand(renderer, element, id, command, args) {
    return renderer.setProperty(element, "@@" + id + ":" + command, args);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ANIMATION_PREFIX = '@';
var DISABLE_ANIMATIONS_FLAG = '@.disabled';
var AnimationRendererFactory = /** @class */ (function () {
    function AnimationRendererFactory(delegate, engine, _zone) {
        this.delegate = delegate;
        this.engine = engine;
        this._zone = _zone;
        this._currentId = 0;
        this._microtaskId = 1;
        this._animationCallbacksBuffer = [];
        this._rendererCache = new Map();
        this._cdRecurDepth = 0;
        engine.onRemovalComplete = function (element, delegate) {
            // Note: if an component element has a leave animation, and the component
            // a host leave animation, the view engine will call `removeChild` for the parent
            // component renderer as well as for the child component renderer.
            // Therefore, we need to check if we already removed the element.
            if (delegate && delegate.parentNode(element)) {
                delegate.removeChild(element.parentNode, element);
            }
        };
    }
    /**
     * @param {?} hostElement
     * @param {?} type
     * @return {?}
     */
    AnimationRendererFactory.prototype.createRenderer = /**
     * @param {?} hostElement
     * @param {?} type
     * @return {?}
     */
    function (hostElement, type) {
        var _this = this;
        var /** @type {?} */ EMPTY_NAMESPACE_ID = '';
        // cache the delegates to find out which cached delegate can
        // be used by which cached renderer
        var /** @type {?} */ delegate = this.delegate.createRenderer(hostElement, type);
        if (!hostElement || !type || !type.data || !type.data['animation']) {
            var /** @type {?} */ renderer = this._rendererCache.get(delegate);
            if (!renderer) {
                renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine);
                // only cache this result when the base renderer is used
                this._rendererCache.set(delegate, renderer);
            }
            return renderer;
        }
        var /** @type {?} */ componentId = type.id;
        var /** @type {?} */ namespaceId = type.id + '-' + this._currentId;
        this._currentId++;
        this.engine.register(namespaceId, hostElement);
        var /** @type {?} */ animationTriggers = /** @type {?} */ (type.data['animation']);
        animationTriggers.forEach(function (trigger) {
            return _this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger);
        });
        return new AnimationRenderer(this, namespaceId, delegate, this.engine);
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.begin = /**
     * @return {?}
     */
    function () {
        this._cdRecurDepth++;
        if (this.delegate.begin) {
            this.delegate.begin();
        }
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype._scheduleCountTask = /**
     * @return {?}
     */
    function () {
        var _this = this;
        Zone.current.scheduleMicroTask('incremenet the animation microtask', function () { return _this._microtaskId++; });
    };
    /* @internal */
    /**
     * @param {?} count
     * @param {?} fn
     * @param {?} data
     * @return {?}
     */
    AnimationRendererFactory.prototype.scheduleListenerCallback = /**
     * @param {?} count
     * @param {?} fn
     * @param {?} data
     * @return {?}
     */
    function (count, fn, data) {
        var _this = this;
        if (count >= 0 && count < this._microtaskId) {
            this._zone.run(function () { return fn(data); });
            return;
        }
        if (this._animationCallbacksBuffer.length == 0) {
            Promise.resolve(null).then(function () {
                _this._zone.run(function () {
                    _this._animationCallbacksBuffer.forEach(function (tuple) {
                        var fn = tuple[0], data = tuple[1];
                        fn(data);
                    });
                    _this._animationCallbacksBuffer = [];
                });
            });
        }
        this._animationCallbacksBuffer.push([fn, data]);
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.end = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._cdRecurDepth--;
        // this is to prevent animations from running twice when an inner
        // component does CD when a parent component insted has inserted it
        if (this._cdRecurDepth == 0) {
            this._zone.runOutsideAngular(function () {
                _this._scheduleCountTask();
                _this.engine.flush(_this._microtaskId);
            });
        }
        if (this.delegate.end) {
            this.delegate.end();
        }
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.whenRenderingDone = /**
     * @return {?}
     */
    function () { return this.engine.whenRenderingDone(); };
    AnimationRendererFactory.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    AnimationRendererFactory.ctorParameters = function () { return [
        { type: _angular_core.RendererFactory2, },
        { type: _angular_animations_browser.ɵAnimationEngine, },
        { type: _angular_core.NgZone, },
    ]; };
    return AnimationRendererFactory;
}());
var BaseAnimationRenderer = /** @class */ (function () {
    function BaseAnimationRenderer(namespaceId, delegate, engine) {
        this.namespaceId = namespaceId;
        this.delegate = delegate;
        this.engine = engine;
        this.destroyNode = this.delegate.destroyNode ? function (n) { return ((delegate.destroyNode))(n); } : null;
    }
    Object.defineProperty(BaseAnimationRenderer.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () { return this.delegate.data; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    BaseAnimationRenderer.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this.engine.destroy(this.namespaceId, this.delegate);
        this.delegate.destroy();
    };
    /**
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createElement = /**
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    function (name, namespace) {
        return this.delegate.createElement(name, namespace);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createComment = /**
     * @param {?} value
     * @return {?}
     */
    function (value) { return this.delegate.createComment(value); };
    /**
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createText = /**
     * @param {?} value
     * @return {?}
     */
    function (value) { return this.delegate.createText(value); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.appendChild = /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    function (parent, newChild) {
        this.delegate.appendChild(parent, newChild);
        this.engine.onInsert(this.namespaceId, newChild, parent, false);
    };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.insertBefore = /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    function (parent, newChild, refChild) {
        this.delegate.insertBefore(parent, newChild, refChild);
        this.engine.onInsert(this.namespaceId, newChild, parent, true);
    };
    /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeChild = /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    function (parent, oldChild) {
        this.engine.onRemove(this.namespaceId, oldChild, this.delegate);
    };
    /**
     * @param {?} selectorOrNode
     * @return {?}
     */
    BaseAnimationRenderer.prototype.selectRootElement = /**
     * @param {?} selectorOrNode
     * @return {?}
     */
    function (selectorOrNode) { return this.delegate.selectRootElement(selectorOrNode); };
    /**
     * @param {?} node
     * @return {?}
     */
    BaseAnimationRenderer.prototype.parentNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return this.delegate.parentNode(node); };
    /**
     * @param {?} node
     * @return {?}
     */
    BaseAnimationRenderer.prototype.nextSibling = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return this.delegate.nextSibling(node); };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setAttribute = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    function (el, name, value, namespace) {
        this.delegate.setAttribute(el, name, value, namespace);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeAttribute = /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    function (el, name, namespace) {
        this.delegate.removeAttribute(el, name, namespace);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    BaseAnimationRenderer.prototype.addClass = /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    function (el, name) { this.delegate.addClass(el, name); };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeClass = /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    function (el, name) { this.delegate.removeClass(el, name); };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?=} flags
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setStyle = /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?=} flags
     * @return {?}
     */
    function (el, style, value, flags) {
        this.delegate.setStyle(el, style, value, flags);
    };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?=} flags
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeStyle = /**
     * @param {?} el
     * @param {?} style
     * @param {?=} flags
     * @return {?}
     */
    function (el, style, flags) {
        this.delegate.removeStyle(el, style, flags);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setProperty = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (el, name, value) {
        if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {
            this.disableAnimations(el, !!value);
        }
        else {
            this.delegate.setProperty(el, name, value);
        }
    };
    /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setValue = /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    function (node, value) { this.delegate.setValue(node, value); };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    BaseAnimationRenderer.prototype.listen = /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    function (target, eventName, callback) {
        return this.delegate.listen(target, eventName, callback);
    };
    /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.disableAnimations = /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    function (element, value) {
        this.engine.disableAnimations(element, value);
    };
    return BaseAnimationRenderer;
}());
var AnimationRenderer = /** @class */ (function (_super) {
    __extends(AnimationRenderer, _super);
    function AnimationRenderer(factory, namespaceId, delegate, engine) {
        var _this = _super.call(this, namespaceId, delegate, engine) || this;
        _this.factory = factory;
        _this.namespaceId = namespaceId;
        return _this;
    }
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    AnimationRenderer.prototype.setProperty = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (el, name, value) {
        if (name.charAt(0) == ANIMATION_PREFIX) {
            if (name.charAt(1) == '.' && name == DISABLE_ANIMATIONS_FLAG) {
                value = value === undefined ? true : !!value;
                this.disableAnimations(el, /** @type {?} */ (value));
            }
            else {
                this.engine.process(this.namespaceId, el, name.substr(1), value);
            }
        }
        else {
            this.delegate.setProperty(el, name, value);
        }
    };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    AnimationRenderer.prototype.listen = /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    function (target, eventName, callback) {
        var _this = this;
        if (eventName.charAt(0) == ANIMATION_PREFIX) {
            var /** @type {?} */ element = resolveElementFromTarget(target);
            var /** @type {?} */ name_1 = eventName.substr(1);
            var /** @type {?} */ phase = '';
            // @listener.phase is for trigger animation callbacks
            // @@listener is for animation builder callbacks
            if (name_1.charAt(0) != ANIMATION_PREFIX) {
                _a = parseTriggerCallbackName(name_1), name_1 = _a[0], phase = _a[1];
            }
            return this.engine.listen(this.namespaceId, element, name_1, phase, function (event) {
                var /** @type {?} */ countId = (/** @type {?} */ (event))['_data'] || -1;
                _this.factory.scheduleListenerCallback(countId, callback, event);
            });
        }
        return this.delegate.listen(target, eventName, callback);
        var _a;
    };
    return AnimationRenderer;
}(BaseAnimationRenderer));
/**
 * @param {?} target
 * @return {?}
 */
function resolveElementFromTarget(target) {
    switch (target) {
        case 'body':
            return document.body;
        case 'document':
            return document;
        case 'window':
            return window;
        default:
            return target;
    }
}
/**
 * @param {?} triggerName
 * @return {?}
 */
function parseTriggerCallbackName(triggerName) {
    var /** @type {?} */ dotIndex = triggerName.indexOf('.');
    var /** @type {?} */ trigger = triggerName.substring(0, dotIndex);
    var /** @type {?} */ phase = triggerName.substr(dotIndex + 1);
    return [trigger, phase];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var InjectableAnimationEngine = /** @class */ (function (_super) {
    __extends(InjectableAnimationEngine, _super);
    function InjectableAnimationEngine(driver, normalizer) {
        return _super.call(this, driver, normalizer) || this;
    }
    InjectableAnimationEngine.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    InjectableAnimationEngine.ctorParameters = function () { return [
        { type: _angular_animations_browser.AnimationDriver, },
        { type: _angular_animations_browser.ɵAnimationStyleNormalizer, },
    ]; };
    return InjectableAnimationEngine;
}(_angular_animations_browser.ɵAnimationEngine));
/**
 * @return {?}
 */
function instantiateSupportedAnimationDriver() {
    if (_angular_animations_browser.ɵsupportsWebAnimations()) {
        return new _angular_animations_browser.ɵWebAnimationsDriver();
    }
    return new _angular_animations_browser.ɵNoopAnimationDriver();
}
/**
 * @return {?}
 */
function instantiateDefaultStyleNormalizer() {
    return new _angular_animations_browser.ɵWebAnimationsStyleNormalizer();
}
/**
 * @param {?} renderer
 * @param {?} engine
 * @param {?} zone
 * @return {?}
 */
function instantiateRendererFactory(renderer, engine, zone) {
    return new AnimationRendererFactory(renderer, engine, zone);
}
var SHARED_ANIMATION_PROVIDERS = [
    { provide: _angular_animations.AnimationBuilder, useClass: BrowserAnimationBuilder },
    { provide: _angular_animations_browser.ɵAnimationStyleNormalizer, useFactory: instantiateDefaultStyleNormalizer },
    { provide: _angular_animations_browser.ɵAnimationEngine, useClass: InjectableAnimationEngine }, {
        provide: _angular_core.RendererFactory2,
        useFactory: instantiateRendererFactory,
        deps: [_angular_platformBrowser.ɵDomRendererFactory2, _angular_animations_browser.ɵAnimationEngine, _angular_core.NgZone]
    }
];
/**
 * Separate providers from the actual module so that we can do a local modification in Google3 to
 * include them in the BrowserModule.
 */
var BROWSER_ANIMATIONS_PROVIDERS = [
    { provide: _angular_animations_browser.AnimationDriver, useFactory: instantiateSupportedAnimationDriver }
].concat(SHARED_ANIMATION_PROVIDERS);
/**
 * Separate providers from the actual module so that we can do a local modification in Google3 to
 * include them in the BrowserTestingModule.
 */
var BROWSER_NOOP_ANIMATIONS_PROVIDERS = [{ provide: _angular_animations_browser.AnimationDriver, useClass: _angular_animations_browser.ɵNoopAnimationDriver }].concat(SHARED_ANIMATION_PROVIDERS);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@experimental Animation support is experimental.
 */
var BrowserAnimationsModule = /** @class */ (function () {
    function BrowserAnimationsModule() {
    }
    BrowserAnimationsModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    exports: [_angular_platformBrowser.BrowserModule],
                    providers: BROWSER_ANIMATIONS_PROVIDERS,
                },] },
    ];
    /** @nocollapse */
    BrowserAnimationsModule.ctorParameters = function () { return []; };
    return BrowserAnimationsModule;
}());
/**
 * \@experimental Animation support is experimental.
 */
var NoopAnimationsModule = /** @class */ (function () {
    function NoopAnimationsModule() {
    }
    NoopAnimationsModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    exports: [_angular_platformBrowser.BrowserModule],
                    providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS,
                },] },
    ];
    /** @nocollapse */
    NoopAnimationsModule.ctorParameters = function () { return []; };
    return NoopAnimationsModule;
}());

exports.BrowserAnimationsModule = BrowserAnimationsModule;
exports.NoopAnimationsModule = NoopAnimationsModule;
exports.ɵBrowserAnimationBuilder = BrowserAnimationBuilder;
exports.ɵBrowserAnimationFactory = BrowserAnimationFactory;
exports.ɵAnimationRenderer = AnimationRenderer;
exports.ɵAnimationRendererFactory = AnimationRendererFactory;
exports.ɵa = BaseAnimationRenderer;
exports.ɵf = BROWSER_ANIMATIONS_PROVIDERS;
exports.ɵg = BROWSER_NOOP_ANIMATIONS_PROVIDERS;
exports.ɵb = InjectableAnimationEngine;
exports.ɵd = instantiateDefaultStyleNormalizer;
exports.ɵe = instantiateRendererFactory;
exports.ɵc = instantiateSupportedAnimationDriver;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=platform-browser-animations.umd.js.map


/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppModuleShared; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_common__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__angular_forms__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_http__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_http___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__angular_http__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_router__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_router___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__angular_router__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_app_app_component__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_navmenu_navmenu_component__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__components_home_home_component__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__components_fetchdata_fetchdata_component__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__components_counter_counter_component__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__components_vehicle_form_vehicle_form_component__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__angular_material__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__angular_material___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11__angular_material__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};











// import 'hammerjs';

var AppModuleShared = /** @class */ (function () {
    function AppModuleShared() {
    }
    AppModuleShared = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["NgModule"])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_5__components_app_app_component__["a" /* AppComponent */],
                __WEBPACK_IMPORTED_MODULE_6__components_navmenu_navmenu_component__["a" /* NavMenuComponent */],
                __WEBPACK_IMPORTED_MODULE_9__components_counter_counter_component__["a" /* CounterComponent */],
                __WEBPACK_IMPORTED_MODULE_8__components_fetchdata_fetchdata_component__["a" /* FetchDataComponent */],
                __WEBPACK_IMPORTED_MODULE_7__components_home_home_component__["a" /* HomeComponent */],
                __WEBPACK_IMPORTED_MODULE_10__components_vehicle_form_vehicle_form_component__["a" /* VehicleFormComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["CommonModule"],
                __WEBPACK_IMPORTED_MODULE_3__angular_http__["HttpModule"],
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["FormsModule"],
                __WEBPACK_IMPORTED_MODULE_11__angular_material__["MatButtonModule"],
                __WEBPACK_IMPORTED_MODULE_11__angular_material__["MatSlideToggleModule"],
                __WEBPACK_IMPORTED_MODULE_4__angular_router__["RouterModule"].forRoot([
                    { path: '', redirectTo: 'home', pathMatch: 'full' },
                    { path: 'vehicles/new', component: __WEBPACK_IMPORTED_MODULE_10__components_vehicle_form_vehicle_form_component__["a" /* VehicleFormComponent */] },
                    { path: 'home', component: __WEBPACK_IMPORTED_MODULE_7__components_home_home_component__["a" /* HomeComponent */] },
                    { path: 'counter', component: __WEBPACK_IMPORTED_MODULE_9__components_counter_counter_component__["a" /* CounterComponent */] },
                    { path: 'fetch-data', component: __WEBPACK_IMPORTED_MODULE_8__components_fetchdata_fetchdata_component__["a" /* FetchDataComponent */] },
                    { path: '**', redirectTo: 'home' }
                ])
            ]
        })
    ], AppModuleShared);
    return AppModuleShared;
}());



/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CounterComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_animations__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_animations___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_animations__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


var CounterComponent = /** @class */ (function () {
    function CounterComponent() {
        this.currentCount = 0;
    }
    CounterComponent.prototype.incrementCounter = function () {
        this.currentCount++;
    };
    CounterComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'counter',
            template: __webpack_require__(78),
            styles: ["\n        .myButton {\n            background-color: purple;\n            color: white;\n        }\n\n        .myButton:hover {\n            background-color: orange;\n            color: white;\n        }\n    "],
            animations: [
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["trigger"])('hoverAnimation', [
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["transition"])(':enter', [
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["style"])({ opacity: 0 }),
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["animate"])(250, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["style"])({ opacity: 1 }))
                    ]),
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["transition"])(':leave', [
                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["animate"])(100, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_animations__["style"])({ opacity: 0 }))
                    ])
                ])
            ]
        })
    ], CounterComponent);
    return CounterComponent;
}());



/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FetchDataComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_http__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_http___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_http__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};


var FetchDataComponent = /** @class */ (function () {
    function FetchDataComponent(http, baseUrl) {
        var _this = this;
        http.get(baseUrl + 'api/SampleData/WeatherForecasts').subscribe(function (result) {
            _this.forecasts = result.json();
        }, function (error) { return console.error(error); });
    }
    FetchDataComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'fetchdata',
            template: __webpack_require__(79)
        }),
        __param(1, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Inject"])('BASE_URL')),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_http__["Http"], String])
    ], FetchDataComponent);
    return FetchDataComponent;
}());



/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HomeComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var HomeComponent = /** @class */ (function () {
    function HomeComponent() {
    }
    HomeComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'home',
            template: __webpack_require__(80)
        })
    ], HomeComponent);
    return HomeComponent;
}());



/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NavMenuComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var NavMenuComponent = /** @class */ (function () {
    function NavMenuComponent() {
    }
    NavMenuComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'nav-menu',
            template: __webpack_require__(81),
            styles: [__webpack_require__(85)]
        })
    ], NavMenuComponent);
    return NavMenuComponent;
}());



/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return VehicleFormComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var VehicleFormComponent = /** @class */ (function () {
    function VehicleFormComponent() {
    }
    VehicleFormComponent.prototype.ngOnInit = function () {
    };
    VehicleFormComponent = __decorate([
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'app-vehicle-form',
            template: __webpack_require__(82),
            styles: [__webpack_require__(86)]
        }),
        __metadata("design:paramtypes", [])
    ], VehicleFormComponent);
    return VehicleFormComponent;
}());



/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_reflect_metadata__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_reflect_metadata___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_reflect_metadata__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_zone_js__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_zone_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_zone_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_add_operator_first__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_add_operator_first___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_add_operator_first__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_common__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_common___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__angular_common__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__angular_platform_server__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__angular_platform_server___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__angular_platform_server__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_aspnet_prerendering__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_aspnet_prerendering___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_aspnet_prerendering__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__app_app_server_module__ = __webpack_require__(51);








__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__angular_core__["enableProdMode"])();
/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_aspnet_prerendering__["createServerRenderer"])(function (params) {
    var providers = [
        { provide: __WEBPACK_IMPORTED_MODULE_5__angular_platform_server__["INITIAL_CONFIG"], useValue: { document: '<app></app>', url: params.url } },
        { provide: __WEBPACK_IMPORTED_MODULE_3__angular_common__["APP_BASE_HREF"], useValue: params.baseUrl },
        { provide: 'BASE_URL', useValue: params.origin + params.baseUrl },
    ];
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__angular_platform_server__["platformDynamicServer"])(providers).bootstrapModule(__WEBPACK_IMPORTED_MODULE_7__app_app_server_module__["a" /* AppModule */]).then(function (moduleRef) {
        var appRef = moduleRef.injector.get(__WEBPACK_IMPORTED_MODULE_4__angular_core__["ApplicationRef"]);
        var state = moduleRef.injector.get(__WEBPACK_IMPORTED_MODULE_5__angular_platform_server__["PlatformState"]);
        var zone = moduleRef.injector.get(__WEBPACK_IMPORTED_MODULE_4__angular_core__["NgZone"]);
        return new Promise(function (resolve, reject) {
            zone.onError.subscribe(function (errorInfo) { return reject(errorInfo); });
            appRef.isStable.first(function (isStable) { return isStable; }).subscribe(function () {
                // Because 'onStable' fires before 'onError', we have to delay slightly before
                // completing the request in case there's an error to report
                setImmediate(function () {
                    resolve({
                        html: state.renderToString()
                    });
                    moduleRef.destroy();
                });
            });
        });
    });
}));


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(23)(undefined);
// imports


// module
exports.push([module.i, "@media (max-width: 767px) {\r\n    /* On small screens, the nav menu spans the full width of the screen. Leave a space for it. */\r\n    .body-content {\r\n        padding-top: 50px;\r\n    }\r\n}\r\n", ""]);

// exports


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(23)(undefined);
// imports


// module
exports.push([module.i, "li .glyphicon {\r\n    margin-right: 10px;\r\n}\r\n\r\n/* Highlighting rules for nav menu items */\r\nli.link-active a,\r\nli.link-active a:hover,\r\nli.link-active a:focus {\r\n    background-color: #4189C7;\r\n    color: white;\r\n}\r\n\r\n/* Keep the nav menu independent of scrolling and on top of other items */\r\n.main-nav {\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    z-index: 1;\r\n}\r\n\r\n@media (min-width: 768px) {\r\n    /* On small screens, convert the nav menu to a vertical sidebar */\r\n    .main-nav {\r\n        height: 100%;\r\n        width: calc(25% - 20px);\r\n    }\r\n    .navbar {\r\n        border-radius: 0px;\r\n        border-width: 0px;\r\n        height: 100%;\r\n    }\r\n    .navbar-header {\r\n        float: none;\r\n    }\r\n    .navbar-collapse {\r\n        border-top: 1px solid #444;\r\n        padding: 0px;\r\n    }\r\n    .navbar ul {\r\n        float: none;\r\n    }\r\n    .navbar li {\r\n        float: none;\r\n        font-size: 15px;\r\n        margin: 6px;\r\n    }\r\n    .navbar li a {\r\n        padding: 10px 16px;\r\n        border-radius: 4px;\r\n    }\r\n    .navbar a {\r\n        /* If a menu item's text is too long, truncate it */\r\n        width: 100%;\r\n        white-space: nowrap;\r\n        overflow: hidden;\r\n        text-overflow: ellipsis;\r\n    }\r\n}\r\n", ""]);

// exports


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(23)(undefined);
// imports


// module
exports.push([module.i, "", ""]);

// exports


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = CustomEvent;

var Event = __webpack_require__(5);

function CustomEvent(type, dictionary) {
  // Just use the superclass constructor to initialize
  Event.call(this, type, dictionary);
}
CustomEvent.prototype = Object.create(Event.prototype, {
  constructor: { value: CustomEvent }
});


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = FilteredElementList;

var Node = __webpack_require__(2);

//
// This file defines node list implementation that lazily traverses
// the document tree (or a subtree rooted at any element) and includes
// only those elements for which a specified filter function returns true.
// It is used to implement the
// {Document,Element}.getElementsBy{TagName,ClassName}{,NS} methods.
//

function FilteredElementList(root, filter) {
  this.root = root;
  this.filter = filter;
  this.lastModTime = root.lastModTime;
  this.done = false;
  this.cache = [];
  this.traverse();
}

FilteredElementList.prototype = {
  get length() {
    this.checkcache();
    if (!this.done) this.traverse();
    return this.cache.length;
  },

  item: function(n) {
    this.checkcache();
    if (!this.done && n >= this.cache.length) this.traverse(n);
    return this.cache[n];
  },

  checkcache: function() {
    if (this.lastModTime !== this.root.lastModTime) {
      // subtree has changed, so invalidate cache
      for (var i = this.cache.length-1; i>=0; i--) {
        this[i] = undefined;
      }
      this.cache.length = 0;
      this.done = false;
      this.lastModTime = this.root.lastModTime;
    }
  },

  // If n is specified, then traverse the tree until we've found the nth
  // item (or until we've found all items).  If n is not specified,
  // traverse until we've found all items.
  traverse: function(n) {
    // increment n so we can compare to length, and so it is never falsy
    if (n !== undefined) n++;

    var elt;
    while ((elt = this.next()) !== null) {
      this[this.cache.length] = elt; //XXX Use proxy instead
      this.cache.push(elt);
      if (n && this.cache.length === n) return;
    }

    // no next element, so we've found everything
    this.done = true;
  },

  // Return the next element under root that matches filter
  next: function() {
    var start = (this.cache.length === 0) ? this.root // Start at the root or at
      : this.cache[this.cache.length-1]; // the last element we found

    var elt;
    if (start.nodeType === Node.DOCUMENT_NODE)
      elt = start.documentElement;
    else
      elt = start.nextElement(this.root);

    while(elt) {
      if (this.filter(elt)) {
        return elt;
      }

      elt = elt.nextElement(this.root);
    }
    return null;
  }
};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var URL = __webpack_require__(16);
var URLUtils = __webpack_require__(40);

module.exports = Location;

function Location(window, href) {
  this._window = window;
  this._href = href;
}

Location.prototype = Object.create(URLUtils.prototype, {
  constructor: { value: Location },

  // Special behavior when href is set
  href: {
    get: function() { return this._href; },
    set: function(v) { this.assign(v); }
  },

  assign: { value: function(url) {
    // Resolve the new url against the current one
    // XXX:
    // This is not actually correct. It should be resolved against
    // the URL of the document of the script. For now, though, I only
    // support a single window and there is only one base url.
    // So this is good enough for now.
    var current = new URL(this._href);
    var newurl = current.resolve(url);

    // Save the new url
    this._href = newurl;

    // Start loading the new document!
    // XXX
    // This is just something hacked together.
    // The real algorithm is: http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html#navigate
  }},

  replace: { value: function(url) {
    // XXX
    // Since we aren't tracking history yet, replace is the same as assign
    this.assign(url);
  }},

  reload: { value: function() {
    // XXX:
    // Actually, the spec is a lot more complicated than this
    this.assign(this.href);
  }},

  toString: { value: function() {
    return this.href;
  }}

});


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {
  VALUE: 1, // The value of a Text, Comment or PI node changed
  ATTR: 2, // A new attribute was added or an attribute value and/or prefix changed
  REMOVE_ATTR: 3, // An attribute was removed
  REMOVE: 4, // A node was removed
  MOVE: 5, // A node was moved
  INSERT: 6 // A node (or a subtree of nodes) was inserted
};

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://html.spec.whatwg.org/multipage/webappapis.html#navigatorid
var NavigatorID = Object.create(null, {
  appCodeName: { value: "Mozilla" },
  appName: { value: "Netscape" },
  appVersion: { value: "4.0" },
  platform: { value: "" },
  product: { value: "Gecko" },
  productSub: { value: "20100101" },
  userAgent: { value: "" },
  vendor: { value: "" },
  vendorSub: { value: "" },
  taintEnabled: { value: function() { return false; } }
});

module.exports = NavigatorID;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = NodeIterator;

var NodeFilter = __webpack_require__(8);
var NodeTraversal = __webpack_require__(35);

/* Private methods and helpers */

/**
 * @based on WebKit's NodeIterator::moveToNext and NodeIterator::moveToPrevious
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeIterator.cpp?rev=186279#L51
 */
function move(node, stayWithin, directionIsNext) {
  if (directionIsNext) {
    return NodeTraversal.next(node, stayWithin);
  } else {
    if (node === stayWithin) {
      return null;
    }
    return NodeTraversal.previous(node, null);
  }
}

/**
 * @spec http://www.w3.org/TR/dom/#concept-nodeiterator-traverse
 * @method
 * @access private
 * @param {NodeIterator} ni
 * @param {string} direction One of 'next' or 'previous'.
 * @return {Node|null}
 */
function traverse(ni, directionIsNext) {
  var node, beforeNode;
  node = ni.referenceNode;
  beforeNode = ni.pointerBeforeReferenceNode;
  while (true) {
    if (beforeNode === directionIsNext) {
      beforeNode = !beforeNode;
    } else {
      node = move(node, ni.root, directionIsNext);
      if (node === null) {
        return null;
      }
    }
    var result = ni.filter.acceptNode(node);
    if (result === NodeFilter.FILTER_ACCEPT) {
      break;
    }
  }
  ni.referenceNode = node;
  ni.pointerBeforeReferenceNode = beforeNode;
  return node;
}

/* Public API */

/**
 * Implemented version: http://www.w3.org/TR/2015/WD-dom-20150618/#nodeiterator
 * Latest version: http://www.w3.org/TR/dom/#nodeiterator
 *
 * @constructor
 * @param {Node} root
 * @param {number} whatToShow [optional]
 * @param {Function|NodeFilter} filter [optional]
 * @throws Error
 */
function NodeIterator(root, whatToShow, filter) {
  var ni = this, active = false;

  if (!root || !root.nodeType) {
    throw new Error('DOMException: NOT_SUPPORTED_ERR');
  }

  ni.root = ni.referenceNode = root;
  ni.pointerBeforeReferenceNode = true;
  ni.whatToShow = Number(whatToShow) || 0;

  if (typeof filter !== 'function') {
    filter = null;
  }

  ni.filter = Object.create(NodeFilter.prototype);

  /**
   * @method
   * @param {Node} node
   * @return {Number} Constant NodeFilter.FILTER_ACCEPT,
   *  NodeFilter.FILTER_REJECT or NodeFilter.FILTER_SKIP.
   */
  ni.filter.acceptNode = function (node) {
    /* jshint bitwise: false */
    var result;
    if (active) {
      throw new Error('DOMException: INVALID_STATE_ERR');
    }

    // Maps nodeType to whatToShow
    if (!(((1 << (node.nodeType - 1)) & ni.whatToShow))) {
      return NodeFilter.FILTER_SKIP;
    }

    if (filter === null) {
      return NodeFilter.FILTER_ACCEPT;
    }

    active = true;
    result = filter(node);
    active = false;

    return result;
  };
}

NodeIterator.prototype = {
  constructor: NodeIterator,

  /**
   * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-nextnode
   * @method
   * @return {Node|null}
   */
  nextNode: function () {
    return traverse(this, true);
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-previousnode
   * @method
   * @return {Node|null}
   */
  previousNode: function () {
    return traverse(this, false);
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-detach
   * @method
   * @return void
   */
  detach: function() {
    /* "The detach() method must do nothing.
     * Its functionality (disabling a NodeIterator object) was removed,
     * but the method itself is preserved for compatibility.
     */
  }
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = TreeWalker;

var NodeFilter = __webpack_require__(8);
var NodeTraversal = __webpack_require__(35);

var mapChild = {
  first: 'firstChild',
  last: 'lastChild',
  next: 'firstChild',
  previous: 'lastChild'
};

var mapSibling = {
  first: 'nextSibling',
  last: 'previousSibling',
  next: 'nextSibling',
  previous: 'previousSibling'
};

/* Private methods and helpers */

/**
 * @spec http://www.w3.org/TR/dom/#concept-traverse-children
 * @method
 * @access private
 * @param {TreeWalker} tw
 * @param {string} type One of 'first' or 'last'.
 * @return {Node|null}
 */
function traverseChildren(tw, type) {
  var child, node, parent, result, sibling;
  node = tw.currentNode[mapChild[type]];
  while (node !== null) {
    result = tw.filter.acceptNode(node);
    if (result === NodeFilter.FILTER_ACCEPT) {
      tw.currentNode = node;
      return node;
    }
    if (result === NodeFilter.FILTER_SKIP) {
      child = node[mapChild[type]];
      if (child !== null) {
        node = child;
        continue;
      }
    }
    while (node !== null) {
      sibling = node[mapSibling[type]];
      if (sibling !== null) {
        node = sibling;
        break;
      }
      parent = node.parentNode;
      if (parent === null || parent === tw.root || parent === tw.currentNode) {
        return null;
      }
      else {
        node = parent;
      }
    }
  }
  return null;
}

/**
 * @spec http://www.w3.org/TR/dom/#concept-traverse-siblings
 * @method
 * @access private
 * @param {TreeWalker} tw
 * @param {TreeWalker} type One of 'next' or 'previous'.
 * @return {Node|nul}
 */
function traverseSiblings(tw, type) {
  var node, result, sibling;
  node = tw.currentNode;
  if (node === tw.root) {
    return null;
  }
  while (true) {
    sibling = node[mapSibling[type]];
    while (sibling !== null) {
      node = sibling;
      result = tw.filter.acceptNode(node);
      if (result === NodeFilter.FILTER_ACCEPT) {
        tw.currentNode = node;
        return node;
      }
      sibling = node[mapChild[type]];
      if (result === NodeFilter.FILTER_REJECT || sibling === null) {
        sibling = node[mapSibling[type]];
      }
    }
    node = node.parentNode;
    if (node === null || node === tw.root) {
      return null;
    }
    if (tw.filter.acceptNode(node) === NodeFilter.FILTER_ACCEPT) {
      return null;
    }
  }
}


/* Public API */

/**
 * Implemented version: http://www.w3.org/TR/2015/WD-dom-20150618/#interface-treewalker
 * Latest version: http://www.w3.org/TR/dom/#interface-treewalker
 *
 * @constructor
 * @param {Node} root
 * @param {number} whatToShow [optional]
 * @param {Function|NodeFilter} filter [optional]
 * @throws Error
 */
function TreeWalker(root, whatToShow, filter) {
  var tw = this, active = false;

  if (!root || !root.nodeType) {
    throw new Error('DOMException: NOT_SUPPORTED_ERR');
  }

  tw.root = root;
  tw.whatToShow = Number(whatToShow) || 0;

  tw.currentNode = root;

  if (typeof filter !== 'function') {
    filter = null;
  }

  tw.filter = Object.create(NodeFilter.prototype);

  /**
   * @method
   * @param {Node} node
   * @return {Number} Constant NodeFilter.FILTER_ACCEPT,
   *  NodeFilter.FILTER_REJECT or NodeFilter.FILTER_SKIP.
   */
  tw.filter.acceptNode = function (node) {
    /* jshint bitwise: false */
    var result;
    if (active) {
      throw new Error('DOMException: INVALID_STATE_ERR');
    }

    // Maps nodeType to whatToShow
    if (!(((1 << (node.nodeType - 1)) & tw.whatToShow))) {
      return NodeFilter.FILTER_SKIP;
    }

    if (filter === null) {
      return NodeFilter.FILTER_ACCEPT;
    }

    active = true;
    result = filter(node);
    active = false;

    return result;
  };
}

TreeWalker.prototype = {

  constructor: TreeWalker,

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-parentnode
   * @method
   * @return {Node|null}
   */
  parentNode: function () {
    var node = this.currentNode;
    while (node !== null && node !== this.root) {
      node = node.parentNode;
      if (node !== null && this.filter.acceptNode(node) === NodeFilter.FILTER_ACCEPT) {
        this.currentNode = node;
        return node;
      }
    }
    return null;
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-firstchild
   * @method
   * @return {Node|null}
   */
  firstChild: function () {
    return traverseChildren(this, 'first');
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-lastchild
   * @method
   * @return {Node|null}
   */
  lastChild: function () {
    return traverseChildren(this, 'last');
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-previoussibling
   * @method
   * @return {Node|null}
   */
  previousSibling: function () {
    return traverseSiblings(this, 'previous');
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-nextsibling
   * @method
   * @return {Node|null}
   */
  nextSibling: function () {
    return traverseSiblings(this, 'next');
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-previousnode
   * @method
   * @return {Node|null}
   */
  previousNode: function () {
    var node, result, sibling;
    node = this.currentNode;
    while (node !== this.root) {
      sibling = node.previousSibling;
      while (sibling !== null) {
        node = sibling;
        result = this.filter.acceptNode(node);
        while (result !== NodeFilter.FILTER_REJECT && node.lastChild !== null) {
          node = node.lastChild;
          result = this.filter.acceptNode(node);
        }
        if (result === NodeFilter.FILTER_ACCEPT) {
          this.currentNode = node;
          return node;
        }
        sibling = node.previousSibling;
      }
      if (node === this.root || node.parentNode === null) {
        return null;
      }
      node = node.parentNode;
      if (this.filter.acceptNode(node) === NodeFilter.FILTER_ACCEPT) {
        this.currentNode = node;
        return node;
      }
    }
    return null;
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-nextnode
   * @based on WebKit's TreeWalker::nextNode
   * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/TreeWalker.cpp?rev=179143#L252
   * @method
   * @return {Node|null}
   */
  nextNode: function () {
    var node, result, following;
    node = this.currentNode;
    result = NodeFilter.FILTER_ACCEPT;

    while (true) {
      while (result !== NodeFilter.FILTER_REJECT && node.firstChild !== null) {
        node = node.firstChild;
        result = this.filter.acceptNode(node);
        if (result === NodeFilter.FILTER_ACCEPT) {
          this.currentNode = node;
          return node;
        }
      }
      following = NodeTraversal.nextSkippingChildren(node, this.root);
      if (following !== null) {
        node = following;
      }
      else {
        return null;
      }
      result = this.filter.acceptNode(node);
      if (result === NodeFilter.FILTER_ACCEPT) {
        this.currentNode = node;
        return node;
      }
    }
  }
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://html.spec.whatwg.org/multipage/webappapis.html#windowtimers
var WindowTimers = {
  setTimeout: setTimeout,
  clearTimeout: clearTimeout,
  setInterval: setInterval,
  clearInterval: clearInterval
};

module.exports = WindowTimers;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* jshint node:true, latedef:false */
 // jshint ignore:line
/*!
Parser-Lib
Copyright (c) 2009-2011 Nicholas C. Zakas. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
/* Version v0.2.5+domino1, Build time: 30-January-2016 05:13:03 */
var parserlib = Object.create(null);
(function(){

/**
 * A generic base to inherit from for any object
 * that needs event handling.
 * @class EventTarget
 * @constructor
 */
function EventTarget(){

    /**
     * The array of listeners for various events.
     * @type Object
     * @property _listeners
     * @private
     */
    this._listeners = Object.create(null);
}

EventTarget.prototype = {

    //restore constructor
    constructor: EventTarget,

    /**
     * Adds a listener for a given event type.
     * @param {String} type The type of event to add a listener for.
     * @param {Function} listener The function to call when the event occurs.
     * @return {void}
     * @method addListener
     */
    addListener: function(type, listener){
        if (!this._listeners[type]){
            this._listeners[type] = [];
        }

        this._listeners[type].push(listener);
    },

    /**
     * Fires an event based on the passed-in object.
     * @param {Object|String} event An object with at least a 'type' attribute
     *      or a string indicating the event name.
     * @return {void}
     * @method fire
     */
    fire: function(event){
        if (typeof event === "string"){
            event = { type: event };
        }
        if (typeof event.target !== "undefined"){
            event.target = this;
        }

        if (typeof event.type === "undefined"){
            throw new Error("Event object missing 'type' property.");
        }

        if (this._listeners[event.type]){

            //create a copy of the array and use that so listeners can't chane
            var listeners = this._listeners[event.type].concat();
            for (var i=0, len=listeners.length; i < len; i++){
                listeners[i].call(this, event);
            }
        }
    },

    /**
     * Removes a listener for a given event type.
     * @param {String} type The type of event to remove a listener from.
     * @param {Function} listener The function to remove from the event.
     * @return {void}
     * @method removeListener
     */
    removeListener: function(type, listener){
        if (this._listeners[type]){
            var listeners = this._listeners[type];
            for (var i=0, len=listeners.length; i < len; i++){
                if (listeners[i] === listener){
                    listeners.splice(i, 1);
                    break;
                }
            }


        }
    }
};
/**
 * Convenient way to read through strings.
 * @namespace parserlib.util
 * @class StringReader
 * @constructor
 * @param {String} text The text to read.
 */
function StringReader(text){

    /**
     * The input text with line endings normalized.
     * @property _input
     * @type String
     * @private
     */
    this._input = text.replace(/(\r|\n){1,2}/g, "\n");


    /**
     * The row for the character to be read next.
     * @property _line
     * @type int
     * @private
     */
    this._line = 1;


    /**
     * The column for the character to be read next.
     * @property _col
     * @type int
     * @private
     */
    this._col = 1;

    /**
     * The index of the character in the input to be read next.
     * @property _cursor
     * @type int
     * @private
     */
    this._cursor = 0;
}

StringReader.prototype = {

    //restore constructor
    constructor: StringReader,

    //-------------------------------------------------------------------------
    // Position info
    //-------------------------------------------------------------------------

    /**
     * Returns the column of the character to be read next.
     * @return {int} The column of the character to be read next.
     * @method getCol
     */
    getCol: function(){
        return this._col;
    },

    /**
     * Returns the row of the character to be read next.
     * @return {int} The row of the character to be read next.
     * @method getLine
     */
    getLine: function(){
        return this._line ;
    },

    /**
     * Determines if you're at the end of the input.
     * @return {Boolean} True if there's no more input, false otherwise.
     * @method eof
     */
    eof: function(){
        return (this._cursor === this._input.length);
    },

    //-------------------------------------------------------------------------
    // Basic reading
    //-------------------------------------------------------------------------

    /**
     * Reads the next character without advancing the cursor.
     * @param {int} count How many characters to look ahead (default is 1).
     * @return {String} The next character or null if there is no next character.
     * @method peek
     */
    peek: function(count){
        var c = null;
        count = (typeof count === "undefined" ? 1 : count);

        //if we're not at the end of the input...
        if (this._cursor < this._input.length){

            //get character and increment cursor and column
            c = this._input.charAt(this._cursor + count - 1);
        }

        return c;
    },

    /**
     * Reads the next character from the input and adjusts the row and column
     * accordingly.
     * @return {String} The next character or null if there is no next character.
     * @method read
     */
    read: function(){
        var c = null;

        //if we're not at the end of the input...
        if (this._cursor < this._input.length){

            //if the last character was a newline, increment row count
            //and reset column count
            if (this._input.charAt(this._cursor) === "\n"){
                this._line++;
                this._col=1;
            } else {
                this._col++;
            }

            //get character and increment cursor and column
            c = this._input.charAt(this._cursor++);
        }

        return c;
    },

    //-------------------------------------------------------------------------
    // Misc
    //-------------------------------------------------------------------------

    /**
     * Saves the current location so it can be returned to later.
     * @method mark
     * @return {void}
     */
    mark: function(){
        this._bookmark = {
            cursor: this._cursor,
            line:   this._line,
            col:    this._col
        };
    },

    reset: function(){
        if (this._bookmark){
            this._cursor = this._bookmark.cursor;
            this._line = this._bookmark.line;
            this._col = this._bookmark.col;
            delete this._bookmark;
        }
    },

    //-------------------------------------------------------------------------
    // Advanced reading
    //-------------------------------------------------------------------------

    /**
     * Reads up to and including the given string. Throws an error if that
     * string is not found.
     * @param {String} pattern The string to read.
     * @return {String} The string when it is found.
     * @throws Error when the string pattern is not found.
     * @method readTo
     */
    readTo: function(pattern){

        var buffer = "",
            c;

        /*
         * First, buffer must be the same length as the pattern.
         * Then, buffer must end with the pattern or else reach the
         * end of the input.
         */
        while (buffer.length < pattern.length || buffer.lastIndexOf(pattern) !== buffer.length - pattern.length){
            c = this.read();
            if (c){
                buffer += c;
            } else {
                throw new Error("Expected \"" + pattern + "\" at line " + this._line  + ", col " + this._col + ".");
            }
        }

        return buffer;

    },

    /**
     * Reads characters while each character causes the given
     * filter function to return true. The function is passed
     * in each character and either returns true to continue
     * reading or false to stop.
     * @param {Function} filter The function to read on each character.
     * @return {String} The string made up of all characters that passed the
     *      filter check.
     * @method readWhile
     */
    readWhile: function(filter){

        var buffer = "",
            c = this.read();

        while(c !== null && filter(c)){
            buffer += c;
            c = this.read();
        }

        return buffer;

    },

    /**
     * Reads characters that match either text or a regular expression and
     * returns those characters. If a match is found, the row and column
     * are adjusted; if no match is found, the reader's state is unchanged.
     * reading or false to stop.
     * @param {String|RegExp} matchter If a string, then the literal string
     *      value is searched for. If a regular expression, then any string
     *      matching the pattern is search for.
     * @return {String} The string made up of all characters that matched or
     *      null if there was no match.
     * @method readMatch
     */
    readMatch: function(matcher){

        var source = this._input.substring(this._cursor),
            value = null;

        //if it's a string, just do a straight match
        if (typeof matcher === "string"){
            if (source.indexOf(matcher) === 0){
                value = this.readCount(matcher.length);
            }
        } else if (matcher instanceof RegExp){
            if (matcher.test(source)){
                value = this.readCount(RegExp.lastMatch.length);
            }
        }

        return value;
    },


    /**
     * Reads a given number of characters. If the end of the input is reached,
     * it reads only the remaining characters and does not throw an error.
     * @param {int} count The number of characters to read.
     * @return {String} The string made up the read characters.
     * @method readCount
     */
    readCount: function(count){
        var buffer = "";

        while(count--){
            buffer += this.read();
        }

        return buffer;
    }

};
/**
 * Type to use when a syntax error occurs.
 * @class SyntaxError
 * @namespace parserlib.util
 * @constructor
 * @param {String} message The error message.
 * @param {int} line The line at which the error occurred.
 * @param {int} col The column at which the error occurred.
 */
function SyntaxError(message, line, col){
    Error.call(this);
    this.name = this.constructor.name;

    /**
     * The column at which the error occurred.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line at which the error occurred.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.message = message;

}

//inherit from Error
SyntaxError.prototype = Object.create(Error.prototype); // jshint ignore:line
SyntaxError.prototype.constructor = SyntaxError; // jshint ignore:line
/**
 * Base type to represent a single syntactic unit.
 * @class SyntaxUnit
 * @namespace parserlib.util
 * @constructor
 * @param {String} text The text of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function SyntaxUnit(text, line, col, type){


    /**
     * The column of text on which the unit resides.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line of text on which the unit resides.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.text = text;

    /**
     * The type of syntax unit.
     * @type int
     * @property type
     */
    this.type = type;
}

/**
 * Create a new syntax unit based solely on the given token.
 * Convenience method for creating a new syntax unit when
 * it represents a single token instead of multiple.
 * @param {Object} token The token object to represent.
 * @return {parserlib.util.SyntaxUnit} The object representing the token.
 * @static
 * @method fromToken
 */
SyntaxUnit.fromToken = function(token){
    return new SyntaxUnit(token.value, token.startLine, token.startCol);
};

SyntaxUnit.prototype = {

    //restore constructor
    constructor: SyntaxUnit,

    /**
     * Returns the text representation of the unit.
     * @return {String} The text representation of the unit.
     * @method valueOf
     */
    valueOf: function(){
        return this.toString();
    },

    /**
     * Returns the text representation of the unit.
     * @return {String} The text representation of the unit.
     * @method toString
     */
    toString: function(){
        return this.text;
    }

};

/**
 * Generic TokenStream providing base functionality.
 * @class TokenStreamBase
 * @namespace parserlib.util
 * @constructor
 * @param {String|StringReader} input The text to tokenize or a reader from
 *      which to read the input.
 */
function TokenStreamBase(input, tokenData){

    /**
     * The string reader for easy access to the text.
     * @type StringReader
     * @property _reader
     * @private
     */
    this._reader = input ? new StringReader(input.toString()) : null;

    /**
     * Token object for the last consumed token.
     * @type Token
     * @property _token
     * @private
     */
    this._token = null;

    /**
     * The array of token information.
     * @type Array
     * @property _tokenData
     * @private
     */
    this._tokenData = tokenData;

    /**
     * Lookahead token buffer.
     * @type Array
     * @property _lt
     * @private
     */
    this._lt = [];

    /**
     * Lookahead token buffer index.
     * @type int
     * @property _ltIndex
     * @private
     */
    this._ltIndex = 0;

    this._ltIndexCache = [];
}

/**
 * Accepts an array of token information and outputs
 * an array of token data containing key-value mappings
 * and matching functions that the TokenStream needs.
 * @param {Array} tokens An array of token descriptors.
 * @return {Array} An array of processed token data.
 * @method createTokenData
 * @static
 */
TokenStreamBase.createTokenData = function(tokens){

    var nameMap     = [],
        typeMap     = Object.create(null),
        tokenData     = tokens.concat([]),
        i            = 0,
        len            = tokenData.length+1;

    tokenData.UNKNOWN = -1;
    tokenData.unshift({name:"EOF"});

    for (; i < len; i++){
        nameMap.push(tokenData[i].name);
        tokenData[tokenData[i].name] = i;
        if (tokenData[i].text){
            typeMap[tokenData[i].text] = i;
        }
    }

    tokenData.name = function(tt){
        return nameMap[tt];
    };

    tokenData.type = function(c){
        return typeMap[c];
    };

    return tokenData;
};

TokenStreamBase.prototype = {

    //restore constructor
    constructor: TokenStreamBase,

    //-------------------------------------------------------------------------
    // Matching methods
    //-------------------------------------------------------------------------

    /**
     * Determines if the next token matches the given token type.
     * If so, that token is consumed; if not, the token is placed
     * back onto the token stream. You can pass in any number of
     * token types and this will return true if any of the token
     * types is found.
     * @param {int|int[]} tokenTypes Either a single token type or an array of
     *      token types that the next token might be. If an array is passed,
     *      it's assumed that the token can be any of these.
     * @param {variant} channel (Optional) The channel to read from. If not
     *      provided, reads from the default (unnamed) channel.
     * @return {Boolean} True if the token type matches, false if not.
     * @method match
     */
    match: function(tokenTypes, channel){

        //always convert to an array, makes things easier
        if (!(tokenTypes instanceof Array)){
            tokenTypes = [tokenTypes];
        }

        var tt  = this.get(channel),
            i   = 0,
            len = tokenTypes.length;

        while(i < len){
            if (tt === tokenTypes[i++]){
                return true;
            }
        }

        //no match found, put the token back
        this.unget();
        return false;
    },

    /**
     * Determines if the next token matches the given token type.
     * If so, that token is consumed; if not, an error is thrown.
     * @param {int|int[]} tokenTypes Either a single token type or an array of
     *      token types that the next token should be. If an array is passed,
     *      it's assumed that the token must be one of these.
     * @param {variant} channel (Optional) The channel to read from. If not
     *      provided, reads from the default (unnamed) channel.
     * @return {void}
     * @method mustMatch
     */
    mustMatch: function(tokenTypes, channel){

        var token;

        //always convert to an array, makes things easier
        if (!(tokenTypes instanceof Array)){
            tokenTypes = [tokenTypes];
        }

        if (!this.match.apply(this, arguments)){
            token = this.LT(1);
            throw new SyntaxError("Expected " + this._tokenData[tokenTypes[0]].name +
                " at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
        }
    },

    //-------------------------------------------------------------------------
    // Consuming methods
    //-------------------------------------------------------------------------

    /**
     * Keeps reading from the token stream until either one of the specified
     * token types is found or until the end of the input is reached.
     * @param {int|int[]} tokenTypes Either a single token type or an array of
     *      token types that the next token should be. If an array is passed,
     *      it's assumed that the token must be one of these.
     * @param {variant} channel (Optional) The channel to read from. If not
     *      provided, reads from the default (unnamed) channel.
     * @return {void}
     * @method advance
     */
    advance: function(tokenTypes, channel){

        while(this.LA(0) !== 0 && !this.match(tokenTypes, channel)){
            this.get();
        }

        return this.LA(0);
    },

    /**
     * Consumes the next token from the token stream.
     * @return {int} The token type of the token that was just consumed.
     * @method get
     */
    get: function(channel){

        var tokenInfo   = this._tokenData,
            i           =0,
            token,
            info;

        //check the lookahead buffer first
        if (this._lt.length && this._ltIndex >= 0 && this._ltIndex < this._lt.length){

            i++;
            this._token = this._lt[this._ltIndex++];
            info = tokenInfo[this._token.type];

            //obey channels logic
            while((info.channel !== undefined && channel !== info.channel) &&
                    this._ltIndex < this._lt.length){
                this._token = this._lt[this._ltIndex++];
                info = tokenInfo[this._token.type];
                i++;
            }

            //here be dragons
            if ((info.channel === undefined || channel === info.channel) &&
                    this._ltIndex <= this._lt.length){
                this._ltIndexCache.push(i);
                return this._token.type;
            }
        }

        //call token retriever method
        token = this._getToken();

        //if it should be hidden, don't save a token
        if (token.type > -1 && !tokenInfo[token.type].hide){

            //apply token channel
            token.channel = tokenInfo[token.type].channel;

            //save for later
            this._token = token;
            this._lt.push(token);

            //save space that will be moved (must be done before array is truncated)
            this._ltIndexCache.push(this._lt.length - this._ltIndex + i);

            //keep the buffer under 5 items
            if (this._lt.length > 5){
                this._lt.shift();
            }

            //also keep the shift buffer under 5 items
            if (this._ltIndexCache.length > 5){
                this._ltIndexCache.shift();
            }

            //update lookahead index
            this._ltIndex = this._lt.length;
        }

        /*
         * Skip to the next token if:
         * 1. The token type is marked as hidden.
         * 2. The token type has a channel specified and it isn't the current channel.
         */
        info = tokenInfo[token.type];
        if (info &&
                (info.hide ||
                (info.channel !== undefined && channel !== info.channel))){
            return this.get(channel);
        } else {
            //return just the type
            return token.type;
        }
    },

    /**
     * Looks ahead a certain number of tokens and returns the token type at
     * that position. This will throw an error if you lookahead past the
     * end of input, past the size of the lookahead buffer, or back past
     * the first token in the lookahead buffer.
     * @param {int} The index of the token type to retrieve. 0 for the
     *      current token, 1 for the next, -1 for the previous, etc.
     * @return {int} The token type of the token in the given position.
     * @method LA
     */
    LA: function(index){
        var total = index,
            tt;
        if (index > 0){
            //TODO: Store 5 somewhere
            if (index > 5){
                throw new Error("Too much lookahead.");
            }

            //get all those tokens
            while(total){
                tt = this.get();
                total--;
            }

            //unget all those tokens
            while(total < index){
                this.unget();
                total++;
            }
        } else if (index < 0){

            if(this._lt[this._ltIndex+index]){
                tt = this._lt[this._ltIndex+index].type;
            } else {
                throw new Error("Too much lookbehind.");
            }

        } else {
            tt = this._token.type;
        }

        return tt;

    },

    /**
     * Looks ahead a certain number of tokens and returns the token at
     * that position. This will throw an error if you lookahead past the
     * end of input, past the size of the lookahead buffer, or back past
     * the first token in the lookahead buffer.
     * @param {int} The index of the token type to retrieve. 0 for the
     *      current token, 1 for the next, -1 for the previous, etc.
     * @return {Object} The token of the token in the given position.
     * @method LA
     */
    LT: function(index){

        //lookahead first to prime the token buffer
        this.LA(index);

        //now find the token, subtract one because _ltIndex is already at the next index
        return this._lt[this._ltIndex+index-1];
    },

    /**
     * Returns the token type for the next token in the stream without
     * consuming it.
     * @return {int} The token type of the next token in the stream.
     * @method peek
     */
    peek: function(){
        return this.LA(1);
    },

    /**
     * Returns the actual token object for the last consumed token.
     * @return {Token} The token object for the last consumed token.
     * @method token
     */
    token: function(){
        return this._token;
    },

    /**
     * Returns the name of the token for the given token type.
     * @param {int} tokenType The type of token to get the name of.
     * @return {String} The name of the token or "UNKNOWN_TOKEN" for any
     *      invalid token type.
     * @method tokenName
     */
    tokenName: function(tokenType){
        if (tokenType < 0 || tokenType > this._tokenData.length){
            return "UNKNOWN_TOKEN";
        } else {
            return this._tokenData[tokenType].name;
        }
    },

    /**
     * Returns the token type value for the given token name.
     * @param {String} tokenName The name of the token whose value should be returned.
     * @return {int} The token type value for the given token name or -1
     *      for an unknown token.
     * @method tokenName
     */
    tokenType: function(tokenName){
        return this._tokenData[tokenName] || -1;
    },

    /**
     * Returns the last consumed token to the token stream.
     * @method unget
     */
    unget: function(){
        //if (this._ltIndex > -1){
        if (this._ltIndexCache.length){
            this._ltIndex -= this._ltIndexCache.pop();//--;
            this._token = this._lt[this._ltIndex - 1];
        } else {
            throw new Error("Too much lookahead.");
        }
    }

};


parserlib.util = {
__proto__   : null,
StringReader: StringReader,
SyntaxError : SyntaxError,
SyntaxUnit  : SyntaxUnit,
EventTarget : EventTarget,
TokenStreamBase : TokenStreamBase
};
})();
/*
Parser-Lib
Copyright (c) 2009-2011 Nicholas C. Zakas. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
/* Version v0.2.5+domino1, Build time: 30-January-2016 05:13:03 */
(function(){
var EventTarget = parserlib.util.EventTarget,
TokenStreamBase = parserlib.util.TokenStreamBase,
StringReader = parserlib.util.StringReader, // jshint ignore:line
SyntaxError = parserlib.util.SyntaxError,
SyntaxUnit  = parserlib.util.SyntaxUnit;

var Colors = {
    __proto__       :null,
    aliceblue       :"#f0f8ff",
    antiquewhite    :"#faebd7",
    aqua            :"#00ffff",
    aquamarine      :"#7fffd4",
    azure           :"#f0ffff",
    beige           :"#f5f5dc",
    bisque          :"#ffe4c4",
    black           :"#000000",
    blanchedalmond  :"#ffebcd",
    blue            :"#0000ff",
    blueviolet      :"#8a2be2",
    brown           :"#a52a2a",
    burlywood       :"#deb887",
    cadetblue       :"#5f9ea0",
    chartreuse      :"#7fff00",
    chocolate       :"#d2691e",
    coral           :"#ff7f50",
    cornflowerblue  :"#6495ed",
    cornsilk        :"#fff8dc",
    crimson         :"#dc143c",
    cyan            :"#00ffff",
    darkblue        :"#00008b",
    darkcyan        :"#008b8b",
    darkgoldenrod   :"#b8860b",
    darkgray        :"#a9a9a9",
    darkgrey        :"#a9a9a9",
    darkgreen       :"#006400",
    darkkhaki       :"#bdb76b",
    darkmagenta     :"#8b008b",
    darkolivegreen  :"#556b2f",
    darkorange      :"#ff8c00",
    darkorchid      :"#9932cc",
    darkred         :"#8b0000",
    darksalmon      :"#e9967a",
    darkseagreen    :"#8fbc8f",
    darkslateblue   :"#483d8b",
    darkslategray   :"#2f4f4f",
    darkslategrey   :"#2f4f4f",
    darkturquoise   :"#00ced1",
    darkviolet      :"#9400d3",
    deeppink        :"#ff1493",
    deepskyblue     :"#00bfff",
    dimgray         :"#696969",
    dimgrey         :"#696969",
    dodgerblue      :"#1e90ff",
    firebrick       :"#b22222",
    floralwhite     :"#fffaf0",
    forestgreen     :"#228b22",
    fuchsia         :"#ff00ff",
    gainsboro       :"#dcdcdc",
    ghostwhite      :"#f8f8ff",
    gold            :"#ffd700",
    goldenrod       :"#daa520",
    gray            :"#808080",
    grey            :"#808080",
    green           :"#008000",
    greenyellow     :"#adff2f",
    honeydew        :"#f0fff0",
    hotpink         :"#ff69b4",
    indianred       :"#cd5c5c",
    indigo          :"#4b0082",
    ivory           :"#fffff0",
    khaki           :"#f0e68c",
    lavender        :"#e6e6fa",
    lavenderblush   :"#fff0f5",
    lawngreen       :"#7cfc00",
    lemonchiffon    :"#fffacd",
    lightblue       :"#add8e6",
    lightcoral      :"#f08080",
    lightcyan       :"#e0ffff",
    lightgoldenrodyellow  :"#fafad2",
    lightgray       :"#d3d3d3",
    lightgrey       :"#d3d3d3",
    lightgreen      :"#90ee90",
    lightpink       :"#ffb6c1",
    lightsalmon     :"#ffa07a",
    lightseagreen   :"#20b2aa",
    lightskyblue    :"#87cefa",
    lightslategray  :"#778899",
    lightslategrey  :"#778899",
    lightsteelblue  :"#b0c4de",
    lightyellow     :"#ffffe0",
    lime            :"#00ff00",
    limegreen       :"#32cd32",
    linen           :"#faf0e6",
    magenta         :"#ff00ff",
    maroon          :"#800000",
    mediumaquamarine:"#66cdaa",
    mediumblue      :"#0000cd",
    mediumorchid    :"#ba55d3",
    mediumpurple    :"#9370d8",
    mediumseagreen  :"#3cb371",
    mediumslateblue :"#7b68ee",
    mediumspringgreen   :"#00fa9a",
    mediumturquoise :"#48d1cc",
    mediumvioletred :"#c71585",
    midnightblue    :"#191970",
    mintcream       :"#f5fffa",
    mistyrose       :"#ffe4e1",
    moccasin        :"#ffe4b5",
    navajowhite     :"#ffdead",
    navy            :"#000080",
    oldlace         :"#fdf5e6",
    olive           :"#808000",
    olivedrab       :"#6b8e23",
    orange          :"#ffa500",
    orangered       :"#ff4500",
    orchid          :"#da70d6",
    palegoldenrod   :"#eee8aa",
    palegreen       :"#98fb98",
    paleturquoise   :"#afeeee",
    palevioletred   :"#d87093",
    papayawhip      :"#ffefd5",
    peachpuff       :"#ffdab9",
    peru            :"#cd853f",
    pink            :"#ffc0cb",
    plum            :"#dda0dd",
    powderblue      :"#b0e0e6",
    purple          :"#800080",
    red             :"#ff0000",
    rosybrown       :"#bc8f8f",
    royalblue       :"#4169e1",
    saddlebrown     :"#8b4513",
    salmon          :"#fa8072",
    sandybrown      :"#f4a460",
    seagreen        :"#2e8b57",
    seashell        :"#fff5ee",
    sienna          :"#a0522d",
    silver          :"#c0c0c0",
    skyblue         :"#87ceeb",
    slateblue       :"#6a5acd",
    slategray       :"#708090",
    slategrey       :"#708090",
    snow            :"#fffafa",
    springgreen     :"#00ff7f",
    steelblue       :"#4682b4",
    tan             :"#d2b48c",
    teal            :"#008080",
    thistle         :"#d8bfd8",
    tomato          :"#ff6347",
    turquoise       :"#40e0d0",
    violet          :"#ee82ee",
    wheat           :"#f5deb3",
    white           :"#ffffff",
    whitesmoke      :"#f5f5f5",
    yellow          :"#ffff00",
    yellowgreen     :"#9acd32",
    //'currentColor' color keyword http://www.w3.org/TR/css3-color/#currentcolor
    currentColor        :"The value of the 'color' property.",
    //CSS2 system colors http://www.w3.org/TR/css3-color/#css2-system
    activeBorder        :"Active window border.",
    activecaption       :"Active window caption.",
    appworkspace        :"Background color of multiple document interface.",
    background          :"Desktop background.",
    buttonface          :"The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttonhighlight     :"The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttonshadow        :"The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttontext          :"Text on push buttons.",
    captiontext         :"Text in caption, size box, and scrollbar arrow box.",
    graytext            :"Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.",
    greytext            :"Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.",
    highlight           :"Item(s) selected in a control.",
    highlighttext       :"Text of item(s) selected in a control.",
    inactiveborder      :"Inactive window border.",
    inactivecaption     :"Inactive window caption.",
    inactivecaptiontext :"Color of text in an inactive caption.",
    infobackground      :"Background color for tooltip controls.",
    infotext            :"Text color for tooltip controls.",
    menu                :"Menu background.",
    menutext            :"Text in menus.",
    scrollbar           :"Scroll bar gray area.",
    threeddarkshadow    :"The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedface          :"The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedhighlight     :"The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedlightshadow   :"The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedshadow        :"The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    window              :"Window background.",
    windowframe         :"Window frame.",
    windowtext          :"Text in windows."
};
/**
 * Represents a selector combinator (whitespace, +, >).
 * @namespace parserlib.css
 * @class Combinator
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} text The text representation of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function Combinator(text, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = "unknown";

    //pretty simple
    if (/^\s+$/.test(text)){
        this.type = "descendant";
    } else if (text === ">"){
        this.type = "child";
    } else if (text === "+"){
        this.type = "adjacent-sibling";
    } else if (text === "~"){
        this.type = "sibling";
    }

}

Combinator.prototype = new SyntaxUnit();
Combinator.prototype.constructor = Combinator;

/**
 * Represents a media feature, such as max-width:500.
 * @namespace parserlib.css
 * @class MediaFeature
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {SyntaxUnit} name The name of the feature.
 * @param {SyntaxUnit} value The value of the feature or null if none.
 */
function MediaFeature(name, value){

    SyntaxUnit.call(this, "(" + name + (value !== null ? ":" + value : "") + ")", name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);

    /**
     * The name of the media feature
     * @type String
     * @property name
     */
    this.name = name;

    /**
     * The value for the feature or null if there is none.
     * @type SyntaxUnit
     * @property value
     */
    this.value = value;
}

MediaFeature.prototype = new SyntaxUnit();
MediaFeature.prototype.constructor = MediaFeature;

/**
 * Represents an individual media query.
 * @namespace parserlib.css
 * @class MediaQuery
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} modifier The modifier "not" or "only" (or null).
 * @param {String} mediaType The type of media (i.e., "print").
 * @param {Array} parts Array of selectors parts making up this selector.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function MediaQuery(modifier, mediaType, features, line, col){

    SyntaxUnit.call(this, (modifier ? modifier + " ": "") + (mediaType ? mediaType : "") + (mediaType && features.length > 0 ? " and " : "") + features.join(" and "), line, col, Parser.MEDIA_QUERY_TYPE);

    /**
     * The media modifier ("not" or "only")
     * @type String
     * @property modifier
     */
    this.modifier = modifier;

    /**
     * The mediaType (i.e., "print")
     * @type String
     * @property mediaType
     */
    this.mediaType = mediaType;

    /**
     * The parts that make up the selector.
     * @type Array
     * @property features
     */
    this.features = features;

}

MediaQuery.prototype = new SyntaxUnit();
MediaQuery.prototype.constructor = MediaQuery;


/**
 * A CSS3 parser.
 * @namespace parserlib.css
 * @class Parser
 * @constructor
 * @param {Object} options (Optional) Various options for the parser:
 *      starHack (true|false) to allow IE6 star hack as valid,
 *      underscoreHack (true|false) to interpret leading underscores
 *      as IE6-7 targeting for known properties, ieFilters (true|false)
 *      to indicate that IE < 8 filters should be accepted and not throw
 *      syntax errors.
 */
function Parser(options){

    //inherit event functionality
    EventTarget.call(this);


    this.options = options || {};

    this._tokenStream = null;
}

//Static constants
Parser.DEFAULT_TYPE = 0;
Parser.COMBINATOR_TYPE = 1;
Parser.MEDIA_FEATURE_TYPE = 2;
Parser.MEDIA_QUERY_TYPE = 3;
Parser.PROPERTY_NAME_TYPE = 4;
Parser.PROPERTY_VALUE_TYPE = 5;
Parser.PROPERTY_VALUE_PART_TYPE = 6;
Parser.SELECTOR_TYPE = 7;
Parser.SELECTOR_PART_TYPE = 8;
Parser.SELECTOR_SUB_PART_TYPE = 9;

Parser.prototype = function(){

    var proto = new EventTarget(),  //new prototype
        prop,
        additions =  {
            __proto__: null,

            //restore constructor
            constructor: Parser,

            //instance constants - yuck
            DEFAULT_TYPE : 0,
            COMBINATOR_TYPE : 1,
            MEDIA_FEATURE_TYPE : 2,
            MEDIA_QUERY_TYPE : 3,
            PROPERTY_NAME_TYPE : 4,
            PROPERTY_VALUE_TYPE : 5,
            PROPERTY_VALUE_PART_TYPE : 6,
            SELECTOR_TYPE : 7,
            SELECTOR_PART_TYPE : 8,
            SELECTOR_SUB_PART_TYPE : 9,

            //-----------------------------------------------------------------
            // Grammar
            //-----------------------------------------------------------------

            _stylesheet: function(){

                /*
                 * stylesheet
                 *  : [ CHARSET_SYM S* STRING S* ';' ]?
                 *    [S|CDO|CDC]* [ import [S|CDO|CDC]* ]*
                 *    [ namespace [S|CDO|CDC]* ]*
                 *    [ [ ruleset | media | page | font_face | keyframes ] [S|CDO|CDC]* ]*
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                    count,
                    token,
                    tt;

                this.fire("startstylesheet");

                //try to read character set
                this._charset();

                this._skipCruft();

                //try to read imports - may be more than one
                while (tokenStream.peek() === Tokens.IMPORT_SYM){
                    this._import();
                    this._skipCruft();
                }

                //try to read namespaces - may be more than one
                while (tokenStream.peek() === Tokens.NAMESPACE_SYM){
                    this._namespace();
                    this._skipCruft();
                }

                //get the next token
                tt = tokenStream.peek();

                //try to read the rest
                while(tt > Tokens.EOF){

                    try {

                        switch(tt){
                            case Tokens.MEDIA_SYM:
                                this._media();
                                this._skipCruft();
                                break;
                            case Tokens.PAGE_SYM:
                                this._page();
                                this._skipCruft();
                                break;
                            case Tokens.FONT_FACE_SYM:
                                this._font_face();
                                this._skipCruft();
                                break;
                            case Tokens.KEYFRAMES_SYM:
                                this._keyframes();
                                this._skipCruft();
                                break;
                            case Tokens.VIEWPORT_SYM:
                                this._viewport();
                                this._skipCruft();
                                break;
                            case Tokens.DOCUMENT_SYM:
                                this._document();
                                this._skipCruft();
                                break;
                            case Tokens.UNKNOWN_SYM:  //unknown @ rule
                                tokenStream.get();
                                if (!this.options.strict){

                                    //fire error event
                                    this.fire({
                                        type:       "error",
                                        error:      null,
                                        message:    "Unknown @ rule: " + tokenStream.LT(0).value + ".",
                                        line:       tokenStream.LT(0).startLine,
                                        col:        tokenStream.LT(0).startCol
                                    });

                                    //skip braces
                                    count=0;
                                    while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) === Tokens.LBRACE){
                                        count++;    //keep track of nesting depth
                                    }

                                    while(count){
                                        tokenStream.advance([Tokens.RBRACE]);
                                        count--;
                                    }

                                } else {
                                    //not a syntax error, rethrow it
                                    throw new SyntaxError("Unknown @ rule.", tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);
                                }
                                break;
                            case Tokens.S:
                                this._readWhitespace();
                                break;
                            default:
                                if(!this._ruleset()){

                                    //error handling for known issues
                                    switch(tt){
                                        case Tokens.CHARSET_SYM:
                                            token = tokenStream.LT(1);
                                            this._charset(false);
                                            throw new SyntaxError("@charset not allowed here.", token.startLine, token.startCol);
                                        case Tokens.IMPORT_SYM:
                                            token = tokenStream.LT(1);
                                            this._import(false);
                                            throw new SyntaxError("@import not allowed here.", token.startLine, token.startCol);
                                        case Tokens.NAMESPACE_SYM:
                                            token = tokenStream.LT(1);
                                            this._namespace(false);
                                            throw new SyntaxError("@namespace not allowed here.", token.startLine, token.startCol);
                                        default:
                                            tokenStream.get();  //get the last token
                                            this._unexpectedToken(tokenStream.token());
                                    }

                                }
                        }
                    } catch(ex) {
                        if (ex instanceof SyntaxError && !this.options.strict){
                            this.fire({
                                type:       "error",
                                error:      ex,
                                message:    ex.message,
                                line:       ex.line,
                                col:        ex.col
                            });
                        } else {
                            throw ex;
                        }
                    }

                    tt = tokenStream.peek();
                }

                if (tt !== Tokens.EOF){
                    this._unexpectedToken(tokenStream.token());
                }

                this.fire("endstylesheet");
            },

            _charset: function(emit){
                var tokenStream = this._tokenStream,
                    charset,
                    token,
                    line,
                    col;

                if (tokenStream.match(Tokens.CHARSET_SYM)){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.STRING);

                    token = tokenStream.token();
                    charset = token.value;

                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.SEMICOLON);

                    if (emit !== false){
                        this.fire({
                            type:   "charset",
                            charset:charset,
                            line:   line,
                            col:    col
                        });
                    }
                }
            },

            _import: function(emit){
                /*
                 * import
                 *   : IMPORT_SYM S*
                 *    [STRING|URI] S* media_query_list? ';' S*
                 */

                var tokenStream = this._tokenStream,
                    uri,
                    importToken,
                    mediaList   = [];

                //read import symbol
                tokenStream.mustMatch(Tokens.IMPORT_SYM);
                importToken = tokenStream.token();
                this._readWhitespace();

                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);

                //grab the URI value
                uri = tokenStream.token().value.replace(/^(?:url\()?["']?([^"']+?)["']?\)?$/, "$1");

                this._readWhitespace();

                mediaList = this._media_query_list();

                //must end with a semicolon
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();

                if (emit !== false){
                    this.fire({
                        type:   "import",
                        uri:    uri,
                        media:  mediaList,
                        line:   importToken.startLine,
                        col:    importToken.startCol
                    });
                }

            },

            _namespace: function(emit){
                /*
                 * namespace
                 *   : NAMESPACE_SYM S* [namespace_prefix S*]? [STRING|URI] S* ';' S*
                 */

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    prefix,
                    uri;

                //read import symbol
                tokenStream.mustMatch(Tokens.NAMESPACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                this._readWhitespace();

                //it's a namespace prefix - no _namespace_prefix() method because it's just an IDENT
                if (tokenStream.match(Tokens.IDENT)){
                    prefix = tokenStream.token().value;
                    this._readWhitespace();
                }

                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
                /*if (!tokenStream.match(Tokens.STRING)){
                    tokenStream.mustMatch(Tokens.URI);
                }*/

                //grab the URI value
                uri = tokenStream.token().value.replace(/(?:url\()?["']([^"']+)["']\)?/, "$1");

                this._readWhitespace();

                //must end with a semicolon
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();

                if (emit !== false){
                    this.fire({
                        type:   "namespace",
                        prefix: prefix,
                        uri:    uri,
                        line:   line,
                        col:    col
                    });
                }

            },

            _media: function(){
                /*
                 * media
                 *   : MEDIA_SYM S* media_query_list S* '{' S* ruleset* '}' S*
                 *   ;
                 */
                var tokenStream     = this._tokenStream,
                    line,
                    col,
                    mediaList;//       = [];

                //look for @media
                tokenStream.mustMatch(Tokens.MEDIA_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                mediaList = this._media_query_list();

                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();

                this.fire({
                    type:   "startmedia",
                    media:  mediaList,
                    line:   line,
                    col:    col
                });

                while(true) {
                    if (tokenStream.peek() === Tokens.PAGE_SYM){
                        this._page();
                    } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM){
                        this._font_face();
                    } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM){
                        this._viewport();
                    } else if (tokenStream.peek() === Tokens.DOCUMENT_SYM){
                        this._document();
                    } else if (!this._ruleset()){
                        break;
                    }
                }

                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();

                this.fire({
                    type:   "endmedia",
                    media:  mediaList,
                    line:   line,
                    col:    col
                });
            },


            //CSS3 Media Queries
            _media_query_list: function(){
                /*
                 * media_query_list
                 *   : S* [media_query [ ',' S* media_query ]* ]?
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    mediaList   = [];


                this._readWhitespace();

                if (tokenStream.peek() === Tokens.IDENT || tokenStream.peek() === Tokens.LPAREN){
                    mediaList.push(this._media_query());
                }

                while(tokenStream.match(Tokens.COMMA)){
                    this._readWhitespace();
                    mediaList.push(this._media_query());
                }

                return mediaList;
            },

            /*
             * Note: "expression" in the grammar maps to the _media_expression
             * method.

             */
            _media_query: function(){
                /*
                 * media_query
                 *   : [ONLY | NOT]? S* media_type S* [ AND S* expression ]*
                 *   | expression [ AND S* expression ]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    type        = null,
                    ident       = null,
                    token       = null,
                    expressions = [];

                if (tokenStream.match(Tokens.IDENT)){
                    ident = tokenStream.token().value.toLowerCase();

                    //since there's no custom tokens for these, need to manually check
                    if (ident !== "only" && ident !== "not"){
                        tokenStream.unget();
                        ident = null;
                    } else {
                        token = tokenStream.token();
                    }
                }

                this._readWhitespace();

                if (tokenStream.peek() === Tokens.IDENT){
                    type = this._media_type();
                    if (token === null){
                        token = tokenStream.token();
                    }
                } else if (tokenStream.peek() === Tokens.LPAREN){
                    if (token === null){
                        token = tokenStream.LT(1);
                    }
                    expressions.push(this._media_expression());
                }

                if (type === null && expressions.length === 0){
                    return null;
                } else {
                    this._readWhitespace();
                    while (tokenStream.match(Tokens.IDENT)){
                        if (tokenStream.token().value.toLowerCase() !== "and"){
                            this._unexpectedToken(tokenStream.token());
                        }

                        this._readWhitespace();
                        expressions.push(this._media_expression());
                    }
                }

                return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);
            },

            //CSS3 Media Queries
            _media_type: function(){
                /*
                 * media_type
                 *   : IDENT
                 *   ;
                 */
                return this._media_feature();
            },

            /**
             * Note: in CSS3 Media Queries, this is called "expression".
             * Renamed here to avoid conflict with CSS3 Selectors
             * definition of "expression". Also note that "expr" in the
             * grammar now maps to "expression" from CSS3 selectors.
             * @method _media_expression
             * @private
             */
            _media_expression: function(){
                /*
                 * expression
                 *  : '(' S* media_feature S* [ ':' S* expr ]? ')' S*
                 *  ;
                 */
                var tokenStream = this._tokenStream,
                    feature     = null,
                    token,
                    expression  = null;

                tokenStream.mustMatch(Tokens.LPAREN);

                feature = this._media_feature();
                this._readWhitespace();

                if (tokenStream.match(Tokens.COLON)){
                    this._readWhitespace();
                    token = tokenStream.LT(1);
                    expression = this._expression();
                }

                tokenStream.mustMatch(Tokens.RPAREN);
                this._readWhitespace();

                return new MediaFeature(feature, (expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null));
            },

            //CSS3 Media Queries
            _media_feature: function(){
                /*
                 * media_feature
                 *   : IDENT
                 *   ;
                 */
                var tokenStream = this._tokenStream;

                this._readWhitespace();

                tokenStream.mustMatch(Tokens.IDENT);

                return SyntaxUnit.fromToken(tokenStream.token());
            },

            //CSS3 Paged Media
            _page: function(){
                /*
                 * page:
                 *    PAGE_SYM S* IDENT? pseudo_page? S*
                 *    '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*
                 *    ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    identifier  = null,
                    pseudoPage  = null;

                //look for @page
                tokenStream.mustMatch(Tokens.PAGE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                if (tokenStream.match(Tokens.IDENT)){
                    identifier = tokenStream.token().value;

                    //The value 'auto' may not be used as a page name and MUST be treated as a syntax error.
                    if (identifier.toLowerCase() === "auto"){
                        this._unexpectedToken(tokenStream.token());
                    }
                }

                //see if there's a colon upcoming
                if (tokenStream.peek() === Tokens.COLON){
                    pseudoPage = this._pseudo_page();
                }

                this._readWhitespace();

                this.fire({
                    type:   "startpage",
                    id:     identifier,
                    pseudo: pseudoPage,
                    line:   line,
                    col:    col
                });

                this._readDeclarations(true, true);

                this.fire({
                    type:   "endpage",
                    id:     identifier,
                    pseudo: pseudoPage,
                    line:   line,
                    col:    col
                });

            },

            //CSS3 Paged Media
            _margin: function(){
                /*
                 * margin :
                 *    margin_sym S* '{' declaration [ ';' S* declaration? ]* '}' S*
                 *    ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    marginSym   = this._margin_sym();

                if (marginSym){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this.fire({
                        type: "startpagemargin",
                        margin: marginSym,
                        line:   line,
                        col:    col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type: "endpagemargin",
                        margin: marginSym,
                        line:   line,
                        col:    col
                    });
                    return true;
                } else {
                    return false;
                }
            },

            //CSS3 Paged Media
            _margin_sym: function(){

                /*
                 * margin_sym :
                 *    TOPLEFTCORNER_SYM |
                 *    TOPLEFT_SYM |
                 *    TOPCENTER_SYM |
                 *    TOPRIGHT_SYM |
                 *    TOPRIGHTCORNER_SYM |
                 *    BOTTOMLEFTCORNER_SYM |
                 *    BOTTOMLEFT_SYM |
                 *    BOTTOMCENTER_SYM |
                 *    BOTTOMRIGHT_SYM |
                 *    BOTTOMRIGHTCORNER_SYM |
                 *    LEFTTOP_SYM |
                 *    LEFTMIDDLE_SYM |
                 *    LEFTBOTTOM_SYM |
                 *    RIGHTTOP_SYM |
                 *    RIGHTMIDDLE_SYM |
                 *    RIGHTBOTTOM_SYM
                 *    ;
                 */

                var tokenStream = this._tokenStream;

                if(tokenStream.match([Tokens.TOPLEFTCORNER_SYM, Tokens.TOPLEFT_SYM,
                        Tokens.TOPCENTER_SYM, Tokens.TOPRIGHT_SYM, Tokens.TOPRIGHTCORNER_SYM,
                        Tokens.BOTTOMLEFTCORNER_SYM, Tokens.BOTTOMLEFT_SYM,
                        Tokens.BOTTOMCENTER_SYM, Tokens.BOTTOMRIGHT_SYM,
                        Tokens.BOTTOMRIGHTCORNER_SYM, Tokens.LEFTTOP_SYM,
                        Tokens.LEFTMIDDLE_SYM, Tokens.LEFTBOTTOM_SYM, Tokens.RIGHTTOP_SYM,
                        Tokens.RIGHTMIDDLE_SYM, Tokens.RIGHTBOTTOM_SYM]))
                {
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else {
                    return null;
                }

            },

            _pseudo_page: function(){
                /*
                 * pseudo_page
                 *   : ':' IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream;

                tokenStream.mustMatch(Tokens.COLON);
                tokenStream.mustMatch(Tokens.IDENT);

                //TODO: CSS3 Paged Media says only "left", "center", and "right" are allowed

                return tokenStream.token().value;
            },

            _font_face: function(){
                /*
                 * font_face
                 *   : FONT_FACE_SYM S*
                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col;

                //look for @page
                tokenStream.mustMatch(Tokens.FONT_FACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                this.fire({
                    type:   "startfontface",
                    line:   line,
                    col:    col
                });

                this._readDeclarations(true);

                this.fire({
                    type:   "endfontface",
                    line:   line,
                    col:    col
                });
            },

            _viewport: function(){
                /*
                 * viewport
                 *   : VIEWPORT_SYM S*
                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*
                 *   ;
                 */
                 var tokenStream = this._tokenStream,
                    line,
                    col;

                    tokenStream.mustMatch(Tokens.VIEWPORT_SYM);
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this._readWhitespace();

                    this.fire({
                        type:   "startviewport",
                        line:   line,
                        col:    col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type:   "endviewport",
                        line:   line,
                        col:    col
                    });

            },

            _document: function(){
                /*
                 * document
                 *   : DOCUMENT_SYM S*
                 *     _document_function [ ',' S* _document_function ]* S*
                 *     '{' S* ruleset* '}'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token,
                    functions = [],
                    prefix = "";

                tokenStream.mustMatch(Tokens.DOCUMENT_SYM);
                token = tokenStream.token();
                if (/^@\-([^\-]+)\-/.test(token.value)) {
                    prefix = RegExp.$1;
                }

                this._readWhitespace();
                functions.push(this._document_function());

                while(tokenStream.match(Tokens.COMMA)) {
                    this._readWhitespace();
                    functions.push(this._document_function());
                }

                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();

                this.fire({
                    type:      "startdocument",
                    functions: functions,
                    prefix:    prefix,
                    line:      token.startLine,
                    col:       token.startCol
                });

                while(true) {
                    if (tokenStream.peek() === Tokens.PAGE_SYM){
                        this._page();
                    } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM){
                        this._font_face();
                    } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM){
                        this._viewport();
                    } else if (tokenStream.peek() === Tokens.MEDIA_SYM){
                        this._media();
                    } else if (!this._ruleset()){
                        break;
                    }
                }

                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();

                this.fire({
                    type:      "enddocument",
                    functions: functions,
                    prefix:    prefix,
                    line:      token.startLine,
                    col:       token.startCol
                });
            },

            _document_function: function(){
                /*
                 * document_function
                 *   : function | URI S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value;

                if (tokenStream.match(Tokens.URI)) {
                    value = tokenStream.token().value;
                    this._readWhitespace();
                } else {
                    value = this._function();
                }

                return value;
            },

            _operator: function(inFunction){

                /*
                 * operator (outside function)
                 *  : '/' S* | ',' S* | /( empty )/
                 * operator (inside function)
                 *  : '/' S* | '+' S* | '*' S* | '-' S* /( empty )/
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                    token       = null;

                if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) ||
                    (inFunction && tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS]))){
                    token =  tokenStream.token();
                    this._readWhitespace();
                }
                return token ? PropertyValuePart.fromToken(token) : null;

            },

            _combinator: function(){

                /*
                 * combinator
                 *  : PLUS S* | GREATER S* | TILDE S* | S+
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                    value       = null,
                    token;

                if(tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])){
                    token = tokenStream.token();
                    value = new Combinator(token.value, token.startLine, token.startCol);
                    this._readWhitespace();
                }

                return value;
            },

            _unary_operator: function(){

                /*
                 * unary_operator
                 *  : '-' | '+'
                 *  ;
                 */

                var tokenStream = this._tokenStream;

                if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])){
                    return tokenStream.token().value;
                } else {
                    return null;
                }
            },

            _property: function(){

                /*
                 * property
                 *   : IDENT S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value       = null,
                    hack        = null,
                    tokenValue,
                    token,
                    line,
                    col;

                //check for star hack - throws error if not allowed
                if (tokenStream.peek() === Tokens.STAR && this.options.starHack){
                    tokenStream.get();
                    token = tokenStream.token();
                    hack = token.value;
                    line = token.startLine;
                    col = token.startCol;
                }

                if(tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();
                    tokenValue = token.value;

                    //check for underscore hack - no error if not allowed because it's valid CSS syntax
                    if (tokenValue.charAt(0) === "_" && this.options.underscoreHack){
                        hack = "_";
                        tokenValue = tokenValue.substring(1);
                    }

                    value = new PropertyName(tokenValue, hack, (line||token.startLine), (col||token.startCol));
                    this._readWhitespace();
                }

                return value;
            },

            //Augmented with CSS3 Selectors
            _ruleset: function(){
                /*
                 * ruleset
                 *   : selectors_group
                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    tt,
                    selectors;


                /*
                 * Error Recovery: If even a single selector fails to parse,
                 * then the entire ruleset should be thrown away.
                 */
                try {
                    selectors = this._selectors_group();
                } catch (ex){
                    if (ex instanceof SyntaxError && !this.options.strict){

                        //fire error event
                        this.fire({
                            type:       "error",
                            error:      ex,
                            message:    ex.message,
                            line:       ex.line,
                            col:        ex.col
                        });

                        //skip over everything until closing brace
                        tt = tokenStream.advance([Tokens.RBRACE]);
                        if (tt === Tokens.RBRACE){
                            //if there's a right brace, the rule is finished so don't do anything
                        } else {
                            //otherwise, rethrow the error because it wasn't handled properly
                            throw ex;
                        }

                    } else {
                        //not a syntax error, rethrow it
                        throw ex;
                    }

                    //trigger parser to continue
                    return true;
                }

                //if it got here, all selectors parsed
                if (selectors){

                    this.fire({
                        type:       "startrule",
                        selectors:  selectors,
                        line:       selectors[0].line,
                        col:        selectors[0].col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type:       "endrule",
                        selectors:  selectors,
                        line:       selectors[0].line,
                        col:        selectors[0].col
                    });

                }

                return selectors;

            },

            //CSS3 Selectors
            _selectors_group: function(){

                /*
                 * selectors_group
                 *   : selector [ COMMA S* selector ]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    selectors   = [],
                    selector;

                selector = this._selector();
                if (selector !== null){

                    selectors.push(selector);
                    while(tokenStream.match(Tokens.COMMA)){
                        this._readWhitespace();
                        selector = this._selector();
                        if (selector !== null){
                            selectors.push(selector);
                        } else {
                            this._unexpectedToken(tokenStream.LT(1));
                        }
                    }
                }

                return selectors.length ? selectors : null;
            },

            //CSS3 Selectors
            _selector: function(){
                /*
                 * selector
                 *   : simple_selector_sequence [ combinator simple_selector_sequence ]*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    selector    = [],
                    nextSelector = null,
                    combinator  = null,
                    ws          = null;

                //if there's no simple selector, then there's no selector
                nextSelector = this._simple_selector_sequence();
                if (nextSelector === null){
                    return null;
                }

                selector.push(nextSelector);

                do {

                    //look for a combinator
                    combinator = this._combinator();

                    if (combinator !== null){
                        selector.push(combinator);
                        nextSelector = this._simple_selector_sequence();

                        //there must be a next selector
                        if (nextSelector === null){
                            this._unexpectedToken(tokenStream.LT(1));
                        } else {

                            //nextSelector is an instance of SelectorPart
                            selector.push(nextSelector);
                        }
                    } else {

                        //if there's not whitespace, we're done
                        if (this._readWhitespace()){

                            //add whitespace separator
                            ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);

                            //combinator is not required
                            combinator = this._combinator();

                            //selector is required if there's a combinator
                            nextSelector = this._simple_selector_sequence();
                            if (nextSelector === null){
                                if (combinator !== null){
                                    this._unexpectedToken(tokenStream.LT(1));
                                }
                            } else {

                                if (combinator !== null){
                                    selector.push(combinator);
                                } else {
                                    selector.push(ws);
                                }

                                selector.push(nextSelector);
                            }
                        } else {
                            break;
                        }

                    }
                } while(true);

                return new Selector(selector, selector[0].line, selector[0].col);
            },

            //CSS3 Selectors
            _simple_selector_sequence: function(){
                /*
                 * simple_selector_sequence
                 *   : [ type_selector | universal ]
                 *     [ HASH | class | attrib | pseudo | negation ]*
                 *   | [ HASH | class | attrib | pseudo | negation ]+
                 *   ;
                 */

                var tokenStream = this._tokenStream,

                    //parts of a simple selector
                    elementName = null,
                    modifiers   = [],

                    //complete selector text
                    selectorText= "",

                    //the different parts after the element name to search for
                    components  = [
                        //HASH
                        function(){
                            return tokenStream.match(Tokens.HASH) ?
                                    new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) :
                                    null;
                        },
                        this._class,
                        this._attrib,
                        this._pseudo,
                        this._negation
                    ],
                    i           = 0,
                    len         = components.length,
                    component   = null,
                    line,
                    col;


                //get starting line and column for the selector
                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;

                elementName = this._type_selector();
                if (!elementName){
                    elementName = this._universal();
                }

                if (elementName !== null){
                    selectorText += elementName;
                }

                while(true){

                    //whitespace means we're done
                    if (tokenStream.peek() === Tokens.S){
                        break;
                    }

                    //check for each component
                    while(i < len && component === null){
                        component = components[i++].call(this);
                    }

                    if (component === null){

                        //we don't have a selector
                        if (selectorText === ""){
                            return null;
                        } else {
                            break;
                        }
                    } else {
                        i = 0;
                        modifiers.push(component);
                        selectorText += component.toString();
                        component = null;
                    }
                }


                return selectorText !== "" ?
                        new SelectorPart(elementName, modifiers, selectorText, line, col) :
                        null;
            },

            //CSS3 Selectors
            _type_selector: function(){
                /*
                 * type_selector
                 *   : [ namespace_prefix ]? element_name
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    ns          = this._namespace_prefix(),
                    elementName = this._element_name();

                if (!elementName){
                    /*
                     * Need to back out the namespace that was read due to both
                     * type_selector and universal reading namespace_prefix
                     * first. Kind of hacky, but only way I can figure out
                     * right now how to not change the grammar.
                     */
                    if (ns){
                        tokenStream.unget();
                        if (ns.length > 1){
                            tokenStream.unget();
                        }
                    }

                    return null;
                } else {
                    if (ns){
                        elementName.text = ns + elementName.text;
                        elementName.col -= ns.length;
                    }
                    return elementName;
                }
            },

            //CSS3 Selectors
            _class: function(){
                /*
                 * class
                 *   : '.' IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.DOT)){
                    tokenStream.mustMatch(Tokens.IDENT);
                    token = tokenStream.token();
                    return new SelectorSubPart("." + token.value, "class", token.startLine, token.startCol - 1);
                } else {
                    return null;
                }

            },

            //CSS3 Selectors
            _element_name: function(){
                /*
                 * element_name
                 *   : IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();
                    return new SelectorSubPart(token.value, "elementName", token.startLine, token.startCol);

                } else {
                    return null;
                }
            },

            //CSS3 Selectors
            _namespace_prefix: function(){
                /*
                 * namespace_prefix
                 *   : [ IDENT | '*' ]? '|'
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    value       = "";

                //verify that this is a namespace prefix
                if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE){

                    if(tokenStream.match([Tokens.IDENT, Tokens.STAR])){
                        value += tokenStream.token().value;
                    }

                    tokenStream.mustMatch(Tokens.PIPE);
                    value += "|";

                }

                return value.length ? value : null;
            },

            //CSS3 Selectors
            _universal: function(){
                /*
                 * universal
                 *   : [ namespace_prefix ]? '*'
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    value       = "",
                    ns;

                ns = this._namespace_prefix();
                if(ns){
                    value += ns;
                }

                if(tokenStream.match(Tokens.STAR)){
                    value += "*";
                }

                return value.length ? value : null;

           },

            //CSS3 Selectors
            _attrib: function(){
                /*
                 * attrib
                 *   : '[' S* [ namespace_prefix ]? IDENT S*
                 *         [ [ PREFIXMATCH |
                 *             SUFFIXMATCH |
                 *             SUBSTRINGMATCH |
                 *             '=' |
                 *             INCLUDES |
                 *             DASHMATCH ] S* [ IDENT | STRING ] S*
                 *         ]? ']'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value       = null,
                    ns,
                    token;

                if (tokenStream.match(Tokens.LBRACKET)){
                    token = tokenStream.token();
                    value = token.value;
                    value += this._readWhitespace();

                    ns = this._namespace_prefix();

                    if (ns){
                        value += ns;
                    }

                    tokenStream.mustMatch(Tokens.IDENT);
                    value += tokenStream.token().value;
                    value += this._readWhitespace();

                    if(tokenStream.match([Tokens.PREFIXMATCH, Tokens.SUFFIXMATCH, Tokens.SUBSTRINGMATCH,
                            Tokens.EQUALS, Tokens.INCLUDES, Tokens.DASHMATCH])){

                        value += tokenStream.token().value;
                        value += this._readWhitespace();

                        tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                        value += tokenStream.token().value;
                        value += this._readWhitespace();
                    }

                    tokenStream.mustMatch(Tokens.RBRACKET);

                    return new SelectorSubPart(value + "]", "attribute", token.startLine, token.startCol);
                } else {
                    return null;
                }
            },

            //CSS3 Selectors
            _pseudo: function(){

                /*
                 * pseudo
                 *   : ':' ':'? [ IDENT | functional_pseudo ]
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    pseudo      = null,
                    colons      = ":",
                    line,
                    col;

                if (tokenStream.match(Tokens.COLON)){

                    if (tokenStream.match(Tokens.COLON)){
                        colons += ":";
                    }

                    if (tokenStream.match(Tokens.IDENT)){
                        pseudo = tokenStream.token().value;
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol - colons.length;
                    } else if (tokenStream.peek() === Tokens.FUNCTION){
                        line = tokenStream.LT(1).startLine;
                        col = tokenStream.LT(1).startCol - colons.length;
                        pseudo = this._functional_pseudo();
                    }

                    if (pseudo){
                        pseudo = new SelectorSubPart(colons + pseudo, "pseudo", line, col);
                    }
                }

                return pseudo;
            },

            //CSS3 Selectors
            _functional_pseudo: function(){
                /*
                 * functional_pseudo
                 *   : FUNCTION S* expression ')'
                 *   ;
                */

                var tokenStream = this._tokenStream,
                    value = null;

                if(tokenStream.match(Tokens.FUNCTION)){
                    value = tokenStream.token().value;
                    value += this._readWhitespace();
                    value += this._expression();
                    tokenStream.mustMatch(Tokens.RPAREN);
                    value += ")";
                }

                return value;
            },

            //CSS3 Selectors
            _expression: function(){
                /*
                 * expression
                 *   : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value       = "";

                while(tokenStream.match([Tokens.PLUS, Tokens.MINUS, Tokens.DIMENSION,
                        Tokens.NUMBER, Tokens.STRING, Tokens.IDENT, Tokens.LENGTH,
                        Tokens.FREQ, Tokens.ANGLE, Tokens.TIME,
                        Tokens.RESOLUTION, Tokens.SLASH])){

                    value += tokenStream.token().value;
                    value += this._readWhitespace();
                }

                return value.length ? value : null;

            },

            //CSS3 Selectors
            _negation: function(){
                /*
                 * negation
                 *   : NOT S* negation_arg S* ')'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    value       = "",
                    arg,
                    subpart     = null;

                if (tokenStream.match(Tokens.NOT)){
                    value = tokenStream.token().value;
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                    value += this._readWhitespace();
                    arg = this._negation_arg();
                    value += arg;
                    value += this._readWhitespace();
                    tokenStream.match(Tokens.RPAREN);
                    value += tokenStream.token().value;

                    subpart = new SelectorSubPart(value, "not", line, col);
                    subpart.args.push(arg);
                }

                return subpart;
            },

            //CSS3 Selectors
            _negation_arg: function(){
                /*
                 * negation_arg
                 *   : type_selector | universal | HASH | class | attrib | pseudo
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    args        = [
                        this._type_selector,
                        this._universal,
                        function(){
                            return tokenStream.match(Tokens.HASH) ?
                                    new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) :
                                    null;
                        },
                        this._class,
                        this._attrib,
                        this._pseudo
                    ],
                    arg         = null,
                    i           = 0,
                    len         = args.length,
                    line,
                    col,
                    part;

                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;

                while(i < len && arg === null){

                    arg = args[i].call(this);
                    i++;
                }

                //must be a negation arg
                if (arg === null){
                    this._unexpectedToken(tokenStream.LT(1));
                }

                //it's an element name
                if (arg.type === "elementName"){
                    part = new SelectorPart(arg, [], arg.toString(), line, col);
                } else {
                    part = new SelectorPart(null, [arg], arg.toString(), line, col);
                }

                return part;
            },

            _declaration: function(){

                /*
                 * declaration
                 *   : property ':' S* expr prio?
                 *   | /( empty )/
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    property    = null,
                    expr        = null,
                    prio        = null,
                    invalid     = null,
                    propertyName= "";

                property = this._property();
                if (property !== null){

                    tokenStream.mustMatch(Tokens.COLON);
                    this._readWhitespace();

                    expr = this._expr();

                    //if there's no parts for the value, it's an error
                    if (!expr || expr.length === 0){
                        this._unexpectedToken(tokenStream.LT(1));
                    }

                    prio = this._prio();

                    /*
                     * If hacks should be allowed, then only check the root
                     * property. If hacks should not be allowed, treat
                     * _property or *property as invalid properties.
                     */
                    propertyName = property.toString();
                    if (this.options.starHack && property.hack === "*" ||
                            this.options.underscoreHack && property.hack === "_") {

                        propertyName = property.text;
                    }

                    try {
                        this._validateProperty(propertyName, expr);
                    } catch (ex) {
                        invalid = ex;
                    }

                    this.fire({
                        type:       "property",
                        property:   property,
                        value:      expr,
                        important:  prio,
                        line:       property.line,
                        col:        property.col,
                        invalid:    invalid
                    });

                    return true;
                } else {
                    return false;
                }
            },

            _prio: function(){
                /*
                 * prio
                 *   : IMPORTANT_SYM S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    result      = tokenStream.match(Tokens.IMPORTANT_SYM);

                this._readWhitespace();
                return result;
            },

            _expr: function(inFunction){
                /*
                 * expr
                 *   : term [ operator term ]*
                 *   ;
                 */

                var values      = [],
					//valueParts	= [],
                    value       = null,
                    operator    = null;

                value = this._term(inFunction);
                if (value !== null){

                    values.push(value);

                    do {
                        operator = this._operator(inFunction);

                        //if there's an operator, keep building up the value parts
                        if (operator){
                            values.push(operator);
                        } /*else {
                            //if there's not an operator, you have a full value
							values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
							valueParts = [];
						}*/

                        value = this._term(inFunction);

                        if (value === null){
                            break;
                        } else {
                            values.push(value);
                        }
                    } while(true);
                }

				//cleanup
                /*if (valueParts.length){
                    values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
                }*/

                return values.length > 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;
            },

            _term: function(inFunction){

                /*
                 * term
                 *   : unary_operator?
                 *     [ NUMBER S* | PERCENTAGE S* | LENGTH S* | ANGLE S* |
                 *       TIME S* | FREQ S* | function | ie_function ]
                 *   | STRING S* | IDENT S* | URI S* | UNICODERANGE S* | hexcolor
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    unary       = null,
                    value       = null,
                    endChar     = null,
                    token,
                    line,
                    col;

                //returns the operator or null
                unary = this._unary_operator();
                if (unary !== null){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                }

                //exception for IE filters
                if (tokenStream.peek() === Tokens.IE_FUNCTION && this.options.ieFilters){

                    value = this._ie_function();
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }

                //see if it's a simple block
                } else if (inFunction && tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])){

                    token = tokenStream.token();
                    endChar = token.endChar;
                    value = token.value + this._expr(inFunction).text;
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                    tokenStream.mustMatch(Tokens.type(endChar));
                    value += endChar;
                    this._readWhitespace();

                //see if there's a simple match
                } else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,
                        Tokens.ANGLE, Tokens.TIME,
                        Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])){

                    value = tokenStream.token().value;
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                    this._readWhitespace();
                } else {

                    //see if it's a color
                    token = this._hexcolor();
                    if (token === null){

                        //if there's no unary, get the start of the next token for line/col info
                        if (unary === null){
                            line = tokenStream.LT(1).startLine;
                            col = tokenStream.LT(1).startCol;
                        }

                        //has to be a function
                        if (value === null){

                            /*
                             * This checks for alpha(opacity=0) style of IE
                             * functions. IE_FUNCTION only presents progid: style.
                             */
                            if (tokenStream.LA(3) === Tokens.EQUALS && this.options.ieFilters){
                                value = this._ie_function();
                            } else {
                                value = this._function();
                            }
                        }

                        /*if (value === null){
                            return null;
                            //throw new Error("Expected identifier at line " + tokenStream.token().startLine + ", character " +  tokenStream.token().startCol + ".");
                        }*/

                    } else {
                        value = token.value;
                        if (unary === null){
                            line = token.startLine;
                            col = token.startCol;
                        }
                    }

                }

                return value !== null ?
                        new PropertyValuePart(unary !== null ? unary + value : value, line, col) :
                        null;

            },

            _function: function(){

                /*
                 * function
                 *   : FUNCTION S* expr ')' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    functionText = null,
                    expr        = null,
                    lt;

                if (tokenStream.match(Tokens.FUNCTION)){
                    functionText = tokenStream.token().value;
                    this._readWhitespace();
                    expr = this._expr(true);
                    functionText += expr;

                    //START: Horrible hack in case it's an IE filter
                    if (this.options.ieFilters && tokenStream.peek() === Tokens.EQUALS){
                        do {

                            if (this._readWhitespace()){
                                functionText += tokenStream.token().value;
                            }

                            //might be second time in the loop
                            if (tokenStream.LA(0) === Tokens.COMMA){
                                functionText += tokenStream.token().value;
                            }

                            tokenStream.match(Tokens.IDENT);
                            functionText += tokenStream.token().value;

                            tokenStream.match(Tokens.EQUALS);
                            functionText += tokenStream.token().value;

                            //functionText += this._term();
                            lt = tokenStream.peek();
                            while(lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN){
                                tokenStream.get();
                                functionText += tokenStream.token().value;
                                lt = tokenStream.peek();
                            }
                        } while(tokenStream.match([Tokens.COMMA, Tokens.S]));
                    }

                    //END: Horrible Hack

                    tokenStream.match(Tokens.RPAREN);
                    functionText += ")";
                    this._readWhitespace();
                }

                return functionText;
            },

            _ie_function: function(){

                /* (My own extension)
                 * ie_function
                 *   : IE_FUNCTION S* IDENT '=' term [S* ','? IDENT '=' term]+ ')' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    functionText = null,
                    lt;

                //IE function can begin like a regular function, too
                if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])){
                    functionText = tokenStream.token().value;

                    do {

                        if (this._readWhitespace()){
                            functionText += tokenStream.token().value;
                        }

                        //might be second time in the loop
                        if (tokenStream.LA(0) === Tokens.COMMA){
                            functionText += tokenStream.token().value;
                        }

                        tokenStream.match(Tokens.IDENT);
                        functionText += tokenStream.token().value;

                        tokenStream.match(Tokens.EQUALS);
                        functionText += tokenStream.token().value;

                        //functionText += this._term();
                        lt = tokenStream.peek();
                        while(lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN){
                            tokenStream.get();
                            functionText += tokenStream.token().value;
                            lt = tokenStream.peek();
                        }
                    } while(tokenStream.match([Tokens.COMMA, Tokens.S]));

                    tokenStream.match(Tokens.RPAREN);
                    functionText += ")";
                    this._readWhitespace();
                }

                return functionText;
            },

            _hexcolor: function(){
                /*
                 * There is a constraint on the color that it must
                 * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])
                 * after the "#"; e.g., "#000" is OK, but "#abcd" is not.
                 *
                 * hexcolor
                 *   : HASH S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token = null,
                    color;

                if(tokenStream.match(Tokens.HASH)){

                    //need to do some validation here

                    token = tokenStream.token();
                    color = token.value;
                    if (!/#[a-f0-9]{3,6}/i.test(color)){
                        throw new SyntaxError("Expected a hex color but found '" + color + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
                    }
                    this._readWhitespace();
                }

                return token;
            },

            //-----------------------------------------------------------------
            // Animations methods
            //-----------------------------------------------------------------

            _keyframes: function(){

                /*
                 * keyframes:
                 *   : KEYFRAMES_SYM S* keyframe_name S* '{' S* keyframe_rule* '}' {
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    token,
                    tt,
                    name,
                    prefix = "";

                tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);
                token = tokenStream.token();
                if (/^@\-([^\-]+)\-/.test(token.value)) {
                    prefix = RegExp.$1;
                }

                this._readWhitespace();
                name = this._keyframe_name();

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.LBRACE);

                this.fire({
                    type:   "startkeyframes",
                    name:   name,
                    prefix: prefix,
                    line:   token.startLine,
                    col:    token.startCol
                });

                this._readWhitespace();
                tt = tokenStream.peek();

                //check for key
                while(tt === Tokens.IDENT || tt === Tokens.PERCENTAGE) {
                    this._keyframe_rule();
                    this._readWhitespace();
                    tt = tokenStream.peek();
                }

                this.fire({
                    type:   "endkeyframes",
                    name:   name,
                    prefix: prefix,
                    line:   token.startLine,
                    col:    token.startCol
                });

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.RBRACE);

            },

            _keyframe_name: function(){

                /*
                 * keyframe_name:
                 *   : IDENT
                 *   | STRING
                 *   ;
                 */
                var tokenStream = this._tokenStream;

                tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                return SyntaxUnit.fromToken(tokenStream.token());
            },

            _keyframe_rule: function(){

                /*
                 * keyframe_rule:
                 *   : key_list S*
                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*
                 *   ;
                 */
                var keyList = this._key_list();

                this.fire({
                    type:   "startkeyframerule",
                    keys:   keyList,
                    line:   keyList[0].line,
                    col:    keyList[0].col
                });

                this._readDeclarations(true);

                this.fire({
                    type:   "endkeyframerule",
                    keys:   keyList,
                    line:   keyList[0].line,
                    col:    keyList[0].col
                });

            },

            _key_list: function(){

                /*
                 * key_list:
                 *   : key [ S* ',' S* key]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    keyList = [];

                //must be least one key
                keyList.push(this._key());

                this._readWhitespace();

                while(tokenStream.match(Tokens.COMMA)){
                    this._readWhitespace();
                    keyList.push(this._key());
                    this._readWhitespace();
                }

                return keyList;
            },

            _key: function(){
                /*
                 * There is a restriction that IDENT can be only "from" or "to".
                 *
                 * key
                 *   : PERCENTAGE
                 *   | IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.PERCENTAGE)){
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else if (tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();

                    if (/from|to/i.test(token.value)){
                        return SyntaxUnit.fromToken(token);
                    }

                    tokenStream.unget();
                }

                //if it gets here, there wasn't a valid token, so time to explode
                this._unexpectedToken(tokenStream.LT(1));
            },

            //-----------------------------------------------------------------
            // Helper methods
            //-----------------------------------------------------------------

            /**
             * Not part of CSS grammar, but useful for skipping over
             * combination of white space and HTML-style comments.
             * @return {void}
             * @method _skipCruft
             * @private
             */
            _skipCruft: function(){
                while(this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])){
                    //noop
                }
            },

            /**
             * Not part of CSS grammar, but this pattern occurs frequently
             * in the official CSS grammar. Split out here to eliminate
             * duplicate code.
             * @param {Boolean} checkStart Indicates if the rule should check
             *      for the left brace at the beginning.
             * @param {Boolean} readMargins Indicates if the rule should check
             *      for margin patterns.
             * @return {void}
             * @method _readDeclarations
             * @private
             */
            _readDeclarations: function(checkStart, readMargins){
                /*
                 * Reads the pattern
                 * S* '{' S* declaration [ ';' S* declaration ]* '}' S*
                 * or
                 * S* '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*
                 * Note that this is how it is described in CSS3 Paged Media, but is actually incorrect.
                 * A semicolon is only necessary following a declaration if there's another declaration
                 * or margin afterwards.
                 */
                var tokenStream = this._tokenStream,
                    tt;


                this._readWhitespace();

                if (checkStart){
                    tokenStream.mustMatch(Tokens.LBRACE);
                }

                this._readWhitespace();

                try {

                    while(true){

                        if (tokenStream.match(Tokens.SEMICOLON) || (readMargins && this._margin())){
                            //noop
                        } else if (this._declaration()){
                            if (!tokenStream.match(Tokens.SEMICOLON)){
                                break;
                            }
                        } else {
                            break;
                        }

                        //if ((!this._margin() && !this._declaration()) || !tokenStream.match(Tokens.SEMICOLON)){
                        //    break;
                        //}
                        this._readWhitespace();
                    }

                    tokenStream.mustMatch(Tokens.RBRACE);
                    this._readWhitespace();

                } catch (ex) {
                    if (ex instanceof SyntaxError && !this.options.strict){

                        //fire error event
                        this.fire({
                            type:       "error",
                            error:      ex,
                            message:    ex.message,
                            line:       ex.line,
                            col:        ex.col
                        });

                        //see if there's another declaration
                        tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);
                        if (tt === Tokens.SEMICOLON){
                            //if there's a semicolon, then there might be another declaration
                            this._readDeclarations(false, readMargins);
                        } else if (tt !== Tokens.RBRACE){
                            //if there's a right brace, the rule is finished so don't do anything
                            //otherwise, rethrow the error because it wasn't handled properly
                            throw ex;
                        }

                    } else {
                        //not a syntax error, rethrow it
                        throw ex;
                    }
                }

            },

            /**
             * In some cases, you can end up with two white space tokens in a
             * row. Instead of making a change in every function that looks for
             * white space, this function is used to match as much white space
             * as necessary.
             * @method _readWhitespace
             * @return {String} The white space if found, empty string if not.
             * @private
             */
            _readWhitespace: function(){

                var tokenStream = this._tokenStream,
                    ws = "";

                while(tokenStream.match(Tokens.S)){
                    ws += tokenStream.token().value;
                }

                return ws;
            },


            /**
             * Throws an error when an unexpected token is found.
             * @param {Object} token The token that was found.
             * @method _unexpectedToken
             * @return {void}
             * @private
             */
            _unexpectedToken: function(token){
                throw new SyntaxError("Unexpected token '" + token.value + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
            },

            /**
             * Helper method used for parsing subparts of a style sheet.
             * @return {void}
             * @method _verifyEnd
             * @private
             */
            _verifyEnd: function(){
                if (this._tokenStream.LA(1) !== Tokens.EOF){
                    this._unexpectedToken(this._tokenStream.LT(1));
                }
            },

            //-----------------------------------------------------------------
            // Validation methods
            //-----------------------------------------------------------------
            _validateProperty: function(property, value){
                Validation.validate(property, value);
            },

            //-----------------------------------------------------------------
            // Parsing methods
            //-----------------------------------------------------------------

            parse: function(input){
                this._tokenStream = new TokenStream(input, Tokens);
                this._stylesheet();
            },

            parseStyleSheet: function(input){
                //just passthrough
                return this.parse(input);
            },

            parseMediaQuery: function(input){
                this._tokenStream = new TokenStream(input, Tokens);
                var result = this._media_query();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses a property value (everything after the semicolon).
             * @return {parserlib.css.PropertyValue} The property value.
             * @throws parserlib.util.SyntaxError If an unexpected token is found.
             * @method parserPropertyValue
             */
            parsePropertyValue: function(input){

                this._tokenStream = new TokenStream(input, Tokens);
                this._readWhitespace();

                var result = this._expr();

                //okay to have a trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses a complete CSS rule, including selectors and
             * properties.
             * @param {String} input The text to parser.
             * @return {Boolean} True if the parse completed successfully, false if not.
             * @method parseRule
             */
            parseRule: function(input){
                this._tokenStream = new TokenStream(input, Tokens);

                //skip any leading white space
                this._readWhitespace();

                var result = this._ruleset();

                //skip any trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses a single CSS selector (no comma)
             * @param {String} input The text to parse as a CSS selector.
             * @return {Selector} An object representing the selector.
             * @throws parserlib.util.SyntaxError If an unexpected token is found.
             * @method parseSelector
             */
            parseSelector: function(input){

                this._tokenStream = new TokenStream(input, Tokens);

                //skip any leading white space
                this._readWhitespace();

                var result = this._selector();

                //skip any trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses an HTML style attribute: a set of CSS declarations
             * separated by semicolons.
             * @param {String} input The text to parse as a style attribute
             * @return {void}
             * @method parseStyleAttribute
             */
            parseStyleAttribute: function(input){
                input += "}"; // for error recovery in _readDeclarations()
                this._tokenStream = new TokenStream(input, Tokens);
                this._readDeclarations();
            }
        };

    //copy over onto prototype
    for (prop in additions){
        if (Object.prototype.hasOwnProperty.call(additions, prop)){
            proto[prop] = additions[prop];
        }
    }

    return proto;
}();


/*
nth
  : S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |
         ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*
  ;
*/
var Properties = {
    __proto__: null,

    //A
    "align-items"                   : "flex-start | flex-end | center | baseline | stretch",
    "align-content"                 : "flex-start | flex-end | center | space-between | space-around | stretch",
    "align-self"                    : "auto | flex-start | flex-end | center | baseline | stretch",
    "-webkit-align-items"           : "flex-start | flex-end | center | baseline | stretch",
    "-webkit-align-content"         : "flex-start | flex-end | center | space-between | space-around | stretch",
    "-webkit-align-self"            : "auto | flex-start | flex-end | center | baseline | stretch",
    "alignment-adjust"              : "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>",
    "alignment-baseline"            : "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "animation"                     : 1,
    "animation-delay"               : { multi: "<time>", comma: true },
    "animation-direction"           : { multi: "normal | alternate", comma: true },
    "animation-duration"            : { multi: "<time>", comma: true },
    "animation-fill-mode"           : { multi: "none | forwards | backwards | both", comma: true },
    "animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "animation-name"                : { multi: "none | <ident>", comma: true },
    "animation-play-state"          : { multi: "running | paused", comma: true },
    "animation-timing-function"     : 1,

    //vendor prefixed
    "-moz-animation-delay"               : { multi: "<time>", comma: true },
    "-moz-animation-direction"           : { multi: "normal | alternate", comma: true },
    "-moz-animation-duration"            : { multi: "<time>", comma: true },
    "-moz-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-moz-animation-name"                : { multi: "none | <ident>", comma: true },
    "-moz-animation-play-state"          : { multi: "running | paused", comma: true },

    "-ms-animation-delay"               : { multi: "<time>", comma: true },
    "-ms-animation-direction"           : { multi: "normal | alternate", comma: true },
    "-ms-animation-duration"            : { multi: "<time>", comma: true },
    "-ms-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-ms-animation-name"                : { multi: "none | <ident>", comma: true },
    "-ms-animation-play-state"          : { multi: "running | paused", comma: true },

    "-webkit-animation-delay"               : { multi: "<time>", comma: true },
    "-webkit-animation-direction"           : { multi: "normal | alternate", comma: true },
    "-webkit-animation-duration"            : { multi: "<time>", comma: true },
    "-webkit-animation-fill-mode"           : { multi: "none | forwards | backwards | both", comma: true },
    "-webkit-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-webkit-animation-name"                : { multi: "none | <ident>", comma: true },
    "-webkit-animation-play-state"          : { multi: "running | paused", comma: true },

    "-o-animation-delay"               : { multi: "<time>", comma: true },
    "-o-animation-direction"           : { multi: "normal | alternate", comma: true },
    "-o-animation-duration"            : { multi: "<time>", comma: true },
    "-o-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-o-animation-name"                : { multi: "none | <ident>", comma: true },
    "-o-animation-play-state"          : { multi: "running | paused", comma: true },

    "appearance"                    : "icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal | none | inherit",
    "azimuth"                       : function (expression) {
        var simple      = "<angle> | leftwards | rightwards | inherit",
            direction   = "left-side | far-left | left | center-left | center | center-right | right | far-right | right-side",
            behind      = false,
            valid       = false,
            part;

        if (!ValidationTypes.isAny(expression, simple)) {
            if (ValidationTypes.isAny(expression, "behind")) {
                behind = true;
                valid = true;
            }

            if (ValidationTypes.isAny(expression, direction)) {
                valid = true;
                if (!behind) {
                    ValidationTypes.isAny(expression, "behind");
                }
            }
        }

        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (<'azimuth'>) but found '" + part + "'.", part.line, part.col);
            }
        }
    },

    //B
    "backface-visibility"           : "visible | hidden",
    "background"                    : 1,
    "background-attachment"         : { multi: "<attachment>", comma: true },
    "background-clip"               : { multi: "<box>", comma: true },
    "background-color"              : "<color> | inherit",
    "background-image"              : { multi: "<bg-image>", comma: true },
    "background-origin"             : { multi: "<box>", comma: true },
    "background-position"           : { multi: "<bg-position>", comma: true },
    "background-repeat"             : { multi: "<repeat-style>" },
    "background-size"               : { multi: "<bg-size>", comma: true },
    "baseline-shift"                : "baseline | sub | super | <percentage> | <length>",
    "behavior"                      : 1,
    "binding"                       : 1,
    "bleed"                         : "<length>",
    "bookmark-label"                : "<content> | <attr> | <string>",
    "bookmark-level"                : "none | <integer>",
    "bookmark-state"                : "open | closed",
    "bookmark-target"               : "none | <uri> | <attr>",
    "border"                        : "<border-width> || <border-style> || <color>",
    "border-bottom"                 : "<border-width> || <border-style> || <color>",
    "border-bottom-color"           : "<color> | inherit",
    "border-bottom-left-radius"     :  "<x-one-radius>",
    "border-bottom-right-radius"    :  "<x-one-radius>",
    "border-bottom-style"           : "<border-style>",
    "border-bottom-width"           : "<border-width>",
    "border-collapse"               : "collapse | separate | inherit",
    "border-color"                  : { multi: "<color> | inherit", max: 4 },
    "border-image"                  : 1,
    "border-image-outset"           : { multi: "<length> | <number>", max: 4 },
    "border-image-repeat"           : { multi: "stretch | repeat | round", max: 2 },
    "border-image-slice"            : function(expression) {

        var valid   = false,
            numeric = "<number> | <percentage>",
            fill    = false,
            count   = 0,
            max     = 4,
            part;

        if (ValidationTypes.isAny(expression, "fill")) {
            fill = true;
            valid = true;
        }

        while (expression.hasNext() && count < max) {
            valid = ValidationTypes.isAny(expression, numeric);
            if (!valid) {
                break;
            }
            count++;
        }


        if (!fill) {
            ValidationTypes.isAny(expression, "fill");
        } else {
            valid = true;
        }

        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected ([<number> | <percentage>]{1,4} && fill?) but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "border-image-source"           : "<image> | none",
    "border-image-width"            : { multi: "<length> | <percentage> | <number> | auto", max: 4 },
    "border-left"                   : "<border-width> || <border-style> || <color>",
    "border-left-color"             : "<color> | inherit",
    "border-left-style"             : "<border-style>",
    "border-left-width"             : "<border-width>",
    "border-radius"                 : function(expression) {

        var valid   = false,
            simple = "<length> | <percentage> | inherit",
            slash   = false,
            count   = 0,
            max     = 8,
            part;

        while (expression.hasNext() && count < max) {
            valid = ValidationTypes.isAny(expression, simple);
            if (!valid) {

                if (String(expression.peek()) === "/" && count > 0 && !slash) {
                    slash = true;
                    max = count + 5;
                    expression.next();
                } else {
                    break;
                }
            }
            count++;
        }

        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (<'border-radius'>) but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "border-right"                  : "<border-width> || <border-style> || <color>",
    "border-right-color"            : "<color> | inherit",
    "border-right-style"            : "<border-style>",
    "border-right-width"            : "<border-width>",
    "border-spacing"                : { multi: "<length> | inherit", max: 2 },
    "border-style"                  : { multi: "<border-style>", max: 4 },
    "border-top"                    : "<border-width> || <border-style> || <color>",
    "border-top-color"              : "<color> | inherit",
    "border-top-left-radius"        : "<x-one-radius>",
    "border-top-right-radius"       : "<x-one-radius>",
    "border-top-style"              : "<border-style>",
    "border-top-width"              : "<border-width>",
    "border-width"                  : { multi: "<border-width>", max: 4 },
    "bottom"                        : "<margin-width> | inherit",
    "-moz-box-align"                : "start | end | center | baseline | stretch",
    "-moz-box-decoration-break"     : "slice |clone",
    "-moz-box-direction"            : "normal | reverse | inherit",
    "-moz-box-flex"                 : "<number>",
    "-moz-box-flex-group"           : "<integer>",
    "-moz-box-lines"                : "single | multiple",
    "-moz-box-ordinal-group"        : "<integer>",
    "-moz-box-orient"               : "horizontal | vertical | inline-axis | block-axis | inherit",
    "-moz-box-pack"                 : "start | end | center | justify",
    "-o-box-decoration-break"       : "slice | clone",
    "-webkit-box-align"             : "start | end | center | baseline | stretch",
    "-webkit-box-decoration-break"  : "slice |clone",
    "-webkit-box-direction"         : "normal | reverse | inherit",
    "-webkit-box-flex"              : "<number>",
    "-webkit-box-flex-group"        : "<integer>",
    "-webkit-box-lines"             : "single | multiple",
    "-webkit-box-ordinal-group"     : "<integer>",
    "-webkit-box-orient"            : "horizontal | vertical | inline-axis | block-axis | inherit",
    "-webkit-box-pack"              : "start | end | center | justify",
    "box-decoration-break"          : "slice | clone",
    "box-shadow"                    : function (expression) {
        var part;

        if (!ValidationTypes.isAny(expression, "none")) {
            Validation.multiProperty("<shadow>", expression, true, Infinity);
        } else {
            if (expression.hasNext()) {
                part = expression.next();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "box-sizing"                    : "content-box | border-box | inherit",
    "break-after"                   : "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
    "break-before"                  : "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
    "break-inside"                  : "auto | avoid | avoid-page | avoid-column",

    //C
    "caption-side"                  : "top | bottom | inherit",
    "clear"                         : "none | right | left | both | inherit",
    "clip"                          : 1,
    "color"                         : "<color> | inherit",
    "color-profile"                 : 1,
    "column-count"                  : "<integer> | auto",                      //http://www.w3.org/TR/css3-multicol/
    "column-fill"                   : "auto | balance",
    "column-gap"                    : "<length> | normal",
    "column-rule"                   : "<border-width> || <border-style> || <color>",
    "column-rule-color"             : "<color>",
    "column-rule-style"             : "<border-style>",
    "column-rule-width"             : "<border-width>",
    "column-span"                   : "none | all",
    "column-width"                  : "<length> | auto",
    "columns"                       : 1,
    "content"                       : 1,
    "counter-increment"             : 1,
    "counter-reset"                 : 1,
    "crop"                          : "<shape> | auto",
    "cue"                           : "cue-after | cue-before | inherit",
    "cue-after"                     : 1,
    "cue-before"                    : 1,
    "cursor"                        : 1,

    //D
    "direction"                     : "ltr | rtl | inherit",
    "display"                       : "inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | none | inherit | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex",
    "dominant-baseline"             : 1,
    "drop-initial-after-adjust"     : "central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>",
    "drop-initial-after-align"      : "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "drop-initial-before-adjust"    : "before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>",
    "drop-initial-before-align"     : "caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "drop-initial-size"             : "auto | line | <length> | <percentage>",
    "drop-initial-value"            : "initial | <integer>",

    //E
    "elevation"                     : "<angle> | below | level | above | higher | lower | inherit",
    "empty-cells"                   : "show | hide | inherit",

    //F
    "filter"                        : 1,
    "fit"                           : "fill | hidden | meet | slice",
    "fit-position"                  : 1,
    "flex"                          : "<flex>",
    "flex-basis"                    : "<width>",
    "flex-direction"                : "row | row-reverse | column | column-reverse",
    "flex-flow"                     : "<flex-direction> || <flex-wrap>",
    "flex-grow"                     : "<number>",
    "flex-shrink"                   : "<number>",
    "flex-wrap"                     : "nowrap | wrap | wrap-reverse",
    "-webkit-flex"                  : "<flex>",
    "-webkit-flex-basis"            : "<width>",
    "-webkit-flex-direction"        : "row | row-reverse | column | column-reverse",
    "-webkit-flex-flow"             : "<flex-direction> || <flex-wrap>",
    "-webkit-flex-grow"             : "<number>",
    "-webkit-flex-shrink"           : "<number>",
    "-webkit-flex-wrap"             : "nowrap | wrap | wrap-reverse",
    "-ms-flex"                      : "<flex>",
    "-ms-flex-align"                : "start | end | center | stretch | baseline",
    "-ms-flex-direction"            : "row | row-reverse | column | column-reverse | inherit",
    "-ms-flex-order"                : "<number>",
    "-ms-flex-pack"                 : "start | end | center | justify",
    "-ms-flex-wrap"                 : "nowrap | wrap | wrap-reverse",
    "float"                         : "left | right | none | inherit",
    "float-offset"                  : 1,
    "font"                          : 1,
    "font-family"                   : 1,
    "font-feature-settings"         : "<feature-tag-value> | normal | inherit",
    "font-kerning"                  : "auto | normal | none | initial | inherit | unset",
    "font-size"                     : "<absolute-size> | <relative-size> | <length> | <percentage> | inherit",
    "font-size-adjust"              : "<number> | none | inherit",
    "font-stretch"                  : "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | inherit",
    "font-style"                    : "normal | italic | oblique | inherit",
    "font-variant"                  : "normal | small-caps | inherit",
    "font-variant-caps"             : "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
    "font-variant-position"         : "normal | sub | super | inherit | initial | unset",
    "font-weight"                   : "normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit",

    //G
    "grid"                          : 1,
    "grid-area"                     : 1,
    "grid-auto-columns"             : 1,
    "grid-auto-flow"                : 1,
    "grid-auto-position"            : 1,
    "grid-auto-rows"                : 1,
    "grid-cell-stacking"            : "columns | rows | layer",
    "grid-column"                   : 1,
    "grid-columns"                  : 1,
    "grid-column-align"             : "start | end | center | stretch",
    "grid-column-sizing"            : 1,
    "grid-column-start"             : 1,
    "grid-column-end"               : 1,
    "grid-column-span"              : "<integer>",
    "grid-flow"                     : "none | rows | columns",
    "grid-layer"                    : "<integer>",
    "grid-row"                      : 1,
    "grid-rows"                     : 1,
    "grid-row-align"                : "start | end | center | stretch",
    "grid-row-start"                : 1,
    "grid-row-end"                  : 1,
    "grid-row-span"                 : "<integer>",
    "grid-row-sizing"               : 1,
    "grid-template"                 : 1,
    "grid-template-areas"           : 1,
    "grid-template-columns"         : 1,
    "grid-template-rows"            : 1,

    //H
    "hanging-punctuation"           : 1,
    "height"                        : "<margin-width> | <content-sizing> | inherit",
    "hyphenate-after"               : "<integer> | auto",
    "hyphenate-before"              : "<integer> | auto",
    "hyphenate-character"           : "<string> | auto",
    "hyphenate-lines"               : "no-limit | <integer>",
    "hyphenate-resource"            : 1,
    "hyphens"                       : "none | manual | auto",

    //I
    "icon"                          : 1,
    "image-orientation"             : "angle | auto",
    "image-rendering"               : 1,
    "image-resolution"              : 1,
    "ime-mode"                      : "auto | normal | active | inactive | disabled | inherit",
    "inline-box-align"              : "initial | last | <integer>",

    //J
    "justify-content"               : "flex-start | flex-end | center | space-between | space-around",
    "-webkit-justify-content"       : "flex-start | flex-end | center | space-between | space-around",

    //L
    "left"                          : "<margin-width> | inherit",
    "letter-spacing"                : "<length> | normal | inherit",
    "line-height"                   : "<number> | <length> | <percentage> | normal | inherit",
    "line-break"                    : "auto | loose | normal | strict",
    "line-stacking"                 : 1,
    "line-stacking-ruby"            : "exclude-ruby | include-ruby",
    "line-stacking-shift"           : "consider-shifts | disregard-shifts",
    "line-stacking-strategy"        : "inline-line-height | block-line-height | max-height | grid-height",
    "list-style"                    : 1,
    "list-style-image"              : "<uri> | none | inherit",
    "list-style-position"           : "inside | outside | inherit",
    "list-style-type"               : "disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none | inherit",

    //M
    "margin"                        : { multi: "<margin-width> | inherit", max: 4 },
    "margin-bottom"                 : "<margin-width> | inherit",
    "margin-left"                   : "<margin-width> | inherit",
    "margin-right"                  : "<margin-width> | inherit",
    "margin-top"                    : "<margin-width> | inherit",
    "mark"                          : 1,
    "mark-after"                    : 1,
    "mark-before"                   : 1,
    "marks"                         : 1,
    "marquee-direction"             : 1,
    "marquee-play-count"            : 1,
    "marquee-speed"                 : 1,
    "marquee-style"                 : 1,
    "max-height"                    : "<length> | <percentage> | <content-sizing> | none | inherit",
    "max-width"                     : "<length> | <percentage> | <content-sizing> | none | inherit",
    "min-height"                    : "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit",
    "min-width"                     : "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit",
    "move-to"                       : 1,

    //N
    "nav-down"                      : 1,
    "nav-index"                     : 1,
    "nav-left"                      : 1,
    "nav-right"                     : 1,
    "nav-up"                        : 1,

    //O
    "object-fit"                    : "fill | contain | cover | none | scale-down",
    "object-position"               : "<bg-position>",
    "opacity"                       : "<number> | inherit",
    "order"                         : "<integer>",
    "-webkit-order"                 : "<integer>",
    "orphans"                       : "<integer> | inherit",
    "outline"                       : 1,
    "outline-color"                 : "<color> | invert | inherit",
    "outline-offset"                : 1,
    "outline-style"                 : "<border-style> | inherit",
    "outline-width"                 : "<border-width> | inherit",
    "overflow"                      : "visible | hidden | scroll | auto | inherit",
    "overflow-style"                : 1,
    "overflow-wrap"                 : "normal | break-word",
    "overflow-x"                    : 1,
    "overflow-y"                    : 1,

    //P
    "padding"                       : { multi: "<padding-width> | inherit", max: 4 },
    "padding-bottom"                : "<padding-width> | inherit",
    "padding-left"                  : "<padding-width> | inherit",
    "padding-right"                 : "<padding-width> | inherit",
    "padding-top"                   : "<padding-width> | inherit",
    "page"                          : 1,
    "page-break-after"              : "auto | always | avoid | left | right | inherit",
    "page-break-before"             : "auto | always | avoid | left | right | inherit",
    "page-break-inside"             : "auto | avoid | inherit",
    "page-policy"                   : 1,
    "pause"                         : 1,
    "pause-after"                   : 1,
    "pause-before"                  : 1,
    "perspective"                   : 1,
    "perspective-origin"            : 1,
    "phonemes"                      : 1,
    "pitch"                         : 1,
    "pitch-range"                   : 1,
    "play-during"                   : 1,
    "pointer-events"                : "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
    "position"                      : "static | relative | absolute | fixed | inherit",
    "presentation-level"            : 1,
    "punctuation-trim"              : 1,

    //Q
    "quotes"                        : 1,

    //R
    "rendering-intent"              : 1,
    "resize"                        : 1,
    "rest"                          : 1,
    "rest-after"                    : 1,
    "rest-before"                   : 1,
    "richness"                      : 1,
    "right"                         : "<margin-width> | inherit",
    "rotation"                      : 1,
    "rotation-point"                : 1,
    "ruby-align"                    : 1,
    "ruby-overhang"                 : 1,
    "ruby-position"                 : 1,
    "ruby-span"                     : 1,

    //S
    "size"                          : 1,
    "speak"                         : "normal | none | spell-out | inherit",
    "speak-header"                  : "once | always | inherit",
    "speak-numeral"                 : "digits | continuous | inherit",
    "speak-punctuation"             : "code | none | inherit",
    "speech-rate"                   : 1,
    "src"                           : 1,
    "stress"                        : 1,
    "string-set"                    : 1,

    "table-layout"                  : "auto | fixed | inherit",
    "tab-size"                      : "<integer> | <length>",
    "target"                        : 1,
    "target-name"                   : 1,
    "target-new"                    : 1,
    "target-position"               : 1,
    "text-align"                    : "left | right | center | justify | match-parent | start | end | inherit" ,
    "text-align-last"               : 1,
    "text-decoration"               : 1,
    "text-emphasis"                 : 1,
    "text-height"                   : 1,
    "text-indent"                   : "<length> | <percentage> | inherit",
    "text-justify"                  : "auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida",
    "text-outline"                  : 1,
    "text-overflow"                 : 1,
    "text-rendering"                : "auto | optimizeSpeed | optimizeLegibility | geometricPrecision | inherit",
    "text-shadow"                   : 1,
    "text-transform"                : "capitalize | uppercase | lowercase | none | inherit",
    "text-wrap"                     : "normal | none | avoid",
    "top"                           : "<margin-width> | inherit",
    "-ms-touch-action"              : "auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation",
    "touch-action"                  : "auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation",
    "transform"                     : 1,
    "transform-origin"              : 1,
    "transform-style"               : 1,
    "transition"                    : 1,
    "transition-delay"              : 1,
    "transition-duration"           : 1,
    "transition-property"           : 1,
    "transition-timing-function"    : 1,

    //U
    "unicode-bidi"                  : "normal | embed | isolate | bidi-override | isolate-override | plaintext | inherit",
    "user-modify"                   : "read-only | read-write | write-only | inherit",
    "user-select"                   : "none | text | toggle | element | elements | all | inherit",

    //V
    "vertical-align"                : "auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length> | inherit",
    "visibility"                    : "visible | hidden | collapse | inherit",
    "voice-balance"                 : 1,
    "voice-duration"                : 1,
    "voice-family"                  : 1,
    "voice-pitch"                   : 1,
    "voice-pitch-range"             : 1,
    "voice-rate"                    : 1,
    "voice-stress"                  : 1,
    "voice-volume"                  : 1,
    "volume"                        : 1,

    //W
    "white-space"                   : "normal | pre | nowrap | pre-wrap | pre-line | inherit | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap", //http://perishablepress.com/wrapping-content/
    "white-space-collapse"          : 1,
    "widows"                        : "<integer> | inherit",
    "width"                         : "<length> | <percentage> | <content-sizing> | auto | inherit",
    "will-change"                   : { multi: "<ident>", comma: true },
    "word-break"                    : "normal | keep-all | break-all",
    "word-spacing"                  : "<length> | normal | inherit",
    "word-wrap"                     : "normal | break-word",
    "writing-mode"                  : "horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb | inherit",

    //Z
    "z-index"                       : "<integer> | auto | inherit",
    "zoom"                          : "<number> | <percentage> | normal"
};
/**
 * Represents a selector combinator (whitespace, +, >).
 * @namespace parserlib.css
 * @class PropertyName
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} text The text representation of the unit.
 * @param {String} hack The type of IE hack applied ("*", "_", or null).
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function PropertyName(text, hack, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);

    /**
     * The type of IE hack applied ("*", "_", or null).
     * @type String
     * @property hack
     */
    this.hack = hack;

}

PropertyName.prototype = new SyntaxUnit();
PropertyName.prototype.constructor = PropertyName;
PropertyName.prototype.toString = function(){
    return (this.hack ? this.hack : "") + this.text;
};
/**
 * Represents a single part of a CSS property value, meaning that it represents
 * just everything single part between ":" and ";". If there are multiple values
 * separated by commas, this type represents just one of the values.
 * @param {String[]} parts An array of value parts making up this value.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 * @namespace parserlib.css
 * @class PropertyValue
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 */
function PropertyValue(parts, line, col){

    SyntaxUnit.call(this, parts.join(" "), line, col, Parser.PROPERTY_VALUE_TYPE);

    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;

}

PropertyValue.prototype = new SyntaxUnit();
PropertyValue.prototype.constructor = PropertyValue;

/**
 * A utility class that allows for easy iteration over the various parts of a
 * property value.
 * @param {parserlib.css.PropertyValue} value The property value to iterate over.
 * @namespace parserlib.css
 * @class PropertyValueIterator
 * @constructor
 */
function PropertyValueIterator(value){

    /**
     * Iterator value
     * @type int
     * @property _i
     * @private
     */
    this._i = 0;

    /**
     * The parts that make up the value.
     * @type Array
     * @property _parts
     * @private
     */
    this._parts = value.parts;

    /**
     * Keeps track of bookmarks along the way.
     * @type Array
     * @property _marks
     * @private
     */
    this._marks = [];

    /**
     * Holds the original property value.
     * @type parserlib.css.PropertyValue
     * @property value
     */
    this.value = value;

}

/**
 * Returns the total number of parts in the value.
 * @return {int} The total number of parts in the value.
 * @method count
 */
PropertyValueIterator.prototype.count = function(){
    return this._parts.length;
};

/**
 * Indicates if the iterator is positioned at the first item.
 * @return {Boolean} True if positioned at first item, false if not.
 * @method isFirst
 */
PropertyValueIterator.prototype.isFirst = function(){
    return this._i === 0;
};

/**
 * Indicates if there are more parts of the property value.
 * @return {Boolean} True if there are more parts, false if not.
 * @method hasNext
 */
PropertyValueIterator.prototype.hasNext = function(){
    return (this._i < this._parts.length);
};

/**
 * Marks the current spot in the iteration so it can be restored to
 * later on.
 * @return {void}
 * @method mark
 */
PropertyValueIterator.prototype.mark = function(){
    this._marks.push(this._i);
};

/**
 * Returns the next part of the property value or null if there is no next
 * part. Does not move the internal counter forward.
 * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next
 * part.
 * @method peek
 */
PropertyValueIterator.prototype.peek = function(count){
    return this.hasNext() ? this._parts[this._i + (count || 0)] : null;
};

/**
 * Returns the next part of the property value or null if there is no next
 * part.
 * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next
 * part.
 * @method next
 */
PropertyValueIterator.prototype.next = function(){
    return this.hasNext() ? this._parts[this._i++] : null;
};

/**
 * Returns the previous part of the property value or null if there is no
 * previous part.
 * @return {parserlib.css.PropertyValuePart} The previous part of the
 * property value or null if there is no previous part.
 * @method previous
 */
PropertyValueIterator.prototype.previous = function(){
    return this._i > 0 ? this._parts[--this._i] : null;
};

/**
 * Restores the last saved bookmark.
 * @return {void}
 * @method restore
 */
PropertyValueIterator.prototype.restore = function(){
    if (this._marks.length){
        this._i = this._marks.pop();
    }
};

/**
 * Represents a single part of a CSS property value, meaning that it represents
 * just one part of the data between ":" and ";".
 * @param {String} text The text representation of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 * @namespace parserlib.css
 * @class PropertyValuePart
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 */
function PropertyValuePart(text, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);

    /**
     * Indicates the type of value unit.
     * @type String
     * @property type
     */
    this.type = "unknown";

    //figure out what type of data it is

    var temp;

    //it is a measurement?
    if (/^([+\-]?[\d\.]+)([a-z]+)$/i.test(text)){  //dimension
        this.type = "dimension";
        this.value = +RegExp.$1;
        this.units = RegExp.$2;

        //try to narrow down
        switch(this.units.toLowerCase()){

            case "em":
            case "rem":
            case "ex":
            case "px":
            case "cm":
            case "mm":
            case "in":
            case "pt":
            case "pc":
            case "ch":
            case "vh":
            case "vw":
            case "vmax":
            case "vmin":
                this.type = "length";
                break;
                
            case "fr":
                this.type = "grid";
                break;

            case "deg":
            case "rad":
            case "grad":
                this.type = "angle";
                break;

            case "ms":
            case "s":
                this.type = "time";
                break;

            case "hz":
            case "khz":
                this.type = "frequency";
                break;

            case "dpi":
            case "dpcm":
                this.type = "resolution";
                break;

            //default

        }

    } else if (/^([+\-]?[\d\.]+)%$/i.test(text)){  //percentage
        this.type = "percentage";
        this.value = +RegExp.$1;
    } else if (/^([+\-]?\d+)$/i.test(text)){  //integer
        this.type = "integer";
        this.value = +RegExp.$1;
    } else if (/^([+\-]?[\d\.]+)$/i.test(text)){  //number
        this.type = "number";
        this.value = +RegExp.$1;

    } else if (/^#([a-f0-9]{3,6})/i.test(text)){  //hexcolor
        this.type = "color";
        temp = RegExp.$1;
        if (temp.length === 3){
            this.red    = parseInt(temp.charAt(0)+temp.charAt(0),16);
            this.green  = parseInt(temp.charAt(1)+temp.charAt(1),16);
            this.blue   = parseInt(temp.charAt(2)+temp.charAt(2),16);
        } else {
            this.red    = parseInt(temp.substring(0,2),16);
            this.green  = parseInt(temp.substring(2,4),16);
            this.blue   = parseInt(temp.substring(4,6),16);
        }
    } else if (/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.test(text)){ //rgb() color with absolute numbers
        this.type   = "color";
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
    } else if (/^rgb\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)){ //rgb() color with percentages
        this.type   = "color";
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
    } else if (/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //rgba() color with absolute numbers
        this.type   = "color";
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
        this.alpha  = +RegExp.$4;
    } else if (/^rgba\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //rgba() color with percentages
        this.type   = "color";
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
        this.alpha  = +RegExp.$4;
    } else if (/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)){ //hsl()
        this.type   = "color";
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;
    } else if (/^hsla\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //hsla() color with percentages
        this.type   = "color";
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;
        this.alpha  = +RegExp.$4;
    } else if (/^url\(["']?([^\)"']+)["']?\)/i.test(text)){ //URI
        this.type   = "uri";
        this.uri    = RegExp.$1;
    } else if (/^([^\(]+)\(/i.test(text)){
        this.type   = "function";
        this.name   = RegExp.$1;
        this.value  = text;
    } else if (/^"([^\n\r\f\\"]|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*"/i.test(text)){    //double-quoted string
        this.type   = "string";
        this.value  = PropertyValuePart.parseString(text);
    } else if (/^'([^\n\r\f\\']|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*'/i.test(text)){    //single-quoted string
        this.type   = "string";
        this.value  = PropertyValuePart.parseString(text);
    } else if (Colors[text.toLowerCase()]){  //named color
        this.type   = "color";
        temp        = Colors[text.toLowerCase()].substring(1);
        this.red    = parseInt(temp.substring(0,2),16);
        this.green  = parseInt(temp.substring(2,4),16);
        this.blue   = parseInt(temp.substring(4,6),16);
    } else if (/^[\,\/]$/.test(text)){
        this.type   = "operator";
        this.value  = text;
    } else if (/^[a-z\-_\u0080-\uFFFF][a-z0-9\-_\u0080-\uFFFF]*$/i.test(text)){
        this.type   = "identifier";
        this.value  = text;
    }

}

PropertyValuePart.prototype = new SyntaxUnit();
PropertyValuePart.prototype.constructor = PropertyValuePart;

/**
 * Helper method to parse a CSS string.
 */
PropertyValuePart.parseString = function(str) {
    str = str.slice(1, -1); // Strip surrounding single/double quotes
    var replacer = function(match, esc) {
        if (/^(\n|\r\n|\r|\f)$/.test(esc)) { return ''; }
        var m = /^[0-9a-f]{1,6}/i.exec(esc);
        if (m) {
            var codePoint = parseInt(m[0], 16);
            if (String.fromCodePoint) {
                return String.fromCodePoint(codePoint);
            } else {
                // XXX No support for surrogates on old JavaScript engines.
                return String.fromCharCode(codePoint);
            }
        }
        return esc;
    };
    return str.replace(/\\(\r\n|[^\r0-9a-f]|[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)/ig,
                       replacer);
};

/**
 * Helper method to serialize a CSS string.
 */
PropertyValuePart.serializeString = function(value) {
    var replacer = function(match, c) {
        if (c === '"') {
            return "\\" + c;
        }
        var cp = String.codePointAt ? String.codePointAt(0) :
            // We only escape non-surrogate chars, so using charCodeAt
            // is harmless here.
            String.charCodeAt(0);
        return "\\" + cp.toString(16) + " ";
    };
    return '"' + value.replace(/["\r\n\f]/g, replacer) + '"';
};

/**
 * Create a new syntax unit based solely on the given token.
 * Convenience method for creating a new syntax unit when
 * it represents a single token instead of multiple.
 * @param {Object} token The token object to represent.
 * @return {parserlib.css.PropertyValuePart} The object representing the token.
 * @static
 * @method fromToken
 */
PropertyValuePart.fromToken = function(token){
    return new PropertyValuePart(token.value, token.startLine, token.startCol);
};
var Pseudos = {
    __proto__:       null,
    ":first-letter": 1,
    ":first-line":   1,
    ":before":       1,
    ":after":        1
};

Pseudos.ELEMENT = 1;
Pseudos.CLASS = 2;

Pseudos.isElement = function(pseudo){
    return pseudo.indexOf("::") === 0 || Pseudos[pseudo.toLowerCase()] === Pseudos.ELEMENT;
};
/**
 * Represents an entire single selector, including all parts but not
 * including multiple selectors (those separated by commas).
 * @namespace parserlib.css
 * @class Selector
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {Array} parts Array of selectors parts making up this selector.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function Selector(parts, line, col){

    SyntaxUnit.call(this, parts.join(" "), line, col, Parser.SELECTOR_TYPE);

    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;

    /**
     * The specificity of the selector.
     * @type parserlib.css.Specificity
     * @property specificity
     */
    this.specificity = Specificity.calculate(this);

}

Selector.prototype = new SyntaxUnit();
Selector.prototype.constructor = Selector;

/**
 * Represents a single part of a selector string, meaning a single set of
 * element name and modifiers. This does not include combinators such as
 * spaces, +, >, etc.
 * @namespace parserlib.css
 * @class SelectorPart
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} elementName The element name in the selector or null
 *      if there is no element name.
 * @param {Array} modifiers Array of individual modifiers for the element.
 *      May be empty if there are none.
 * @param {String} text The text representation of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function SelectorPart(elementName, modifiers, text, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);

    /**
     * The tag name of the element to which this part
     * of the selector affects.
     * @type String
     * @property elementName
     */
    this.elementName = elementName;

    /**
     * The parts that come after the element name, such as class names, IDs,
     * pseudo classes/elements, etc.
     * @type Array
     * @property modifiers
     */
    this.modifiers = modifiers;

}

SelectorPart.prototype = new SyntaxUnit();
SelectorPart.prototype.constructor = SelectorPart;

/**
 * Represents a selector modifier string, meaning a class name, element name,
 * element ID, pseudo rule, etc.
 * @namespace parserlib.css
 * @class SelectorSubPart
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} text The text representation of the unit.
 * @param {String} type The type of selector modifier.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function SelectorSubPart(text, type, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = type;

    /**
     * Some subparts have arguments, this represents them.
     * @type Array
     * @property args
     */
    this.args = [];

}

SelectorSubPart.prototype = new SyntaxUnit();
SelectorSubPart.prototype.constructor = SelectorSubPart;

/**
 * Represents a selector's specificity.
 * @namespace parserlib.css
 * @class Specificity
 * @constructor
 * @param {int} a Should be 1 for inline styles, zero for stylesheet styles
 * @param {int} b Number of ID selectors
 * @param {int} c Number of classes and pseudo classes
 * @param {int} d Number of element names and pseudo elements
 */
function Specificity(a, b, c, d){
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
}

Specificity.prototype = {
    constructor: Specificity,

    /**
     * Compare this specificity to another.
     * @param {Specificity} other The other specificity to compare to.
     * @return {int} -1 if the other specificity is larger, 1 if smaller, 0 if equal.
     * @method compare
     */
    compare: function(other){
        var comps = ["a", "b", "c", "d"],
            i, len;

        for (i=0, len=comps.length; i < len; i++){
            if (this[comps[i]] < other[comps[i]]){
                return -1;
            } else if (this[comps[i]] > other[comps[i]]){
                return 1;
            }
        }

        return 0;
    },

    /**
     * Creates a numeric value for the specificity.
     * @return {int} The numeric value for the specificity.
     * @method valueOf
     */
    valueOf: function(){
        return (this.a * 1000) + (this.b * 100) + (this.c * 10) + this.d;
    },

    /**
     * Returns a string representation for specificity.
     * @return {String} The string representation of specificity.
     * @method toString
     */
    toString: function(){
        return this.a + "," + this.b + "," + this.c + "," + this.d;
    }

};

/**
 * Calculates the specificity of the given selector.
 * @param {parserlib.css.Selector} The selector to calculate specificity for.
 * @return {parserlib.css.Specificity} The specificity of the selector.
 * @static
 * @method calculate
 */
Specificity.calculate = function(selector){

    var i, len,
        part,
        b=0, c=0, d=0;

    function updateValues(part){

        var i, j, len, num,
            elementName = part.elementName ? part.elementName.text : "",
            modifier;

        if (elementName && elementName.charAt(elementName.length-1) !== "*") {
            d++;
        }

        for (i=0, len=part.modifiers.length; i < len; i++){
            modifier = part.modifiers[i];
            switch(modifier.type){
                case "class":
                case "attribute":
                    c++;
                    break;

                case "id":
                    b++;
                    break;

                case "pseudo":
                    if (Pseudos.isElement(modifier.text)){
                        d++;
                    } else {
                        c++;
                    }
                    break;

                case "not":
                    for (j=0, num=modifier.args.length; j < num; j++){
                        updateValues(modifier.args[j]);
                    }
            }
         }
    }

    for (i=0, len=selector.parts.length; i < len; i++){
        part = selector.parts[i];

        if (part instanceof SelectorPart){
            updateValues(part);
        }
    }

    return new Specificity(0, b, c, d);
};

var h = /^[0-9a-fA-F]$/,
    //nonascii = /^[\u0080-\uFFFF]$/,
    nl = /\n|\r\n|\r|\f/;

//-----------------------------------------------------------------------------
// Helper functions
//-----------------------------------------------------------------------------


function isHexDigit(c){
    return c !== null && h.test(c);
}

function isDigit(c){
    return c !== null && /\d/.test(c);
}

function isWhitespace(c){
    return c !== null && /\s/.test(c);
}

function isNewLine(c){
    return c !== null && nl.test(c);
}

function isNameStart(c){
    return c !== null && (/[a-z_\u0080-\uFFFF\\]/i.test(c));
}

function isNameChar(c){
    return c !== null && (isNameStart(c) || /[0-9\-\\]/.test(c));
}

function isIdentStart(c){
    return c !== null && (isNameStart(c) || /\-\\/.test(c));
}

function mix(receiver, supplier){
	for (var prop in supplier){
		if (Object.prototype.hasOwnProperty.call(supplier, prop)){
			receiver[prop] = supplier[prop];
		}
	}
	return receiver;
}

//-----------------------------------------------------------------------------
// CSS Token Stream
//-----------------------------------------------------------------------------


/**
 * A token stream that produces CSS tokens.
 * @param {String|Reader} input The source of text to tokenize.
 * @constructor
 * @class TokenStream
 * @namespace parserlib.css
 */
function TokenStream(input){
	TokenStreamBase.call(this, input, Tokens);
}

TokenStream.prototype = mix(new TokenStreamBase(), {

    /**
     * Overrides the TokenStreamBase method of the same name
     * to produce CSS tokens.
     * @param {variant} channel The name of the channel to use
     *      for the next token.
     * @return {Object} A token object representing the next token.
     * @method _getToken
     * @private
     */
    _getToken: function(channel){

        var c,
            reader = this._reader,
            token   = null,
            startLine   = reader.getLine(),
            startCol    = reader.getCol();

        c = reader.read();


        while(c){
            switch(c){

                /*
                 * Potential tokens:
                 * - COMMENT
                 * - SLASH
                 * - CHAR
                 */
                case "/":

                    if(reader.peek() === "*"){
                        token = this.commentToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - DASHMATCH
                 * - INCLUDES
                 * - PREFIXMATCH
                 * - SUFFIXMATCH
                 * - SUBSTRINGMATCH
                 * - CHAR
                 */
                case "|":
                case "~":
                case "^":
                case "$":
                case "*":
                    if(reader.peek() === "="){
                        token = this.comparisonToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - STRING
                 * - INVALID
                 */
                case "\"":
                case "'":
                    token = this.stringToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - HASH
                 * - CHAR
                 */
                case "#":
                    if (isNameChar(reader.peek())){
                        token = this.hashToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - DOT
                 * - NUMBER
                 * - DIMENSION
                 * - PERCENTAGE
                 */
                case ".":
                    if (isDigit(reader.peek())){
                        token = this.numberToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - CDC
                 * - MINUS
                 * - NUMBER
                 * - DIMENSION
                 * - PERCENTAGE
                 */
                case "-":
                    if (reader.peek() === "-"){  //could be closing HTML-style comment
                        token = this.htmlCommentEndToken(c, startLine, startCol);
                    } else if (isNameStart(reader.peek())){
                        token = this.identOrFunctionToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - IMPORTANT_SYM
                 * - CHAR
                 */
                case "!":
                    token = this.importantToken(c, startLine, startCol);
                    break;

                /*
                 * Any at-keyword or CHAR
                 */
                case "@":
                    token = this.atRuleToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - NOT
                 * - CHAR
                 */
                case ":":
                    token = this.notToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - CDO
                 * - CHAR
                 */
                case "<":
                    token = this.htmlCommentStartToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - UNICODE_RANGE
                 * - URL
                 * - CHAR
                 */
                case "U":
                case "u":
                    if (reader.peek() === "+"){
                        token = this.unicodeRangeToken(c, startLine, startCol);
                        break;
                    }
                    /* falls through */
                default:

                    /*
                     * Potential tokens:
                     * - NUMBER
                     * - DIMENSION
                     * - LENGTH
                     * - FREQ
                     * - TIME
                     * - EMS
                     * - EXS
                     * - ANGLE
                     */
                    if (isDigit(c)){
                        token = this.numberToken(c, startLine, startCol);
                    } else

                    /*
                     * Potential tokens:
                     * - S
                     */
                    if (isWhitespace(c)){
                        token = this.whitespaceToken(c, startLine, startCol);
                    } else

                    /*
                     * Potential tokens:
                     * - IDENT
                     */
                    if (isIdentStart(c)){
                        token = this.identOrFunctionToken(c, startLine, startCol);
                    } else

                    /*
                     * Potential tokens:
                     * - CHAR
                     * - PLUS
                     */
                    {
                        token = this.charToken(c, startLine, startCol);
                    }






            }

            //make sure this token is wanted
            //TODO: check channel
            break;
        }

        if (!token && c === null){
            token = this.createToken(Tokens.EOF,null,startLine,startCol);
        }

        return token;
    },

    //-------------------------------------------------------------------------
    // Methods to create tokens
    //-------------------------------------------------------------------------

    /**
     * Produces a token based on available data and the current
     * reader position information. This method is called by other
     * private methods to create tokens and is never called directly.
     * @param {int} tt The token type.
     * @param {String} value The text value of the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @param {Object} options (Optional) Specifies a channel property
     *      to indicate that a different channel should be scanned
     *      and/or a hide property indicating that the token should
     *      be hidden.
     * @return {Object} A token object.
     * @method createToken
     */
    createToken: function(tt, value, startLine, startCol, options){
        var reader = this._reader;
        options = options || {};

        return {
            value:      value,
            type:       tt,
            channel:    options.channel,
            endChar:    options.endChar,
            hide:       options.hide || false,
            startLine:  startLine,
            startCol:   startCol,
            endLine:    reader.getLine(),
            endCol:     reader.getCol()
        };
    },

    //-------------------------------------------------------------------------
    // Methods to create specific tokens
    //-------------------------------------------------------------------------

    /**
     * Produces a token for any at-rule. If the at-rule is unknown, then
     * the token is for a single "@" character.
     * @param {String} first The first character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method atRuleToken
     */
    atRuleToken: function(first, startLine, startCol){
        var rule    = first,
            reader  = this._reader,
            tt      = Tokens.CHAR,
            ident;

        /*
         * First, mark where we are. There are only four @ rules,
         * so anything else is really just an invalid token.
         * Basically, if this doesn't match one of the known @
         * rules, just return '@' as an unknown token and allow
         * parsing to continue after that point.
         */
        reader.mark();

        //try to find the at-keyword
        ident = this.readName();
        rule = first + ident;
        tt = Tokens.type(rule.toLowerCase());

        //if it's not valid, use the first character only and reset the reader
        if (tt === Tokens.CHAR || tt === Tokens.UNKNOWN){
            if (rule.length > 1){
                tt = Tokens.UNKNOWN_SYM;
            } else {
                tt = Tokens.CHAR;
                rule = first;
                reader.reset();
            }
        }

        return this.createToken(tt, rule, startLine, startCol);
    },

    /**
     * Produces a character token based on the given character
     * and location in the stream. If there's a special (non-standard)
     * token name, this is used; otherwise CHAR is used.
     * @param {String} c The character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method charToken
     */
    charToken: function(c, startLine, startCol){
        var tt = Tokens.type(c);
        var opts = {};

        if (tt === -1){
            tt = Tokens.CHAR;
        } else {
            opts.endChar = Tokens[tt].endChar;
        }

        return this.createToken(tt, c, startLine, startCol, opts);
    },

    /**
     * Produces a character token based on the given character
     * and location in the stream. If there's a special (non-standard)
     * token name, this is used; otherwise CHAR is used.
     * @param {String} first The first character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method commentToken
     */
    commentToken: function(first, startLine, startCol){
        var comment = this.readComment(first);

        return this.createToken(Tokens.COMMENT, comment, startLine, startCol);
    },

    /**
     * Produces a comparison token based on the given character
     * and location in the stream. The next character must be
     * read and is already known to be an equals sign.
     * @param {String} c The character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method comparisonToken
     */
    comparisonToken: function(c, startLine, startCol){
        var reader  = this._reader,
            comparison  = c + reader.read(),
            tt      = Tokens.type(comparison) || Tokens.CHAR;

        return this.createToken(tt, comparison, startLine, startCol);
    },

    /**
     * Produces a hash token based on the specified information. The
     * first character provided is the pound sign (#) and then this
     * method reads a name afterward.
     * @param {String} first The first character (#) in the hash name.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method hashToken
     */
    hashToken: function(first, startLine, startCol){
        var name    = this.readName(first);

        return this.createToken(Tokens.HASH, name, startLine, startCol);
    },

    /**
     * Produces a CDO or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method htmlCommentStartToken
     */
    htmlCommentStartToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(3);

        if (text === "<!--"){
            return this.createToken(Tokens.CDO, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },

    /**
     * Produces a CDC or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method htmlCommentEndToken
     */
    htmlCommentEndToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(2);

        if (text === "-->"){
            return this.createToken(Tokens.CDC, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },

    /**
     * Produces an IDENT or FUNCTION token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the identifier.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method identOrFunctionToken
     */
    identOrFunctionToken: function(first, startLine, startCol){
        var reader  = this._reader,
            ident   = this.readName(first),
            tt      = Tokens.IDENT,
            uriFns  = ["url(", "url-prefix(", "domain("];

        //if there's a left paren immediately after, it's a URI or function
        if (reader.peek() === "("){
            ident += reader.read();
            if (uriFns.indexOf(ident.toLowerCase()) > -1){
                tt = Tokens.URI;
                ident = this.readURI(ident);

                //didn't find a valid URL or there's no closing paren
                if (uriFns.indexOf(ident.toLowerCase()) > -1){
                    tt = Tokens.FUNCTION;
                }
            } else {
                tt = Tokens.FUNCTION;
            }
        } else if (reader.peek() === ":"){  //might be an IE function

            //IE-specific functions always being with progid:
            if (ident.toLowerCase() === "progid"){
                ident += reader.readTo("(");
                tt = Tokens.IE_FUNCTION;
            }
        }

        return this.createToken(tt, ident, startLine, startCol);
    },

    /**
     * Produces an IMPORTANT_SYM or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method importantToken
     */
    importantToken: function(first, startLine, startCol){
        var reader      = this._reader,
            important   = first,
            tt          = Tokens.CHAR,
            temp,
            c;

        reader.mark();
        c = reader.read();

        while(c){

            //there can be a comment in here
            if (c === "/"){

                //if the next character isn't a star, then this isn't a valid !important token
                if (reader.peek() !== "*"){
                    break;
                } else {
                    temp = this.readComment(c);
                    if (temp === ""){    //broken!
                        break;
                    }
                }
            } else if (isWhitespace(c)){
                important += c + this.readWhitespace();
            } else if (/i/i.test(c)){
                temp = reader.readCount(8);
                if (/mportant/i.test(temp)){
                    important += c + temp;
                    tt = Tokens.IMPORTANT_SYM;

                }
                break;  //we're done
            } else {
                break;
            }

            c = reader.read();
        }

        if (tt === Tokens.CHAR){
            reader.reset();
            return this.charToken(first, startLine, startCol);
        } else {
            return this.createToken(tt, important, startLine, startCol);
        }


    },

    /**
     * Produces a NOT or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method notToken
     */
    notToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(4);

        if (text.toLowerCase() === ":not("){
            return this.createToken(Tokens.NOT, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },

    /**
     * Produces a number token based on the given character
     * and location in the stream. This may return a token of
     * NUMBER, EMS, EXS, LENGTH, ANGLE, TIME, FREQ, DIMENSION,
     * or PERCENTAGE.
     * @param {String} first The first character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method numberToken
     */
    numberToken: function(first, startLine, startCol){
        var reader  = this._reader,
            value   = this.readNumber(first),
            ident,
            tt      = Tokens.NUMBER,
            c       = reader.peek();

        if (isIdentStart(c)){
            ident = this.readName(reader.read());
            value += ident;

            if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)){
                tt = Tokens.LENGTH;
            } else if (/^deg|^rad$|^grad$/i.test(ident)){
                tt = Tokens.ANGLE;
            } else if (/^ms$|^s$/i.test(ident)){
                tt = Tokens.TIME;
            } else if (/^hz$|^khz$/i.test(ident)){
                tt = Tokens.FREQ;
            } else if (/^dpi$|^dpcm$/i.test(ident)){
                tt = Tokens.RESOLUTION;
            } else {
                tt = Tokens.DIMENSION;
            }

        } else if (c === "%"){
            value += reader.read();
            tt = Tokens.PERCENTAGE;
        }

        return this.createToken(tt, value, startLine, startCol);
    },

    /**
     * Produces a string token based on the given character
     * and location in the stream. Since strings may be indicated
     * by single or double quotes, a failure to match starting
     * and ending quotes results in an INVALID token being generated.
     * The first character in the string is passed in and then
     * the rest are read up to and including the final quotation mark.
     * @param {String} first The first character in the string.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method stringToken
     */
    stringToken: function(first, startLine, startCol){
        var delim   = first,
            string  = first,
            reader  = this._reader,
            prev    = first,
            tt      = Tokens.STRING,
            c       = reader.read();

        while(c){
            string += c;

            //if the delimiter is found with an escapement, we're done.
            if (c === delim && prev !== "\\"){
                break;
            }

            //if there's a newline without an escapement, it's an invalid string
            if (isNewLine(reader.peek()) && c !== "\\"){
                tt = Tokens.INVALID;
                break;
            }

            //save previous and get next
            prev = c;
            c = reader.read();
        }

        //if c is null, that means we're out of input and the string was never closed
        if (c === null){
            tt = Tokens.INVALID;
        }

        return this.createToken(tt, string, startLine, startCol);
    },

    unicodeRangeToken: function(first, startLine, startCol){
        var reader  = this._reader,
            value   = first,
            temp,
            tt      = Tokens.CHAR;

        //then it should be a unicode range
        if (reader.peek() === "+"){
            reader.mark();
            value += reader.read();
            value += this.readUnicodeRangePart(true);

            //ensure there's an actual unicode range here
            if (value.length === 2){
                reader.reset();
            } else {

                tt = Tokens.UNICODE_RANGE;

                //if there's a ? in the first part, there can't be a second part
                if (value.indexOf("?") === -1){

                    if (reader.peek() === "-"){
                        reader.mark();
                        temp = reader.read();
                        temp += this.readUnicodeRangePart(false);

                        //if there's not another value, back up and just take the first
                        if (temp.length === 1){
                            reader.reset();
                        } else {
                            value += temp;
                        }
                    }

                }
            }
        }

        return this.createToken(tt, value, startLine, startCol);
    },

    /**
     * Produces a S token based on the specified information. Since whitespace
     * may have multiple characters, this consumes all whitespace characters
     * into a single token.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method whitespaceToken
     */
    whitespaceToken: function(first, startLine, startCol){
        var value   = first + this.readWhitespace();
        return this.createToken(Tokens.S, value, startLine, startCol);
    },




    //-------------------------------------------------------------------------
    // Methods to read values from the string stream
    //-------------------------------------------------------------------------

    readUnicodeRangePart: function(allowQuestionMark){
        var reader  = this._reader,
            part = "",
            c       = reader.peek();

        //first read hex digits
        while(isHexDigit(c) && part.length < 6){
            reader.read();
            part += c;
            c = reader.peek();
        }

        //then read question marks if allowed
        if (allowQuestionMark){
            while(c === "?" && part.length < 6){
                reader.read();
                part += c;
                c = reader.peek();
            }
        }

        //there can't be any other characters after this point

        return part;
    },

    readWhitespace: function(){
        var reader  = this._reader,
            whitespace = "",
            c       = reader.peek();

        while(isWhitespace(c)){
            reader.read();
            whitespace += c;
            c = reader.peek();
        }

        return whitespace;
    },
    readNumber: function(first){
        var reader  = this._reader,
            number  = first,
            hasDot  = (first === "."),
            c       = reader.peek();


        while(c){
            if (isDigit(c)){
                number += reader.read();
            } else if (c === "."){
                if (hasDot){
                    break;
                } else {
                    hasDot = true;
                    number += reader.read();
                }
            } else {
                break;
            }

            c = reader.peek();
        }

        return number;
    },
    readString: function(){
        var reader  = this._reader,
            delim   = reader.read(),
            string  = delim,
            prev    = delim,
            c       = reader.peek();

        while(c){
            c = reader.read();
            string += c;

            //if the delimiter is found with an escapement, we're done.
            if (c === delim && prev !== "\\"){
                break;
            }

            //if there's a newline without an escapement, it's an invalid string
            if (isNewLine(reader.peek()) && c !== "\\"){
                string = "";
                break;
            }

            //save previous and get next
            prev = c;
            c = reader.peek();
        }

        //if c is null, that means we're out of input and the string was never closed
        if (c === null){
            string = "";
        }

        return string;
    },
    readURI: function(first){
        var reader  = this._reader,
            uri     = first,
            inner   = "",
            c       = reader.peek();

        reader.mark();

        //skip whitespace before
        while(c && isWhitespace(c)){
            reader.read();
            c = reader.peek();
        }

        //it's a string
        if (c === "'" || c === "\""){
            inner = this.readString();
        } else {
            inner = this.readURL();
        }

        c = reader.peek();

        //skip whitespace after
        while(c && isWhitespace(c)){
            reader.read();
            c = reader.peek();
        }

        //if there was no inner value or the next character isn't closing paren, it's not a URI
        if (inner === "" || c !== ")"){
            uri = first;
            reader.reset();
        } else {
            uri += inner + reader.read();
        }

        return uri;
    },
    readURL: function(){
        var reader  = this._reader,
            url     = "",
            c       = reader.peek();

        //TODO: Check for escape and nonascii
        while (/^[!#$%&\\*-~]$/.test(c)){
            url += reader.read();
            c = reader.peek();
        }

        return url;

    },
    readName: function(first){
        var reader  = this._reader,
            ident   = first || "",
            c       = reader.peek();

        while(true){
            if (c === "\\"){
                ident += this.readEscape(reader.read());
                c = reader.peek();
            } else if(c && isNameChar(c)){
                ident += reader.read();
                c = reader.peek();
            } else {
                break;
            }
        }

        return ident;
    },

    readEscape: function(first){
        var reader  = this._reader,
            cssEscape = first || "",
            i       = 0,
            c       = reader.peek();

        if (isHexDigit(c)){
            do {
                cssEscape += reader.read();
                c = reader.peek();
            } while(c && isHexDigit(c) && ++i < 6);
        }

        if (cssEscape.length === 3 && /\s/.test(c) ||
            cssEscape.length === 7 || cssEscape.length === 1){
                reader.read();
        } else {
            c = "";
        }

        return cssEscape + c;
    },

    readComment: function(first){
        var reader  = this._reader,
            comment = first || "",
            c       = reader.read();

        if (c === "*"){
            while(c){
                comment += c;

                //look for end of comment
                if (comment.length > 2 && c === "*" && reader.peek() === "/"){
                    comment += reader.read();
                    break;
                }

                c = reader.read();
            }

            return comment;
        } else {
            return "";
        }

    }
});

var Tokens  = [

    /*
     * The following token names are defined in CSS3 Grammar: http://www.w3.org/TR/css3-syntax/#lexical
     */

    //HTML-style comments
    { name: "CDO"},
    { name: "CDC"},

    //ignorables
    { name: "S", whitespace: true/*, channel: "ws"*/},
    { name: "COMMENT", comment: true, hide: true, channel: "comment" },

    //attribute equality
    { name: "INCLUDES", text: "~="},
    { name: "DASHMATCH", text: "|="},
    { name: "PREFIXMATCH", text: "^="},
    { name: "SUFFIXMATCH", text: "$="},
    { name: "SUBSTRINGMATCH", text: "*="},

    //identifier types
    { name: "STRING"},
    { name: "IDENT"},
    { name: "HASH"},

    //at-keywords
    { name: "IMPORT_SYM", text: "@import"},
    { name: "PAGE_SYM", text: "@page"},
    { name: "MEDIA_SYM", text: "@media"},
    { name: "FONT_FACE_SYM", text: "@font-face"},
    { name: "CHARSET_SYM", text: "@charset"},
    { name: "NAMESPACE_SYM", text: "@namespace"},
    { name: "VIEWPORT_SYM", text: ["@viewport", "@-ms-viewport", "@-o-viewport"]},
    { name: "DOCUMENT_SYM", text: ["@document", "@-moz-document"]},
    { name: "UNKNOWN_SYM" },
    //{ name: "ATKEYWORD"},

    //CSS3 animations
    { name: "KEYFRAMES_SYM", text: [ "@keyframes", "@-webkit-keyframes", "@-moz-keyframes", "@-o-keyframes" ] },

    //important symbol
    { name: "IMPORTANT_SYM"},

    //measurements
    { name: "LENGTH"},
    { name: "ANGLE"},
    { name: "TIME"},
    { name: "FREQ"},
    { name: "DIMENSION"},
    { name: "PERCENTAGE"},
    { name: "NUMBER"},

    //functions
    { name: "URI"},
    { name: "FUNCTION"},

    //Unicode ranges
    { name: "UNICODE_RANGE"},

    /*
     * The following token names are defined in CSS3 Selectors: http://www.w3.org/TR/css3-selectors/#selector-syntax
     */

    //invalid string
    { name: "INVALID"},

    //combinators
    { name: "PLUS", text: "+" },
    { name: "GREATER", text: ">"},
    { name: "COMMA", text: ","},
    { name: "TILDE", text: "~"},

    //modifier
    { name: "NOT"},

    /*
     * Defined in CSS3 Paged Media
     */
    { name: "TOPLEFTCORNER_SYM", text: "@top-left-corner"},
    { name: "TOPLEFT_SYM", text: "@top-left"},
    { name: "TOPCENTER_SYM", text: "@top-center"},
    { name: "TOPRIGHT_SYM", text: "@top-right"},
    { name: "TOPRIGHTCORNER_SYM", text: "@top-right-corner"},
    { name: "BOTTOMLEFTCORNER_SYM", text: "@bottom-left-corner"},
    { name: "BOTTOMLEFT_SYM", text: "@bottom-left"},
    { name: "BOTTOMCENTER_SYM", text: "@bottom-center"},
    { name: "BOTTOMRIGHT_SYM", text: "@bottom-right"},
    { name: "BOTTOMRIGHTCORNER_SYM", text: "@bottom-right-corner"},
    { name: "LEFTTOP_SYM", text: "@left-top"},
    { name: "LEFTMIDDLE_SYM", text: "@left-middle"},
    { name: "LEFTBOTTOM_SYM", text: "@left-bottom"},
    { name: "RIGHTTOP_SYM", text: "@right-top"},
    { name: "RIGHTMIDDLE_SYM", text: "@right-middle"},
    { name: "RIGHTBOTTOM_SYM", text: "@right-bottom"},

    /*
     * The following token names are defined in CSS3 Media Queries: http://www.w3.org/TR/css3-mediaqueries/#syntax
     */
    /*{ name: "MEDIA_ONLY", state: "media"},
    { name: "MEDIA_NOT", state: "media"},
    { name: "MEDIA_AND", state: "media"},*/
    { name: "RESOLUTION", state: "media"},

    /*
     * The following token names are not defined in any CSS specification but are used by the lexer.
     */

    //not a real token, but useful for stupid IE filters
    { name: "IE_FUNCTION" },

    //part of CSS3 grammar but not the Flex code
    { name: "CHAR" },

    //TODO: Needed?
    //Not defined as tokens, but might as well be
    {
        name: "PIPE",
        text: "|"
    },
    {
        name: "SLASH",
        text: "/"
    },
    {
        name: "MINUS",
        text: "-"
    },
    {
        name: "STAR",
        text: "*"
    },

    {
        name: "LBRACE",
        endChar: "}",
        text: "{"
    },
    {
        name: "RBRACE",
        text: "}"
    },
    {
        name: "LBRACKET",
        endChar: "]",
        text: "["
    },
    {
        name: "RBRACKET",
        text: "]"
    },
    {
        name: "EQUALS",
        text: "="
    },
    {
        name: "COLON",
        text: ":"
    },
    {
        name: "SEMICOLON",
        text: ";"
    },

    {
        name: "LPAREN",
        endChar: ")",
        text: "("
    },
    {
        name: "RPAREN",
        text: ")"
    },
    {
        name: "DOT",
        text: "."
    }
];

(function(){

    var nameMap = [],
        typeMap = Object.create(null);

    Tokens.UNKNOWN = -1;
    Tokens.unshift({name:"EOF"});
    for (var i=0, len = Tokens.length; i < len; i++){
        nameMap.push(Tokens[i].name);
        Tokens[Tokens[i].name] = i;
        if (Tokens[i].text){
            if (Tokens[i].text instanceof Array){
                for (var j=0; j < Tokens[i].text.length; j++){
                    typeMap[Tokens[i].text[j]] = i;
                }
            } else {
                typeMap[Tokens[i].text] = i;
            }
        }
    }

    Tokens.name = function(tt){
        return nameMap[tt];
    };

    Tokens.type = function(c){
        return typeMap[c] || -1;
    };

})();



//This file will likely change a lot! Very experimental!
var Validation = {

    validate: function(property, value){

        //normalize name
        var name        = property.toString().toLowerCase(),
            expression  = new PropertyValueIterator(value),
            spec        = Properties[name];

        if (!spec) {
            if (name.indexOf("-") !== 0){    //vendor prefixed are ok
                throw new ValidationError("Unknown property '" + property + "'.", property.line, property.col);
            }
        } else if (typeof spec !== "number"){

            //initialization
            if (typeof spec === "string"){
                if (spec.indexOf("||") > -1) {
                    this.groupProperty(spec, expression);
                } else {
                    this.singleProperty(spec, expression, 1);
                }

            } else if (spec.multi) {
                this.multiProperty(spec.multi, expression, spec.comma, spec.max || Infinity);
            } else if (typeof spec === "function") {
                spec(expression);
            }

        }

    },

    singleProperty: function(types, expression, max, partial) {

        var result      = false,
            value       = expression.value,
            count       = 0,
            part;

        while (expression.hasNext() && count < max) {
            result = ValidationTypes.isAny(expression, types);
            if (!result) {
                break;
            }
            count++;
        }

        if (!result) {
            if (expression.hasNext() && !expression.isFirst()) {
                part = expression.peek();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                 throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
            }
        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }

    },

    multiProperty: function (types, expression, comma, max) {

        var result      = false,
            value       = expression.value,
            count       = 0,
            part;

        while(expression.hasNext() && !result && count < max) {
            if (ValidationTypes.isAny(expression, types)) {
                count++;
                if (!expression.hasNext()) {
                    result = true;

                } else if (comma) {
                    if (String(expression.peek()) === ",") {
                        part = expression.next();
                    } else {
                        break;
                    }
                }
            } else {
                break;

            }
        }

        if (!result) {
            if (expression.hasNext() && !expression.isFirst()) {
                part = expression.peek();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                part = expression.previous();
                if (comma && String(part) === ",") {
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
                } else {
                    throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
                }
            }

        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }

    },

    groupProperty: function (types, expression, comma) {

        var result      = false,
            value       = expression.value,
            typeCount   = types.split("||").length,
            groups      = { count: 0 },
            partial     = false,
            name,
            part;

        while(expression.hasNext() && !result) {
            name = ValidationTypes.isAnyOfGroup(expression, types);
            if (name) {

                //no dupes
                if (groups[name]) {
                    break;
                } else {
                    groups[name] = 1;
                    groups.count++;
                    partial = true;

                    if (groups.count === typeCount || !expression.hasNext()) {
                        result = true;
                    }
                }
            } else {
                break;
            }
        }

        if (!result) {
            if (partial && expression.hasNext()) {
                    part = expression.peek();
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
            }
        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }
    }



};
/**
 * Type to use when a validation error occurs.
 * @class ValidationError
 * @namespace parserlib.util
 * @constructor
 * @param {String} message The error message.
 * @param {int} line The line at which the error occurred.
 * @param {int} col The column at which the error occurred.
 */
function ValidationError(message, line, col){

    /**
     * The column at which the error occurred.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line at which the error occurred.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.message = message;

}

//inherit from Error
ValidationError.prototype = new Error();
//This file will likely change a lot! Very experimental!
var ValidationTypes = {

    isLiteral: function (part, literals) {
        var text = part.text.toString().toLowerCase(),
            args = literals.split(" | "),
            i, len, found = false;

        for (i=0,len=args.length; i < len && !found; i++){
            if (text === args[i].toLowerCase()){
                found = true;
            }
        }

        return found;
    },

    isSimple: function(type) {
        return !!this.simple[type];
    },

    isComplex: function(type) {
        return !!this.complex[type];
    },

    /**
     * Determines if the next part(s) of the given expression
     * are any of the given types.
     */
    isAny: function (expression, types) {
        var args = types.split(" | "),
            i, len, found = false;

        for (i=0,len=args.length; i < len && !found && expression.hasNext(); i++){
            found = this.isType(expression, args[i]);
        }

        return found;
    },

    /**
     * Determines if the next part(s) of the given expression
     * are one of a group.
     */
    isAnyOfGroup: function(expression, types) {
        var args = types.split(" || "),
            i, len, found = false;

        for (i=0,len=args.length; i < len && !found; i++){
            found = this.isType(expression, args[i]);
        }

        return found ? args[i-1] : false;
    },

    /**
     * Determines if the next part(s) of the given expression
     * are of a given type.
     */
    isType: function (expression, type) {
        var part = expression.peek(),
            result = false;

        if (type.charAt(0) !== "<") {
            result = this.isLiteral(part, type);
            if (result) {
                expression.next();
            }
        } else if (this.simple[type]) {
            result = this.simple[type](part);
            if (result) {
                expression.next();
            }
        } else {
            result = this.complex[type](expression);
        }

        return result;
    },



    simple: {
        __proto__: null,

        "<absolute-size>": function(part){
            return ValidationTypes.isLiteral(part, "xx-small | x-small | small | medium | large | x-large | xx-large");
        },

        "<attachment>": function(part){
            return ValidationTypes.isLiteral(part, "scroll | fixed | local");
        },

        "<attr>": function(part){
            return part.type === "function" && part.name === "attr";
        },

        "<bg-image>": function(part){
            return this["<image>"](part) || this["<gradient>"](part) ||  String(part) === "none";
        },

        "<gradient>": function(part) {
            return part.type === "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?(?:repeating\-)?(?:radial\-|linear\-)?gradient/i.test(part);
        },

        "<box>": function(part){
            return ValidationTypes.isLiteral(part, "padding-box | border-box | content-box");
        },

        "<content>": function(part){
            return part.type === "function" && part.name === "content";
        },

        "<relative-size>": function(part){
            return ValidationTypes.isLiteral(part, "smaller | larger");
        },

        //any identifier
        "<ident>": function(part){
            return part.type === "identifier";
        },

        "<length>": function(part){
            if (part.type === "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?calc/i.test(part)){
                return true;
            }else{
                return part.type === "length" || part.type === "number" || part.type === "integer" || String(part) === "0";
            }
        },

        "<color>": function(part){
            return part.type === "color" || String(part) === "transparent" || String(part) === "currentColor";
        },

        "<number>": function(part){
            return part.type === "number" || this["<integer>"](part);
        },

        "<integer>": function(part){
            return part.type === "integer";
        },

        "<line>": function(part){
            return part.type === "integer";
        },

        "<angle>": function(part){
            return part.type === "angle";
        },

        "<uri>": function(part){
            return part.type === "uri";
        },

        "<image>": function(part){
            return this["<uri>"](part);
        },

        "<percentage>": function(part){
            return part.type === "percentage" || String(part) === "0";
        },

        "<border-width>": function(part){
            return this["<length>"](part) || ValidationTypes.isLiteral(part, "thin | medium | thick");
        },

        "<border-style>": function(part){
            return ValidationTypes.isLiteral(part, "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset");
        },

        "<content-sizing>": function(part){ // http://www.w3.org/TR/css3-sizing/#width-height-keywords
            return ValidationTypes.isLiteral(part, "fill-available | -moz-available | -webkit-fill-available | max-content | -moz-max-content | -webkit-max-content | min-content | -moz-min-content | -webkit-min-content | fit-content | -moz-fit-content | -webkit-fit-content");
        },

        "<margin-width>": function(part){
            return this["<length>"](part) || this["<percentage>"](part) || ValidationTypes.isLiteral(part, "auto");
        },

        "<padding-width>": function(part){
            return this["<length>"](part) || this["<percentage>"](part);
        },

        "<shape>": function(part){
            return part.type === "function" && (part.name === "rect" || part.name === "inset-rect");
        },

        "<time>": function(part) {
            return part.type === "time";
        },

        "<flex-grow>": function(part){
            return this["<number>"](part);
        },

        "<flex-shrink>": function(part){
            return this["<number>"](part);
        },

        "<width>": function(part){
            return this["<margin-width>"](part);
        },

        "<flex-basis>": function(part){
            return this["<width>"](part);
        },

        "<flex-direction>": function(part){
            return ValidationTypes.isLiteral(part, "row | row-reverse | column | column-reverse");
        },

        "<flex-wrap>": function(part){
            return ValidationTypes.isLiteral(part, "nowrap | wrap | wrap-reverse");
        },

        "<feature-tag-value>": function(part){
            return (part.type === "function" && /^[A-Z0-9]{4}$/i.test(part));
        }
    },

    complex: {
        __proto__: null,

        "<bg-position>": function(expression){
            var result  = false,
                numeric = "<percentage> | <length>",
                xDir    = "left | right",
                yDir    = "top | bottom",
                count = 0;

            while (expression.peek(count) && expression.peek(count).text !== ",") {
                count++;
            }

/*
<position> = [
  [ left | center | right | top | bottom | <percentage> | <length> ]
|
  [ left | center | right | <percentage> | <length> ]
  [ top | center | bottom | <percentage> | <length> ]
|
  [ center | [ left | right ] [ <percentage> | <length> ]? ] &&
  [ center | [ top | bottom ] [ <percentage> | <length> ]? ]
]
*/

            if (count < 3) {
                if (ValidationTypes.isAny(expression, xDir + " | center | " + numeric)) {
                        result = true;
                        ValidationTypes.isAny(expression, yDir + " | center | " + numeric);
                } else if (ValidationTypes.isAny(expression, yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, xDir + " | center");
                }
            } else {
                if (ValidationTypes.isAny(expression, xDir)) {
                    if (ValidationTypes.isAny(expression, yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    } else if (ValidationTypes.isAny(expression, numeric)) {
                        if (ValidationTypes.isAny(expression, yDir)) {
                            result = true;
                            ValidationTypes.isAny(expression, numeric);
                        } else if (ValidationTypes.isAny(expression, "center")) {
                            result = true;
                        }
                    }
                } else if (ValidationTypes.isAny(expression, yDir)) {
                    if (ValidationTypes.isAny(expression, xDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    } else if (ValidationTypes.isAny(expression, numeric)) {
                        if (ValidationTypes.isAny(expression, xDir)) {
                                result = true;
                                ValidationTypes.isAny(expression, numeric);
                        } else if (ValidationTypes.isAny(expression, "center")) {
                            result = true;
                        }
                    }
                } else if (ValidationTypes.isAny(expression, "center")) {
                    if (ValidationTypes.isAny(expression, xDir + " | " + yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    }
                }
            }

            return result;
        },

        "<bg-size>": function(expression){
            //<bg-size> = [ <length> | <percentage> | auto ]{1,2} | cover | contain
            var result  = false,
                numeric = "<percentage> | <length> | auto";

            if (ValidationTypes.isAny(expression, "cover | contain")) {
                result = true;
            } else if (ValidationTypes.isAny(expression, numeric)) {
                result = true;
                ValidationTypes.isAny(expression, numeric);
            }

            return result;
        },

        "<repeat-style>": function(expression){
            //repeat-x | repeat-y | [repeat | space | round | no-repeat]{1,2}
            var result  = false,
                values  = "repeat | space | round | no-repeat",
                part;

            if (expression.hasNext()){
                part = expression.next();

                if (ValidationTypes.isLiteral(part, "repeat-x | repeat-y")) {
                    result = true;
                } else if (ValidationTypes.isLiteral(part, values)) {
                    result = true;

                    if (expression.hasNext() && ValidationTypes.isLiteral(expression.peek(), values)) {
                        expression.next();
                    }
                }
            }

            return result;

        },

        "<shadow>": function(expression) {
            //inset? && [ <length>{2,4} && <color>? ]
            var result  = false,
                count   = 0,
                inset   = false,
                color   = false;

            if (expression.hasNext()) {

                if (ValidationTypes.isAny(expression, "inset")){
                    inset = true;
                }

                if (ValidationTypes.isAny(expression, "<color>")) {
                    color = true;
                }

                while (ValidationTypes.isAny(expression, "<length>") && count < 4) {
                    count++;
                }


                if (expression.hasNext()) {
                    if (!color) {
                        ValidationTypes.isAny(expression, "<color>");
                    }

                    if (!inset) {
                        ValidationTypes.isAny(expression, "inset");
                    }

                }

                result = (count >= 2 && count <= 4);

            }

            return result;
        },

        "<x-one-radius>": function(expression) {
            //[ <length> | <percentage> ] [ <length> | <percentage> ]?
            var result  = false,
                simple = "<length> | <percentage> | inherit";

            if (ValidationTypes.isAny(expression, simple)){
                result = true;
                ValidationTypes.isAny(expression, simple);
            }

            return result;
        },

        "<flex>": function(expression) {
            // http://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/#flex-property
            // none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]
            // Valid syntaxes, according to https://developer.mozilla.org/en-US/docs/Web/CSS/flex#Syntax
            // * none
            // * <flex-grow>
            // * <flex-basis>
            // * <flex-grow> <flex-basis>
            // * <flex-grow> <flex-shrink>
            // * <flex-grow> <flex-shrink> <flex-basis>
            // * inherit
            var part,
                result = false;
            if (ValidationTypes.isAny(expression, "none | inherit")) {
                result = true;
            } else {
                if (ValidationTypes.isType(expression, "<flex-grow>")) {
                    if (expression.peek()) {
                        if (ValidationTypes.isType(expression, "<flex-shrink>")) {
                            if (expression.peek()) {
                                result = ValidationTypes.isType(expression, "<flex-basis>");
                            } else {
                                result = true;
                            }
                        } else if (ValidationTypes.isType(expression, "<flex-basis>")) {
                            result = expression.peek() === null;
                        }
                    } else {
                        result = true;
                    }
                } else if (ValidationTypes.isType(expression, "<flex-basis>")) {
                    result = true;
                }
            }

            if (!result) {
                // Generate a more verbose error than "Expected <flex>..."
                part = expression.peek();
                throw new ValidationError("Expected (none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]) but found '" + expression.value.text + "'.", part.line, part.col);
            }

            return result;
        }
    }
};

parserlib.css = {
__proto__           :null,
Colors              :Colors,
Combinator          :Combinator,
Parser              :Parser,
PropertyName        :PropertyName,
PropertyValue       :PropertyValue,
PropertyValuePart   :PropertyValuePart,
MediaFeature        :MediaFeature,
MediaQuery          :MediaQuery,
Selector            :Selector,
SelectorPart        :SelectorPart,
SelectorSubPart     :SelectorSubPart,
Specificity         :Specificity,
TokenStream         :TokenStream,
Tokens              :Tokens,
ValidationError     :ValidationError
};
})();

(function(){
/* jshint forin:false */
for(var prop in parserlib){
exports[prop] = parserlib[prop];
}
})();


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DOMImplementation = __webpack_require__(7);
var HTMLParser = __webpack_require__(15);
var Window = __webpack_require__(17);

exports.createDOMImplementation = function() {
  return new DOMImplementation();
};

exports.createDocument = function(html, force) {
  // Previous API couldn't let you pass '' as a document, and that
  // yields a slightly different document than createHTMLDocument('')
  // does.  The new `force` parameter lets you pass '' if you want to.
  if (html || force) {
    var parser = new HTMLParser();
    parser.parse(html || '', true);
    return parser.document();
  }
  return new DOMImplementation().createHTMLDocument("");
};

exports.createWindow = function(html, address) {
  var document = exports.createDocument(html);
  if (address !== undefined) { document._address = address; }
  return new Window(document);
};

exports.impl = __webpack_require__(45);


/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = "<div class='container-fluid'>\r\n    <div class='row'>\r\n        <div class='col-sm-3'>\r\n            <nav-menu></nav-menu>\r\n        </div>\r\n        <div class='col-sm-9 body-content'>\r\n            <router-outlet></router-outlet>\r\n        </div>\r\n    </div>\r\n</div>\r\n";

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = "<h1>Counter</h1>\r\n\r\n<p>This is a simple example of an Angular component.</p>\r\n\r\n<p>Current count: <strong>{{ currentCount }}</strong></p>\r\n\r\n<button mat-raised-button class=\"myButton\" (click)=\"incrementCounter()\" [@hoverAnimation]>Increment</button>\r\n\r\n<mat-slide-toggle [(ngModel)]=\"isEnabled\">Toggle</mat-slide-toggle>";

/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports = "<h1>Weather forecast</h1>\r\n\r\n<p>This component demonstrates fetching data from the server.</p>\r\n\r\n<p *ngIf=\"!forecasts\"><em>Loading...</em></p>\r\n\r\n<table class='table' *ngIf=\"forecasts\">\r\n    <thead>\r\n        <tr>\r\n            <th>Date</th>\r\n            <th>Temp. (C)</th>\r\n            <th>Temp. (F)</th>\r\n            <th>Summary</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr *ngFor=\"let forecast of forecasts\">\r\n            <td>{{ forecast.dateFormatted }}</td>\r\n            <td>{{ forecast.temperatureC }}</td>\r\n            <td>{{ forecast.temperatureF }}</td>\r\n            <td>{{ forecast.summary }}</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n";

/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports = "<h1>Hello, world!</h1>\r\n<p>Welcome to your new single-page application, built with:</p>\r\n<ul>\r\n    <li><a href='https://get.asp.net/'>ASP.NET Core</a> and <a href='https://msdn.microsoft.com/en-us/library/67ef8sbd.aspx'>C#</a> for cross-platform server-side code</li>\r\n    <li><a href='https://angular.io/'>Angular</a> and <a href='http://www.typescriptlang.org/'>TypeScript</a> for client-side code</li>\r\n    <li><a href='https://webpack.github.io/'>Webpack</a> for building and bundling client-side resources</li>\r\n    <li><a href='http://getbootstrap.com/'>Bootstrap</a> for layout and styling</li>\r\n</ul>\r\n<p>To help you get started, we've also set up:</p>\r\n<ul>\r\n    <li><strong>Client-side navigation</strong>. For example, click <em>Counter</em> then <em>Back</em> to return here.</li>\r\n    <li><strong>Server-side prerendering</strong>. For faster initial loading and improved SEO, your Angular app is prerendered on the server. The resulting HTML is then transferred to the browser where a client-side copy of the app takes over.</li>\r\n    <li><strong>Webpack dev middleware</strong>. In development mode, there's no need to run the <code>webpack</code> build tool. Your client-side resources are dynamically built on demand. Updates are available as soon as you modify any file.</li>\r\n    <li><strong>Hot module replacement</strong>. In development mode, you don't even need to reload the page after making most changes. Within seconds of saving changes to files, your Angular app will be rebuilt and a new instance injected into the page.</li>\r\n    <li><strong>Efficient production builds</strong>. In production mode, development-time features are disabled, and the <code>webpack</code> build tool produces minified static CSS and JavaScript files.</li>\r\n</ul>";

/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = "<div class='main-nav'>\r\n    <div class='navbar navbar-inverse'>\r\n        <div class='navbar-header'>\r\n            <button type='button' class='navbar-toggle' data-toggle='collapse' data-target='.navbar-collapse'>\r\n                <span class='sr-only'>Toggle navigation</span>\r\n                <span class='icon-bar'></span>\r\n                <span class='icon-bar'></span>\r\n                <span class='icon-bar'></span>\r\n            </button>\r\n            <a class='navbar-brand' [routerLink]=\"['/home']\">ProcessHub</a>\r\n        </div>\r\n        <div class='clearfix'></div>\r\n        <div class='navbar-collapse collapse'>\r\n            <ul class='nav navbar-nav'>\r\n                <li [routerLinkActive]=\"['link-active']\">\r\n                    <a [routerLink]=\"['/home']\">\r\n                        <span class='glyphicon glyphicon-home'></span> Home\r\n                    </a>\r\n                </li>\r\n                <li [routerLinkActive]=\"['link-active']\">\r\n                    <a [routerLink]=\"['/vehicles/new']\">\r\n                        <span class='glyphicon glyphicon-plus'></span> vehicles NEW\r\n                    </a>\r\n                </li>\r\n                <li [routerLinkActive]=\"['link-active']\">\r\n                    <a [routerLink]=\"['/counter']\">\r\n                        <span class='glyphicon glyphicon-education'></span> Counter\r\n                    </a>\r\n                </li>\r\n                <li [routerLinkActive]=\"['link-active']\">\r\n                    <a [routerLink]=\"['/fetch-data']\">\r\n                        <span class='glyphicon glyphicon-th-list'></span> Fetch data\r\n                    </a>\r\n                </li>\r\n            </ul>\r\n        </div>\r\n    </div>\r\n</div>\r\n";

/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = "<p>\r\n  vehicle-module acually works \r\n</p>\r\n";

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(21);
// HACK: this is here for backward compatability
// TODO(benlesh): remove this in v6.
exports.toPromise = Observable_1.Observable.prototype.toPromise;
//# sourceMappingURL=toPromise.js.map

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(64);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(65);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(66);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.2
(function() {
  var InvalidStateError, NetworkError, ProgressEvent, SecurityError, SyntaxError, XMLHttpRequest, XMLHttpRequestEventTarget, XMLHttpRequestUpload, http, https, os, url,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLHttpRequestEventTarget = (function() {
    function XMLHttpRequestEventTarget() {
      this.onloadstart = null;
      this.onprogress = null;
      this.onabort = null;
      this.onerror = null;
      this.onload = null;
      this.ontimeout = null;
      this.onloadend = null;
      this._listeners = {};
    }

    XMLHttpRequestEventTarget.prototype.onloadstart = null;

    XMLHttpRequestEventTarget.prototype.onprogress = null;

    XMLHttpRequestEventTarget.prototype.onabort = null;

    XMLHttpRequestEventTarget.prototype.onerror = null;

    XMLHttpRequestEventTarget.prototype.onload = null;

    XMLHttpRequestEventTarget.prototype.ontimeout = null;

    XMLHttpRequestEventTarget.prototype.onloadend = null;

    XMLHttpRequestEventTarget.prototype.addEventListener = function(eventType, listener) {
      var base;
      eventType = eventType.toLowerCase();
      (base = this._listeners)[eventType] || (base[eventType] = []);
      this._listeners[eventType].push(listener);
      return void 0;
    };

    XMLHttpRequestEventTarget.prototype.removeEventListener = function(eventType, listener) {
      var index;
      eventType = eventType.toLowerCase();
      if (this._listeners[eventType]) {
        index = this._listeners[eventType].indexOf(listener);
        if (index !== -1) {
          this._listeners[eventType].splice(index, 1);
        }
      }
      return void 0;
    };

    XMLHttpRequestEventTarget.prototype.dispatchEvent = function(event) {
      var eventType, j, len, listener, listeners;
      event.currentTarget = event.target = this;
      eventType = event.type;
      if (listeners = this._listeners[eventType]) {
        for (j = 0, len = listeners.length; j < len; j++) {
          listener = listeners[j];
          listener.call(this, event);
        }
      }
      if (listener = this["on" + eventType]) {
        listener.call(this, event);
      }
      return void 0;
    };

    return XMLHttpRequestEventTarget;

  })();

  http = __webpack_require__(96);

  https = __webpack_require__(97);

  os = __webpack_require__(98);

  url = __webpack_require__(50);

  XMLHttpRequest = (function(superClass) {
    extend(XMLHttpRequest, superClass);

    function XMLHttpRequest(options) {
      XMLHttpRequest.__super__.constructor.call(this);
      this.onreadystatechange = null;
      this._anonymous = options && options.anon;
      this.readyState = XMLHttpRequest.UNSENT;
      this.response = null;
      this.responseText = '';
      this.responseType = '';
      this.responseURL = '';
      this.status = 0;
      this.statusText = '';
      this.timeout = 0;
      this.upload = new XMLHttpRequestUpload(this);
      this._method = null;
      this._url = null;
      this._sync = false;
      this._headers = null;
      this._loweredHeaders = null;
      this._mimeOverride = null;
      this._request = null;
      this._response = null;
      this._responseParts = null;
      this._responseHeaders = null;
      this._aborting = null;
      this._error = null;
      this._loadedBytes = 0;
      this._totalBytes = 0;
      this._lengthComputable = false;
    }

    XMLHttpRequest.prototype.onreadystatechange = null;

    XMLHttpRequest.prototype.readyState = null;

    XMLHttpRequest.prototype.response = null;

    XMLHttpRequest.prototype.responseText = null;

    XMLHttpRequest.prototype.responseType = null;

    XMLHttpRequest.prototype.status = null;

    XMLHttpRequest.prototype.timeout = null;

    XMLHttpRequest.prototype.upload = null;

    XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
      var xhrUrl;
      method = method.toUpperCase();
      if (method in this._restrictedMethods) {
        throw new SecurityError("HTTP method " + method + " is not allowed in XHR");
      }
      xhrUrl = this._parseUrl(url);
      if (async === void 0) {
        async = true;
      }
      switch (this.readyState) {
        case XMLHttpRequest.UNSENT:
        case XMLHttpRequest.OPENED:
        case XMLHttpRequest.DONE:
          null;
          break;
        case XMLHttpRequest.HEADERS_RECEIVED:
        case XMLHttpRequest.LOADING:
          null;
      }
      this._method = method;
      this._url = xhrUrl;
      this._sync = !async;
      this._headers = {};
      this._loweredHeaders = {};
      this._mimeOverride = null;
      this._setReadyState(XMLHttpRequest.OPENED);
      this._request = null;
      this._response = null;
      this.status = 0;
      this.statusText = '';
      this._responseParts = [];
      this._responseHeaders = null;
      this._loadedBytes = 0;
      this._totalBytes = 0;
      this._lengthComputable = false;
      return void 0;
    };

    XMLHttpRequest.prototype.setRequestHeader = function(name, value) {
      var loweredName;
      if (this.readyState !== XMLHttpRequest.OPENED) {
        throw new InvalidStateError("XHR readyState must be OPENED");
      }
      loweredName = name.toLowerCase();
      if (this._restrictedHeaders[loweredName] || /^sec\-/.test(loweredName) || /^proxy-/.test(loweredName)) {
        console.warn("Refused to set unsafe header \"" + name + "\"");
        return void 0;
      }
      value = value.toString();
      if (loweredName in this._loweredHeaders) {
        name = this._loweredHeaders[loweredName];
        this._headers[name] = this._headers[name] + ', ' + value;
      } else {
        this._loweredHeaders[loweredName] = name;
        this._headers[name] = value;
      }
      return void 0;
    };

    XMLHttpRequest.prototype.send = function(data) {
      if (this.readyState !== XMLHttpRequest.OPENED) {
        throw new InvalidStateError("XHR readyState must be OPENED");
      }
      if (this._request) {
        throw new InvalidStateError("send() already called");
      }
      switch (this._url.protocol) {
        case 'file:':
          this._sendFile(data);
          break;
        case 'http:':
        case 'https:':
          this._sendHttp(data);
          break;
        default:
          throw new NetworkError("Unsupported protocol " + this._url.protocol);
      }
      return void 0;
    };

    XMLHttpRequest.prototype.abort = function() {
      if (!this._request) {
        return;
      }
      this._request.abort();
      this._setError();
      this._dispatchProgress('abort');
      this._dispatchProgress('loadend');
      return void 0;
    };

    XMLHttpRequest.prototype.getResponseHeader = function(name) {
      var loweredName;
      if (!this._responseHeaders) {
        return null;
      }
      loweredName = name.toLowerCase();
      if (loweredName in this._responseHeaders) {
        return this._responseHeaders[loweredName];
      } else {
        return null;
      }
    };

    XMLHttpRequest.prototype.getAllResponseHeaders = function() {
      var lines, name, value;
      if (!this._responseHeaders) {
        return '';
      }
      lines = (function() {
        var ref, results;
        ref = this._responseHeaders;
        results = [];
        for (name in ref) {
          value = ref[name];
          results.push(name + ": " + value);
        }
        return results;
      }).call(this);
      return lines.join("\r\n");
    };

    XMLHttpRequest.prototype.overrideMimeType = function(newMimeType) {
      if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {
        throw new InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
      }
      this._mimeOverride = newMimeType.toLowerCase();
      return void 0;
    };

    XMLHttpRequest.prototype.nodejsSet = function(options) {
      var baseUrl, parsedUrl;
      if ('httpAgent' in options) {
        this.nodejsHttpAgent = options.httpAgent;
      }
      if ('httpsAgent' in options) {
        this.nodejsHttpsAgent = options.httpsAgent;
      }
      if ('baseUrl' in options) {
        baseUrl = options.baseUrl;
        if (baseUrl !== null) {
          parsedUrl = url.parse(baseUrl, false, true);
          if (!parsedUrl.protocol) {
            throw new SyntaxError("baseUrl must be an absolute URL");
          }
        }
        this.nodejsBaseUrl = baseUrl;
      }
      return void 0;
    };

    XMLHttpRequest.nodejsSet = function(options) {
      XMLHttpRequest.prototype.nodejsSet(options);
      return void 0;
    };

    XMLHttpRequest.prototype.UNSENT = 0;

    XMLHttpRequest.UNSENT = 0;

    XMLHttpRequest.prototype.OPENED = 1;

    XMLHttpRequest.OPENED = 1;

    XMLHttpRequest.prototype.HEADERS_RECEIVED = 2;

    XMLHttpRequest.HEADERS_RECEIVED = 2;

    XMLHttpRequest.prototype.LOADING = 3;

    XMLHttpRequest.LOADING = 3;

    XMLHttpRequest.prototype.DONE = 4;

    XMLHttpRequest.DONE = 4;

    XMLHttpRequest.prototype.nodejsHttpAgent = http.globalAgent;

    XMLHttpRequest.prototype.nodejsHttpsAgent = https.globalAgent;

    XMLHttpRequest.prototype.nodejsBaseUrl = null;

    XMLHttpRequest.prototype._restrictedMethods = {
      CONNECT: true,
      TRACE: true,
      TRACK: true
    };

    XMLHttpRequest.prototype._restrictedHeaders = {
      'accept-charset': true,
      'accept-encoding': true,
      'access-control-request-headers': true,
      'access-control-request-method': true,
      connection: true,
      'content-length': true,
      cookie: true,
      cookie2: true,
      date: true,
      dnt: true,
      expect: true,
      host: true,
      'keep-alive': true,
      origin: true,
      referer: true,
      te: true,
      trailer: true,
      'transfer-encoding': true,
      upgrade: true,
      'user-agent': true,
      via: true
    };

    XMLHttpRequest.prototype._privateHeaders = {
      'set-cookie': true,
      'set-cookie2': true
    };

    XMLHttpRequest.prototype._userAgent = ("Mozilla/5.0 (" + (os.type()) + " " + (os.arch()) + ") ") + ("node.js/" + process.versions.node + " v8/" + process.versions.v8);

    XMLHttpRequest.prototype._setReadyState = function(newReadyState) {
      var event;
      this.readyState = newReadyState;
      event = new ProgressEvent('readystatechange');
      this.dispatchEvent(event);
      return void 0;
    };

    XMLHttpRequest.prototype._sendFile = function() {
      if (this._url.method !== 'GET') {
        throw new NetworkError('The file protocol only supports GET');
      }
      throw new Error("Protocol file: not implemented");
    };

    XMLHttpRequest.prototype._sendHttp = function(data) {
      if (this._sync) {
        throw new Error("Synchronous XHR processing not implemented");
      }
      if ((data != null) && (this._method === 'GET' || this._method === 'HEAD')) {
        console.warn("Discarding entity body for " + this._method + " requests");
        data = null;
      } else {
        data || (data = '');
      }
      this.upload._setData(data);
      this._finalizeHeaders();
      this._sendHxxpRequest();
      return void 0;
    };

    XMLHttpRequest.prototype._sendHxxpRequest = function() {
      var agent, hxxp, request;
      if (this._url.protocol === 'http:') {
        hxxp = http;
        agent = this.nodejsHttpAgent;
      } else {
        hxxp = https;
        agent = this.nodejsHttpsAgent;
      }
      request = hxxp.request({
        hostname: this._url.hostname,
        port: this._url.port,
        path: this._url.path,
        auth: this._url.auth,
        method: this._method,
        headers: this._headers,
        agent: agent
      });
      this._request = request;
      if (this.timeout) {
        request.setTimeout(this.timeout, (function(_this) {
          return function() {
            return _this._onHttpTimeout(request);
          };
        })(this));
      }
      request.on('response', (function(_this) {
        return function(response) {
          return _this._onHttpResponse(request, response);
        };
      })(this));
      request.on('error', (function(_this) {
        return function(error) {
          return _this._onHttpRequestError(request, error);
        };
      })(this));
      this.upload._startUpload(request);
      if (this._request === request) {
        this._dispatchProgress('loadstart');
      }
      return void 0;
    };

    XMLHttpRequest.prototype._finalizeHeaders = function() {
      this._headers['Connection'] = 'keep-alive';
      this._headers['Host'] = this._url.host;
      if (this._anonymous) {
        this._headers['Referer'] = 'about:blank';
      }
      this._headers['User-Agent'] = this._userAgent;
      this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
      return void 0;
    };

    XMLHttpRequest.prototype._onHttpResponse = function(request, response) {
      var lengthString;
      if (this._request !== request) {
        return;
      }
      switch (response.statusCode) {
        case 301:
        case 302:
        case 303:
        case 307:
        case 308:
          this._url = this._parseUrl(response.headers['location']);
          this._method = 'GET';
          if ('content-type' in this._loweredHeaders) {
            delete this._headers[this._loweredHeaders['content-type']];
            delete this._loweredHeaders['content-type'];
          }
          if ('Content-Type' in this._headers) {
            delete this._headers['Content-Type'];
          }
          delete this._headers['Content-Length'];
          this.upload._reset();
          this._finalizeHeaders();
          this._sendHxxpRequest();
          return;
      }
      this._response = response;
      this._response.on('data', (function(_this) {
        return function(data) {
          return _this._onHttpResponseData(response, data);
        };
      })(this));
      this._response.on('end', (function(_this) {
        return function() {
          return _this._onHttpResponseEnd(response);
        };
      })(this));
      this._response.on('close', (function(_this) {
        return function() {
          return _this._onHttpResponseClose(response);
        };
      })(this));
      this.responseURL = this._url.href.split('#')[0];
      this.status = this._response.statusCode;
      this.statusText = http.STATUS_CODES[this.status];
      this._parseResponseHeaders(response);
      if (lengthString = this._responseHeaders['content-length']) {
        this._totalBytes = parseInt(lengthString);
        this._lengthComputable = true;
      } else {
        this._lengthComputable = false;
      }
      return this._setReadyState(XMLHttpRequest.HEADERS_RECEIVED);
    };

    XMLHttpRequest.prototype._onHttpResponseData = function(response, data) {
      if (this._response !== response) {
        return;
      }
      this._responseParts.push(data);
      this._loadedBytes += data.length;
      if (this.readyState !== XMLHttpRequest.LOADING) {
        this._setReadyState(XMLHttpRequest.LOADING);
      }
      return this._dispatchProgress('progress');
    };

    XMLHttpRequest.prototype._onHttpResponseEnd = function(response) {
      if (this._response !== response) {
        return;
      }
      this._parseResponse();
      this._request = null;
      this._response = null;
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('load');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._onHttpResponseClose = function(response) {
      var request;
      if (this._response !== response) {
        return;
      }
      request = this._request;
      this._setError();
      request.abort();
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('error');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._onHttpTimeout = function(request) {
      if (this._request !== request) {
        return;
      }
      this._setError();
      request.abort();
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('timeout');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._onHttpRequestError = function(request, error) {
      if (this._request !== request) {
        return;
      }
      this._setError();
      request.abort();
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('error');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._dispatchProgress = function(eventType) {
      var event;
      event = new ProgressEvent(eventType);
      event.lengthComputable = this._lengthComputable;
      event.loaded = this._loadedBytes;
      event.total = this._totalBytes;
      this.dispatchEvent(event);
      return void 0;
    };

    XMLHttpRequest.prototype._setError = function() {
      this._request = null;
      this._response = null;
      this._responseHeaders = null;
      this._responseParts = null;
      return void 0;
    };

    XMLHttpRequest.prototype._parseUrl = function(urlString) {
      var absoluteUrlString, index, password, user, xhrUrl;
      if (this.nodejsBaseUrl === null) {
        absoluteUrlString = urlString;
      } else {
        absoluteUrlString = url.resolve(this.nodejsBaseUrl, urlString);
      }
      xhrUrl = url.parse(absoluteUrlString, false, true);
      xhrUrl.hash = null;
      if (xhrUrl.auth && ((typeof user !== "undefined" && user !== null) || (typeof password !== "undefined" && password !== null))) {
        index = xhrUrl.auth.indexOf(':');
        if (index === -1) {
          if (!user) {
            user = xhrUrl.auth;
          }
        } else {
          if (!user) {
            user = xhrUrl.substring(0, index);
          }
          if (!password) {
            password = xhrUrl.substring(index + 1);
          }
        }
      }
      if (user || password) {
        xhrUrl.auth = user + ":" + password;
      }
      return xhrUrl;
    };

    XMLHttpRequest.prototype._parseResponseHeaders = function(response) {
      var loweredName, name, ref, value;
      this._responseHeaders = {};
      ref = response.headers;
      for (name in ref) {
        value = ref[name];
        loweredName = name.toLowerCase();
        if (this._privateHeaders[loweredName]) {
          continue;
        }
        if (this._mimeOverride !== null && loweredName === 'content-type') {
          value = this._mimeOverride;
        }
        this._responseHeaders[loweredName] = value;
      }
      if (this._mimeOverride !== null && !('content-type' in this._responseHeaders)) {
        this._responseHeaders['content-type'] = this._mimeOverride;
      }
      return void 0;
    };

    XMLHttpRequest.prototype._parseResponse = function() {
      var arrayBuffer, buffer, i, j, jsonError, ref, view;
      if (Buffer.concat) {
        buffer = Buffer.concat(this._responseParts);
      } else {
        buffer = this._concatBuffers(this._responseParts);
      }
      this._responseParts = null;
      switch (this.responseType) {
        case 'text':
          this._parseTextResponse(buffer);
          break;
        case 'json':
          this.responseText = null;
          try {
            this.response = JSON.parse(buffer.toString('utf-8'));
          } catch (error1) {
            jsonError = error1;
            this.response = null;
          }
          break;
        case 'buffer':
          this.responseText = null;
          this.response = buffer;
          break;
        case 'arraybuffer':
          this.responseText = null;
          arrayBuffer = new ArrayBuffer(buffer.length);
          view = new Uint8Array(arrayBuffer);
          for (i = j = 0, ref = buffer.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            view[i] = buffer[i];
          }
          this.response = arrayBuffer;
          break;
        default:
          this._parseTextResponse(buffer);
      }
      return void 0;
    };

    XMLHttpRequest.prototype._parseTextResponse = function(buffer) {
      var e;
      try {
        this.responseText = buffer.toString(this._parseResponseEncoding());
      } catch (error1) {
        e = error1;
        this.responseText = buffer.toString('binary');
      }
      this.response = this.responseText;
      return void 0;
    };

    XMLHttpRequest.prototype._parseResponseEncoding = function() {
      var contentType, encoding, match;
      encoding = null;
      if (contentType = this._responseHeaders['content-type']) {
        if (match = /\;\s*charset\=(.*)$/.exec(contentType)) {
          return match[1];
        }
      }
      return 'utf-8';
    };

    XMLHttpRequest.prototype._concatBuffers = function(buffers) {
      var buffer, j, k, len, len1, length, target;
      if (buffers.length === 0) {
        return new Buffer(0);
      }
      if (buffers.length === 1) {
        return buffers[0];
      }
      length = 0;
      for (j = 0, len = buffers.length; j < len; j++) {
        buffer = buffers[j];
        length += buffer.length;
      }
      target = new Buffer(length);
      length = 0;
      for (k = 0, len1 = buffers.length; k < len1; k++) {
        buffer = buffers[k];
        buffer.copy(target, length);
        length += buffer.length;
      }
      return target;
    };

    return XMLHttpRequest;

  })(XMLHttpRequestEventTarget);

  module.exports = XMLHttpRequest;

  XMLHttpRequest.XMLHttpRequest = XMLHttpRequest;

  SecurityError = (function(superClass) {
    extend(SecurityError, superClass);

    function SecurityError() {
      SecurityError.__super__.constructor.apply(this, arguments);
    }

    return SecurityError;

  })(Error);

  XMLHttpRequest.SecurityError = SecurityError;

  InvalidStateError = (function(superClass) {
    extend(InvalidStateError, superClass);

    function InvalidStateError() {
      InvalidStateError.__super__.constructor.apply(this, arguments);
    }

    return InvalidStateError;

  })(Error);

  InvalidStateError = (function(superClass) {
    extend(InvalidStateError, superClass);

    function InvalidStateError() {
      return InvalidStateError.__super__.constructor.apply(this, arguments);
    }

    return InvalidStateError;

  })(Error);

  XMLHttpRequest.InvalidStateError = InvalidStateError;

  NetworkError = (function(superClass) {
    extend(NetworkError, superClass);

    function NetworkError() {
      NetworkError.__super__.constructor.apply(this, arguments);
    }

    return NetworkError;

  })(Error);

  XMLHttpRequest.SyntaxError = SyntaxError;

  SyntaxError = (function(superClass) {
    extend(SyntaxError, superClass);

    function SyntaxError() {
      SyntaxError.__super__.constructor.apply(this, arguments);
    }

    return SyntaxError;

  })(Error);

  ProgressEvent = (function() {
    function ProgressEvent(type) {
      this.type = type;
      this.target = null;
      this.currentTarget = null;
      this.lengthComputable = false;
      this.loaded = 0;
      this.total = 0;
    }

    ProgressEvent.prototype.bubbles = false;

    ProgressEvent.prototype.cancelable = false;

    ProgressEvent.prototype.target = null;

    ProgressEvent.prototype.loaded = null;

    ProgressEvent.prototype.lengthComputable = null;

    ProgressEvent.prototype.total = null;

    return ProgressEvent;

  })();

  XMLHttpRequest.ProgressEvent = ProgressEvent;

  XMLHttpRequestUpload = (function(superClass) {
    extend(XMLHttpRequestUpload, superClass);

    function XMLHttpRequestUpload(request) {
      XMLHttpRequestUpload.__super__.constructor.call(this);
      this._request = request;
      this._reset();
    }

    XMLHttpRequestUpload.prototype._reset = function() {
      this._contentType = null;
      this._body = null;
      return void 0;
    };

    XMLHttpRequestUpload.prototype._setData = function(data) {
      var body, i, j, k, offset, ref, ref1, view;
      if (typeof data === 'undefined' || data === null) {
        return;
      }
      if (typeof data === 'string') {
        if (data.length !== 0) {
          this._contentType = 'text/plain;charset=UTF-8';
        }
        this._body = new Buffer(data, 'utf8');
      } else if (Buffer.isBuffer(data)) {
        this._body = data;
      } else if (data instanceof ArrayBuffer) {
        body = new Buffer(data.byteLength);
        view = new Uint8Array(data);
        for (i = j = 0, ref = data.byteLength; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          body[i] = view[i];
        }
        this._body = body;
      } else if (data.buffer && data.buffer instanceof ArrayBuffer) {
        body = new Buffer(data.byteLength);
        offset = data.byteOffset;
        view = new Uint8Array(data.buffer);
        for (i = k = 0, ref1 = data.byteLength; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
          body[i] = view[i + offset];
        }
        this._body = body;
      } else {
        throw new Error("Unsupported send() data " + data);
      }
      return void 0;
    };

    XMLHttpRequestUpload.prototype._finalizeHeaders = function(headers, loweredHeaders) {
      if (this._contentType) {
        if (!('content-type' in loweredHeaders)) {
          headers['Content-Type'] = this._contentType;
        }
      }
      if (this._body) {
        headers['Content-Length'] = this._body.length.toString();
      }
      return void 0;
    };

    XMLHttpRequestUpload.prototype._startUpload = function(request) {
      if (this._body) {
        request.write(this._body);
      }
      request.end();
      return void 0;
    };

    return XMLHttpRequestUpload;

  })(XMLHttpRequestEventTarget);

  XMLHttpRequest.XMLHttpRequestUpload = XMLHttpRequestUpload;

}).call(this);


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(24);

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(3);

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(44);

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(56);

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(74);

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(75);

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(76);

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(0))(92);

/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 98 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ })
/******/ ])));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMDQ2NzdiZGJkNGEyMjE4YjhiMTciLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiLi92ZW5kb3JcIiIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kb21pbm8vbGliL05vZGUuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL2J1bmRsZXMvY29yZS51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy8uL34vZG9taW5vL2xpYi9FbGVtZW50LmpzIiwid2VicGFjazovLy8uL34vZG9taW5vL2xpYi9FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvQ2hhcmFjdGVyRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvRE9NSW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9kb21pbm8vbGliL05vZGVGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kb21pbm8vbGliL05vZGVMaXN0LmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL2J1bmRsZXMvY29tbW9uLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vLy4vfi9kb21pbm8vbGliL0NTU1N0eWxlRGVjbGFyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9kb21pbm8vbGliL0NoaWxkTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvRG9jdW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kb21pbm8vbGliL0RvY3VtZW50VHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvSFRNTFBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvVVJMLmpzIiwid2VicGFjazovLy8uL34vZG9taW5vL2xpYi9XaW5kb3cuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kb21pbm8vbGliL2h0bWxlbHRzLmpzIiwid2VicGFjazovLy8uL34vZG9taW5vL2xpYi9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kb21pbm8vbGliL3htbG5hbWVzLmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9PYnNlcnZhYmxlLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnVuZGxlcy9hbmltYXRpb25zLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9odHRwL2J1bmRsZXMvaHR0cC51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy8uL34vQGFuZ3VsYXIvcGxhdGZvcm0tc2VydmVyL2J1bmRsZXMvcGxhdGZvcm0tc2VydmVyLnVtZC5qcyIsIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnVuZGxlcy9hbmltYXRpb25zLWJyb3dzZXIudW1kLmpzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9hcHAvYXBwLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvQ29tbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvRE9NRXhjZXB0aW9uLmpzIiwid2VicGFjazovLy8uL34vZG9taW5vL2xpYi9ET01Ub2tlbkxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kb21pbm8vbGliL0RvY3VtZW50RnJhZ21lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kb21pbm8vbGliL0V2ZW50VGFyZ2V0LmpzIiwid2VicGFjazovLy8uL34vZG9taW5vL2xpYi9MZWFmLmpzIiwid2VicGFjazovLy8uL34vZG9taW5vL2xpYi9Nb3VzZUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vZG9taW5vL2xpYi9Ob2RlVHJhdmVyc2FsLmpzIiwid2VicGFjazovLy8uL34vZG9taW5vL2xpYi9Ob25Eb2N1bWVudFR5cGVDaGlsZE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kb21pbm8vbGliL1Byb2Nlc3NpbmdJbnN0cnVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvVUlFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvVVJMVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kb21pbm8vbGliL2F0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kb21pbm8vbGliL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvZGVmaW5lRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL34vZG9taW5vL2xpYi9pbXBsLmpzIiwid2VicGFjazovLy8uL34vZG9taW5vL2xpYi9zbG9wcHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kb21pbm8vbGliL3N2Zy5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYnVuZGxlcy9wbGF0Zm9ybS1icm93c2VyLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2ZpcnN0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1cmxcIiIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2FwcC5zZXJ2ZXIubW9kdWxlLnRzIiwid2VicGFjazovLy8uL34vcmVmbGVjdC1tZXRhZGF0YS9SZWZsZWN0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvZmlyc3QuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9hc3BuZXQtcHJlcmVuZGVyaW5nL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3pvbmUuanMvZGlzdC96b25lLW5vZGUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy8uL34vQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9idW5kbGVzL3BsYXRmb3JtLWJyb3dzZXItYW5pbWF0aW9ucy51bWQuanMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9hcHAuc2hhcmVkLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvY291bnRlci9jb3VudGVyLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvZmV0Y2hkYXRhL2ZldGNoZGF0YS5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2hvbWUvaG9tZS5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL25hdm1lbnUvbmF2bWVudS5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL3ZlaGljbGUtZm9ybS92ZWhpY2xlLWZvcm0uY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9ib290LnNlcnZlci50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvYXBwL2FwcC5jb21wb25lbnQuY3NzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9uYXZtZW51L25hdm1lbnUuY29tcG9uZW50LmNzcyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvdmVoaWNsZS1mb3JtL3ZlaGljbGUtZm9ybS5jb21wb25lbnQuY3NzIiwid2VicGFjazovLy8uL34vZG9taW5vL2xpYi9DdXN0b21FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvRmlsdGVyZWRFbGVtZW50TGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvTG9jYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9kb21pbm8vbGliL011dGF0aW9uQ29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL34vZG9taW5vL2xpYi9OYXZpZ2F0b3JJRC5qcyIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvTm9kZUl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vZG9taW5vL2xpYi9UcmVlV2Fsa2VyLmpzIiwid2VicGFjazovLy8uL34vZG9taW5vL2xpYi9XaW5kb3dUaW1lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kb21pbm8vbGliL2Nzc3BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2RvbWluby9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2FwcC9hcHAuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2NvdW50ZXIvY291bnRlci5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvZmV0Y2hkYXRhL2ZldGNoZGF0YS5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvaG9tZS9ob21lLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9uYXZtZW51L25hdm1lbnUuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL3ZlaGljbGUtZm9ybS92ZWhpY2xlLWZvcm0uY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3RvUHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvYXBwL2FwcC5jb21wb25lbnQuY3NzP2RkYzMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL25hdm1lbnUvbmF2bWVudS5jb21wb25lbnQuY3NzPzlmNjQiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL3ZlaGljbGUtZm9ybS92ZWhpY2xlLWZvcm0uY29tcG9uZW50LmNzcz8xMWI0Iiwid2VicGFjazovLy8uL34veGhyMi9saWIveGhyMi5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2Zvcm1zL2J1bmRsZXMvZm9ybXMudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvU3ViamVjdC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9idW5kbGVzL2NvbXBpbGVyLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2ZpbHRlci5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9tYXRlcmlhbC9idW5kbGVzL21hdGVyaWFsLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMvYnVuZGxlcy9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3JvdXRlci9idW5kbGVzL3JvdXRlci51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL2J1bmRsZXMvY29tbW9uLWh0dHAudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiaHR0cHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJvc1wiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2hFQSxxQzs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDRDQUE0QztBQUNqRiw0Q0FBNEMsbURBQW1EO0FBQy9GLHlDQUF5QyxnREFBZ0Q7QUFDekYsNENBQTRDLG1EQUFtRDtBQUMvRixpREFBaUQseURBQXlEO0FBQzFHLG9DQUFvQywyQ0FBMkM7QUFDL0Usd0NBQXdDLCtDQUErQztBQUN2Rix3Q0FBd0MsK0NBQStDO0FBQ3ZGLGtDQUFrQyx3Q0FBd0M7QUFDMUUsK0NBQStDLHNEQUFzRDtBQUNyRyxxQ0FBcUMsMkNBQTJDO0FBQ2hGLHlDQUF5QyxnREFBZ0Q7QUFDekYsd0NBQXdDLCtDQUErQztBQUN2RixvQ0FBb0MsMENBQTBDO0FBQzlFLG1DQUFtQyx5Q0FBeUM7QUFDNUUsaUNBQWlDLHVDQUF1QztBQUN4RSx1Q0FBdUMsOENBQThDO0FBQ3JGLHlDQUF5QyxnREFBZ0Q7QUFDekYsbUNBQW1DLHlDQUF5QztBQUM1RSwyQ0FBMkMsbURBQW1EO0FBQzlGLHFDQUFxQyw0Q0FBNEM7O0FBRWpGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMseUNBQXlDO0FBQ3BGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLHdCQUF3QixFQUFFO0FBQ3JFOzs7Ozs7OztBQ3hFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxlQUFlLDhCQUE4Qjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7O0FBRTdCLGtCQUFrQjtBQUNsQjtBQUNBLElBQUk7O0FBRUosa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBLElBQUk7O0FBRUosZUFBZTtBQUNmO0FBQ0EsSUFBSTs7QUFFSixjQUFjO0FBQ2Q7QUFDQSxJQUFJOztBQUVKLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSix5QkFBeUI7QUFDekI7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsSUFBSTs7QUFFSixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLElBQUk7O0FBRUosZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLGFBQWE7QUFDYix3QkFBd0IsY0FBYztBQUN0Qyx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDLGlCQUFpQixZQUFZO0FBQzdCLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosZUFBZTtBQUNmO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLEdBQUc7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsb0JBQW9CO0FBQ3BCO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsNEJBQTRCO0FBQzVCO0FBQ0EsdUJBQXVCLEdBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7OztBQUdKO0FBQ0EsV0FBVztBQUNYO0FBQ0EsSUFBSTs7QUFFSixjQUFjO0FBQ2QsaUJBQWlCLDRCQUE0QjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQsZ0NBQWdDLHdCQUF3QjtBQUN4RCxnQ0FBZ0MsbUJBQW1CO0FBQ25ELGdDQUFnQyw0QkFBNEI7QUFDNUQsZ0NBQWdDLCtCQUErQjtBQUMvRCxnQ0FBZ0MscUJBQXFCO0FBQ3JELGdDQUFnQyxxQ0FBcUM7QUFDckUsZ0NBQWdDLHNCQUFzQjtBQUN0RCxnQ0FBZ0MsdUJBQXVCO0FBQ3ZELGdDQUFnQyw0QkFBNEI7QUFDNUQsZ0NBQWdDLGdDQUFnQztBQUNoRSxnQ0FBZ0M7QUFDaEMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixpQ0FBaUM7QUFDakM7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQyxxQ0FBcUM7QUFDckM7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzcxQkEsNkM7Ozs7Ozs7QUNBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQyxzQkFBc0I7O0FBRXRCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCLHFCQUFxQixHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVILGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0osc0JBQXNCO0FBQ3RCO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixxQkFBcUI7QUFDckI7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLHNCQUFzQjtBQUN0QjtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUosMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxJQUFJOztBQUVKLHNCQUFzQjtBQUN0QjtBQUNBLElBQUk7O0FBRUo7QUFDQSxXQUFXLDhCQUE4Qjs7QUFFekM7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUosWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxHQUFHO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EsSUFBSTs7QUFFSixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLElBQUk7O0FBRUosaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxJQUFJOztBQUVKLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxJQUFJOztBQUVKO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSixvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsY0FBYyxrQkFBa0IsOEJBQThCLEdBQUc7QUFDakU7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVzs7QUFFdEM7QUFDQTtBQUNBLGtDQUFrQyxjQUFjOztBQUVoRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixZQUFZO0FBQ1o7QUFDQSxJQUFJOztBQUVKLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLGtCQUFrQjtBQUNsQjtBQUNBLElBQUk7O0FBRUoscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGtCQUFrQixrQkFBa0IsRUFBRTtBQUN0QyxtQkFBbUIsbUJBQW1CLEVBQUU7QUFDeEMscUJBQXFCLG1CQUFtQixFQUFFO0FBQzFDLG9CQUFvQixnQkFBZ0IsRUFBRTtBQUN0QyxzQkFBc0IsZ0JBQWdCLEVBQUU7QUFDeEM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQiw4QkFBOEI7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ240QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLG9CQUFvQjtBQUNwQjtBQUNBLElBQUk7O0FBRUosNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxJQUFJOztBQUVKLG1CQUFtQjtBQUNuQjtBQUNBLElBQUk7O0FBRUosY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLENBQUM7Ozs7Ozs7O0FDakVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxJQUFJOztBQUVKLFdBQVcsa0JBQWtCLHlCQUF5Qjs7QUFFdEQsQ0FBQzs7QUFFRDtBQUNBOzs7Ozs7OztBQ3pIQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFDQUFxQztBQUMvQyxXQUFXLHdCQUF3QjtBQUNuQyxXQUFXLG9DQUFvQztBQUMvQyxZQUFZLG9DQUFvQztBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7Ozs7Ozs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDdkJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1pBLDZDOzs7Ozs7O0FDQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNILHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1COztBQUVuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBLHFCQUFxQjtBQUNyQiw2QkFBNkI7QUFDN0I7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLElBQUk7O0FBRUosd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxJQUFJOztBQUVKLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUoscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSTs7QUFFSix3QkFBd0I7QUFDeEI7QUFDQSxJQUFJOztBQUVKLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7QUNsVEE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEMsa0NBQWtDO0FBQ2xDLG1EQUFtRCx3QkFBd0IsRUFBRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QyxrQ0FBa0M7QUFDbEMsbURBQW1ELHdCQUF3QixFQUFFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDLGtDQUFrQztBQUNsQyxtREFBbUQsd0JBQXdCLEVBQUU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7Ozs7Ozs7O0FDaEdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0EsZ0JBQWdCLGlDQUFpQztBQUNqRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBLElBQUk7QUFDSixlQUFlLGNBQWM7O0FBRTdCLG1CQUFtQjtBQUNuQjtBQUNBLElBQUk7QUFDSixrQkFBa0I7QUFDbEI7QUFDQSxJQUFJO0FBQ0osMkJBQTJCO0FBQzNCO0FBQ0EsSUFBSTtBQUNKLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxHQUFHLDJCQUEyQjs7QUFFOUIsb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRywyQkFBMkI7O0FBRTlCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0Esc0JBQXNCLDZDQUE2QztBQUNuRSx5QkFBeUIsZ0RBQWdEO0FBQ3pFLDJCQUEyQixrREFBa0Q7QUFDN0UsMkJBQTJCLGtEQUFrRDs7QUFFN0UsY0FBYztBQUNkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKLGVBQWU7QUFDZjtBQUNBLEdBQUcsMkJBQTJCOztBQUU5QjtBQUNBLFFBQVEsaUJBQWlCO0FBQ3pCLFdBQVcsaUNBQWlDO0FBQzVDLGFBQWEsaUJBQWlCO0FBQzlCLFdBQVcsaUNBQWlDO0FBQzVDLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCxFQUFFO0FBQ0Y7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0RBQXdELG9CQUFvQjtBQUM1RSxHQUFHO0FBQ0gsa0NBQWtDLGtCQUFrQixFQUFFO0FBQ3RELG9DQUFvQyxrQkFBa0IsRUFBRTtBQUN4RCxxQ0FBcUMsa0JBQWtCLEVBQUU7QUFDekQscUNBQXFDLGtCQUFrQixFQUFFO0FBQ3pELGtDQUFrQyxrQkFBa0IsRUFBRTs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBLFNBQVM7QUFDVDtBQUNBLElBQUk7QUFDSixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QixZQUFZLGlCQUFpQjtBQUM3QixVQUFVLGlCQUFpQjtBQUMzQixVQUFVLGlCQUFpQjtBQUMzQixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBLHFCQUFxQix5QkFBeUIsRUFBRTtBQUNoRDtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQix5QkFBeUIsRUFBRTtBQUNoRDtBQUNBLEdBQUc7O0FBRUgsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUosWUFBWTtBQUNaO0FBQ0EsSUFBSTs7QUFFSixTQUFTO0FBQ1Q7QUFDQSxJQUFJOztBQUVKLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLElBQUk7O0FBRUosWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7O0FBRUo7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7OztBQUdKO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixhQUFhO0FBQ2I7QUFDQTtBQUNBLElBQUk7O0FBRUoscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLElBQUk7O0FBRUosaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosa0JBQWtCO0FBQ2xCO0FBQ0EsSUFBSTs7QUFFSixxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzN4QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtCQUFrQixrQkFBa0IsR0FBRztBQUNwRDtBQUNBLHFCQUFxQixhQUFhLEVBQUU7QUFDcEM7QUFDQSxHQUFHOztBQUVIO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsSUFBSTs7QUFFSixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOzs7Ozs7OztBQ3JDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LFNBQVMsR0FBRyxRQUFRLElBQUksU0FBUyxNQUFNLGFBQWEsS0FBSyxXQUFXLGVBQWUsU0FBUyxPQUFPLFFBQVEsSUFBSSxXQUFXLFFBQVEsSUFBSSxXQUFXLE1BQU0sVUFBVSxHQUFHLE9BQU8sYUFBYSxHQUFHLFFBQVEsS0FBSyxNQUFNLE9BQU8sR0FBRyxNQUFNLE1BQU0sYUFBYSxLQUFLLElBQUksVUFBVSxNQUFNLE9BQU8sV0FBVyxLQUFLLGtCQUFrQixJQUFJLFFBQVEsS0FBSyxPQUFPLFFBQVEsc0JBQXNCLFFBQVEsYUFBYSxNQUFNLE1BQU0sT0FBTyxNQUFNLFlBQVksR0FBRyxLQUFLLE1BQU0sV0FBVyxNQUFNLEtBQUssU0FBUyxNQUFNLEtBQUssT0FBTyxXQUFXLEdBQUcsR0FBRyxHQUFHLE9BQU8sR0FBRyxHQUFHLEdBQUcsR0FBRyxRQUFRLEdBQUcsR0FBRyxHQUFHLE9BQU8sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsTUFBTSxPQUFPLEdBQUcsR0FBRyxHQUFHLE9BQU8sR0FBRyxHQUFHLEdBQUcsR0FBRyxRQUFRLE1BQU0sT0FBTyxPQUFPLEdBQUcsR0FBRyxHQUFHLE9BQU8sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsVUFBVSxTQUFTLE1BQU0sVUFBVSxLQUFLLE9BQU8sR0FBRyxRQUFRLEdBQUcsTUFBTSxhQUFhLElBQUksUUFBUSxHQUFHLE1BQU0sR0FBRyxrQkFBa0IsTUFBTSxLQUFLLE9BQU8sUUFBUSxJQUFJLE1BQU0sR0FBRyxTQUFTLElBQUksY0FBYyxLQUFLLE9BQU8sTUFBTSxRQUFRLElBQUksT0FBTyxTQUFTLFFBQVEsT0FBTyxPQUFPLE9BQU8sUUFBUSxRQUFRLE1BQU0sSUFBSSxRQUFRLEdBQUcsTUFBTSxJQUFJLG1CQUFtQixPQUFPLFFBQVEsR0FBRyxLQUFLLE1BQU0sTUFBTSxNQUFNLE9BQU8sS0FBSyxNQUFNLFVBQVUsS0FBSyxhQUFhLE1BQU0sR0FBRyxhQUFhLEdBQUcsT0FBTyxJQUFJLFdBQVcsS0FBSyxhQUFhLEtBQUssTUFBTSxRQUFRLEtBQUssTUFBTSxJQUFJLGFBQWEsS0FBSyxTQUFTLFVBQVUsR0FBRyxPQUFPLEdBQUcsU0FBUyxjQUFjLEdBQUcsU0FBUyxJQUFJLFVBQVUsR0FBRyxPQUFPLE9BQU8sUUFBUSxJQUFJLE1BQU0sSUFBSSxHQUFHLGFBQWEsR0FBRyxpQkFBaUIsTUFBTSxNQUFNLE9BQU8sTUFBTSxpQkFBaUIsT0FBTyxPQUFPLEtBQUssYUFBYSxLQUFLLFFBQVEsVUFBVSxLQUFLLFVBQVUsTUFBTSxJQUFJLE9BQU8sR0FBRyxhQUFhLEtBQUssV0FBVyxHQUFHLE9BQU8sVUFBVSxJQUFJLFFBQVEsUUFBUSxNQUFNLE9BQU8sV0FBVyxHQUFHLFVBQVUsR0FBRyxZQUFZLFFBQVEsTUFBTSxJQUFJLElBQUksT0FBTyxLQUFLLE1BQU0sUUFBUSxTQUFTLE9BQU8sT0FBTyxVQUFVLEtBQUssV0FBVyxJQUFJLE1BQU0sT0FBTyxLQUFLLFFBQVEsTUFBTSxRQUFRLGVBQWUsWUFBWSxZQUFZLGdCQUFnQixPQUFPLGVBQWUsU0FBUyxLQUFLLGFBQWEsR0FBRyxLQUFLLE1BQU0sVUFBVSxPQUFPLEdBQUcsV0FBVyxLQUFLLFNBQVMsUUFBUSxRQUFRLGVBQWUsSUFBSSxXQUFXLE9BQU8sV0FBVyxPQUFPLEdBQUcsUUFBUSxHQUFHLE1BQU0sR0FBRyxTQUFTLEdBQUcsT0FBTyxNQUFNLE9BQU8sS0FBSyxRQUFRLFFBQVEsR0FBRyxNQUFNLEtBQUssV0FBVyxRQUFRLEtBQUssR0FBRyxhQUFhLEdBQUcsR0FBRyxTQUFTLElBQUksVUFBVSxJQUFJLFlBQVksSUFBSSxNQUFNLE9BQU8sS0FBSyxHQUFHLGVBQWUsTUFBTSxTQUFTLFlBQVksTUFBTSxXQUFXLEtBQUssT0FBTyxJQUFJLFVBQVUsVUFBVSxLQUFLLFNBQVMsS0FBSyxJQUFJLFFBQVEsR0FBRyxVQUFVLEtBQUssU0FBUyxLQUFLLGNBQWMsV0FBVyxxQkFBcUIsSUFBSSxPQUFPLFVBQVUsUUFBUSxLQUFLLElBQUksT0FBTyxNQUFNLFFBQVEsS0FBSyxLQUFLLE1BQU0sUUFBUSxTQUFTLE1BQU0sR0FBRyxZQUFZLG1CQUFtQixJQUFJLEdBQUcsSUFBSSxHQUFHLEdBQUcsUUFBUSxHQUFHLFFBQVEsSUFBSSxHQUFHLEtBQUssT0FBTyxHQUFHLEtBQUssS0FBSyxNQUFNLE1BQU0sV0FBVyxHQUFHLFdBQVcsUUFBUSxHQUFHLElBQUksUUFBUSxTQUFTLEdBQUcsTUFBTSxNQUFNLEdBQUcsTUFBTSxHQUFHLE9BQU8sT0FBTyxJQUFJLFFBQVEsTUFBTSxHQUFHLFFBQVEsSUFBSSxPQUFPLE1BQU0sR0FBRyxPQUFPLEtBQUssTUFBTSxHQUFHLEdBQUcsR0FBRyxRQUFRLE9BQU8sTUFBTSxPQUFPLE1BQU0sR0FBRyxPQUFPLE1BQU0sTUFBTSxRQUFRLE9BQU8sR0FBRyxHQUFHLFFBQVEsT0FBTyxJQUFJLE1BQU0sTUFBTSxPQUFPLGVBQWUsSUFBSSxNQUFNLFdBQVcsT0FBTyxPQUFPLEtBQUssZ0JBQWdCLElBQUksV0FBVyxVQUFVLElBQUksTUFBTSxTQUFTLE1BQU0sS0FBSyxHQUFHLFFBQVEsTUFBTSxhQUFhLEtBQUssT0FBTyxNQUFNLEtBQUssWUFBWSxPQUFPLFVBQVUsTUFBTSxnQkFBZ0IsWUFBWSxLQUFLLE1BQU0sU0FBUyxNQUFNLE1BQU0sV0FBVyxNQUFNLGFBQWEsT0FBTyxLQUFLLElBQUksU0FBUyxLQUFLLFNBQVMsR0FBRyxRQUFRLE9BQU8sU0FBUyxJQUFJLE9BQU8sS0FBSyxPQUFPLFlBQVksT0FBTyxNQUFNLE1BQU0sS0FBSyxLQUFLLEtBQUssT0FBTyxNQUFNLFFBQVEsS0FBSyxPQUFPLE1BQU0sS0FBSyxVQUFVLE1BQU0sUUFBUSxNQUFNLFVBQVUsS0FBSyxJQUFJLElBQUksT0FBTyxPQUFPLFNBQVMsT0FBTyxHQUFHLEtBQUssTUFBTSxHQUFHLElBQUksUUFBUSxNQUFNLFVBQVUsSUFBSSxnQkFBZ0IsR0FBRyxLQUFLLE1BQU0sS0FBSyxRQUFRLE1BQU0sT0FBTyxjQUFjLEdBQUcsV0FBVyxHQUFHLEtBQUssT0FBTyxLQUFLLEtBQUssS0FBSyxLQUFLLGNBQWMsSUFBSSxNQUFNLE9BQU8sTUFBTSxHQUFHLE1BQU0sVUFBVSxRQUFRLE1BQU0sTUFBTSxPQUFPLEdBQUcsSUFBSSxJQUFJLEtBQUssUUFBUSxNQUFNLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLElBQUksT0FBTyxLQUFLLE1BQU0sR0FBRyxZQUFZLEtBQUssWUFBWSxHQUFHLFFBQVEsUUFBUSxHQUFHLGNBQWMsU0FBUyxJQUFJLEtBQUssR0FBRyxTQUFTLFFBQVEsR0FBRyxXQUFXLE9BQU8sS0FBSyxPQUFPLGVBQWUsTUFBTSxpQkFBaUIsSUFBSSxhQUFhLGtCQUFrQixHQUFHLFdBQVcsWUFBWSxhQUFhLElBQUksTUFBTSxHQUFHLE9BQU8sT0FBTyxJQUFJLFFBQVEsTUFBTSxHQUFHLFFBQVEsSUFBSSxhQUFhLEtBQUssVUFBVSxNQUFNLE1BQU0sS0FBSyxhQUFhLE1BQU0sR0FBRyxPQUFPLEdBQUcsYUFBYSxNQUFNLEdBQUcsT0FBTyxNQUFNLE1BQU0sS0FBSyxRQUFRLE1BQU0sS0FBSyxXQUFXLFNBQVMsTUFBTSxTQUFTLE9BQU8sTUFBTSxPQUFPLE1BQU0sR0FBRyxPQUFPLGFBQWEsSUFBSSxNQUFNLG1CQUFtQixZQUFZLFNBQVMsWUFBWSxpQkFBaUIsT0FBTyxTQUFTLEdBQUcsS0FBSyxRQUFRLFNBQVMsS0FBSyxPQUFPLE1BQU0sR0FBRyxVQUFVLElBQUksVUFBVSxRQUFRLFFBQVEsR0FBRyxJQUFJLEtBQUssV0FBVyxJQUFJLEdBQUcsT0FBTyxHQUFHLEdBQUcsUUFBUSxPQUFPLEdBQUcsUUFBUSxPQUFPLE9BQU8sSUFBSSxNQUFNLE1BQU0sTUFBTSxNQUFNLE9BQU8sU0FBUyxNQUFNLEdBQUcsR0FBRyxnQkFBZ0IsTUFBTSxjQUFjLElBQUksWUFBWSxRQUFRLFFBQVEsTUFBTSxLQUFLLFFBQVEsUUFBUSxNQUFNLE1BQU0sSUFBSSxRQUFRLFdBQVcsR0FBRyxPQUFPLGNBQWMsSUFBSSxJQUFJLFNBQVMsT0FBTyxLQUFLLEtBQUssS0FBSyxVQUFVLEdBQUcsTUFBTSxHQUFHLFdBQVcsSUFBSSxRQUFRLFVBQVUsSUFBSSxJQUFJLFFBQVEsTUFBTSxPQUFPLFFBQVEsS0FBSyxhQUFhLE1BQU0sR0FBRyxtQkFBbUIsWUFBWSxJQUFJLE1BQU0sR0FBRyxjQUFjLFVBQVUsTUFBTSxVQUFVLE1BQU0sSUFBSSxNQUFNLEdBQUcsSUFBSSxJQUFJLE1BQU0sU0FBUyxPQUFPLEdBQUcsV0FBVyxTQUFTLEdBQUcsYUFBYSxLQUFLLE9BQU8sUUFBUSxLQUFLLEtBQUssR0FBRyxPQUFPLE1BQU0sS0FBSyxTQUFTLE1BQU0sSUFBSSxPQUFPLE1BQU0sU0FBUyxJQUFJLFVBQVUsR0FBRyxNQUFNLE9BQU8sTUFBTSxNQUFNLEdBQUcsT0FBTyxJQUFJLE1BQU0sTUFBTSxHQUFHLFdBQVcsS0FBSyxLQUFLLE9BQU8sTUFBTSxHQUFHLElBQUksTUFBTSxTQUFTLEdBQUcsS0FBSyxJQUFJLE1BQU0sWUFBWSxZQUFZLE9BQU8sR0FBRyxPQUFPLE9BQU8sR0FBRyxPQUFPLE1BQU0sT0FBTyxHQUFHLFFBQVEsUUFBUSxNQUFNLE9BQU8sR0FBRyxLQUFLLE9BQU8sR0FBRyxHQUFHLFNBQVMsT0FBTyxHQUFHLEdBQUcsZ0JBQWdCLE9BQU8sSUFBSSxHQUFHLFFBQVEsTUFBTSxLQUFLLE1BQU0sTUFBTSxJQUFJLGFBQWEsUUFBUSxHQUFHLEdBQUcsWUFBWSxRQUFRLEdBQUcsWUFBWSxLQUFLLEdBQUcsR0FBRyxhQUFhLFVBQVUsUUFBUSxNQUFNLEdBQUcsT0FBTyxLQUFLLFVBQVUsSUFBSSxXQUFXLEdBQUcsR0FBRyxRQUFRLE9BQU8sR0FBRyxVQUFVLElBQUksT0FBTyxHQUFHLEdBQUcsUUFBUSxPQUFPLEdBQUcsYUFBYSxNQUFNLEtBQUssbUJBQW1CLElBQUksV0FBVyxJQUFJLFNBQVMsTUFBTSxLQUFLLElBQUksWUFBWSxNQUFNLElBQUksTUFBTSxPQUFPLEdBQUcsUUFBUSxTQUFTLEdBQUcsTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLFVBQVUsU0FBUyxNQUFNLElBQUksUUFBUSxTQUFTLFVBQVUsS0FBSyxZQUFZLEdBQUcsS0FBSyxVQUFVLE1BQU0sSUFBSSxJQUFJLE1BQU0sT0FBTyxTQUFTLEdBQUcsU0FBUyxNQUFNLElBQUksVUFBVSxHQUFHLE1BQU0sU0FBUyxRQUFRLE1BQU0sTUFBTSxHQUFHLFVBQVUsS0FBSyxVQUFVLEdBQUcsS0FBSyxPQUFPLFFBQVEsS0FBSyxLQUFLLE9BQU8sS0FBSyxNQUFNLE9BQU8sSUFBSSxJQUFJLElBQUksUUFBUSxJQUFJLE9BQU8sR0FBRyxTQUFTLE1BQU0sS0FBSyxXQUFXLFNBQVMsSUFBSSxPQUFPLE9BQU8sWUFBWSxNQUFNLE1BQU0sVUFBVSxHQUFHLElBQUksS0FBSyxVQUFVLEtBQUssS0FBSyxHQUFHLE1BQU0sS0FBSyxVQUFVLEdBQUcsT0FBTyxLQUFLLE9BQU8sU0FBUyxHQUFHLGlCQUFpQixHQUFHLEtBQUssUUFBUSxNQUFNLEdBQUcsS0FBSyxPQUFPLEdBQUcsSUFBSSxJQUFJLE1BQU0sS0FBSyxLQUFLLFlBQVksSUFBSSxLQUFLLFFBQVEsR0FBRyxJQUFJLEtBQUssTUFBTSxNQUFNLFFBQVEsU0FBUyxJQUFJLFlBQVksS0FBSyxLQUFLLE1BQU0sVUFBVSxHQUFHLFFBQVEsSUFBSSxLQUFLLFFBQVEsVUFBVSxNQUFNLE1BQU0sT0FBTyxJQUFJLE9BQU8sTUFBTSxTQUFTLEdBQUcsUUFBUSxTQUFTLEtBQUssS0FBSyxPQUFPLEtBQUssa0JBQWtCLEtBQUssU0FBUyxJQUFJLEtBQUssZ0JBQWdCLElBQUksTUFBTSxPQUFPLEtBQUssV0FBVyxLQUFLLE1BQU0sUUFBUSxPQUFPLEdBQUcsR0FBRyxJQUFJLE1BQU0sUUFBUSxJQUFJLE1BQU0sSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksS0FBSyxJQUFJLEdBQUcsVUFBVSxPQUFPLE1BQU0sWUFBWSxLQUFLLFlBQVksR0FBRyxRQUFRLFFBQVEsR0FBRyxjQUFjLFNBQVMsSUFBSSxLQUFLLEdBQUcsU0FBUyxPQUFPLFFBQVEsR0FBRyxLQUFLLFlBQVksS0FBSyxNQUFNLEdBQUcsS0FBSyxHQUFHLFlBQVksTUFB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQ0FBZ0MsRUFBRTtBQUNwRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOEJBQThCLEVBQUU7QUFDbEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxxQ0FBcUM7QUFDckMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MscUNBQXFDO0FBQ3JDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MscUNBQXFDO0FBQ3JDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEMsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDNWtPQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixzQkFBc0IsRUFBRTtBQUNsRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsOEJBQThCO0FBQzlCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLElBQUk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLDJCQUEyQiwwQ0FBMEM7QUFDckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQyxHQUFHO0FBQ0g7QUFDQTs7Ozs7Ozs7QUM5NEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOzs7Ozs7OztBQ3JJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6RkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDhCQUE4QjtBQUMzQyxjO0FBQ0EscUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLFVBQVU7QUFDVjtBQUNBLElBQUk7QUFDSixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QixFQUFFO0FBQ2hEO0FBQ0EsR0FBRztBQUNIO0FBQ0EscUJBQXFCLHlCQUF5QixFQUFFO0FBQ2hEO0FBQ0EsR0FBRzs7QUFFSCxDQUFDOzs7Ozs7OztBQ2xFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEdBQUc7QUFDbkM7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7OztBQ3pQQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFO0FBQ0EsMENBQTBDLDJDQUEyQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx3Q0FBd0M7QUFDeEMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx3Q0FBd0M7QUFDeEMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUJBQXVCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDBCQUEwQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGFBQWE7QUFDNUUsaUVBQWlFLGFBQWE7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QVcsT0FBTztBQUNsQixXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWdCLElBQUk7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLElBQUk7QUFDbkI7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLElBQUk7QUFDbkI7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxJQUFJO0FBQ25CLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixJQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsSUFBSTtBQUNmLFdBQVcsSUFBSTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsV0FBVztBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsSUFBSTtBQUNmLFdBQVcsSUFBSTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQix1QkFBdUI7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7O0FBRUE7O0FBRUEsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQ0FBc0M7QUFDN0UsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0NBQWtDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLDRDQUE0QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLDZDQUE2QztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdDQUFnQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUFDdEIsZUFBZSxJQUFJO0FBQ25CLGVBQWUsSUFBSTtBQUNuQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7Ozs7QUFLTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFD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OztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVULDJDQUEyQztBQUMzQztBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSwyREFBMkQsRUFBRTtBQUM3RDtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtB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QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsOEJBQThCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDhDQUE4Qyw4QkFBOEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQ0FBaUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxDQUFDOzs7Ozs7O0FDMTJCRCw4Qzs7Ozs7O0FDQUEsNkM7Ozs7OztBQ0FBLDhDOzs7Ozs7QUNBQSw4Qzs7Ozs7O0FDQUEsOEM7Ozs7OztBQ0FBLDhDOzs7Ozs7QUNBQSw4Qzs7Ozs7O0FDQUEsOEM7Ozs7OztBQ0FBLGlDOzs7Ozs7QUNBQSxrQzs7Ozs7O0FDQUEsK0IiLCJmaWxlIjoibWFpbi1zZXJ2ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcImRpc3QvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNjMpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDA0Njc3YmRiZDRhMjIxOGI4YjE3IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi92ZW5kb3JcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCIuL3ZlbmRvclwiXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgRE9NRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9ET01FeGNlcHRpb24nKTtcclxudmFyIEVSUiA9IERPTUV4Y2VwdGlvbjtcclxudmFyIGlzQXBpV3JpdGFibGUgPSByZXF1aXJlKFwiLi9jb25maWdcIikuaXNBcGlXcml0YWJsZTtcclxuXHJcbmV4cG9ydHMuTkFNRVNQQUNFID0ge1xyXG4gIEhUTUw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcclxuICBYTUw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLFxyXG4gIFhNTE5TOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nLFxyXG4gIE1BVEhNTDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnLFxyXG4gIFNWRzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcclxuICBYTElOSzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnXHJcbn07XHJcblxyXG4vL1xyXG4vLyBTaG9ydGN1dCBmdW5jdGlvbnMgZm9yIHRocm93aW5nIGVycm9ycyBvZiB2YXJpb3VzIHR5cGVzLlxyXG4vL1xyXG5leHBvcnRzLkluZGV4U2l6ZUVycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLklOREVYX1NJWkVfRVJSKTsgfTtcclxuZXhwb3J0cy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuSElFUkFSQ0hZX1JFUVVFU1RfRVJSKTsgfTtcclxuZXhwb3J0cy5Xcm9uZ0RvY3VtZW50RXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuV1JPTkdfRE9DVU1FTlRfRVJSKTsgfTtcclxuZXhwb3J0cy5JbnZhbGlkQ2hhcmFjdGVyRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuSU5WQUxJRF9DSEFSQUNURVJfRVJSKTsgfTtcclxuZXhwb3J0cy5Ob01vZGlmaWNhdGlvbkFsbG93ZWRFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5OT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlIpOyB9O1xyXG5leHBvcnRzLk5vdEZvdW5kRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuTk9UX0ZPVU5EX0VSUik7IH07XHJcbmV4cG9ydHMuTm90U3VwcG9ydGVkRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuTk9UX1NVUFBPUlRFRF9FUlIpOyB9O1xyXG5leHBvcnRzLkludmFsaWRTdGF0ZUVycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLklOVkFMSURfU1RBVEVfRVJSKTsgfTtcclxuZXhwb3J0cy5TeW50YXhFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5TWU5UQVhfRVJSKTsgfTtcclxuZXhwb3J0cy5JbnZhbGlkTW9kaWZpY2F0aW9uRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSKTsgfTtcclxuZXhwb3J0cy5OYW1lc3BhY2VFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5OQU1FU1BBQ0VfRVJSKTsgfTtcclxuZXhwb3J0cy5JbnZhbGlkQWNjZXNzRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuSU5WQUxJRF9BQ0NFU1NfRVJSKTsgfTtcclxuZXhwb3J0cy5UeXBlTWlzbWF0Y2hFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5UWVBFX01JU01BVENIX0VSUik7IH07XHJcbmV4cG9ydHMuU2VjdXJpdHlFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5TRUNVUklUWV9FUlIpOyB9O1xyXG5leHBvcnRzLk5ldHdvcmtFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5ORVRXT1JLX0VSUik7IH07XHJcbmV4cG9ydHMuQWJvcnRFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5BQk9SVF9FUlIpOyB9O1xyXG5leHBvcnRzLlVybE1pc21hdGNoRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuVVJMX01JU01BVENIX0VSUik7IH07XHJcbmV4cG9ydHMuUXVvdGFFeGNlZWRlZEVycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLlFVT1RBX0VYQ0VFREVEX0VSUik7IH07XHJcbmV4cG9ydHMuVGltZW91dEVycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLlRJTUVPVVRfRVJSKTsgfTtcclxuZXhwb3J0cy5JbnZhbGlkTm9kZVR5cGVFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5JTlZBTElEX05PREVfVFlQRV9FUlIpOyB9O1xyXG5leHBvcnRzLkRhdGFDbG9uZUVycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLkRBVEFfQ0xPTkVfRVJSKTsgfTtcclxuXHJcbmV4cG9ydHMubnlpID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhyb3cgbmV3IEVycm9yKFwiTm90WWV0SW1wbGVtZW50ZWRcIik7XHJcbn07XHJcblxyXG5leHBvcnRzLmFzc2VydCA9IGZ1bmN0aW9uKGV4cHIsIG1zZykge1xyXG4gIGlmICghZXhwcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIGZhaWxlZDogXCIgKyAobXNnIHx8IFwiXCIpICsgXCJcXG5cIiArIG5ldyBFcnJvcigpLnN0YWNrKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnRzLmV4cG9zZSA9IGZ1bmN0aW9uKHNyYywgYykge1xyXG4gIGZvciAodmFyIG4gaW4gc3JjKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYy5wcm90b3R5cGUsIG4sIHsgdmFsdWU6IHNyY1tuXSwgd3JpdGFibGU6IGlzQXBpV3JpdGFibGUgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICBmb3IgKHZhciBuIGluIGIpIHtcclxuICAgIGFbbl0gPSBiW25dO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIENvbXBhcmUgdHdvIG5vZGVzIGJhc2VkIG9uIHRoZWlyIGRvY3VtZW50IG9yZGVyLiBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkXHJcbi8vIHRvIGJlIHBhc3NlZCB0byBzb3J0KCkuIEFzc3VtZXMgdGhhdCB0aGUgYXJyYXkgYmVpbmcgc29ydGVkIGRvZXMgbm90XHJcbi8vIGNvbnRhaW4gZHVwbGljYXRlcy4gIEFuZCB0aGF0IGFsbCBub2RlcyBhcmUgY29ubmVjdGVkIGFuZCBjb21wYXJhYmxlLlxyXG4vLyBDbGV2ZXIgY29kZSBieSBwcGsgdmlhIGplcmVzaWcuXHJcbmV4cG9ydHMuZG9jdW1lbnRPcmRlciA9IGZ1bmN0aW9uKG4sbSkge1xyXG4gIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xyXG4gIHJldHVybiAzIC0gKG4uY29tcGFyZURvY3VtZW50UG9zaXRpb24obSkgJiA2KTtcclxufTtcclxuXHJcbmV4cG9ydHMudG9BU0NJSUxvd2VyQ2FzZSA9IGZ1bmN0aW9uKHMpIHtcclxuICByZXR1cm4gcy5yZXBsYWNlKC9bQS1aXSsvZywgZnVuY3Rpb24odCkgeyByZXR1cm4gdC50b0xvd2VyQ2FzZSgpOyB9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gTm9kZTtcclxuXHJcbnZhciBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vRXZlbnRUYXJnZXQnKTtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG52YXIgTkFNRVNQQUNFID0gdXRpbHMuTkFNRVNQQUNFO1xyXG5cclxuLy8gQWxsIG5vZGVzIGhhdmUgYSBub2RlVHlwZSBhbmQgYW4gb3duZXJEb2N1bWVudC5cclxuLy8gT25jZSBpbnNlcnRlZCwgdGhleSBhbHNvIGhhdmUgYSBwYXJlbnROb2RlLlxyXG4vLyBUaGlzIGlzIGFuIGFic3RyYWN0IGNsYXNzOyBhbGwgbm9kZXMgaW4gYSBkb2N1bWVudCBhcmUgaW5zdGFuY2VzXHJcbi8vIG9mIGEgc3VidHlwZSwgc28gYWxsIHRoZSBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIGJ5IG1vcmUgc3BlY2lmaWNcclxuLy8gY29uc3RydWN0b3JzLlxyXG5mdW5jdGlvbiBOb2RlKCkge1xyXG59XHJcblxyXG52YXIgRUxFTUVOVF9OT0RFICAgICAgICAgICAgICAgID0gTm9kZS5FTEVNRU5UX05PREUgPSAxO1xyXG52YXIgQVRUUklCVVRFX05PREUgICAgICAgICAgICAgID0gTm9kZS5BVFRSSUJVVEVfTk9ERSA9IDI7XHJcbnZhciBURVhUX05PREUgICAgICAgICAgICAgICAgICAgPSBOb2RlLlRFWFRfTk9ERSA9IDM7XHJcbnZhciBDREFUQV9TRUNUSU9OX05PREUgICAgICAgICAgPSBOb2RlLkNEQVRBX1NFQ1RJT05fTk9ERSA9IDQ7XHJcbnZhciBFTlRJVFlfUkVGRVJFTkNFX05PREUgICAgICAgPSBOb2RlLkVOVElUWV9SRUZFUkVOQ0VfTk9ERSA9IDU7XHJcbnZhciBFTlRJVFlfTk9ERSAgICAgICAgICAgICAgICAgPSBOb2RlLkVOVElUWV9OT0RFID0gNjtcclxudmFyIFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERSA9IE5vZGUuUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFID0gNztcclxudmFyIENPTU1FTlRfTk9ERSAgICAgICAgICAgICAgICA9IE5vZGUuQ09NTUVOVF9OT0RFID0gODtcclxudmFyIERPQ1VNRU5UX05PREUgICAgICAgICAgICAgICA9IE5vZGUuRE9DVU1FTlRfTk9ERSA9IDk7XHJcbnZhciBET0NVTUVOVF9UWVBFX05PREUgICAgICAgICAgPSBOb2RlLkRPQ1VNRU5UX1RZUEVfTk9ERSA9IDEwO1xyXG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAgICAgID0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XHJcbnZhciBOT1RBVElPTl9OT0RFICAgICAgICAgICAgICAgPSBOb2RlLk5PVEFUSU9OX05PREUgPSAxMjtcclxuXHJcbnZhciBET0NVTUVOVF9QT1NJVElPTl9ESVNDT05ORUNURUQgICAgICAgICAgICA9IE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRElTQ09OTkVDVEVEID0gMHgwMTtcclxudmFyIERPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyAgICAgICAgICAgICAgID0gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcgPSAweDAyO1xyXG52YXIgRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HICAgICAgICAgICAgICAgPSBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyA9IDB4MDQ7XHJcbnZhciBET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUyAgICAgICAgICAgICAgICA9IE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlMgPSAweDA4O1xyXG52YXIgRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZICAgICAgICAgICAgPSBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSA9IDB4MTA7XHJcbnZhciBET0NVTUVOVF9QT1NJVElPTl9JTVBMRU1FTlRBVElPTl9TUEVDSUZJQyA9IE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fSU1QTEVNRU5UQVRJT05fU1BFQ0lGSUMgPSAweDIwO1xyXG5cclxudmFyIGhhc1Jhd0NvbnRlbnQgPSB7XHJcbiAgU1RZTEU6IHRydWUsXHJcbiAgU0NSSVBUOiB0cnVlLFxyXG4gIFhNUDogdHJ1ZSxcclxuICBJRlJBTUU6IHRydWUsXHJcbiAgTk9FTUJFRDogdHJ1ZSxcclxuICBOT0ZSQU1FUzogdHJ1ZSxcclxuICBQTEFJTlRFWFQ6IHRydWVcclxufTtcclxuXHJcbnZhciBlbXB0eUVsZW1lbnRzID0ge1xyXG4gIGFyZWE6IHRydWUsXHJcbiAgYmFzZTogdHJ1ZSxcclxuICBiYXNlZm9udDogdHJ1ZSxcclxuICBiZ3NvdW5kOiB0cnVlLFxyXG4gIGJyOiB0cnVlLFxyXG4gIGNvbDogdHJ1ZSxcclxuICBlbWJlZDogdHJ1ZSxcclxuICBmcmFtZTogdHJ1ZSxcclxuICBocjogdHJ1ZSxcclxuICBpbWc6IHRydWUsXHJcbiAgaW5wdXQ6IHRydWUsXHJcbiAga2V5Z2VuOiB0cnVlLFxyXG4gIGxpbms6IHRydWUsXHJcbiAgbWV0YTogdHJ1ZSxcclxuICBwYXJhbTogdHJ1ZSxcclxuICBzb3VyY2U6IHRydWUsXHJcbiAgdHJhY2s6IHRydWUsXHJcbiAgd2JyOiB0cnVlXHJcbn07XHJcblxyXG52YXIgZXh0cmFOZXdMaW5lID0ge1xyXG4gIC8qIFJlbW92ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9odG1sL2lzc3Vlcy85NDRcclxuICBwcmU6IHRydWUsXHJcbiAgdGV4dGFyZWE6IHRydWUsXHJcbiAgbGlzdGluZzogdHJ1ZVxyXG4gICovXHJcbn07XHJcblxyXG5Ob2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB7XHJcblxyXG4gIC8vIE5vZGUgdGhhdCBhcmUgbm90IGluc2VydGVkIGludG8gdGhlIHRyZWUgaW5oZXJpdCBhIG51bGwgcGFyZW50XHJcbiAgcGFyZW50Tm9kZTogeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUgfSxcclxuXHJcbiAgLy8gWFhYOiB0aGUgYmFzZVVSSSBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBieSBkb20gY29yZSwgYnV0XHJcbiAgLy8gYSBjb3JyZWN0IGltcGxlbWVudGF0aW9uIG9mIGl0IHJlcXVpcmVzIEhUTUwgZmVhdHVyZXMsIHNvXHJcbiAgLy8gd2UnbGwgY29tZSBiYWNrIHRvIHRoaXMgbGF0ZXIuXHJcbiAgYmFzZVVSSTogeyBnZXQ6IHV0aWxzLm55aSB9LFxyXG5cclxuICBwYXJlbnRFbGVtZW50OiB7IGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gKHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUubm9kZVR5cGU9PT1FTEVNRU5UX05PREUpID8gdGhpcy5wYXJlbnROb2RlIDogbnVsbDtcclxuICB9fSxcclxuXHJcbiAgaGFzQ2hpbGROb2RlczogeyB2YWx1ZTogZnVuY3Rpb24oKSB7ICAvLyBPdmVycmlkZGVuIGluIGxlYWYuanNcclxuICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoID4gMDtcclxuICB9fSxcclxuXHJcbiAgZmlyc3RDaGlsZDogeyBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggPT09IDAgPyBudWxsIDogdGhpcy5jaGlsZE5vZGVzWzBdO1xyXG4gIH19LFxyXG5cclxuICBsYXN0Q2hpbGQ6IHsgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwID8gbnVsbCA6IHRoaXMuY2hpbGROb2Rlc1t0aGlzLmNoaWxkTm9kZXMubGVuZ3RoLTFdO1xyXG4gIH19LFxyXG5cclxuICBwcmV2aW91c1NpYmxpbmc6IHsgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgIGlmICghdGhpcy5wYXJlbnROb2RlKSByZXR1cm4gbnVsbDtcclxuICAgIHZhciBzaWJzID0gdGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXMsIGkgPSB0aGlzLmluZGV4O1xyXG4gICAgcmV0dXJuIGkgPT09IDAgPyBudWxsIDogc2lic1tpLTFdO1xyXG4gIH19LFxyXG5cclxuICBuZXh0U2libGluZzogeyBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCF0aGlzLnBhcmVudE5vZGUpIHJldHVybiBudWxsO1xyXG4gICAgdmFyIHNpYnMgPSB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2RlcywgaSA9IHRoaXMuaW5kZXg7XHJcbiAgICByZXR1cm4gaSsxID09PSBzaWJzLmxlbmd0aCA/IG51bGwgOiBzaWJzW2krMV07XHJcbiAgfX0sXHJcblxyXG5cclxuICBfY291bnRDaGlsZHJlbk9mVHlwZTogeyB2YWx1ZTogZnVuY3Rpb24odHlwZSkge1xyXG4gICAgdmFyIHN1bSA9IDAsIG5vZGVzID0gdGhpcy5jaGlsZE5vZGVzLCBsZW5ndGggPSBub2Rlcy5sZW5ndGgsIGk7XHJcbiAgICBmb3IgKGk9MDsgaTxsZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAobm9kZXNbaV0ubm9kZVR5cGUgPT09IHR5cGUpIHN1bSsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1bTtcclxuICB9fSxcclxuXHJcbiAgX2Vuc3VyZUluc2VydFZhbGlkOiB7IHZhbHVlOiBmdW5jdGlvbiBfZW5zdXJlSW5zZXJ0VmFsaWQobm9kZSwgY2hpbGQsIGlzUHJlaW5zZXJ0KSB7XHJcbiAgICB2YXIgcGFyZW50ID0gdGhpcywgaTtcclxuICAgIGlmICghbm9kZS5ub2RlVHlwZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgbm9kZScpO1xyXG4gICAgLy8gMS4gSWYgcGFyZW50IGlzIG5vdCBhIERvY3VtZW50LCBEb2N1bWVudEZyYWdtZW50LCBvciBFbGVtZW50XHJcbiAgICAvLyBub2RlLCB0aHJvdyBhIEhpZXJhcmNoeVJlcXVlc3RFcnJvci5cclxuICAgIHN3aXRjaCAocGFyZW50Lm5vZGVUeXBlKSB7XHJcbiAgICBjYXNlIERPQ1VNRU5UX05PREU6XHJcbiAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XHJcbiAgICBjYXNlIEVMRU1FTlRfTk9ERTpcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OiB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcclxuICAgIH1cclxuICAgIC8vIDIuIElmIG5vZGUgaXMgYSBob3N0LWluY2x1ZGluZyBpbmNsdXNpdmUgYW5jZXN0b3Igb2YgcGFyZW50LFxyXG4gICAgLy8gdGhyb3cgYSBIaWVyYXJjaHlSZXF1ZXN0RXJyb3IuXHJcbiAgICBpZiAobm9kZS5pc0FuY2VzdG9yKHBhcmVudCkpIHV0aWxzLkhpZXJhcmNoeVJlcXVlc3RFcnJvcigpO1xyXG4gICAgLy8gMy4gSWYgY2hpbGQgaXMgbm90IG51bGwgYW5kIGl0cyBwYXJlbnQgaXMgbm90IHBhcmVudCwgdGhlblxyXG4gICAgLy8gdGhyb3cgYSBOb3RGb3VuZEVycm9yLiAocmVwbGFjZUNoaWxkIG9taXRzIHRoZSAnY2hpbGQgaXMgbm90IG51bGwnXHJcbiAgICAvLyBhbmQgdGhyb3dzIGEgVHlwZUVycm9yIGhlcmUgaWYgY2hpbGQgaXMgbnVsbC4pXHJcbiAgICBpZiAoY2hpbGQgIT09IG51bGwgfHwgIWlzUHJlaW5zZXJ0KSB7XHJcbiAgICAgIGlmIChjaGlsZC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHV0aWxzLk5vdEZvdW5kRXJyb3IoKTtcclxuICAgIH1cclxuICAgIC8vIDQuIElmIG5vZGUgaXMgbm90IGEgRG9jdW1lbnRGcmFnbWVudCwgRG9jdW1lbnRUeXBlLCBFbGVtZW50LFxyXG4gICAgLy8gVGV4dCwgUHJvY2Vzc2luZ0luc3RydWN0aW9uLCBvciBDb21tZW50IG5vZGUsIHRocm93IGFcclxuICAgIC8vIEhpZXJhcmNoeVJlcXVlc3RFcnJvci5cclxuICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xyXG4gICAgY2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxyXG4gICAgY2FzZSBET0NVTUVOVF9UWVBFX05PREU6XHJcbiAgICBjYXNlIEVMRU1FTlRfTk9ERTpcclxuICAgIGNhc2UgVEVYVF9OT0RFOlxyXG4gICAgY2FzZSBQUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREU6XHJcbiAgICBjYXNlIENPTU1FTlRfTk9ERTpcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OiB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcclxuICAgIH1cclxuICAgIC8vIDUuIElmIGVpdGhlciBub2RlIGlzIGEgVGV4dCBub2RlIGFuZCBwYXJlbnQgaXMgYSBkb2N1bWVudCwgb3JcclxuICAgIC8vIG5vZGUgaXMgYSBkb2N0eXBlIGFuZCBwYXJlbnQgaXMgbm90IGEgZG9jdW1lbnQsIHRocm93IGFcclxuICAgIC8vIEhpZXJhcmNoeVJlcXVlc3RFcnJvci5cclxuICAgIC8vIDYuIElmIHBhcmVudCBpcyBhIGRvY3VtZW50LCBhbmQgYW55IG9mIHRoZSBzdGF0ZW1lbnRzIGJlbG93LCBzd2l0Y2hlZFxyXG4gICAgLy8gb24gbm9kZSwgYXJlIHRydWUsIHRocm93IGEgSGllcmFyY2h5UmVxdWVzdEVycm9yLlxyXG4gICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSkge1xyXG4gICAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcclxuICAgICAgY2FzZSBURVhUX05PREU6XHJcbiAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcclxuICAgICAgICAvLyA2YTEuIElmIG5vZGUgaGFzIG1vcmUgdGhhbiBvbmUgZWxlbWVudCBjaGlsZCBvciBoYXMgYSBUZXh0XHJcbiAgICAgICAgLy8gbm9kZSBjaGlsZC5cclxuICAgICAgICBpZiAobm9kZS5fY291bnRDaGlsZHJlbk9mVHlwZShURVhUX05PREUpID4gMClcclxuICAgICAgICAgIHV0aWxzLkhpZXJhcmNoeVJlcXVlc3RFcnJvcigpO1xyXG4gICAgICAgIHN3aXRjaCAobm9kZS5fY291bnRDaGlsZHJlbk9mVHlwZShFTEVNRU5UX05PREUpKSB7XHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgLy8gNmEyLiBPdGhlcndpc2UsIGlmIG5vZGUgaGFzIG9uZSBlbGVtZW50IGNoaWxkIGFuZCBlaXRoZXJcclxuICAgICAgICAgIC8vIHBhcmVudCBoYXMgYW4gZWxlbWVudCBjaGlsZCwgY2hpbGQgaXMgYSBkb2N0eXBlLCBvciBjaGlsZFxyXG4gICAgICAgICAgLy8gaXMgbm90IG51bGwgYW5kIGEgZG9jdHlwZSBpcyBmb2xsb3dpbmcgY2hpbGQuIFtwcmVpbnNlcnRdXHJcbiAgICAgICAgICAvLyA2YTIuIE90aGVyd2lzZSwgaWYgbm9kZSBoYXMgb25lIGVsZW1lbnQgY2hpbGQgYW5kIGVpdGhlclxyXG4gICAgICAgICAgLy8gcGFyZW50IGhhcyBhbiBlbGVtZW50IGNoaWxkIHRoYXQgaXMgbm90IGNoaWxkIG9yIGFcclxuICAgICAgICAgIC8vIGRvY3R5cGUgaXMgZm9sbG93aW5nIGNoaWxkLiBbcmVwbGFjZVdpdGhdXHJcbiAgICAgICAgICBpZiAoY2hpbGQgIT09IG51bGwgLyogYWx3YXlzIHRydWUgaGVyZSBmb3IgcmVwbGFjZVdpdGggKi8pIHtcclxuICAgICAgICAgICAgaWYgKGlzUHJlaW5zZXJ0ICYmIGNoaWxkLm5vZGVUeXBlID09PSBET0NVTUVOVF9UWVBFX05PREUpXHJcbiAgICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XHJcbiAgICAgICAgICAgIGZvciAoaT1wYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZE5vZGVzW2ldID09PSBjaGlsZCkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09PSBET0NVTUVOVF9UWVBFX05PREUpXHJcbiAgICAgICAgICAgICAgICB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaSA9IHBhcmVudC5fY291bnRDaGlsZHJlbk9mVHlwZShFTEVNRU5UX05PREUpO1xyXG4gICAgICAgICAgaWYgKGlzUHJlaW5zZXJ0KSB7XHJcbiAgICAgICAgICAgIC8vIFwicGFyZW50IGhhcyBhbiBlbGVtZW50IGNoaWxkXCJcclxuICAgICAgICAgICAgaWYgKGkgPiAwKVxyXG4gICAgICAgICAgICAgIHV0aWxzLkhpZXJhcmNoeVJlcXVlc3RFcnJvcigpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gXCJwYXJlbnQgaGFzIGFuIGVsZW1lbnQgY2hpbGQgdGhhdCBpcyBub3QgY2hpbGRcIlxyXG4gICAgICAgICAgICBpZiAoaSA+IDEgfHwgKGkgPT09IDEgJiYgY2hpbGQubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSkpXHJcbiAgICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OiAvLyA2YTEsIGNvbnRpbnVlZC4gKG1vcmUgdGhhbiBvbmUgRWxlbWVudCBjaGlsZClcclxuICAgICAgICAgIHV0aWxzLkhpZXJhcmNoeVJlcXVlc3RFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBFTEVNRU5UX05PREU6XHJcbiAgICAgICAgLy8gNmIuIHBhcmVudCBoYXMgYW4gZWxlbWVudCBjaGlsZCwgY2hpbGQgaXMgYSBkb2N0eXBlLCBvclxyXG4gICAgICAgIC8vIGNoaWxkIGlzIG5vdCBudWxsIGFuZCBhIGRvY3R5cGUgaXMgZm9sbG93aW5nIGNoaWxkLiBbcHJlaW5zZXJ0XVxyXG4gICAgICAgIC8vIDZiLiBwYXJlbnQgaGFzIGFuIGVsZW1lbnQgY2hpbGQgdGhhdCBpcyBub3QgY2hpbGQgb3IgYVxyXG4gICAgICAgIC8vIGRvY3R5cGUgaXMgZm9sbG93aW5nIGNoaWxkLiBbcmVwbGFjZVdpdGhdXHJcbiAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsIC8qIGFsd2F5cyB0cnVlIGhlcmUgZm9yIHJlcGxhY2VXaXRoICovKSB7XHJcbiAgICAgICAgICBpZiAoaXNQcmVpbnNlcnQgJiYgY2hpbGQubm9kZVR5cGUgPT09IERPQ1VNRU5UX1RZUEVfTk9ERSlcclxuICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XHJcbiAgICAgICAgICBmb3IgKGk9cGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50LmNoaWxkTm9kZXNbaV0gPT09IGNoaWxkKSBicmVhaztcclxuICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09PSBET0NVTUVOVF9UWVBFX05PREUpXHJcbiAgICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgPSBwYXJlbnQuX2NvdW50Q2hpbGRyZW5PZlR5cGUoRUxFTUVOVF9OT0RFKTtcclxuICAgICAgICBpZiAoaXNQcmVpbnNlcnQpIHtcclxuICAgICAgICAgIC8vIFwicGFyZW50IGhhcyBhbiBlbGVtZW50IGNoaWxkXCJcclxuICAgICAgICAgIGlmIChpID4gMClcclxuICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIFwicGFyZW50IGhhcyBhbiBlbGVtZW50IGNoaWxkIHRoYXQgaXMgbm90IGNoaWxkXCJcclxuICAgICAgICAgIGlmIChpID4gMSB8fCAoaSA9PT0gMSAmJiBjaGlsZC5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFKSlcclxuICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERPQ1VNRU5UX1RZUEVfTk9ERTpcclxuICAgICAgICAvLyA2Yy4gcGFyZW50IGhhcyBhIGRvY3R5cGUgY2hpbGQsIGNoaWxkIGlzIG5vbi1udWxsIGFuZCBhblxyXG4gICAgICAgIC8vIGVsZW1lbnQgaXMgcHJlY2VkaW5nIGNoaWxkLCBvciBjaGlsZCBpcyBudWxsIGFuZCBwYXJlbnQgaGFzXHJcbiAgICAgICAgLy8gYW4gZWxlbWVudCBjaGlsZC4gW3ByZWluc2VydF1cclxuICAgICAgICAvLyA2Yy4gcGFyZW50IGhhcyBhIGRvY3R5cGUgY2hpbGQgdGhhdCBpcyBub3QgY2hpbGQsIG9yIGFuXHJcbiAgICAgICAgLy8gZWxlbWVudCBpcyBwcmVjZWRpbmcgY2hpbGQuIFtyZXBsYWNlV2l0aF1cclxuICAgICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcclxuICAgICAgICAgIGlmIChwYXJlbnQuX2NvdW50Q2hpbGRyZW5PZlR5cGUoRUxFTUVOVF9OT0RFKSlcclxuICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGNoaWxkIGlzIGFsd2F5cyBub24tbnVsbCBmb3IgW3JlcGxhY2VXaXRoXSBjYXNlXHJcbiAgICAgICAgICBmb3IgKGk9MDsgaTxwYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50LmNoaWxkTm9kZXNbaV0gPT09IGNoaWxkKSBicmVhaztcclxuICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpXHJcbiAgICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgPSBwYXJlbnQuX2NvdW50Q2hpbGRyZW5PZlR5cGUoRE9DVU1FTlRfVFlQRV9OT0RFKTtcclxuICAgICAgICBpZiAoaXNQcmVpbnNlcnQpIHtcclxuICAgICAgICAgIC8vIFwicGFyZW50IGhhcyBhbiBkb2N0eXBlIGNoaWxkXCJcclxuICAgICAgICAgIGlmIChpID4gMClcclxuICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIFwicGFyZW50IGhhcyBhbiBkb2N0eXBlIGNoaWxkIHRoYXQgaXMgbm90IGNoaWxkXCJcclxuICAgICAgICAgIGlmIChpID4gMSB8fCAoaSA9PT0gMSAmJiBjaGlsZC5ub2RlVHlwZSAhPT0gRE9DVU1FTlRfVFlQRV9OT0RFKSlcclxuICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyA1LCBjb250aW51ZWQ6IChwYXJlbnQgaXMgbm90IGEgZG9jdW1lbnQpXHJcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9UWVBFX05PREUpIHV0aWxzLkhpZXJhcmNoeVJlcXVlc3RFcnJvcigpO1xyXG4gICAgfVxyXG4gIH19LFxyXG5cclxuICBpbnNlcnRCZWZvcmU6IHsgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZShub2RlLCBjaGlsZCkge1xyXG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XHJcbiAgICAvLyAxLiBFbnN1cmUgcHJlLWluc2VydGlvbiB2YWxpZGl0eVxyXG4gICAgcGFyZW50Ll9lbnN1cmVJbnNlcnRWYWxpZChub2RlLCBjaGlsZCwgdHJ1ZSk7XHJcbiAgICAvLyAyLiBMZXQgcmVmZXJlbmNlIGNoaWxkIGJlIGNoaWxkLlxyXG4gICAgdmFyIHJlZkNoaWxkID0gY2hpbGQ7XHJcbiAgICAvLyAzLiBJZiByZWZlcmVuY2UgY2hpbGQgaXMgbm9kZSwgc2V0IGl0IHRvIG5vZGUncyBuZXh0IHNpYmxpbmdcclxuICAgIGlmIChyZWZDaGlsZCA9PT0gbm9kZSkgeyByZWZDaGlsZCA9IG5vZGUubmV4dFNpYmxpbmc7IH1cclxuICAgIC8vIDQuIEFkb3B0IG5vZGUgaW50byBwYXJlbnQncyBub2RlIGRvY3VtZW50LlxyXG4gICAgcGFyZW50LmRvYy5hZG9wdE5vZGUobm9kZSk7XHJcbiAgICAvLyA1LiBJbnNlcnQgbm9kZSBpbnRvIHBhcmVudCBiZWZvcmUgcmVmZXJlbmNlIGNoaWxkLlxyXG4gICAgaWYgKHJlZkNoaWxkID09PSBudWxsKSB7XHJcbiAgICAgIHBhcmVudC5fYXBwZW5kQ2hpbGQobm9kZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBub2RlLmluc2VydChwYXJlbnQsIHJlZkNoaWxkLmluZGV4KTtcclxuICAgIH1cclxuICAgIC8vIDYuIFJldHVybiBub2RlXHJcbiAgICByZXR1cm4gbm9kZTtcclxuICB9fSxcclxuXHJcblxyXG4gIGFwcGVuZENoaWxkOiB7IHZhbHVlOiBmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgLy8gVGhpcyBpbnZva2VzIF9hcHBlbmRDaGlsZCBhZnRlciBkb2luZyB2YWxpZGl0eSBjaGVja3MuXHJcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoY2hpbGQsIG51bGwpO1xyXG4gIH19LFxyXG5cclxuICBfYXBwZW5kQ2hpbGQ6IHsgdmFsdWU6IGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICBjaGlsZC5pbnNlcnQodGhpcywgdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCk7XHJcbiAgICByZXR1cm4gY2hpbGQ7XHJcbiAgfX0sXHJcblxyXG4gIHJlbW92ZUNoaWxkOiB7IHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDaGlsZChjaGlsZCkge1xyXG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XHJcbiAgICBpZiAoIWNoaWxkLm5vZGVUeXBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBub2RlJyk7XHJcbiAgICBpZiAoY2hpbGQucGFyZW50Tm9kZSAhPT0gcGFyZW50KSB1dGlscy5Ob3RGb3VuZEVycm9yKCk7XHJcbiAgICBjaGlsZC5yZW1vdmUoKTtcclxuICAgIHJldHVybiBjaGlsZDtcclxuICB9fSxcclxuXHJcbiAgLy8gVG8gcmVwbGFjZSBhIGBjaGlsZGAgd2l0aCBgbm9kZWAgd2l0aGluIGEgYHBhcmVudGAgKHRoaXMpXHJcbiAgcmVwbGFjZUNoaWxkOiB7IHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlQ2hpbGQobm9kZSwgY2hpbGQpIHtcclxuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xyXG4gICAgLy8gRW5zdXJlIHZhbGlkaXR5IChzbGlnaHQgZGlmZmVyZW5jZXMgZnJvbSBwcmUtaW5zZXJ0aW9uIGNoZWNrKVxyXG4gICAgcGFyZW50Ll9lbnN1cmVJbnNlcnRWYWxpZChub2RlLCBjaGlsZCwgZmFsc2UpO1xyXG4gICAgLy8gQWRvcHQgbm9kZSBpbnRvIHBhcmVudCdzIG5vZGUgZG9jdW1lbnQuXHJcbiAgICBpZiAobm9kZS5kb2MgIT09IHBhcmVudC5kb2MpIHtcclxuICAgICAgLy8gWFhYIGFkb3B0Tm9kZSBoYXMgc2lkZS1lZmZlY3Qgb2YgcmVtb3Zpbmcgbm9kZSBmcm9tIGl0cyBwYXJlbnRcclxuICAgICAgLy8gYW5kIGdlbmVyYXRpbmcgYSBtdXRhdGlvbiBldmVudCwgdGh1cyBjYXVzaW5nIHRoZSBfaW5zZXJ0T3JSZXBsYWNlXHJcbiAgICAgIC8vIHRvIGdlbmVyYXRlIHR3byBkZWxldGVzIGFuZCBhbiBpbnNlcnQgaW5zdGVhZCBvZiBhICdtb3ZlJ1xyXG4gICAgICAvLyBldmVudC4gIEl0IGxvb2tzIGxpa2UgdGhlIG5ldyBNdXRhdGlvbk9ic2VydmVyIHN0dWZmIGF2b2lkc1xyXG4gICAgICAvLyB0aGlzIHByb2JsZW0sIGJ1dCBmb3Igbm93IGxldCdzIG9ubHkgYWRvcHQgKGllLCByZW1vdmUgYG5vZGVgXHJcbiAgICAgIC8vIGZyb20gaXRzIHBhcmVudCkgaGVyZSBpZiB3ZSBuZWVkIHRvLlxyXG4gICAgICBwYXJlbnQuZG9jLmFkb3B0Tm9kZShub2RlKTtcclxuICAgIH1cclxuICAgIC8vIERvIHRoZSByZXBsYWNlLlxyXG4gICAgbm9kZS5faW5zZXJ0T3JSZXBsYWNlKHBhcmVudCwgY2hpbGQuaW5kZXgsIHRydWUpO1xyXG4gICAgcmV0dXJuIGNoaWxkO1xyXG4gIH19LFxyXG5cclxuICAvLyBTZWU6IGh0dHA6Ly9lam9obi5vcmcvYmxvZy9jb21wYXJpbmctZG9jdW1lbnQtcG9zaXRpb24vXHJcbiAgY29udGFpbnM6IHsgdmFsdWU6IGZ1bmN0aW9uIGNvbnRhaW5zKG5vZGUpIHtcclxuICAgIGlmIChub2RlID09PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgaWYgKHRoaXMgPT09IG5vZGUpIHsgcmV0dXJuIHRydWU7IC8qIGluY2x1c2l2ZSBkZXNjZW5kYW50ICovIH1cclxuICAgIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xyXG4gICAgcmV0dXJuICh0aGlzLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5vZGUpICZcclxuICAgICAgICAgICAgRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKSAhPT0gMDtcclxuICB9fSxcclxuXHJcbiAgY29tcGFyZURvY3VtZW50UG9zaXRpb246IHsgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoYXQpe1xyXG4gICAgLy8gQmFzaWMgYWxnb3JpdGhtIGZvciBmaW5kaW5nIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0d28gbm9kZXMuXHJcbiAgICAvLyBNYWtlIGEgbGlzdCB0aGUgYW5jZXN0b3JzIG9mIGVhY2ggbm9kZSwgc3RhcnRpbmcgd2l0aCB0aGVcclxuICAgIC8vIGRvY3VtZW50IGVsZW1lbnQgYW5kIHByb2NlZWRpbmcgZG93biB0byB0aGUgbm9kZXMgdGhlbXNlbHZlcy5cclxuICAgIC8vIFRoZW4sIGxvb3AgdGhyb3VnaCB0aGUgbGlzdHMsIGxvb2tpbmcgZm9yIHRoZSBmaXJzdCBlbGVtZW50XHJcbiAgICAvLyB0aGF0IGRpZmZlcnMuICBUaGUgb3JkZXIgb2YgdGhvc2UgdHdvIGVsZW1lbnRzIGdpdmUgdGhlXHJcbiAgICAvLyBvcmRlciBvZiB0aGVpciBkZXNjZW5kYW50IG5vZGVzLiAgT3IsIGlmIG9uZSBsaXN0IGlzIGEgcHJlZml4XHJcbiAgICAvLyBvZiB0aGUgb3RoZXIgb25lLCB0aGVuIHRoYXQgbm9kZSBjb250YWlucyB0aGUgb3RoZXIuXHJcblxyXG4gICAgaWYgKHRoaXMgPT09IHRoYXQpIHJldHVybiAwO1xyXG5cclxuICAgIC8vIElmIHRoZXkncmUgbm90IG93bmVkIGJ5IHRoZSBzYW1lIGRvY3VtZW50IG9yIGlmIG9uZSBpcyByb290ZWRcclxuICAgIC8vIGFuZCBvbmUgaXMgbm90LCB0aGVuIHRoZXkncmUgZGlzY29ubmVjdGVkLlxyXG4gICAgaWYgKHRoaXMuZG9jICE9PSB0aGF0LmRvYyB8fFxyXG4gICAgICB0aGlzLnJvb3RlZCAhPT0gdGhhdC5yb290ZWQpXHJcbiAgICAgIHJldHVybiAoRE9DVU1FTlRfUE9TSVRJT05fRElTQ09OTkVDVEVEICtcclxuICAgICAgICAgIERPQ1VNRU5UX1BPU0lUSU9OX0lNUExFTUVOVEFUSU9OX1NQRUNJRklDKTtcclxuXHJcbiAgICAvLyBHZXQgYXJyYXlzIG9mIGFuY2VzdG9ycyBmb3IgdGhpcyBhbmQgdGhhdFxyXG4gICAgdmFyIHRoZXNlID0gW10sIHRob3NlID0gW107XHJcbiAgICBmb3IodmFyIG4gPSB0aGlzOyBuICE9PSBudWxsOyBuID0gbi5wYXJlbnROb2RlKSB0aGVzZS5wdXNoKG4pO1xyXG4gICAgZm9yKG4gPSB0aGF0OyBuICE9PSBudWxsOyBuID0gbi5wYXJlbnROb2RlKSB0aG9zZS5wdXNoKG4pO1xyXG4gICAgdGhlc2UucmV2ZXJzZSgpOyAgLy8gU28gd2Ugc3RhcnQgd2l0aCB0aGUgb3V0ZXJtb3N0XHJcbiAgICB0aG9zZS5yZXZlcnNlKCk7XHJcblxyXG4gICAgaWYgKHRoZXNlWzBdICE9PSB0aG9zZVswXSkgLy8gTm8gY29tbW9uIGFuY2VzdG9yXHJcbiAgICAgIHJldHVybiAoRE9DVU1FTlRfUE9TSVRJT05fRElTQ09OTkVDVEVEICtcclxuICAgICAgICAgIERPQ1VNRU5UX1BPU0lUSU9OX0lNUExFTUVOVEFUSU9OX1NQRUNJRklDKTtcclxuXHJcbiAgICBuID0gTWF0aC5taW4odGhlc2UubGVuZ3RoLCB0aG9zZS5sZW5ndGgpO1xyXG4gICAgZm9yKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xyXG4gICAgICBpZiAodGhlc2VbaV0gIT09IHRob3NlW2ldKSB7XHJcbiAgICAgICAgLy8gV2UgZm91bmQgdHdvIGRpZmZlcmVudCBhbmNlc3RvcnMsIHNvIGNvbXBhcmVcclxuICAgICAgICAvLyB0aGVpciBwb3NpdGlvbnNcclxuICAgICAgICBpZiAodGhlc2VbaV0uaW5kZXggPCB0aG9zZVtpXS5pbmRleClcclxuICAgICAgICAgIHJldHVybiBET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgcmV0dXJuIERPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHdlIGdldCB0byBoZXJlLCB0aGVuIG9uZSBvZiB0aGUgbm9kZXMgKHRoZSBvbmUgd2l0aCB0aGVcclxuICAgIC8vIHNob3J0ZXIgbGlzdCBvZiBhbmNlc3RvcnMpIGNvbnRhaW5zIHRoZSBvdGhlciBvbmUuXHJcbiAgICBpZiAodGhlc2UubGVuZ3RoIDwgdGhvc2UubGVuZ3RoKVxyXG4gICAgICByZXR1cm4gKERPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyArXHJcbiAgICAgICAgICBET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpO1xyXG4gICAgZWxzZVxyXG4gICAgICByZXR1cm4gKERPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyArXHJcbiAgICAgICAgICBET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUyk7XHJcbiAgfX0sXHJcblxyXG4gIGlzU2FtZU5vZGU6IHt2YWx1ZSA6IGZ1bmN0aW9uIGlzU2FtZU5vZGUobm9kZSkge1xyXG4gICAgcmV0dXJuIHRoaXMgPT09IG5vZGU7XHJcbiAgfX0sXHJcblxyXG5cclxuICAvLyBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIHRoZSBnZW5lcmljIHBhcnRzIG9mIG5vZGUgZXF1YWxpdHkgdGVzdGluZ1xyXG4gIC8vIGFuZCBkZWZlcnMgdG8gdGhlIChub24tcmVjdXJzaXZlKSB0eXBlLXNwZWNpZmljIGlzRXF1YWwoKSBtZXRob2RcclxuICAvLyBkZWZpbmVkIGJ5IHN1YmNsYXNzZXNcclxuICBpc0VxdWFsTm9kZTogeyB2YWx1ZTogZnVuY3Rpb24gaXNFcXVhbE5vZGUobm9kZSkge1xyXG4gICAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gdGhpcy5ub2RlVHlwZSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIC8vIENoZWNrIGZvciBzYW1lIG51bWJlciBvZiBjaGlsZHJlblxyXG4gICAgLy8gQ2hlY2sgZm9yIGNoaWxkcmVuIHRoaXMgd2F5IGJlY2F1c2UgaXQgaXMgbW9yZSBlZmZpY2llbnRcclxuICAgIC8vIGZvciBjaGlsZGxlc3MgbGVhZiBub2Rlcy5cclxuICAgIHZhciBuOyAvLyBudW1iZXIgb2YgY2hpbGQgbm9kZXNcclxuICAgIGlmICghdGhpcy5maXJzdENoaWxkKSB7XHJcbiAgICAgIG4gPSAwO1xyXG4gICAgICBpZiAobm9kZS5maXJzdENoaWxkKSByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgbiA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7XHJcbiAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoICE9PSBuKSByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgdHlwZS1zcGVjaWZpYyBwcm9wZXJ0aWVzIGZvciBlcXVhbGl0eVxyXG4gICAgaWYgKCF0aGlzLmlzRXF1YWwobm9kZSkpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAvLyBOb3cgY2hlY2sgY2hpbGRyZW4gZm9yIGVxdWFsaXR5XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgIHZhciBjMSA9IHRoaXMuY2hpbGROb2Rlc1tpXSwgYzIgPSBub2RlLmNoaWxkTm9kZXNbaV07XHJcbiAgICAgIGlmICghYzEuaXNFcXVhbE5vZGUoYzIpKSByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfX0sXHJcblxyXG4gIC8vIFRoaXMgbWV0aG9kIGRlbGVnYXRlcyBzaGFsbG93IGNsb25pbmcgdG8gYSBjbG9uZSgpIG1ldGhvZFxyXG4gIC8vIHRoYXQgZWFjaCBjb25jcmV0ZSBzdWJjbGFzcyBtdXN0IGltcGxlbWVudFxyXG4gIGNsb25lTm9kZTogeyB2YWx1ZTogZnVuY3Rpb24oZGVlcCkge1xyXG4gICAgLy8gQ2xvbmUgdGhpcyBub2RlXHJcbiAgICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lKCk7XHJcblxyXG4gICAgLy8gSGFuZGxlIHRoZSByZWN1cnNpdmUgY2FzZSBpZiBuZWNlc3NhcnlcclxuICAgIGlmIChkZWVwICYmIHRoaXMuZmlyc3RDaGlsZCkge1xyXG4gICAgICBmb3IodmFyIGkgPSAwLCBuID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIGNsb25lLl9hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbaV0uY2xvbmVOb2RlKHRydWUpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjbG9uZTtcclxuICB9fSxcclxuXHJcbiAgbG9va3VwUHJlZml4OiB7IHZhbHVlOiBmdW5jdGlvbiBsb29rdXBQcmVmaXgobnMpIHtcclxuICAgIHZhciBlO1xyXG4gICAgaWYgKG5zID09PSAnJykgcmV0dXJuIG51bGw7XHJcbiAgICBzd2l0Y2godGhpcy5ub2RlVHlwZSkge1xyXG4gICAgY2FzZSBFTEVNRU5UX05PREU6XHJcbiAgICAgIHJldHVybiB0aGlzLmxvY2F0ZU5hbWVzcGFjZVByZWZpeChucyk7XHJcbiAgICBjYXNlIERPQ1VNRU5UX05PREU6XHJcbiAgICAgIGUgPSB0aGlzLmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgcmV0dXJuIGUgPyBlLmxvY2F0ZU5hbWVzcGFjZVByZWZpeChucykgOiBudWxsO1xyXG4gICAgY2FzZSBET0NVTUVOVF9UWVBFX05PREU6XHJcbiAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgZSA9IHRoaXMucGFyZW50RWxlbWVudDtcclxuICAgICAgcmV0dXJuIGUgPyBlLmxvY2F0ZU5hbWVzcGFjZVByZWZpeChucykgOiBudWxsO1xyXG4gICAgfVxyXG4gIH19LFxyXG5cclxuXHJcbiAgbG9va3VwTmFtZXNwYWNlVVJJOiB7dmFsdWU6IGZ1bmN0aW9uIGxvb2t1cE5hbWVzcGFjZVVSSShwcmVmaXgpIHtcclxuICAgIHZhciBlO1xyXG4gICAgc3dpdGNoKHRoaXMubm9kZVR5cGUpIHtcclxuICAgIGNhc2UgRUxFTUVOVF9OT0RFOlxyXG4gICAgICByZXR1cm4gdGhpcy5sb2NhdGVOYW1lc3BhY2UocHJlZml4KTtcclxuICAgIGNhc2UgRE9DVU1FTlRfTk9ERTpcclxuICAgICAgZSA9IHRoaXMuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICByZXR1cm4gZSA/IGUubG9jYXRlTmFtZXNwYWNlKHByZWZpeCkgOiBudWxsO1xyXG4gICAgY2FzZSBET0NVTUVOVF9UWVBFX05PREU6XHJcbiAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgZSA9IHRoaXMucGFyZW50RWxlbWVudDtcclxuICAgICAgcmV0dXJuIGUgPyBlLmxvY2F0ZU5hbWVzcGFjZShwcmVmaXgpIDogbnVsbDtcclxuICAgIH1cclxuICB9fSxcclxuXHJcbiAgaXNEZWZhdWx0TmFtZXNwYWNlOiB7IHZhbHVlOiBmdW5jdGlvbiBpc0RlZmF1bHROYW1lc3BhY2UobnMpIHtcclxuICAgIHZhciBkZWZhdWx0bnMgPSB0aGlzLmxvb2t1cE5hbWVzcGFjZVVSSShudWxsKTtcclxuICAgIGlmIChkZWZhdWx0bnMgPT09IG51bGwpIGRlZmF1bHRucyA9ICcnO1xyXG4gICAgcmV0dXJuIG5zID09PSBkZWZhdWx0bnM7XHJcbiAgfX0sXHJcblxyXG4gIC8vIFV0aWxpdHkgbWV0aG9kcyBmb3Igbm9kZXMuICBOb3QgcGFydCBvZiB0aGUgRE9NXHJcblxyXG4gIC8vIFJldHVybiB0aGUgaW5kZXggb2YgdGhpcyBub2RlIGluIGl0cyBwYXJlbnQuXHJcbiAgLy8gVGhyb3cgaWYgbm8gcGFyZW50LCBvciBpZiB0aGlzIG5vZGUgaXMgbm90IGEgY2hpbGQgb2YgaXRzIHBhcmVudFxyXG4gIGluZGV4OiB7IGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICB1dGlscy5hc3NlcnQodGhpcy5wYXJlbnROb2RlKTtcclxuICAgIHZhciBraWRzID0gdGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXM7XHJcbiAgICBpZiAodGhpcy5faW5kZXggPT09IHVuZGVmaW5lZCB8fCBraWRzW3RoaXMuX2luZGV4XSAhPT0gdGhpcykge1xyXG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBkb24ndCBoYXZlIGFuIE8oTl4yKSBibG93dXAgaWYgbm9uZSBvZiB0aGVcclxuICAgICAgLy8ga2lkcyBoYXZlIGRlZmluZWQgaW5kaWNlcyB5ZXQgYW5kIHdlJ3JlIHRyYXZlcnNpbmcgdmlhXHJcbiAgICAgIC8vIG5leHRTaWJsaW5nIG9yIHByZXZTaWJsaW5nXHJcbiAgICAgIGZvciAodmFyIGk9MDsgaTxraWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAga2lkc1tpXS5faW5kZXggPSBpO1xyXG4gICAgICB9XHJcbiAgICAgIHV0aWxzLmFzc2VydChraWRzW3RoaXMuX2luZGV4XSA9PT0gdGhpcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5faW5kZXg7XHJcbiAgfX0sXHJcblxyXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoaXMgbm9kZSBpcyBlcXVhbCB0byBvciBpcyBhbiBhbmNlc3RvciBvZiB0aGF0IG5vZGVcclxuICAvLyBOb3RlIHRoYXQgbm9kZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgYW5jZXN0b3JzIG9mIHRoZW1zZWx2ZXNcclxuICBpc0FuY2VzdG9yOiB7IHZhbHVlOiBmdW5jdGlvbih0aGF0KSB7XHJcbiAgICAvLyBJZiB0aGV5IGJlbG9uZyB0byBkaWZmZXJlbnQgZG9jdW1lbnRzLCB0aGVuIHRoZXkncmUgdW5yZWxhdGVkLlxyXG4gICAgaWYgKHRoaXMuZG9jICE9PSB0aGF0LmRvYykgcmV0dXJuIGZhbHNlO1xyXG4gICAgLy8gSWYgb25lIGlzIHJvb3RlZCBhbmQgb25lIGlzbid0IHRoZW4gdGhleSdyZSBub3QgcmVsYXRlZFxyXG4gICAgaWYgKHRoaXMucm9vdGVkICE9PSB0aGF0LnJvb3RlZCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIC8vIE90aGVyd2lzZSBjaGVjayBieSB0cmF2ZXJzaW5nIHRoZSBwYXJlbnROb2RlIGNoYWluXHJcbiAgICBmb3IodmFyIGUgPSB0aGF0OyBlOyBlID0gZS5wYXJlbnROb2RlKSB7XHJcbiAgICAgIGlmIChlID09PSB0aGlzKSByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9fSxcclxuXHJcbiAgLy8gRE9NSU5PIENoYW5nZWQgdGhlIGJlaGF2aW9yIHRvIGNvbmZvcm0gd2l0aCB0aGUgc3BlY3MuIFNlZTpcclxuICAvLyBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2QvdG9waWMvbW96aWxsYS5kZXYucGxhdGZvcm0vNzdzSVljcGREbWMvZGlzY3Vzc2lvblxyXG4gIGVuc3VyZVNhbWVEb2M6IHsgdmFsdWU6IGZ1bmN0aW9uKHRoYXQpIHtcclxuICAgIGlmICh0aGF0Lm93bmVyRG9jdW1lbnQgPT09IG51bGwpIHtcclxuICAgICAgdGhhdC5vd25lckRvY3VtZW50ID0gdGhpcy5kb2M7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKHRoYXQub3duZXJEb2N1bWVudCAhPT0gdGhpcy5kb2MpIHtcclxuICAgICAgdXRpbHMuV3JvbmdEb2N1bWVudEVycm9yKCk7XHJcbiAgICB9XHJcbiAgfX0sXHJcblxyXG4gIC8vIFJlbW92ZSBhbGwgb2YgdGhpcyBub2RlJ3MgY2hpbGRyZW4uICBUaGlzIGlzIGEgbWlub3JcclxuICAvLyBvcHRpbWl6YXRpb24gdGhhdCBvbmx5IGNhbGxzIG1vZGlmeSgpIG9uY2UuXHJcbiAgcmVtb3ZlQ2hpbGRyZW46IHsgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKCkge1xyXG4gICAgdmFyIG4gPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoO1xyXG4gICAgaWYgKG4pIHtcclxuICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3RlZCA/IHRoaXMub3duZXJEb2N1bWVudCA6IG51bGw7XHJcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBpZiAocm9vdCkgcm9vdC5tdXRhdGVSZW1vdmUodGhpcy5jaGlsZE5vZGVzW2ldKTtcclxuICAgICAgICB0aGlzLmNoaWxkTm9kZXNbaV0ucGFyZW50Tm9kZSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCA9IDA7IC8vIEZvcmdldCBhbGwgY2hpbGRyZW5cclxuICAgICAgdGhpcy5tb2RpZnkoKTsgICAgICAgICAgICAgIC8vIFVwZGF0ZSBsYXN0IG1vZGlmaWVkIHR5cGUgb25jZSBvbmx5XHJcbiAgICB9XHJcbiAgfX0sXHJcblxyXG4gIC8vIEluc2VydCB0aGlzIG5vZGUgYXMgYSBjaGlsZCBvZiBwYXJlbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCxcclxuICAvLyBmaXJpbmcgbXV0YXRpb24gZXZlbnRzIGFzIG5lY2Vzc2FyeVxyXG4gIGluc2VydDogeyB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0KHBhcmVudCwgaW5kZXgpIHtcclxuICAgIHRoaXMuX2luc2VydE9yUmVwbGFjZShwYXJlbnQsIGluZGV4LCBmYWxzZSk7XHJcbiAgfX0sXHJcblxyXG4gIC8vIEluc2VydCB0aGlzIG5vZGUgYXMgYSBjaGlsZCBvZiBwYXJlbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCxcclxuICAvLyBvciByZXBsYWNlIHRoZSBzcGVjaWZpZWQgY2hpbGQgd2l0aCB0aGlzIG5vZGUsIGZpcmluZyBtdXRhdGlvbiBldmVudHMgYXNcclxuICAvLyBuZWNlc3NhcnlcclxuICBfaW5zZXJ0T3JSZXBsYWNlOiB7IHZhbHVlOiBmdW5jdGlvbiBfaW5zZXJ0T3JSZXBsYWNlKHBhcmVudCwgaW5kZXgsIGlzUmVwbGFjZSkge1xyXG4gICAgdmFyIGNoaWxkID0gdGhpcztcclxuICAgIHZhciBraWRzID0gcGFyZW50LmNoaWxkTm9kZXM7XHJcblxyXG4gICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmIGNoaWxkLnJvb3RlZCkge1xyXG4gICAgICB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBhIGNoaWxkIG9mIHRoZSBzcGVjaWZpZWQgcGFyZW50LCB0aGVuXHJcbiAgICAvLyB0aGUgaW5kZXggbWF5IGhhdmUgdG8gYmUgYWRqdXN0ZWQuXHJcbiAgICBpZiAoY2hpbGQucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XHJcbiAgICAgIHZhciBjdXJyZW50SW5kZXggPSBjaGlsZC5pbmRleDtcclxuICAgICAgLy8gSWYgd2UncmUgbm90IG1vdmluZyB0aGUgbm9kZSwgd2UncmUgZG9uZSBub3dcclxuICAgICAgLy8gWFhYOiBvciBkbyBET00gbXV0YXRpb24gZXZlbnRzIHN0aWxsIGhhdmUgdG8gYmUgZmlyZWQ/XHJcbiAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IGluZGV4KSByZXR1cm47XHJcblxyXG4gICAgICAvLyBJZiB0aGUgY2hpbGQgaXMgYmVmb3JlIHRoZSBzcG90IGl0IGlzIHRvIGJlIGluc2VydGVkIGF0LFxyXG4gICAgICAvLyB0aGVuIHdoZW4gaXQgaXMgcmVtb3ZlZCwgdGhlIGluZGV4IG9mIHRoYXQgc3BvdCB3aWxsIGJlXHJcbiAgICAgIC8vIHJlZHVjZWQuXHJcbiAgICAgIGlmIChjdXJyZW50SW5kZXggPCBpbmRleCkgaW5kZXgtLTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZWxldGUgdGhlIG9sZCBjaGlsZFxyXG4gICAgaWYgKGlzUmVwbGFjZSkge1xyXG4gICAgICB2YXIgb2xkQ2hpbGQgPSBwYXJlbnQuY2hpbGROb2Rlc1tpbmRleF07XHJcbiAgICAgIGlmIChvbGRDaGlsZC5yb290ZWQpIG9sZENoaWxkLmRvYy5tdXRhdGVSZW1vdmUob2xkQ2hpbGQpO1xyXG4gICAgICBvbGRDaGlsZC5wYXJlbnROb2RlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBib3RoIHRoZSBjaGlsZCBhbmQgdGhlIHBhcmVudCBhcmUgcm9vdGVkLCB0aGVuIHdlIHdhbnQgdG9cclxuICAgIC8vIHRyYW5zcGxhbnQgdGhlIGNoaWxkIHdpdGhvdXQgdXByb290aW5nIGFuZCByZXJvb3RpbmcgaXQuXHJcbiAgICBpZiAoY2hpbGQucm9vdGVkICYmIHBhcmVudC5yb290ZWQpIHtcclxuICAgICAgLy8gUmVtb3ZlIHRoZSBjaGlsZCBmcm9tIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSB0cmVlXHJcbiAgICAgIC8vIHdpdGhvdXQgY2FsbGluZyByZW1vdmUoKSwgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0byB1cHJvb3QgaXQuXHJcbiAgICAgIHZhciBjdXJwYXIgPSBjaGlsZC5wYXJlbnROb2RlO1xyXG4gICAgICBjdXJwYXIuY2hpbGROb2Rlcy5zcGxpY2UoY2hpbGQuaW5kZXgsIDEpO1xyXG4gICAgICBjdXJwYXIubW9kaWZ5KCk7XHJcblxyXG4gICAgICAvLyBBbmQgaW5zZXJ0IGl0IGFzIGEgY2hpbGQgb2YgaXRzIG5ldyBwYXJlbnRcclxuICAgICAgY2hpbGQucGFyZW50Tm9kZSA9IHBhcmVudDtcclxuICAgICAgaWYgKGlzUmVwbGFjZSkge1xyXG4gICAgICAgIGtpZHNbaW5kZXhdID0gY2hpbGQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAga2lkcy5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcclxuICAgICAgfVxyXG4gICAgICBjaGlsZC5faW5kZXggPSBpbmRleDtcclxuICAgICAgcGFyZW50Lm1vZGlmeSgpO1xyXG5cclxuICAgICAgLy8gR2VuZXJhdGUgYSBtb3ZlIG11dGF0aW9uIGV2ZW50XHJcbiAgICAgIHBhcmVudC5kb2MubXV0YXRlTW92ZShjaGlsZCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgdmFyIHNwbGljZUFyZ3MgPSBbaW5kZXgsIGlzUmVwbGFjZSA/IDEgOiAwXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdmFyIGZyYWdDaGlsZCA9IGNoaWxkLmNoaWxkTm9kZXNbaV07XHJcbiAgICAgICAgICBzcGxpY2VBcmdzLnB1c2goZnJhZ0NoaWxkKTtcclxuICAgICAgICAgIGZyYWdDaGlsZC5wYXJlbnROb2RlID0gcGFyZW50O1xyXG4gICAgICAgICAgZnJhZ0NoaWxkLl9pbmRleCA9IGluZGV4ICsgaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBub2RlcyBmcm9tIHRoZSBkb2N1bWVudCBmcmFnbWVudFxyXG4gICAgICAgIGNoaWxkLmNoaWxkTm9kZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAvLyBBZGQgYWxsIG5vZGVzIHRvIHRoZSBuZXcgcGFyZW50LCBvdmVyd3JpdGluZyB0aGUgb2xkIGNoaWxkXHJcbiAgICAgICAga2lkcy5zcGxpY2UuYXBwbHkoa2lkcywgc3BsaWNlQXJncyk7XHJcbiAgICAgICAgLy8gQ2FsbCB0aGUgbXV0YXRpb24gaGFuZGxlcnNcclxuICAgICAgICAvLyBVc2Ugc3BsaWNlQXJncyBzaW5jZSB0aGUgb3JpZ2luYWwgYXJyYXkgaGFzIGJlZW4gZGVzdHJveWVkLiBUaGVcclxuICAgICAgICAvLyBsaXZlbmVzcyBndWFyYW50ZWUgcmVxdWlyZXMgdXMgdG8gY2xvbmUgdGhlIGFycmF5IHNvIHRoYXRcclxuICAgICAgICAvLyByZWZlcmVuY2VzIHRvIHRoZSBjaGlsZE5vZGVzIG9mIHRoZSBEb2N1bWVudEZyYWdtZW50IHdpbGwgYmUgZW1wdHlcclxuICAgICAgICAvLyB3aGVuIHRoZSBpbnNlcnRpb24gaGFuZGxlcnMgYXJlIGNhbGxlZC5cclxuICAgICAgICBpZiAocGFyZW50LnJvb3RlZCkge1xyXG4gICAgICAgICAgcGFyZW50Lm1vZGlmeSgpO1xyXG4gICAgICAgICAgZm9yIChpID0gMjsgaSA8IHNwbGljZUFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcGFyZW50LmRvYy5tdXRhdGVJbnNlcnQoc3BsaWNlQXJnc1tpXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIElmIHRoZSBjaGlsZCBhbHJlYWR5IGhhcyBhIHBhcmVudCwgaXQgbmVlZHMgdG8gYmVcclxuICAgICAgICAvLyByZW1vdmVkIGZyb20gdGhhdCBwYXJlbnQsIHdoaWNoIG1heSBhbHNvIHVwcm9vdCBpdFxyXG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnROb2RlKSBjaGlsZC5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgLy8gTm93IGluc2VydCB0aGUgY2hpbGQgaW50byB0aGUgcGFyZW50J3MgYXJyYXkgb2YgY2hpbGRyZW5cclxuICAgICAgICBjaGlsZC5wYXJlbnROb2RlID0gcGFyZW50O1xyXG4gICAgICAgIGlmIChpc1JlcGxhY2UpIHtcclxuICAgICAgICAgIGtpZHNbaW5kZXhdID0gY2hpbGQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGtpZHMuc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoaWxkLl9pbmRleCA9IGluZGV4O1xyXG5cclxuICAgICAgICAvLyBBbmQgcm9vdCB0aGUgY2hpbGQgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgaWYgKHBhcmVudC5yb290ZWQpIHtcclxuICAgICAgICAgIHBhcmVudC5tb2RpZnkoKTtcclxuICAgICAgICAgIHBhcmVudC5kb2MubXV0YXRlSW5zZXJ0KGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9fSxcclxuXHJcblxyXG4gIC8vIFJldHVybiB0aGUgbGFzdE1vZFRpbWUgdmFsdWUgZm9yIHRoaXMgbm9kZS4gKEZvciB1c2UgYXMgYVxyXG4gIC8vIGNhY2hlIGludmFsaWRhdGlvbiBtZWNoYW5pc20uIElmIHRoZSBub2RlIGRvZXMgbm90IGFscmVhZHlcclxuICAvLyBoYXZlIG9uZSwgaW5pdGlhbGl6ZSBpdCBmcm9tIHRoZSBvd25lciBkb2N1bWVudCdzIG1vZGNsb2NrXHJcbiAgLy8gcHJvcGVydHkuIChOb3RlIHRoYXQgbW9kY2xvY2sgZG9lcyBub3QgcmV0dXJuIHRoZSBhY3R1YWxcclxuICAvLyB0aW1lOyBpdCBpcyBzaW1wbHkgYSBjb3VudGVyIGluY3JlbWVudGVkIG9uIGVhY2ggZG9jdW1lbnRcclxuICAvLyBtb2RpZmljYXRpb24pXHJcbiAgbGFzdE1vZFRpbWU6IHsgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgIGlmICghdGhpcy5fbGFzdE1vZFRpbWUpIHtcclxuICAgICAgdGhpcy5fbGFzdE1vZFRpbWUgPSB0aGlzLmRvYy5tb2RjbG9jaztcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9sYXN0TW9kVGltZTtcclxuICB9fSxcclxuXHJcbiAgLy8gSW5jcmVtZW50IHRoZSBvd25lciBkb2N1bWVudCdzIG1vZGNsb2NrIGFuZCB1c2UgdGhlIG5ld1xyXG4gIC8vIHZhbHVlIHRvIHVwZGF0ZSB0aGUgbGFzdE1vZFRpbWUgdmFsdWUgZm9yIHRoaXMgbm9kZSBhbmRcclxuICAvLyBhbGwgb2YgaXRzIGFuY2VzdG9ycy4gTm9kZXMgdGhhdCBoYXZlIG5ldmVyIGhhZCB0aGVpclxyXG4gIC8vIGxhc3RNb2RUaW1lIHZhbHVlIHF1ZXJpZWQgZG8gbm90IG5lZWQgdG8gaGF2ZSBhXHJcbiAgLy8gbGFzdE1vZFRpbWUgcHJvcGVydHkgc2V0IG9uIHRoZW0gc2luY2UgdGhlcmUgaXMgbm9cclxuICAvLyBwcmV2aW91c2x5IHF1ZXJpZWQgdmFsdWUgdG8gZXZlciBjb21wYXJlIHRoZSBuZXcgdmFsdWVcclxuICAvLyBhZ2FpbnN0LCBzbyBvbmx5IHVwZGF0ZSBub2RlcyB0aGF0IGFscmVhZHkgaGF2ZSBhXHJcbiAgLy8gX2xhc3RNb2RUaW1lIHByb3BlcnR5LlxyXG4gIG1vZGlmeTogeyB2YWx1ZTogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5kb2MubW9kY2xvY2spIHsgLy8gU2tpcCB3aGlsZSBkb2MubW9kY2xvY2sgPT0gMFxyXG4gICAgICB2YXIgdGltZSA9ICsrdGhpcy5kb2MubW9kY2xvY2s7XHJcbiAgICAgIGZvcih2YXIgbiA9IHRoaXM7IG47IG4gPSBuLnBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgICBpZiAobi5fbGFzdE1vZFRpbWUpIHtcclxuICAgICAgICAgIG4uX2xhc3RNb2RUaW1lID0gdGltZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9fSxcclxuXHJcbiAgLy8gVGhpcyBhdHRyaWJ1dGUgaXMgbm90IHBhcnQgb2YgdGhlIERPTSBidXQgaXMgcXVpdGUgaGVscGZ1bC5cclxuICAvLyBJdCByZXR1cm5zIHRoZSBkb2N1bWVudCB3aXRoIHdoaWNoIGEgbm9kZSBpcyBhc3NvY2lhdGVkLiAgVXN1YWxseVxyXG4gIC8vIHRoaXMgaXMgdGhlIG93bmVyRG9jdW1lbnQuIEJ1dCBvd25lckRvY3VtZW50IGlzIG51bGwgZm9yIHRoZVxyXG4gIC8vIGRvY3VtZW50IG9iamVjdCBpdHNlbGYsIHNvIHRoaXMgaXMgYSBoYW5keSB3YXkgdG8gZ2V0IHRoZSBkb2N1bWVudFxyXG4gIC8vIHJlZ2FyZGxlc3Mgb2YgdGhlIG5vZGUgdHlwZVxyXG4gIGRvYzogeyBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzO1xyXG4gIH19LFxyXG5cclxuXHJcbiAgLy8gSWYgdGhlIG5vZGUgaGFzIGEgbmlkIChub2RlIGlkKSwgdGhlbiBpdCBpcyByb290ZWQgaW4gYSBkb2N1bWVudFxyXG4gIHJvb3RlZDogeyBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5fbmlkO1xyXG4gIH19LFxyXG5cclxuICBub3JtYWxpemU6IHsgdmFsdWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgZm9yICh2YXIgaT0wOyBpIDwgdGhpcy5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGROb2Rlc1tpXTtcclxuXHJcbiAgICAgIGlmIChjaGlsZC5ub3JtYWxpemUpIHtcclxuICAgICAgICBjaGlsZC5ub3JtYWxpemUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2hpbGQubm9kZVZhbHVlID09PSBcIlwiKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZCk7XHJcbiAgICAgICAgaS0tO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaSkge1xyXG4gICAgICAgIHZhciBwcmV2Q2hpbGQgPSB0aGlzLmNoaWxkTm9kZXNbaS0xXTtcclxuXHJcbiAgICAgICAgaWYgKHByZXZDaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcclxuICAgICAgICAgIC8vIHJlbW92ZSB0aGUgY2hpbGQgYW5kIGRlY3JlbWVudCBpXHJcbiAgICAgICAgICBwcmV2Q2hpbGQuYXBwZW5kRGF0YShjaGlsZC5ub2RlVmFsdWUpO1xyXG5cclxuICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgICAgaS0tO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH19LFxyXG5cclxuICAvLyBDb252ZXJ0IHRoZSBjaGlsZHJlbiBvZiBhIG5vZGUgdG8gYW4gSFRNTCBzdHJpbmcuXHJcbiAgLy8gVGhpcyBpcyB1c2VkIGJ5IHRoZSBpbm5lckhUTUwgZ2V0dGVyXHJcbiAgLy8gVGhlIHNlcmlhbGl6YXRpb24gc3BlYyBpcyBhdDpcclxuICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtZW5kLmh0bWwjc2VyaWFsaXppbmctaHRtbC1mcmFnbWVudHNcclxuICBzZXJpYWxpemU6IHsgdmFsdWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHMgPSAnJztcclxuICAgIGZvcih2YXIgaSA9IDAsIG4gPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgIHZhciBraWQgPSB0aGlzLmNoaWxkTm9kZXNbaV07XHJcbiAgICAgIHN3aXRjaChraWQubm9kZVR5cGUpIHtcclxuICAgICAgY2FzZSAxOiAvL0VMRU1FTlRfTk9ERVxyXG4gICAgICAgIHZhciBucyA9IGtpZC5uYW1lc3BhY2VVUkk7XHJcbiAgICAgICAgdmFyIGh0bWwgPSBucyA9PT0gTkFNRVNQQUNFLkhUTUw7XHJcbiAgICAgICAgdmFyIHRhZ25hbWUgPSAoaHRtbCB8fCBucyA9PT0gTkFNRVNQQUNFLlNWRyB8fCBucyA9PT0gTkFNRVNQQUNFLk1BVEhNTCkgPyBraWQubG9jYWxOYW1lIDoga2lkLnRhZ05hbWU7XHJcblxyXG4gICAgICAgIHMgKz0gJzwnICsgdGFnbmFtZTtcclxuXHJcbiAgICAgICAgZm9yKHZhciBqID0gMCwgayA9IGtpZC5fbnVtYXR0cnM7IGogPCBrOyBqKyspIHtcclxuICAgICAgICAgIHZhciBhID0ga2lkLl9hdHRyKGopO1xyXG4gICAgICAgICAgcyArPSAnICcgKyBhdHRybmFtZShhKTtcclxuICAgICAgICAgIGlmIChhLnZhbHVlICE9PSB1bmRlZmluZWQpIHMgKz0gJz1cIicgKyBlc2NhcGVBdHRyKGEudmFsdWUpICsgJ1wiJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcyArPSAnPic7XHJcblxyXG4gICAgICAgIGlmICghKGh0bWwgJiYgZW1wdHlFbGVtZW50c1t0YWduYW1lXSkpIHtcclxuICAgICAgICAgIHZhciBzcyA9IGtpZC5zZXJpYWxpemUoKTtcclxuICAgICAgICAgIGlmIChodG1sICYmIGV4dHJhTmV3TGluZVt0YWduYW1lXSAmJiBzcy5jaGFyQXQoMCk9PT0nXFxuJykgcyArPSAnXFxuJztcclxuICAgICAgICAgIC8vIFNlcmlhbGl6ZSBjaGlsZHJlbiBhbmQgYWRkIGVuZCB0YWcgZm9yIGFsbCBvdGhlcnNcclxuICAgICAgICAgIHMgKz0gc3M7XHJcbiAgICAgICAgICBzICs9ICc8LycgKyB0YWduYW1lICsgJz4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAzOiAvL1RFWFRfTk9ERVxyXG4gICAgICBjYXNlIDQ6IC8vQ0RBVEFfU0VDVElPTl9OT0RFXHJcbiAgICAgICAgdmFyIHBhcmVudHRhZztcclxuICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmXHJcbiAgICAgICAgICB0aGlzLm5hbWVzcGFjZVVSSSA9PT0gTkFNRVNQQUNFLkhUTUwpXHJcbiAgICAgICAgICBwYXJlbnR0YWcgPSB0aGlzLnRhZ05hbWU7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgcGFyZW50dGFnID0gJyc7XHJcblxyXG4gICAgICAgIGlmIChoYXNSYXdDb250ZW50W3BhcmVudHRhZ10gfHxcclxuICAgICAgICAgICAgKHBhcmVudHRhZz09PSdOT1NDUklQVCcgJiYgdGhpcy5vd25lckRvY3VtZW50Ll9zY3JpcHRpbmdfZW5hYmxlZCkpIHtcclxuICAgICAgICAgIHMgKz0ga2lkLmRhdGE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHMgKz0gZXNjYXBlKGtpZC5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgODogLy9DT01NRU5UX05PREVcclxuICAgICAgICBzICs9ICc8IS0tJyArIGtpZC5kYXRhICsgJy0tPic7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgNzogLy9QUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREVcclxuICAgICAgICBzICs9ICc8PycgKyBraWQudGFyZ2V0ICsgJyAnICsga2lkLmRhdGEgKyAnPz4nO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDEwOiAvL0RPQ1VNRU5UX1RZUEVfTk9ERVxyXG4gICAgICAgIHMgKz0gJzwhRE9DVFlQRSAnICsga2lkLm5hbWU7XHJcblxyXG4gICAgICAgIGlmIChmYWxzZSkge1xyXG4gICAgICAgICAgLy8gTGF0ZXN0IEhUTUwgc2VyaWFsaXphdGlvbiBzcGVjIG9taXRzIHRoZSBwdWJsaWMvc3lzdGVtIElEXHJcbiAgICAgICAgICBpZiAoa2lkLnB1YmxpY0lEKSB7XHJcbiAgICAgICAgICAgIHMgKz0gJyBQVUJMSUMgXCInICsga2lkLnB1YmxpY0lkICsgJ1wiJztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoa2lkLnN5c3RlbUlkKSB7XHJcbiAgICAgICAgICAgIHMgKz0gJyBcIicgKyBraWQuc3lzdGVtSWQgKyAnXCInO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcyArPSAnPic7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdXRpbHMuSW52YWxpZFN0YXRlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcztcclxuICB9fSxcclxuXHJcbiAgLy8gbWlycm9yIG5vZGUgdHlwZSBwcm9wZXJ0aWVzIGluIHRoZSBwcm90b3R5cGUsIHNvIHRoZXkgYXJlIHByZXNlbnRcclxuICAvLyBpbiBpbnN0YW5jZXMgb2YgTm9kZSAoYW5kIHN1YmNsYXNzZXMpXHJcbiAgRUxFTUVOVF9OT0RFOiAgICAgICAgICAgICAgICB7IHZhbHVlOiBFTEVNRU5UX05PREUgfSxcclxuICBBVFRSSUJVVEVfTk9ERTogICAgICAgICAgICAgIHsgdmFsdWU6IEFUVFJJQlVURV9OT0RFIH0sXHJcbiAgVEVYVF9OT0RFOiAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiBURVhUX05PREUgfSxcclxuICBDREFUQV9TRUNUSU9OX05PREU6ICAgICAgICAgIHsgdmFsdWU6IENEQVRBX1NFQ1RJT05fTk9ERSB9LFxyXG4gIEVOVElUWV9SRUZFUkVOQ0VfTk9ERTogICAgICAgeyB2YWx1ZTogRU5USVRZX1JFRkVSRU5DRV9OT0RFIH0sXHJcbiAgRU5USVRZX05PREU6ICAgICAgICAgICAgICAgICB7IHZhbHVlOiBFTlRJVFlfTk9ERSB9LFxyXG4gIFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERTogeyB2YWx1ZTogUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFIH0sXHJcbiAgQ09NTUVOVF9OT0RFOiAgICAgICAgICAgICAgICB7IHZhbHVlOiBDT01NRU5UX05PREUgfSxcclxuICBET0NVTUVOVF9OT0RFOiAgICAgICAgICAgICAgIHsgdmFsdWU6IERPQ1VNRU5UX05PREUgfSxcclxuICBET0NVTUVOVF9UWVBFX05PREU6ICAgICAgICAgIHsgdmFsdWU6IERPQ1VNRU5UX1RZUEVfTk9ERSB9LFxyXG4gIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6ICAgICAgeyB2YWx1ZTogRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB9LFxyXG4gIE5PVEFUSU9OX05PREU6ICAgICAgICAgICAgICAgeyB2YWx1ZTogTk9UQVRJT05fTk9ERSB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gZXNjYXBlKHMpIHtcclxuICByZXR1cm4gcy5yZXBsYWNlKC9bJjw+XFx1MDBBMF0vZywgZnVuY3Rpb24oYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgJyYnOiByZXR1cm4gJyZhbXA7JztcclxuICAgIGNhc2UgJzwnOiByZXR1cm4gJyZsdDsnO1xyXG4gICAgY2FzZSAnPic6IHJldHVybiAnJmd0Oyc7XHJcbiAgICBjYXNlICdcXHUwMEEwJzogcmV0dXJuICcmbmJzcDsnO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlc2NhcGVBdHRyKHMpIHtcclxuICB2YXIgdG9Fc2NhcGUgPSAvWyZcIlxcdTAwQTBdL2c7XHJcbiAgaWYgKCF0b0VzY2FwZS50ZXN0KHMpKSB7XHJcbiAgICAgIC8vIG5vdGhpbmcgdG8gZG8sIGZhc3QgcGF0aFxyXG4gICAgICByZXR1cm4gcztcclxuICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gcy5yZXBsYWNlKHRvRXNjYXBlLCBmdW5jdGlvbihjKSB7XHJcbiAgICAgICAgc3dpdGNoKGMpIHtcclxuICAgICAgICBjYXNlICcmJzogcmV0dXJuICcmYW1wOyc7XHJcbiAgICAgICAgY2FzZSAnXCInOiByZXR1cm4gJyZxdW90Oyc7XHJcbiAgICAgICAgY2FzZSAnXFx1MDBBMCc6IHJldHVybiAnJm5ic3A7JztcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXR0cm5hbWUoYSkge1xyXG4gIHZhciBucyA9IGEubmFtZXNwYWNlVVJJO1xyXG4gIGlmICghbnMpXHJcbiAgICByZXR1cm4gYS5sb2NhbE5hbWU7XHJcbiAgaWYgKG5zID09PSBOQU1FU1BBQ0UuWE1MKVxyXG4gICAgcmV0dXJuICd4bWw6JyArIGEubG9jYWxOYW1lO1xyXG4gIGlmIChucyA9PT0gTkFNRVNQQUNFLlhMSU5LKVxyXG4gICAgcmV0dXJuICd4bGluazonICsgYS5sb2NhbE5hbWU7XHJcblxyXG4gIGlmIChucyA9PT0gTkFNRVNQQUNFLlhNTE5TKSB7XHJcbiAgICBpZiAoYS5sb2NhbE5hbWUgPT09ICd4bWxucycpIHJldHVybiAneG1sbnMnO1xyXG4gICAgZWxzZSByZXR1cm4gJ3htbG5zOicgKyBhLmxvY2FsTmFtZTtcclxuICB9XHJcbiAgcmV0dXJuIGEubmFtZTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZG9taW5vL2xpYi9Ob2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDEpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL2J1bmRsZXMvY29yZS51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnQ7XHJcblxyXG52YXIgeG1sID0gcmVxdWlyZSgnLi94bWxuYW1lcycpO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbnZhciBOQU1FU1BBQ0UgPSB1dGlscy5OQU1FU1BBQ0U7XHJcbnZhciBhdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyk7XHJcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XHJcbnZhciBOb2RlTGlzdCA9IHJlcXVpcmUoJy4vTm9kZUxpc3QnKTtcclxudmFyIEZpbHRlcmVkRWxlbWVudExpc3QgPSByZXF1aXJlKCcuL0ZpbHRlcmVkRWxlbWVudExpc3QnKTtcclxudmFyIERPTVRva2VuTGlzdCA9IHJlcXVpcmUoJy4vRE9NVG9rZW5MaXN0Jyk7XHJcbnZhciBzZWxlY3QgPSByZXF1aXJlKCcuL3NlbGVjdCcpO1xyXG52YXIgQ2hpbGROb2RlID0gcmVxdWlyZSgnLi9DaGlsZE5vZGUnKTtcclxudmFyIE5vbkRvY3VtZW50VHlwZUNoaWxkTm9kZSA9IHJlcXVpcmUoJy4vTm9uRG9jdW1lbnRUeXBlQ2hpbGROb2RlJyk7XHJcblxyXG5mdW5jdGlvbiBFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBuYW1lc3BhY2VVUkksIHByZWZpeCkge1xyXG4gIHRoaXMubm9kZVR5cGUgPSBOb2RlLkVMRU1FTlRfTk9ERTtcclxuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBkb2M7XHJcbiAgdGhpcy5sb2NhbE5hbWUgPSBsb2NhbE5hbWU7XHJcbiAgdGhpcy5uYW1lc3BhY2VVUkkgPSBuYW1lc3BhY2VVUkk7XHJcbiAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XHJcblxyXG4gIHRoaXMudGFnTmFtZSA9IChwcmVmaXggIT09IG51bGwpID8gcHJlZml4ICsgJzonICsgbG9jYWxOYW1lIDogbG9jYWxOYW1lO1xyXG5cclxuICBpZiAobmFtZXNwYWNlVVJJICE9PSBOQU1FU1BBQ0UuSFRNTCB8fCAoIW5hbWVzcGFjZVVSSSAmJiAhZG9jLmlzSFRNTCkpIHRoaXMuaXNIVE1MID0gZmFsc2U7XHJcblxyXG4gIGlmICh0aGlzLmlzSFRNTCkgdGhpcy50YWdOYW1lID0gdGhpcy50YWdOYW1lLnRvVXBwZXJDYXNlKCk7XHJcblxyXG4gIHRoaXMuY2hpbGROb2RlcyA9IG5ldyBOb2RlTGlzdCgpO1xyXG5cclxuICAvLyBUaGVzZSBwcm9wZXJ0aWVzIG1haW50YWluIHRoZSBzZXQgb2YgYXR0cmlidXRlc1xyXG4gIHRoaXMuX2F0dHJzQnlRTmFtZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7IC8vIFRoZSBxbmFtZS0+QXR0ciBtYXBcclxuICB0aGlzLl9hdHRyc0J5TE5hbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpOyAvLyBUaGUgbnN8bG5hbWUtPkF0dHIgbWFwXHJcbiAgdGhpcy5fYXR0cktleXMgPSBbXTsgICAgIC8vIGF0dHIgaW5kZXggLT4gbnN8bG5hbWVcclxuXHJcbiAgdGhpcy5faW5kZXggPSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlY3Vyc2l2ZUdldFRleHQobm9kZSwgYSkge1xyXG4gIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xyXG4gICAgYS5wdXNoKG5vZGUuX2RhdGEpO1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIGZvcih2YXIgaSA9IDAsIG4gPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyAgaSA8IG47IGkrKylcclxuICAgICAgcmVjdXJzaXZlR2V0VGV4dChub2RlLmNoaWxkTm9kZXNbaV0sIGEpO1xyXG4gIH1cclxufVxyXG5cclxuRWxlbWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlLCB7XHJcbiAgbm9kZU5hbWU6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudGFnTmFtZTsgfX0sXHJcbiAgbm9kZVZhbHVlOiB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKCkge31cclxuICB9LFxyXG4gIHRleHRDb250ZW50OiB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgc3RyaW5ncyA9IFtdO1xyXG4gICAgICByZWN1cnNpdmVHZXRUZXh0KHRoaXMsIHN0cmluZ3MpO1xyXG4gICAgICByZXR1cm4gc3RyaW5ncy5qb2luKCcnKTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKG5ld3RleHQpIHtcclxuICAgICAgdGhpcy5yZW1vdmVDaGlsZHJlbigpO1xyXG4gICAgICBpZiAobmV3dGV4dCAhPT0gbnVsbCAmJiBuZXd0ZXh0ICE9PSAnJykge1xyXG4gICAgICAgIHRoaXMuX2FwcGVuZENoaWxkKHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuZXd0ZXh0KSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIGlubmVySFRNTDoge1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XHJcbiAgICB9LFxyXG4gICAgc2V0OiB1dGlscy5ueWlcclxuICB9LFxyXG4gIG91dGVySFRNTDoge1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgLy8gXCJ0aGUgYXR0cmlidXRlIG11c3QgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyB0aGUgSFRNTCBmcmFnbWVudFxyXG4gICAgICAvLyBzZXJpYWxpemF0aW9uIGFsZ29yaXRobSBvbiBhIGZpY3Rpb25hbCBub2RlIHdob3NlIG9ubHkgY2hpbGQgaXNcclxuICAgICAgLy8gdGhlIGNvbnRleHQgb2JqZWN0XCJcclxuICAgICAgdmFyIGZpY3Rpb25hbCA9IHtcclxuICAgICAgICBjaGlsZE5vZGVzOiBbIHRoaXMgXSxcclxuICAgICAgICBub2RlVHlwZTogMFxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gTm9kZS5wcm90b3R5cGUuc2VyaWFsaXplLmNhbGwoZmljdGlvbmFsKTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IHV0aWxzLm55aVxyXG4gIH0sXHJcblxyXG4gIGNoaWxkcmVuOiB7IGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoIXRoaXMuX2NoaWxkcmVuKSB7XHJcbiAgICAgIHRoaXMuX2NoaWxkcmVuID0gbmV3IENoaWxkcmVuQ29sbGVjdGlvbih0aGlzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcclxuICB9fSxcclxuXHJcbiAgYXR0cmlidXRlczogeyBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCF0aGlzLl9hdHRyaWJ1dGVzKSB7XHJcbiAgICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBuZXcgQXR0cmlidXRlc0FycmF5KHRoaXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXM7XHJcbiAgfX0sXHJcblxyXG5cclxuICBmaXJzdEVsZW1lbnRDaGlsZDogeyBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGtpZHMgPSB0aGlzLmNoaWxkTm9kZXM7XHJcbiAgICBmb3IodmFyIGkgPSAwLCBuID0ga2lkcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgaWYgKGtpZHNbaV0ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSByZXR1cm4ga2lkc1tpXTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH19LFxyXG5cclxuICBsYXN0RWxlbWVudENoaWxkOiB7IGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIga2lkcyA9IHRoaXMuY2hpbGROb2RlcztcclxuICAgIGZvcih2YXIgaSA9IGtpZHMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGlmIChraWRzW2ldLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkgcmV0dXJuIGtpZHNbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9fSxcclxuXHJcbiAgY2hpbGRFbGVtZW50Q291bnQ6IHsgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcclxuICB9fSxcclxuXHJcblxyXG4gIC8vIFJldHVybiB0aGUgbmV4dCBlbGVtZW50LCBpbiBzb3VyY2Ugb3JkZXIsIGFmdGVyIHRoaXMgb25lIG9yXHJcbiAgLy8gbnVsbCBpZiB0aGVyZSBhcmUgbm8gbW9yZS4gIElmIHJvb3QgZWxlbWVudCBpcyBzcGVjaWZpZWQsXHJcbiAgLy8gdGhlbiBkb24ndCB0cmF2ZXJzZSBiZXlvbmQgaXRzIHN1YnRyZWUuXHJcbiAgLy9cclxuICAvLyBUaGlzIGlzIG5vdCBhIERPTSBtZXRob2QsIGJ1dCBpcyBjb252ZW5pZW50IGZvclxyXG4gIC8vIGxhenkgdHJhdmVyc2FscyBvZiB0aGUgdHJlZS5cclxuICBuZXh0RWxlbWVudDogeyB2YWx1ZTogZnVuY3Rpb24ocm9vdCkge1xyXG4gICAgaWYgKCFyb290KSByb290ID0gdGhpcy5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICAgIHZhciBuZXh0ID0gdGhpcy5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgIGlmICghbmV4dCkge1xyXG4gICAgICAvLyBkb24ndCB1c2Ugc2libGluZyBpZiB3ZSdyZSBhdCByb290XHJcbiAgICAgIGlmICh0aGlzPT09cm9vdCkgcmV0dXJuIG51bGw7XHJcbiAgICAgIG5leHQgPSB0aGlzLm5leHRFbGVtZW50U2libGluZztcclxuICAgIH1cclxuICAgIGlmIChuZXh0KSByZXR1cm4gbmV4dDtcclxuXHJcbiAgICAvLyBJZiB3ZSBjYW4ndCBnbyBkb3duIG9yIGFjcm9zcywgdGhlbiB3ZSBoYXZlIHRvIGdvIHVwXHJcbiAgICAvLyBhbmQgYWNyb3NzIHRvIHRoZSBwYXJlbnQgc2libGluZyBvciBhbm90aGVyIGFuY2VzdG9yJ3NcclxuICAgIC8vIHNpYmxpbmcuICBCZSBjYXJlZnVsLCB0aG91Z2g6IGlmIHdlIHJlYWNoIHRoZSByb290XHJcbiAgICAvLyBlbGVtZW50LCBvciBpZiB3ZSByZWFjaCB0aGUgZG9jdW1lbnRFbGVtZW50LCB0aGVuXHJcbiAgICAvLyB0aGUgdHJhdmVyc2FsIGVuZHMuXHJcbiAgICBmb3IodmFyIHBhcmVudCA9IHRoaXMucGFyZW50RWxlbWVudDtcclxuICAgICAgcGFyZW50ICYmIHBhcmVudCAhPT0gcm9vdDtcclxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQpIHtcclxuXHJcbiAgICAgIG5leHQgPSBwYXJlbnQubmV4dEVsZW1lbnRTaWJsaW5nO1xyXG4gICAgICBpZiAobmV4dCkgcmV0dXJuIG5leHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfX0sXHJcblxyXG4gIC8vIFhYWDpcclxuICAvLyBUZXN0cyBhcmUgY3VycmVudGx5IGZhaWxpbmcgZm9yIHRoaXMgZnVuY3Rpb24uXHJcbiAgLy8gQXdhaXRpbmcgcmVzb2x1dGlvbiBvZjpcclxuICAvLyBodHRwOi8vbGlzdHMudzMub3JnL0FyY2hpdmVzL1B1YmxpYy93d3ctZG9tLzIwMTFKdWxTZXAvMDAxNi5odG1sXHJcbiAgZ2V0RWxlbWVudHNCeVRhZ05hbWU6IHsgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRzQnlUYWdOYW1lKGxuYW1lKSB7XHJcbiAgICB2YXIgZmlsdGVyO1xyXG4gICAgaWYgKCFsbmFtZSkgcmV0dXJuIG5ldyBOb2RlTGlzdCgpO1xyXG4gICAgaWYgKGxuYW1lID09PSAnKicpXHJcbiAgICAgIGZpbHRlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcclxuICAgIGVsc2UgaWYgKHRoaXMuaXNIVE1MKVxyXG4gICAgICBmaWx0ZXIgPSBodG1sTG9jYWxOYW1lRWxlbWVudEZpbHRlcihsbmFtZSk7XHJcbiAgICBlbHNlXHJcbiAgICAgIGZpbHRlciA9IGxvY2FsTmFtZUVsZW1lbnRGaWx0ZXIobG5hbWUpO1xyXG5cclxuICAgIHJldHVybiBuZXcgRmlsdGVyZWRFbGVtZW50TGlzdCh0aGlzLCBmaWx0ZXIpO1xyXG4gIH19LFxyXG5cclxuICBnZXRFbGVtZW50c0J5VGFnTmFtZU5TOiB7IHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50c0J5VGFnTmFtZU5TKG5zLCBsbmFtZSl7XHJcbiAgICB2YXIgZmlsdGVyO1xyXG4gICAgaWYgKG5zID09PSAnKicgJiYgbG5hbWUgPT09ICcqJylcclxuICAgICAgZmlsdGVyID0gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xyXG4gICAgZWxzZSBpZiAobnMgPT09ICcqJylcclxuICAgICAgZmlsdGVyID0gbG9jYWxOYW1lRWxlbWVudEZpbHRlcihsbmFtZSk7XHJcbiAgICBlbHNlIGlmIChsbmFtZSA9PT0gJyonKVxyXG4gICAgICBmaWx0ZXIgPSBuYW1lc3BhY2VFbGVtZW50RmlsdGVyKG5zKTtcclxuICAgIGVsc2VcclxuICAgICAgZmlsdGVyID0gbmFtZXNwYWNlTG9jYWxOYW1lRWxlbWVudEZpbHRlcihucywgbG5hbWUpO1xyXG5cclxuICAgIHJldHVybiBuZXcgRmlsdGVyZWRFbGVtZW50TGlzdCh0aGlzLCBmaWx0ZXIpO1xyXG4gIH19LFxyXG5cclxuICBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lOiB7IHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lKG5hbWVzKXtcclxuICAgIG5hbWVzID0gU3RyaW5nKG5hbWVzKS50cmltKCk7XHJcbiAgICBpZiAobmFtZXMgPT09ICcnKSB7XHJcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTm9kZUxpc3QoKTsgLy8gRW1wdHkgbm9kZSBsaXN0XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBuYW1lcyA9IG5hbWVzLnNwbGl0KC9cXHMrLyk7ICAvLyBTcGxpdCBvbiBzcGFjZXNcclxuICAgIHJldHVybiBuZXcgRmlsdGVyZWRFbGVtZW50TGlzdCh0aGlzLCBjbGFzc05hbWVzRWxlbWVudEZpbHRlcihuYW1lcykpO1xyXG4gIH19LFxyXG5cclxuICBnZXRFbGVtZW50c0J5TmFtZTogeyB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudHNCeU5hbWUobmFtZSkge1xyXG4gICAgcmV0dXJuIG5ldyBGaWx0ZXJlZEVsZW1lbnRMaXN0KHRoaXMsIGVsZW1lbnROYW1lRmlsdGVyKFN0cmluZyhuYW1lKSkpO1xyXG4gIH19LFxyXG5cclxuICAvLyBPdmVyd3JpdHRlbiBpbiB0aGUgY29uc3RydWN0b3IgaWYgbm90IGluIHRoZSBIVE1MIG5hbWVzcGFjZVxyXG4gIGlzSFRNTDogeyB2YWx1ZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcclxuXHJcbiAgLy8gVXRpbGl0eSBtZXRob2RzIHVzZWQgYnkgdGhlIHB1YmxpYyBBUEkgbWV0aG9kcyBhYm92ZVxyXG4gIGNsb25lOiB7IHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcclxuICAgIHZhciBlO1xyXG5cclxuICAgIC8vIFhYWDpcclxuICAgIC8vIE1vZGlmeSB0aGlzIHRvIHVzZSB0aGUgY29uc3RydWN0b3IgZGlyZWN0bHkgb3JcclxuICAgIC8vIGF2b2lkIGVycm9yIGNoZWNraW5nIGluIHNvbWUgb3RoZXIgd2F5LiBJbiBjYXNlIHdlIHRyeVxyXG4gICAgLy8gdG8gY2xvbmUgYW4gaW52YWxpZCBub2RlIHRoYXQgdGhlIHBhcnNlciBpbnNlcnRlZC5cclxuICAgIC8vXHJcbiAgICBpZiAodGhpcy5uYW1lc3BhY2VVUkkgIT09IE5BTUVTUEFDRS5IVE1MIHx8IHRoaXMucHJlZml4KVxyXG4gICAgICBlID0gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5hbWVzcGFjZVVSSSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdOYW1lKTtcclxuICAgIGVsc2VcclxuICAgICAgZSA9IHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMubG9jYWxOYW1lKTtcclxuXHJcbiAgICBmb3IodmFyIGkgPSAwLCBuID0gdGhpcy5fYXR0cktleXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgIHZhciBsbmFtZSA9IHRoaXMuX2F0dHJLZXlzW2ldO1xyXG4gICAgICB2YXIgYSA9IHRoaXMuX2F0dHJzQnlMTmFtZVtsbmFtZV07XHJcbiAgICAgIHZhciBiID0gbmV3IEF0dHIoZSwgYS5sb2NhbE5hbWUsIGEucHJlZml4LCBhLm5hbWVzcGFjZVVSSSk7XHJcbiAgICAgIGIuZGF0YSA9IGEuZGF0YTtcclxuICAgICAgZS5fYXR0cnNCeUxOYW1lW2xuYW1lXSA9IGI7XHJcbiAgICAgIGUuX2FkZFFOYW1lKGIpO1xyXG4gICAgfVxyXG4gICAgZS5fYXR0cktleXMgPSB0aGlzLl9hdHRyS2V5cy5jb25jYXQoKTtcclxuXHJcbiAgICByZXR1cm4gZTtcclxuICB9fSxcclxuXHJcbiAgaXNFcXVhbDogeyB2YWx1ZTogZnVuY3Rpb24gaXNFcXVhbCh0aGF0KSB7XHJcbiAgICBpZiAodGhpcy5sb2NhbE5hbWUgIT09IHRoYXQubG9jYWxOYW1lIHx8XHJcbiAgICAgIHRoaXMubmFtZXNwYWNlVVJJICE9PSB0aGF0Lm5hbWVzcGFjZVVSSSB8fFxyXG4gICAgICB0aGlzLnByZWZpeCAhPT0gdGhhdC5wcmVmaXggfHxcclxuICAgICAgdGhpcy5fbnVtYXR0cnMgIT09IHRoYXQuX251bWF0dHJzKVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgLy8gQ29tcGFyZSB0aGUgc2V0cyBvZiBhdHRyaWJ1dGVzLCBpZ25vcmluZyBvcmRlclxyXG4gICAgLy8gYW5kIGlnbm9yaW5nIGF0dHJpYnV0ZSBwcmVmaXhlcy5cclxuICAgIGZvcih2YXIgaSA9IDAsIG4gPSB0aGlzLl9udW1hdHRyczsgaSA8IG47IGkrKykge1xyXG4gICAgICB2YXIgYSA9IHRoaXMuX2F0dHIoaSk7XHJcbiAgICAgIGlmICghdGhhdC5oYXNBdHRyaWJ1dGVOUyhhLm5hbWVzcGFjZVVSSSwgYS5sb2NhbE5hbWUpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHRoYXQuZ2V0QXR0cmlidXRlTlMoYS5uYW1lc3BhY2VVUkksYS5sb2NhbE5hbWUpICE9PSBhLnZhbHVlKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9fSxcclxuXHJcbiAgLy8gVGhpcyBpcyB0aGUgJ2xvY2F0ZSBhIG5hbWVzcGFjZSBwcmVmaXgnIGFsZ29yaXRobSBmcm9tIHRoZVxyXG4gIC8vIERPTUNvcmUgc3BlY2lmaWNhdGlvbi4gIEl0IGlzIHVzZWQgYnkgTm9kZS5sb29rdXBQcmVmaXgoKVxyXG4gIGxvY2F0ZU5hbWVzcGFjZVByZWZpeDogeyB2YWx1ZTogZnVuY3Rpb24gbG9jYXRlTmFtZXNwYWNlUHJlZml4KG5zKSB7XHJcbiAgICBpZiAodGhpcy5uYW1lc3BhY2VVUkkgPT09IG5zICYmIHRoaXMucHJlZml4ICE9PSBudWxsKVxyXG4gICAgICByZXR1cm4gdGhpcy5wcmVmaXg7XHJcblxyXG4gICAgZm9yKHZhciBpID0gMCwgbiA9IHRoaXMuX251bWF0dHJzOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgIHZhciBhID0gdGhpcy5fYXR0cihpKTtcclxuICAgICAgaWYgKGEucHJlZml4ID09PSAneG1sbnMnICYmIGEudmFsdWUgPT09IG5zKVxyXG4gICAgICAgIHJldHVybiBhLmxvY2FsTmFtZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnRFbGVtZW50O1xyXG4gICAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5sb2NhdGVOYW1lc3BhY2VQcmVmaXgobnMpIDogbnVsbDtcclxuICB9fSxcclxuXHJcbiAgLy8gVGhpcyBpcyB0aGUgJ2xvY2F0ZSBhIG5hbWVzcGFjZScgYWxnb3JpdGhtIGZvciBFbGVtZW50IG5vZGVzXHJcbiAgLy8gZnJvbSB0aGUgRE9NIENvcmUgc3BlYy4gIEl0IGlzIHVzZWQgYnkgTm9kZS5sb29rdXBOYW1lc3BhY2VVUklcclxuICBsb2NhdGVOYW1lc3BhY2U6IHsgdmFsdWU6IGZ1bmN0aW9uIGxvY2F0ZU5hbWVzcGFjZShwcmVmaXgpIHtcclxuICAgIGlmICh0aGlzLnByZWZpeCA9PT0gcHJlZml4ICYmIHRoaXMubmFtZXNwYWNlVVJJICE9PSBudWxsKVxyXG4gICAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VVUkk7XHJcblxyXG4gICAgZm9yKHZhciBpID0gMCwgbiA9IHRoaXMuX251bWF0dHJzOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgIHZhciBhID0gdGhpcy5fYXR0cihpKTtcclxuICAgICAgaWYgKChhLnByZWZpeCA9PT0gJ3htbG5zJyAmJiBhLmxvY2FsTmFtZSA9PT0gcHJlZml4KSB8fFxyXG4gICAgICAgIChhLnByZWZpeCA9PT0gbnVsbCAmJiBhLmxvY2FsTmFtZSA9PT0gJ3htbG5zJykpIHtcclxuICAgICAgICByZXR1cm4gYS52YWx1ZSB8fCBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50RWxlbWVudDtcclxuICAgIHJldHVybiBwYXJlbnQgPyBwYXJlbnQubG9jYXRlTmFtZXNwYWNlKHByZWZpeCkgOiBudWxsO1xyXG4gIH19LFxyXG5cclxuICAvL1xyXG4gIC8vIEF0dHJpYnV0ZSBoYW5kbGluZyBtZXRob2RzIGFuZCB1dGlsaXRpZXNcclxuICAvL1xyXG5cclxuICAvKlxyXG4gICAqIEF0dHJpYnV0ZXMgaW4gdGhlIERPTSBhcmUgdHJpY2t5OlxyXG4gICAqXHJcbiAgICogLSB0aGVyZSBhcmUgdGhlIDggYmFzaWMgZ2V0L3NldC9oYXMvcmVtb3ZlQXR0cmlidXRle05TfSBtZXRob2RzXHJcbiAgICpcclxuICAgKiAtIGJ1dCBtYW55IEhUTUwgYXR0cmlidXRlcyBhcmUgYWxzbyAncmVmbGVjdGVkJyB0aHJvdWdoIElETFxyXG4gICAqICAgYXR0cmlidXRlcyB3aGljaCBtZWFucyB0aGF0IHRoZXkgY2FuIGJlIHF1ZXJpZWQgYW5kIHNldCB0aHJvdWdoXHJcbiAgICogICByZWd1bGFyIHByb3BlcnRpZXMgb2YgdGhlIGVsZW1lbnQuICBUaGVyZSBpcyBqdXN0IG9uZSBhdHRyaWJ1dGVcclxuICAgKiAgIHZhbHVlLCBidXQgdHdvIHdheXMgdG8gZ2V0IGFuZCBzZXQgaXQuXHJcbiAgICpcclxuICAgKiAtIERpZmZlcmVudCBIVE1MIGVsZW1lbnQgdHlwZXMgaGF2ZSBkaWZmZXJlbnQgc2V0cyBvZiByZWZsZWN0ZWRcclxuICAgICBhdHRyaWJ1dGVzLlxyXG4gICAqXHJcbiAgICogLSBhdHRyaWJ1dGVzIGNhbiBhbHNvIGJlIHF1ZXJpZWQgYW5kIHNldCB0aHJvdWdoIHRoZSAuYXR0cmlidXRlc1xyXG4gICAqICAgcHJvcGVydHkgb2YgYW4gZWxlbWVudC4gIFRoaXMgcHJvcGVydHkgYmVoYXZlcyBsaWtlIGFuIGFycmF5IG9mXHJcbiAgICogICBBdHRyIG9iamVjdHMuICBUaGUgdmFsdWUgcHJvcGVydHkgb2YgZWFjaCBBdHRyIGlzIHdyaXRlYWJsZSwgc29cclxuICAgKiAgIHRoaXMgaXMgYSB0aGlyZCB3YXkgdG8gcmVhZCBhbmQgd3JpdGUgYXR0cmlidXRlcy5cclxuICAgKlxyXG4gICAqIC0gZm9yIGVmZmljaWVuY3ksIHdlIHJlYWxseSB3YW50IHRvIHN0b3JlIGF0dHJpYnV0ZXMgaW4gc29tZSBraW5kXHJcbiAgICogICBvZiBuYW1lLT5hdHRyIG1hcC4gIEJ1dCB0aGUgYXR0cmlidXRlc1tdIGFycmF5IGlzIGFuIGFycmF5LCBub3QgYVxyXG4gICAqICAgbWFwLCB3aGljaCBpcyBraW5kIG9mIHVubmF0dXJhbC5cclxuICAgKlxyXG4gICAqIC0gV2hlbiB1c2luZyBuYW1lc3BhY2VzIGFuZCBwcmVmaXhlcywgYW5kIG1peGluZyB0aGUgTlMgbWV0aG9kc1xyXG4gICAqICAgd2l0aCB0aGUgbm9uLU5TIG1ldGhvZHMsIGl0IGlzIGFwcGFyZW50bHkgYWN0dWFsbHkgcG9zc2libGUgZm9yXHJcbiAgICogICBhbiBhdHRyaWJ1dGVzW10gYXJyYXkgdG8gaGF2ZSBtb3JlIHRoYW4gb25lIGF0dHJpYnV0ZSB3aXRoIHRoZVxyXG4gICAqICAgc2FtZSBxdWFsaWZpZWQgbmFtZS4gIEFuZCBjZXJ0YWluIG1ldGhvZHMgbXVzdCBvcGVyYXRlIG9uIG9ubHlcclxuICAgKiAgIHRoZSBmaXJzdCBhdHRyaWJ1dGUgd2l0aCBzdWNoIGEgbmFtZS4gIFNvIGZvciB0aGVzZSBtZXRob2RzLCBhblxyXG4gICAqICAgaW5lZmZpY2llbnQgYXJyYXktbGlrZSBkYXRhIHN0cnVjdHVyZSB3b3VsZCBiZSBlYXNpZXIgdG9cclxuICAgKiAgIGltcGxlbWVudC5cclxuICAgKlxyXG4gICAqIC0gVGhlIGF0dHJpYnV0ZXNbXSBhcnJheSBpcyBsaXZlLCBub3QgYSBzbmFwc2hvdCwgc28gY2hhbmdlcyB0byB0aGVcclxuICAgKiAgIGF0dHJpYnV0ZXMgbXVzdCBiZSBpbW1lZGlhdGVseSB2aXNpYmxlIHRocm91Z2ggZXhpc3RpbmcgYXJyYXlzLlxyXG4gICAqXHJcbiAgICogLSBXaGVuIGF0dHJpYnV0ZXMgYXJlIHF1ZXJpZWQgYW5kIHNldCB0aHJvdWdoIElETCBwcm9wZXJ0aWVzXHJcbiAgICogICAoaW5zdGVhZCBvZiB0aGUgZ2V0L3NldEF0dHJpYnV0ZXMoKSBtZXRob2Qgb3IgdGhlIGF0dHJpYnV0ZXNbXVxyXG4gICAqICAgYXJyYXkpIHRoZXkgbWF5IGJlIHN1YmplY3QgdG8gdHlwZSBjb252ZXJzaW9ucywgVVJMXHJcbiAgICogICBub3JtYWxpemF0aW9uLCBldGMuLCBzbyBzb21lIGV4dHJhIHByb2Nlc3NpbmcgaXMgcmVxdWlyZWQgaW4gdGhhdFxyXG4gICAqICAgY2FzZS5cclxuICAgKlxyXG4gICAqIC0gQnV0IGFjY2VzcyB0aHJvdWdoIElETCBwcm9wZXJ0aWVzIGlzIHByb2JhYmx5IHRoZSBtb3N0IGNvbW1vblxyXG4gICAqICAgY2FzZSwgc28gd2UnZCBsaWtlIHRoYXQgdG8gYmUgYXMgZmFzdCBhcyBwb3NzaWJsZS5cclxuICAgKlxyXG4gICAqIC0gV2UgY2FuJ3QganVzdCBzdG9yZSBhdHRyaWJ1dGUgdmFsdWVzIGluIHRoZWlyIHBhcnNlZCBpZGwgZm9ybSxcclxuICAgKiAgIGJlY2F1c2Ugc2V0QXR0cmlidXRlKCkgaGFzIHRvIHJldHVybiB3aGF0ZXZlciBzdHJpbmcgaXMgcGFzc2VkIHRvXHJcbiAgICogICBnZXRBdHRyaWJ1dGUgZXZlbiBpZiBpdCBpcyBub3QgYSBsZWdhbCwgcGFyc2VhYmxlIHZhbHVlLiBTb1xyXG4gICAqICAgYXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIHN0b3JlZCBpbiB1bnBhcnNlZCBzdHJpbmcgZm9ybS5cclxuICAgKlxyXG4gICAqIC0gV2UgbmVlZCB0byBiZSBhYmxlIHRvIHNlbmQgY2hhbmdlIG5vdGlmaWNhdGlvbnMgb3IgbXV0YXRpb25cclxuICAgKiAgIGV2ZW50cyBvZiBzb21lIHNvcnQgdG8gdGhlIHJlbmRlcmVyIHdoZW5ldmVyIGFuIGF0dHJpYnV0ZSB2YWx1ZVxyXG4gICAqICAgY2hhbmdlcywgcmVnYXJkbGVzcyBvZiB0aGUgd2F5IGluIHdoaWNoIGl0IGNoYW5nZXMuXHJcbiAgICpcclxuICAgKiAtIFNvbWUgYXR0cmlidXRlcywgc3VjaCBhcyBpZCBhbmQgY2xhc3MgYWZmZWN0IG90aGVyIHBhcnRzIG9mIHRoZVxyXG4gICAqICAgRE9NIEFQSSwgbGlrZSBnZXRFbGVtZW50QnlJZCBhbmQgZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSBhbmQgc29cclxuICAgKiAgIGZvciBlZmZpY2llbmN5LCB3ZSBuZWVkIHRvIHNwZWNpYWxseSB0cmFjayBjaGFuZ2VzIHRvIHRoZXNlXHJcbiAgICogICBzcGVjaWFsIGF0dHJpYnV0ZXMuXHJcbiAgICpcclxuICAgKiAtIFNvbWUgYXR0cmlidXRlcyBsaWtlIGNsYXNzIGhhdmUgZGlmZmVyZW50IG5hbWVzIChjbGFzc05hbWUpIHdoZW5cclxuICAgKiAgIHJlZmxlY3RlZC5cclxuICAgKlxyXG4gICAqIC0gQXR0cmlidXRlcyB3aG9zZSBuYW1lcyBiZWdpbiB3aXRoIHRoZSBzdHJpbmcgJ2RhdGEtJyBhcmUgdHJlYXRlZFxyXG4gICAgIHNwZWNpYWxseS5cclxuICAgKlxyXG4gICAqIC0gUmVmbGVjdGVkIGF0dHJpYnV0ZXMgdGhhdCBoYXZlIGEgYm9vbGVhbiB0eXBlIGluIElETCBoYXZlIHNwZWNpYWxcclxuICAgKiAgIGJlaGF2aW9yOiBzZXR0aW5nIHRoZW0gdG8gZmFsc2UgKGluIElETCkgaXMgdGhlIHNhbWUgYXMgcmVtb3ZpbmdcclxuICAgKiAgIHRoZW0gd2l0aCByZW1vdmVBdHRyaWJ1dGUoKVxyXG4gICAqXHJcbiAgICogLSBudW1lcmljIGF0dHJpYnV0ZXMgKGxpa2UgSFRNTEVsZW1lbnQudGFiSW5kZXgpIGNhbiBoYXZlIGRlZmF1bHRcclxuICAgKiAgIHZhbHVlcyB0aGF0IG11c3QgYmUgcmV0dXJuZWQgYnkgdGhlIGlkbCBnZXR0ZXIgZXZlbiBpZiB0aGVcclxuICAgKiAgIGNvbnRlbnQgYXR0cmlidXRlIGRvZXMgbm90IGV4aXN0LiAoVGhlIGRlZmF1bHQgdGFiSW5kZXggdmFsdWVcclxuICAgKiAgIGFjdHVhbGx5IHZhcmllcyBiYXNlZCBvbiB0aGUgdHlwZSBvZiB0aGUgZWxlbWVudCwgc28gdGhhdCBpcyBhXHJcbiAgICogICB0cmlja3kgb25lKS5cclxuICAgKlxyXG4gICAqIFNlZVxyXG4gICAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3VybHMuaHRtbCNyZWZsZWN0XHJcbiAgICogZm9yIHJ1bGVzIG9uIGhvdyBhdHRyaWJ1dGVzIGFyZSByZWZsZWN0ZWQuXHJcbiAgICpcclxuICAgKi9cclxuXHJcbiAgZ2V0QXR0cmlidXRlOiB7IHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUocW5hbWUpIHtcclxuICAgIGlmICh0aGlzLmlzSFRNTCkgcW5hbWUgPSB1dGlscy50b0FTQ0lJTG93ZXJDYXNlKHFuYW1lKTtcclxuICAgIHZhciBhdHRyID0gdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXTtcclxuICAgIGlmICghYXR0cikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cikpICAvLyBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lXHJcbiAgICAgIGF0dHIgPSBhdHRyWzBdOyAgICAgICAgIC8vIHVzZSB0aGUgZmlyc3RcclxuXHJcbiAgICByZXR1cm4gYXR0ci52YWx1ZTtcclxuICB9fSxcclxuXHJcbiAgZ2V0QXR0cmlidXRlTlM6IHsgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZU5TKG5zLCBsbmFtZSkge1xyXG4gICAgdmFyIGF0dHIgPSB0aGlzLl9hdHRyc0J5TE5hbWVbKG5zID09PSBudWxsID8gJycgOiBucykgKyAnfCcgKyBsbmFtZV07XHJcbiAgICByZXR1cm4gYXR0ciA/IGF0dHIudmFsdWUgOiBudWxsO1xyXG4gIH19LFxyXG5cclxuICBoYXNBdHRyaWJ1dGU6IHsgdmFsdWU6IGZ1bmN0aW9uIGhhc0F0dHJpYnV0ZShxbmFtZSkge1xyXG4gICAgaWYgKHRoaXMuaXNIVE1MKSBxbmFtZSA9IHV0aWxzLnRvQVNDSUlMb3dlckNhc2UocW5hbWUpO1xyXG4gICAgcmV0dXJuIHRoaXMuX2F0dHJzQnlRTmFtZVtxbmFtZV0gIT09IHVuZGVmaW5lZDtcclxuICB9fSxcclxuXHJcbiAgaGFzQXR0cmlidXRlTlM6IHsgdmFsdWU6IGZ1bmN0aW9uIGhhc0F0dHJpYnV0ZU5TKG5zLCBsbmFtZSkge1xyXG4gICAgdmFyIGtleSA9IChucyA9PT0gbnVsbCA/ICcnIDogbnMpICsgJ3wnICsgbG5hbWU7XHJcbiAgICByZXR1cm4gdGhpcy5fYXR0cnNCeUxOYW1lW2tleV0gIT09IHVuZGVmaW5lZDtcclxuICB9fSxcclxuXHJcbiAgLy8gU2V0IHRoZSBhdHRyaWJ1dGUgd2l0aG91dCBlcnJvciBjaGVja2luZy4gVGhlIHBhcnNlciB1c2VzIHRoaXMuXHJcbiAgX3NldEF0dHJpYnV0ZTogeyB2YWx1ZTogZnVuY3Rpb24gX3NldEF0dHJpYnV0ZShxbmFtZSwgdmFsdWUpIHtcclxuICAgIC8vIFhYWDogdGhlIHNwZWMgc2F5cyB0aGF0IHRoaXMgbmV4dCBzZWFyY2ggc2hvdWxkIGJlIGRvbmVcclxuICAgIC8vIG9uIHRoZSBsb2NhbCBuYW1lLCBidXQgSSB0aGluayB0aGF0IGlzIGFuIGVycm9yLlxyXG4gICAgLy8gZW1haWwgcGVuZGluZyBvbiB3d3ctZG9tIGFib3V0IGl0LlxyXG4gICAgdmFyIGF0dHIgPSB0aGlzLl9hdHRyc0J5UU5hbWVbcW5hbWVdO1xyXG4gICAgdmFyIGlzbmV3O1xyXG4gICAgaWYgKCFhdHRyKSB7XHJcbiAgICAgIGF0dHIgPSB0aGlzLl9uZXdhdHRyKHFuYW1lKTtcclxuICAgICAgaXNuZXcgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dHIpKSBhdHRyID0gYXR0clswXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3cgc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUgb24gdGhlIG5ldyBvciBleGlzdGluZyBBdHRyIG9iamVjdC5cclxuICAgIC8vIFRoZSBBdHRyLnZhbHVlIHNldHRlciBtZXRob2QgaGFuZGxlcyBtdXRhdGlvbiBldmVudHMsIGV0Yy5cclxuICAgIGF0dHIudmFsdWUgPSB2YWx1ZTtcclxuICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzKSB0aGlzLl9hdHRyaWJ1dGVzW3FuYW1lXSA9IGF0dHI7XHJcbiAgICBpZiAoaXNuZXcgJiYgdGhpcy5fbmV3YXR0cmhvb2spIHRoaXMuX25ld2F0dHJob29rKHFuYW1lLCB2YWx1ZSk7XHJcbiAgfX0sXHJcblxyXG4gIC8vIENoZWNrIGZvciBlcnJvcnMsIGFuZCB0aGVuIHNldCB0aGUgYXR0cmlidXRlXHJcbiAgc2V0QXR0cmlidXRlOiB7IHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUocW5hbWUsIHZhbHVlKSB7XHJcbiAgICBpZiAoIXhtbC5pc1ZhbGlkTmFtZShxbmFtZSkpIHV0aWxzLkludmFsaWRDaGFyYWN0ZXJFcnJvcigpO1xyXG4gICAgaWYgKHRoaXMuaXNIVE1MKSBxbmFtZSA9IHV0aWxzLnRvQVNDSUlMb3dlckNhc2UocW5hbWUpO1xyXG4gICAgaWYgKHFuYW1lLnN1YnN0cmluZygwLCA1KSA9PT0gJ3htbG5zJykgdXRpbHMuTmFtZXNwYWNlRXJyb3IoKTtcclxuICAgIHRoaXMuX3NldEF0dHJpYnV0ZShxbmFtZSwgU3RyaW5nKHZhbHVlKSk7XHJcbiAgfX0sXHJcblxyXG5cclxuICAvLyBUaGUgdmVyc2lvbiB3aXRoIG5vIGVycm9yIGNoZWNraW5nIHVzZWQgYnkgdGhlIHBhcnNlclxyXG4gIF9zZXRBdHRyaWJ1dGVOUzogeyB2YWx1ZTogZnVuY3Rpb24gX3NldEF0dHJpYnV0ZU5TKG5zLCBxbmFtZSwgdmFsdWUpIHtcclxuICAgIHZhciBwb3MgPSBxbmFtZS5pbmRleE9mKCc6JyksIHByZWZpeCwgbG5hbWU7XHJcbiAgICBpZiAocG9zID09PSAtMSkge1xyXG4gICAgICBwcmVmaXggPSBudWxsO1xyXG4gICAgICBsbmFtZSA9IHFuYW1lO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHByZWZpeCA9IHFuYW1lLnN1YnN0cmluZygwLCBwb3MpO1xyXG4gICAgICBsbmFtZSA9IHFuYW1lLnN1YnN0cmluZyhwb3MrMSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGtleSA9IChucyA9PT0gbnVsbCA/ICcnIDogbnMpICsgJ3wnICsgbG5hbWU7XHJcbiAgICBpZiAobnMgPT09ICcnKSBucyA9IG51bGw7XHJcblxyXG4gICAgdmFyIGF0dHIgPSB0aGlzLl9hdHRyc0J5TE5hbWVba2V5XTtcclxuICAgIHZhciBpc25ldztcclxuICAgIGlmICghYXR0cikge1xyXG4gICAgICBhdHRyID0gbmV3IEF0dHIodGhpcywgbG5hbWUsIHByZWZpeCwgbnMpO1xyXG4gICAgICBpc25ldyA9IHRydWU7XHJcbiAgICAgIHRoaXMuX2F0dHJzQnlMTmFtZVtrZXldID0gYXR0cjtcclxuICAgICAgdGhpcy5fYXR0cktleXMucHVzaChrZXkpO1xyXG5cclxuICAgICAgLy8gV2UgYWxzbyBoYXZlIHRvIG1ha2UgdGhlIGF0dHIgc2VhcmNoYWJsZSBieSBxbmFtZS5cclxuICAgICAgLy8gQnV0IHdlIGhhdmUgdG8gYmUgY2FyZWZ1bCBiZWNhdXNlIHRoZXJlIG1heSBhbHJlYWR5XHJcbiAgICAgIC8vIGJlIGFuIGF0dHIgd2l0aCB0aGlzIHFuYW1lLlxyXG4gICAgICB0aGlzLl9hZGRRTmFtZShhdHRyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAvLyBDYWxsaW5nIHNldEF0dHJpYnV0ZU5TKCkgY2FuIGNoYW5nZSB0aGUgcHJlZml4IG9mIGFuXHJcbiAgICAgIC8vIGV4aXN0aW5nIGF0dHJpYnV0ZSFcclxuICAgICAgaWYgKGF0dHIucHJlZml4ICE9PSBwcmVmaXgpIHtcclxuICAgICAgICAvLyBVbmJpbmQgdGhlIG9sZCBxbmFtZVxyXG4gICAgICAgIHRoaXMuX3JlbW92ZVFOYW1lKGF0dHIpO1xyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJlZml4XHJcbiAgICAgICAgYXR0ci5wcmVmaXggPSBwcmVmaXg7XHJcbiAgICAgICAgLy8gQmluZCB0aGUgbmV3IHFuYW1lXHJcbiAgICAgICAgdGhpcy5fYWRkUU5hbWUoYXR0cik7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgfVxyXG4gICAgYXR0ci52YWx1ZSA9IHZhbHVlOyAvLyBBdXRvbWF0aWNhbGx5IHNlbmRzIG11dGF0aW9uIGV2ZW50XHJcbiAgICBpZiAoaXNuZXcgJiYgdGhpcy5fbmV3YXR0cmhvb2spIHRoaXMuX25ld2F0dHJob29rKHFuYW1lLCB2YWx1ZSk7XHJcbiAgfX0sXHJcblxyXG4gIC8vIERvIGVycm9yIGNoZWNraW5nIHRoZW4gY2FsbCBfc2V0QXR0cmlidXRlTlNcclxuICBzZXRBdHRyaWJ1dGVOUzogeyB2YWx1ZTogZnVuY3Rpb24gc2V0QXR0cmlidXRlTlMobnMsIHFuYW1lLCB2YWx1ZSkge1xyXG4gICAgaWYgKCF4bWwuaXNWYWxpZE5hbWUocW5hbWUpKSB1dGlscy5JbnZhbGlkQ2hhcmFjdGVyRXJyb3IoKTtcclxuICAgIGlmICgheG1sLmlzVmFsaWRRTmFtZShxbmFtZSkpIHV0aWxzLk5hbWVzcGFjZUVycm9yKCk7XHJcblxyXG4gICAgdmFyIHBvcyA9IHFuYW1lLmluZGV4T2YoJzonKTtcclxuICAgIHZhciBwcmVmaXggPSAocG9zID09PSAtMSkgPyBudWxsIDogcW5hbWUuc3Vic3RyaW5nKDAsIHBvcyk7XHJcbiAgICBpZiAobnMgPT09ICcnKSBucyA9IG51bGw7XHJcblxyXG4gICAgaWYgKChwcmVmaXggIT09IG51bGwgJiYgbnMgPT09IG51bGwpIHx8XHJcbiAgICAgIChwcmVmaXggPT09ICd4bWwnICYmIG5zICE9PSBOQU1FU1BBQ0UuWE1MKSB8fFxyXG4gICAgICAoKHFuYW1lID09PSAneG1sbnMnIHx8IHByZWZpeCA9PT0gJ3htbG5zJykgJiZcclxuICAgICAgIChucyAhPT0gTkFNRVNQQUNFLlhNTE5TKSkgfHxcclxuICAgICAgKG5zID09PSBOQU1FU1BBQ0UuWE1MTlMgJiZcclxuICAgICAgICEocW5hbWUgPT09ICd4bWxucycgfHwgcHJlZml4ID09PSAneG1sbnMnKSkpXHJcbiAgICAgIHV0aWxzLk5hbWVzcGFjZUVycm9yKCk7XHJcblxyXG4gICAgdGhpcy5fc2V0QXR0cmlidXRlTlMobnMsIHFuYW1lLCBTdHJpbmcodmFsdWUpKTtcclxuICB9fSxcclxuXHJcbiAgcmVtb3ZlQXR0cmlidXRlOiB7IHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUocW5hbWUpIHtcclxuICAgIGlmICh0aGlzLmlzSFRNTCkgcW5hbWUgPSB1dGlscy50b0FTQ0lJTG93ZXJDYXNlKHFuYW1lKTtcclxuXHJcbiAgICB2YXIgYXR0ciA9IHRoaXMuX2F0dHJzQnlRTmFtZVtxbmFtZV07XHJcbiAgICBpZiAoIWF0dHIpIHJldHVybjtcclxuXHJcbiAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIG1hdGNoIGZvciB0aGlzIHFuYW1lXHJcbiAgICAvLyBzbyBkb24ndCBkZWxldGUgdGhlIHFuYW1lIG1hcHBpbmcsIGp1c3QgcmVtb3ZlIHRoZSBmaXJzdFxyXG4gICAgLy8gZWxlbWVudCBmcm9tIGl0LlxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cikpIHtcclxuICAgICAgaWYgKGF0dHIubGVuZ3RoID4gMikge1xyXG4gICAgICAgIGF0dHIgPSBhdHRyLnNoaWZ0KCk7ICAvLyByZW1vdmUgaXQgZnJvbSB0aGUgYXJyYXlcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLl9hdHRyc0J5UU5hbWVbcW5hbWVdID0gYXR0clsxXTtcclxuICAgICAgICBhdHRyID0gYXR0clswXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIC8vIG9ubHkgYSBzaW5nbGUgbWF0Y2gsIHNvIHJlbW92ZSB0aGUgcW5hbWUgbWFwcGluZ1xyXG4gICAgICB0aGlzLl9hdHRyc0J5UU5hbWVbcW5hbWVdID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBucyA9IGF0dHIubmFtZXNwYWNlVVJJO1xyXG4gICAgLy8gTm93IGF0dHIgaXMgdGhlIHJlbW92ZWQgYXR0cmlidXRlLiAgRmlndXJlIG91dCBpdHNcclxuICAgIC8vIG5zK2xuYW1lIGtleSBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIG90aGVyIG1hcHBpbmcgYXMgd2VsbC5cclxuICAgIHZhciBrZXkgPSAobnMgPT09IG51bGwgPyAnJyA6IG5zKSArICd8JyArIGF0dHIubG9jYWxOYW1lO1xyXG4gICAgdGhpcy5fYXR0cnNCeUxOYW1lW2tleV0gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgdmFyIGkgPSB0aGlzLl9hdHRyS2V5cy5pbmRleE9mKGtleSk7XHJcbiAgICB0aGlzLl9hdHRyS2V5cy5zcGxpY2UoaSwgMSk7XHJcblxyXG4gICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXMpXHJcbiAgICAgIHRoaXMuX2F0dHJpYnV0ZXNbcW5hbWVdID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIC8vIE9uY2hhbmdlIGhhbmRsZXIgZm9yIHRoZSBhdHRyaWJ1dGVcclxuICAgIGlmIChhdHRyLm9uY2hhbmdlKVxyXG4gICAgICBhdHRyLm9uY2hhbmdlKHRoaXMsIGF0dHIubG9jYWxOYW1lLCBhdHRyLnZhbHVlLCBudWxsKTtcclxuXHJcbiAgICAvLyBNdXRhdGlvbiBldmVudFxyXG4gICAgaWYgKHRoaXMucm9vdGVkKSB0aGlzLm93bmVyRG9jdW1lbnQubXV0YXRlUmVtb3ZlQXR0cihhdHRyKTtcclxuICB9fSxcclxuXHJcbiAgcmVtb3ZlQXR0cmlidXRlTlM6IHsgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZU5TKG5zLCBsbmFtZSkge1xyXG4gICAgdmFyIGtleSA9IChucyA9PT0gbnVsbCA/ICcnIDogbnMpICsgJ3wnICsgbG5hbWU7XHJcbiAgICB2YXIgYXR0ciA9IHRoaXMuX2F0dHJzQnlMTmFtZVtrZXldO1xyXG4gICAgaWYgKCFhdHRyKSByZXR1cm47XHJcblxyXG4gICAgdGhpcy5fYXR0cnNCeUxOYW1lW2tleV0gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgdmFyIGkgPSB0aGlzLl9hdHRyS2V5cy5pbmRleE9mKGtleSk7XHJcbiAgICB0aGlzLl9hdHRyS2V5cy5zcGxpY2UoaSwgMSk7XHJcblxyXG4gICAgLy8gTm93IGZpbmQgdGhlIHNhbWUgQXR0ciBvYmplY3QgaW4gdGhlIHFuYW1lIG1hcHBpbmcgYW5kIHJlbW92ZSBpdFxyXG4gICAgLy8gQnV0IGJlIGNhcmVmdWwgYmVjYXVzZSB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBtYXRjaC5cclxuICAgIHRoaXMuX3JlbW92ZVFOYW1lKGF0dHIpO1xyXG5cclxuICAgIC8vIE9uY2hhbmdlIGhhbmRsZXIgZm9yIHRoZSBhdHRyaWJ1dGVcclxuICAgIGlmIChhdHRyLm9uY2hhbmdlKVxyXG4gICAgICBhdHRyLm9uY2hhbmdlKHRoaXMsIGF0dHIubG9jYWxOYW1lLCBhdHRyLnZhbHVlLCBudWxsKTtcclxuICAgIC8vIE11dGF0aW9uIGV2ZW50XHJcbiAgICBpZiAodGhpcy5yb290ZWQpIHRoaXMub3duZXJEb2N1bWVudC5tdXRhdGVSZW1vdmVBdHRyKGF0dHIpO1xyXG4gIH19LFxyXG5cclxuICAvLyBUaGlzICdyYXcnIHZlcnNpb24gb2YgZ2V0QXR0cmlidXRlIGlzIHVzZWQgYnkgdGhlIGdldHRlciBmdW5jdGlvbnNcclxuICAvLyBvZiByZWZsZWN0ZWQgYXR0cmlidXRlcy4gSXQgc2tpcHMgc29tZSBlcnJvciBjaGVja2luZyBhbmRcclxuICAvLyBuYW1lc3BhY2Ugc3RlcHNcclxuICBfZ2V0YXR0cjogeyB2YWx1ZTogZnVuY3Rpb24gX2dldGF0dHIocW5hbWUpIHtcclxuICAgIC8vIEFzc3VtZSB0aGF0IHFuYW1lIGlzIGFscmVhZHkgbG93ZXJjYXNlZCwgc28gZG9uJ3QgZG8gaXQgaGVyZS5cclxuICAgIC8vIEFsc28gZG9uJ3QgY2hlY2sgd2hldGhlciBhdHRyIGlzIGFuIGFycmF5OiBhIHFuYW1lIHdpdGggbm9cclxuICAgIC8vIHByZWZpeCB3aWxsIG5ldmVyIGhhdmUgdHdvIG1hdGNoaW5nIEF0dHIgb2JqZWN0cyAoYmVjYXVzZVxyXG4gICAgLy8gc2V0QXR0cmlidXRlTlMgZG9lc24ndCBhbGxvdyBhIG5vbi1udWxsIG5hbWVzcGFjZSB3aXRoIGFcclxuICAgIC8vIG51bGwgcHJlZml4LlxyXG4gICAgdmFyIGF0dHIgPSB0aGlzLl9hdHRyc0J5UU5hbWVbcW5hbWVdO1xyXG4gICAgcmV0dXJuIGF0dHIgPyBhdHRyLnZhbHVlIDogbnVsbDtcclxuICB9fSxcclxuXHJcbiAgLy8gVGhlIHJhdyB2ZXJzaW9uIG9mIHNldEF0dHJpYnV0ZSBmb3IgcmVmbGVjdGVkIGlkbCBhdHRyaWJ1dGVzLlxyXG4gIF9zZXRhdHRyOiB7IHZhbHVlOiBmdW5jdGlvbiBfc2V0YXR0cihxbmFtZSwgdmFsdWUpIHtcclxuICAgIHZhciBhdHRyID0gdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXTtcclxuICAgIHZhciBpc25ldztcclxuICAgIGlmICghYXR0cikge1xyXG4gICAgICBhdHRyID0gdGhpcy5fbmV3YXR0cihxbmFtZSk7XHJcbiAgICAgIGlzbmV3ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGF0dHIudmFsdWUgPSBTdHJpbmcodmFsdWUpO1xyXG4gICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXMpIHRoaXMuX2F0dHJpYnV0ZXNbcW5hbWVdID0gYXR0cjtcclxuICAgIGlmIChpc25ldyAmJiB0aGlzLl9uZXdhdHRyaG9vaykgdGhpcy5fbmV3YXR0cmhvb2socW5hbWUsIHZhbHVlKTtcclxuICB9fSxcclxuXHJcbiAgLy8gQ3JlYXRlIGEgbmV3IEF0dHIgb2JqZWN0LCBpbnNlcnQgaXQsIGFuZCByZXR1cm4gaXQuXHJcbiAgLy8gVXNlZCBieSBzZXRBdHRyaWJ1dGUoKSBhbmQgYnkgc2V0KClcclxuICBfbmV3YXR0cjogeyB2YWx1ZTogZnVuY3Rpb24gX25ld2F0dHIocW5hbWUpIHtcclxuICAgIHZhciBhdHRyID0gbmV3IEF0dHIodGhpcywgcW5hbWUsIG51bGwsIG51bGwpO1xyXG4gICAgdmFyIGtleSA9ICd8JyArIHFuYW1lO1xyXG4gICAgdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXSA9IGF0dHI7XHJcbiAgICB0aGlzLl9hdHRyc0J5TE5hbWVba2V5XSA9IGF0dHI7XHJcbiAgICB0aGlzLl9hdHRyS2V5cy5wdXNoKGtleSk7XHJcbiAgICByZXR1cm4gYXR0cjtcclxuICB9fSxcclxuXHJcbiAgLy8gQWRkIGEgcW5hbWUtPkF0dHIgbWFwcGluZyB0byB0aGUgX2F0dHJzQnlRTmFtZSBvYmplY3QsIHRha2luZyBpbnRvXHJcbiAgLy8gYWNjb3VudCB0aGF0IHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIGF0dHIgb2JqZWN0IHdpdGggdGhlXHJcbiAgLy8gc2FtZSBxbmFtZVxyXG4gIF9hZGRRTmFtZTogeyB2YWx1ZTogZnVuY3Rpb24oYXR0cikge1xyXG4gICAgdmFyIHFuYW1lID0gYXR0ci5uYW1lO1xyXG4gICAgdmFyIGV4aXN0aW5nID0gdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXTtcclxuICAgIGlmICghZXhpc3RpbmcpIHtcclxuICAgICAgdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXSA9IGF0dHI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV4aXN0aW5nKSkge1xyXG4gICAgICBleGlzdGluZy5wdXNoKGF0dHIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHRoaXMuX2F0dHJzQnlRTmFtZVtxbmFtZV0gPSBbZXhpc3RpbmcsIGF0dHJdO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXMpIHRoaXMuX2F0dHJpYnV0ZXNbcW5hbWVdID0gYXR0cjtcclxuICB9fSxcclxuXHJcbiAgLy8gUmVtb3ZlIGEgcW5hbWUtPkF0dHIgbWFwcGluZyB0byB0aGUgX2F0dHJzQnlRTmFtZSBvYmplY3QsIHRha2luZyBpbnRvXHJcbiAgLy8gYWNjb3VudCB0aGF0IHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIGF0dHIgb2JqZWN0IHdpdGggdGhlXHJcbiAgLy8gc2FtZSBxbmFtZVxyXG4gIF9yZW1vdmVRTmFtZTogeyB2YWx1ZTogZnVuY3Rpb24oYXR0cikge1xyXG4gICAgdmFyIHFuYW1lID0gYXR0ci5uYW1lO1xyXG4gICAgdmFyIHRhcmdldCA9IHRoaXMuX2F0dHJzQnlRTmFtZVtxbmFtZV07XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICB2YXIgaWR4ID0gdGFyZ2V0LmluZGV4T2YoYXR0cik7XHJcbiAgICAgIHV0aWxzLmFzc2VydChpZHggIT09IC0xKTsgLy8gSXQgbXVzdCBiZSBoZXJlIHNvbWV3aGVyZVxyXG4gICAgICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgIHRoaXMuX2F0dHJzQnlRTmFtZVtxbmFtZV0gPSB0YXJnZXRbMS1pZHhdO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRhcmdldC5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHV0aWxzLmFzc2VydCh0YXJnZXQgPT09IGF0dHIpOyAgLy8gSWYgb25seSBvbmUsIGl0IG11c3QgbWF0Y2hcclxuICAgICAgdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9fSxcclxuXHJcbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgYXR0cmlidXRlc1xyXG4gIF9udW1hdHRyczogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fYXR0cktleXMubGVuZ3RoOyB9fSxcclxuICAvLyBSZXR1cm4gdGhlIG50aCBBdHRyIG9iamVjdFxyXG4gIF9hdHRyOiB7IHZhbHVlOiBmdW5jdGlvbihuKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYXR0cnNCeUxOYW1lW3RoaXMuX2F0dHJLZXlzW25dXTtcclxuICB9fSxcclxuXHJcbiAgLy8gRGVmaW5lIGdldHRlcnMgYW5kIHNldHRlcnMgZm9yIGFuICdpZCcgcHJvcGVydHkgdGhhdCByZWZsZWN0c1xyXG4gIC8vIHRoZSBjb250ZW50IGF0dHJpYnV0ZSAnaWQnLlxyXG4gIGlkOiBhdHRyaWJ1dGVzLnByb3BlcnR5KHtuYW1lOiAnaWQnfSksXHJcblxyXG4gIC8vIERlZmluZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGZvciBhICdjbGFzc05hbWUnIHByb3BlcnR5IHRoYXQgcmVmbGVjdHNcclxuICAvLyB0aGUgY29udGVudCBhdHRyaWJ1dGUgJ2NsYXNzJy5cclxuICBjbGFzc05hbWU6IGF0dHJpYnV0ZXMucHJvcGVydHkoe25hbWU6ICdjbGFzcyd9KSxcclxuXHJcbiAgY2xhc3NMaXN0OiB7IGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBpZiAodGhpcy5fY2xhc3NMaXN0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9jbGFzc0xpc3Q7XHJcbiAgICB9XHJcbiAgICB2YXIgZHRsaXN0ID0gbmV3IERPTVRva2VuTGlzdChcclxuICAgICAgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYuY2xhc3NOYW1lIHx8IFwiXCI7XHJcbiAgICAgIH0sXHJcbiAgICAgIGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICBzZWxmLmNsYXNzTmFtZSA9IHY7XHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgICB0aGlzLl9jbGFzc0xpc3QgPSBkdGxpc3Q7XHJcbiAgICByZXR1cm4gZHRsaXN0O1xyXG4gIH19LFxyXG5cclxuICBtYXRjaGVzOiB7IHZhbHVlOiBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgcmV0dXJuIHNlbGVjdC5tYXRjaGVzKHRoaXMsIHNlbGVjdG9yKTtcclxuICB9fSxcclxuXHJcbiAgY2xvc2VzdDogeyB2YWx1ZTogZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICAgIHZhciBlbCA9IHRoaXM7XHJcbiAgICB3aGlsZSAoZWwubWF0Y2hlcyAmJiAhZWwubWF0Y2hlcyhzZWxlY3RvcikpIGVsID0gZWwucGFyZW50Tm9kZTtcclxuICAgIHJldHVybiBlbC5tYXRjaGVzID8gZWwgOiBudWxsO1xyXG4gIH19LFxyXG5cclxuICBxdWVyeVNlbGVjdG9yOiB7IHZhbHVlOiBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgcmV0dXJuIHNlbGVjdChzZWxlY3RvciwgdGhpcylbMF07XHJcbiAgfX0sXHJcblxyXG4gIHF1ZXJ5U2VsZWN0b3JBbGw6IHsgdmFsdWU6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcbiAgICB2YXIgbm9kZXMgPSBzZWxlY3Qoc2VsZWN0b3IsIHRoaXMpO1xyXG4gICAgcmV0dXJuIG5vZGVzLml0ZW0gPyBub2RlcyA6IG5ldyBOb2RlTGlzdChub2Rlcyk7XHJcbiAgfX1cclxuXHJcbn0pO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRWxlbWVudC5wcm90b3R5cGUsIENoaWxkTm9kZSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEVsZW1lbnQucHJvdG90eXBlLCBOb25Eb2N1bWVudFR5cGVDaGlsZE5vZGUpO1xyXG5cclxuLy8gUmVnaXN0ZXIgc3BlY2lhbCBoYW5kbGluZyBmb3IgdGhlIGlkIGF0dHJpYnV0ZVxyXG5hdHRyaWJ1dGVzLnJlZ2lzdGVyQ2hhbmdlSGFuZGxlcihFbGVtZW50LCAnaWQnLFxyXG4gZnVuY3Rpb24oZWxlbWVudCwgbG5hbWUsIG9sZHZhbCwgbmV3dmFsKSB7XHJcbiAgIGlmIChlbGVtZW50LnJvb3RlZCkge1xyXG4gICAgIGlmIChvbGR2YWwpIHtcclxuICAgICAgIGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWxJZChvbGR2YWwsIGVsZW1lbnQpO1xyXG4gICAgIH1cclxuICAgICBpZiAobmV3dmFsKSB7XHJcbiAgICAgICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWRkSWQobmV3dmFsLCBlbGVtZW50KTtcclxuICAgICB9XHJcbiAgIH1cclxuIH1cclxuKTtcclxuXHJcblxyXG4vLyBUaGUgQXR0ciBjbGFzcyByZXByZXNlbnRzIGEgc2luZ2xlIGF0dHJpYnV0ZS4gIFRoZSB2YWx1ZXMgaW5cclxuLy8gX2F0dHJzQnlRTmFtZSBhbmQgX2F0dHJzQnlMTmFtZSBhcmUgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MuXHJcbmZ1bmN0aW9uIEF0dHIoZWx0LCBsbmFtZSwgcHJlZml4LCBuYW1lc3BhY2UpIHtcclxuICAvLyBBbHdheXMgcmVtZW1iZXIgd2hhdCBlbGVtZW50IHdlJ3JlIGFzc29jaWF0ZWQgd2l0aC5cclxuICAvLyBXZSBuZWVkIHRoaXMgdG8gcHJvcGVydHkgaGFuZGxlIG11dGF0aW9uc1xyXG4gIHRoaXMub3duZXJFbGVtZW50ID0gZWx0O1xyXG5cclxuICBpZiAoIW5hbWVzcGFjZSAmJiAhcHJlZml4ICYmIGVsdC5fYXR0cmlidXRlQ2hhbmdlSGFuZGxlcnNbbG5hbWVdKVxyXG4gICAgdGhpcy5vbmNoYW5nZSA9IGVsdC5fYXR0cmlidXRlQ2hhbmdlSGFuZGxlcnNbbG5hbWVdO1xyXG5cclxuICAvLyBsb2NhbE5hbWUgYW5kIG5hbWVzcGFjZSBhcmUgY29uc3RhbnQgZm9yIGFueSBhdHRyIG9iamVjdC5cclxuICAvLyBCdXQgdmFsdWUgbWF5IGNoYW5nZS4gIEFuZCBzbyBjYW4gcHJlZml4LCBhbmQgc28sIHRoZXJlZm9yZSBjYW4gbmFtZS5cclxuICB0aGlzLmxvY2FsTmFtZSA9IGxuYW1lO1xyXG4gIHRoaXMucHJlZml4ID0gKHByZWZpeD09PW51bGwgfHwgcHJlZml4PT09JycpID8gbnVsbCA6ICgnJyArIHByZWZpeCk7XHJcbiAgdGhpcy5uYW1lc3BhY2VVUkkgPSAobmFtZXNwYWNlPT09bnVsbCB8fCBuYW1lc3BhY2U9PT0nJykgPyBudWxsIDogKCcnICsgbmFtZXNwYWNlKTtcclxufVxyXG5cclxuQXR0ci5wcm90b3R5cGUgPSB7XHJcbiAgZ2V0IG5hbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wcmVmaXggPyB0aGlzLnByZWZpeCArICc6JyArIHRoaXMubG9jYWxOYW1lIDogdGhpcy5sb2NhbE5hbWU7XHJcbiAgfSxcclxuXHJcbiAgZ2V0IHZhbHVlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcclxuICB9LFxyXG5cclxuICBnZXQgc3BlY2lmaWVkKCkge1xyXG4gICAgLy8gRGVwcmVjYXRlZFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSxcclxuXHJcbiAgc2V0IHZhbHVlKHZhbHVlKSB7XHJcbiAgICB2YXIgb2xkdmFsID0gdGhpcy5kYXRhO1xyXG4gICAgdmFsdWUgPSAodmFsdWUgPT09IHVuZGVmaW5lZCkgPyAnJyA6IHZhbHVlICsgJyc7XHJcbiAgICBpZiAodmFsdWUgPT09IG9sZHZhbCkgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xyXG5cclxuICAgIC8vIFJ1biB0aGUgb25jaGFuZ2UgaG9vayBmb3IgdGhlIGF0dHJpYnV0ZVxyXG4gICAgLy8gaWYgdGhlcmUgaXMgb25lLlxyXG4gICAgaWYgKHRoaXMub25jaGFuZ2UpXHJcbiAgICAgIHRoaXMub25jaGFuZ2UodGhpcy5vd25lckVsZW1lbnQsdGhpcy5sb2NhbE5hbWUsIG9sZHZhbCwgdmFsdWUpO1xyXG5cclxuICAgIC8vIEdlbmVyYXRlIGEgbXV0YXRpb24gZXZlbnQgaWYgdGhlIGVsZW1lbnQgaXMgcm9vdGVkXHJcbiAgICBpZiAodGhpcy5vd25lckVsZW1lbnQucm9vdGVkKVxyXG4gICAgICB0aGlzLm93bmVyRWxlbWVudC5vd25lckRvY3VtZW50Lm11dGF0ZUF0dHIodGhpcywgb2xkdmFsKTtcclxuICB9LFxyXG5cclxuICAvLyBMZWdhY3kgYWxpYXNlcyAoc2VlIGdoIzcwIGFuZCBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS1hdHRyKVxyXG4gIGdldCBub2RlTmFtZSgpIHsgcmV0dXJuIHRoaXMubmFtZTsgfSxcclxuICBnZXQgbm9kZVZhbHVlKCkgeyByZXR1cm4gdGhpcy52YWx1ZTsgfSxcclxuICBnZXQgdGV4dENvbnRlbnQoKSB7IHJldHVybiB0aGlzLnZhbHVlOyB9LFxyXG4gIHNldCBub2RlVmFsdWUodikgeyB0aGlzLnZhbHVlID0gdjsgfSxcclxuICBzZXQgdGV4dENvbnRlbnQodikgeyB0aGlzLnZhbHVlID0gdjsgfSxcclxufTtcclxuXHJcblxyXG4vLyBUaGUgYXR0cmlidXRlcyBwcm9wZXJ0eSBvZiBhbiBFbGVtZW50IHdpbGwgYmUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuLy8gVGhpcyBjbGFzcyBpcyByZWFsbHkganVzdCBhIGR1bW15LCB0aG91Z2guIEl0IG9ubHkgZGVmaW5lcyBhIGxlbmd0aFxyXG4vLyBwcm9wZXJ0eSBhbmQgYW4gaXRlbSgpIG1ldGhvZC4gVGhlIEF0dHJBcnJheVByb3h5IHRoYXRcclxuLy8gZGVmaW5lcyB0aGUgcHVibGljIEFQSSBqdXN0IHVzZXMgdGhlIEVsZW1lbnQgb2JqZWN0IGl0c2VsZi5cclxuZnVuY3Rpb24gQXR0cmlidXRlc0FycmF5KGVsdCkge1xyXG4gIHRoaXMuZWxlbWVudCA9IGVsdDtcclxuICBmb3IgKHZhciBuYW1lIGluIGVsdC5fYXR0cnNCeVFOYW1lKSB7XHJcbiAgICB0aGlzW25hbWVdID0gZWx0Ll9hdHRyc0J5UU5hbWVbbmFtZV07XHJcbiAgfVxyXG59XHJcbkF0dHJpYnV0ZXNBcnJheS5wcm90b3R5cGUgPSB7XHJcbiAgZ2V0IGxlbmd0aCgpIHtcclxuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuX2F0dHJLZXlzLmxlbmd0aDtcclxuICB9LFxyXG4gIGl0ZW06IGZ1bmN0aW9uKG4pIHtcclxuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuX2F0dHJzQnlMTmFtZVt0aGlzLmVsZW1lbnQuX2F0dHJLZXlzW25dXTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuLy8gVGhlIGNoaWxkcmVuIHByb3BlcnR5IG9mIGFuIEVsZW1lbnQgd2lsbCBiZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4vLyBJdCBkZWZpbmVzIGxlbmd0aCwgaXRlbSgpIGFuZCBuYW1lZEl0ZW0oKSBhbmQgd2lsbCBiZSB3cmFwcGVkIGJ5IGFuXHJcbi8vIEhUTUxDb2xsZWN0aW9uIHdoZW4gZXhwb3NlZCB0aHJvdWdoIHRoZSBET00uXHJcbmZ1bmN0aW9uIENoaWxkcmVuQ29sbGVjdGlvbihlKSB7XHJcbiAgdGhpcy5lbGVtZW50ID0gZTtcclxuICB0aGlzLnVwZGF0ZUNhY2hlKCk7XHJcbn1cclxuXHJcbkNoaWxkcmVuQ29sbGVjdGlvbi5wcm90b3R5cGUgPSB7XHJcbiAgZ2V0IGxlbmd0aCgpIHtcclxuICAgIHRoaXMudXBkYXRlQ2FjaGUoKTtcclxuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuQnlOdW1iZXIubGVuZ3RoO1xyXG4gIH0sXHJcbiAgaXRlbTogZnVuY3Rpb24gaXRlbShuKSB7XHJcbiAgICB0aGlzLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbkJ5TnVtYmVyW25dIHx8IG51bGw7XHJcbiAgfSxcclxuXHJcbiAgbmFtZWRJdGVtOiBmdW5jdGlvbiBuYW1lZEl0ZW0obmFtZSkge1xyXG4gICAgdGhpcy51cGRhdGVDYWNoZSgpO1xyXG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5CeU5hbWVbbmFtZV0gfHwgbnVsbDtcclxuICB9LFxyXG5cclxuICAvLyBUaGlzIGF0dHJpYnV0ZSByZXR1cm5zIHRoZSBlbnRpcmUgbmFtZS0+ZWxlbWVudCBtYXAuXHJcbiAgLy8gSXQgaXMgbm90IHBhcnQgb2YgdGhlIEhUTUxDb2xsZWN0aW9uIEFQSSwgYnV0IHdlIG5lZWQgaXQgaW5cclxuICAvLyBzcmMvSFRNTENvbGxlY3Rpb25Qcm94eVxyXG4gIGdldCBuYW1lZEl0ZW1zKCkge1xyXG4gICAgdGhpcy51cGRhdGVDYWNoZSgpO1xyXG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5CeU5hbWU7XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlQ2FjaGU6IGZ1bmN0aW9uIHVwZGF0ZUNhY2hlKCkge1xyXG4gICAgdmFyIG5hbWVkRWx0cyA9IC9eKGF8YXBwbGV0fGFyZWF8ZW1iZWR8Zm9ybXxmcmFtZXxmcmFtZXNldHxpZnJhbWV8aW1nfG9iamVjdCkkLztcclxuICAgIGlmICh0aGlzLmxhc3RNb2RUaW1lICE9PSB0aGlzLmVsZW1lbnQubGFzdE1vZFRpbWUpIHtcclxuICAgICAgdGhpcy5sYXN0TW9kVGltZSA9IHRoaXMuZWxlbWVudC5sYXN0TW9kVGltZTtcclxuXHJcbiAgICAgIHZhciBuID0gdGhpcy5jaGlsZHJlbkJ5TnVtYmVyICYmIHRoaXMuY2hpbGRyZW5CeU51bWJlci5sZW5ndGggfHwgMDtcclxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHRoaXNbaV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuY2hpbGRyZW5CeU51bWJlciA9IFtdO1xyXG4gICAgICB0aGlzLmNoaWxkcmVuQnlOYW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHJcbiAgICAgIGZvcihpID0gMCwgbiA9IHRoaXMuZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHZhciBjID0gdGhpcy5lbGVtZW50LmNoaWxkTm9kZXNbaV07XHJcbiAgICAgICAgaWYgKGMubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XHJcblxyXG4gICAgICAgICAgdGhpc1t0aGlzLmNoaWxkcmVuQnlOdW1iZXIubGVuZ3RoXSA9IGM7XHJcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuQnlOdW1iZXIucHVzaChjKTtcclxuXHJcbiAgICAgICAgICAvLyBYWFggQXJlIHRoZXJlIGFueSByZXF1aXJlbWVudHMgYWJvdXQgdGhlIG5hbWVzcGFjZVxyXG4gICAgICAgICAgLy8gb2YgdGhlIGlkIHByb3BlcnR5P1xyXG4gICAgICAgICAgdmFyIGlkID0gYy5nZXRBdHRyaWJ1dGUoJ2lkJyk7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaWQgdGhhdCBpcyBub3QgYWxyZWFkeSBpbiB1c2UuLi5cclxuICAgICAgICAgIGlmIChpZCAmJiAhdGhpcy5jaGlsZHJlbkJ5TmFtZVtpZF0pXHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5CeU5hbWVbaWRdID0gYztcclxuXHJcbiAgICAgICAgICAvLyBGb3IgY2VydGFpbiBIVE1MIGVsZW1lbnRzIHdlIGNoZWNrIHRoZSBuYW1lIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgdmFyIG5hbWUgPSBjLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xyXG4gICAgICAgICAgaWYgKG5hbWUgJiZcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gTkFNRVNQQUNFLkhUTUwgJiZcclxuICAgICAgICAgICAgbmFtZWRFbHRzLnRlc3QodGhpcy5lbGVtZW50LmxvY2FsTmFtZSkgJiZcclxuICAgICAgICAgICAgIXRoaXMuY2hpbGRyZW5CeU5hbWVbbmFtZV0pXHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5CeU5hbWVbaWRdID0gYztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vLyBUaGVzZSBmdW5jdGlvbnMgcmV0dXJuIHByZWRpY2F0ZXMgZm9yIGZpbHRlcmluZyBlbGVtZW50cy5cclxuLy8gVGhleSdyZSB1c2VkIGJ5IHRoZSBEb2N1bWVudCBhbmQgRWxlbWVudCBjbGFzc2VzIGZvciBtZXRob2RzIGxpa2VcclxuLy8gZ2V0RWxlbWVudHNCeVRhZ05hbWUgYW5kIGdldEVsZW1lbnRzQnlDbGFzc05hbWVcclxuXHJcbmZ1bmN0aW9uIGxvY2FsTmFtZUVsZW1lbnRGaWx0ZXIobG5hbWUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oZSkgeyByZXR1cm4gZS5sb2NhbE5hbWUgPT09IGxuYW1lOyB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBodG1sTG9jYWxOYW1lRWxlbWVudEZpbHRlcihsbmFtZSkge1xyXG4gIHZhciBsY2xuYW1lID0gdXRpbHMudG9BU0NJSUxvd2VyQ2FzZShsbmFtZSk7XHJcbiAgaWYgKGxjbG5hbWUgPT09IGxuYW1lKVxyXG4gICAgcmV0dXJuIGxvY2FsTmFtZUVsZW1lbnRGaWx0ZXIobG5hbWUpO1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24oZSkge1xyXG4gICAgcmV0dXJuIGUuaXNIVE1MID8gZS5sb2NhbE5hbWUgPT09IGxjbG5hbWUgOiBlLmxvY2FsTmFtZSA9PT0gbG5hbWU7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gbmFtZXNwYWNlRWxlbWVudEZpbHRlcihucykge1xyXG4gIHJldHVybiBmdW5jdGlvbihlKSB7IHJldHVybiBlLm5hbWVzcGFjZVVSSSA9PT0gbnM7IH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5hbWVzcGFjZUxvY2FsTmFtZUVsZW1lbnRGaWx0ZXIobnMsIGxuYW1lKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcclxuICAgIHJldHVybiBlLm5hbWVzcGFjZVVSSSA9PT0gbnMgJiYgZS5sb2NhbE5hbWUgPT09IGxuYW1lO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIFhYWFxyXG4vLyBPcHRpbWl6ZSB0aGlzIHdoZW4gSSBpbXBsZW1lbnQgY2xhc3NMaXN0LlxyXG5mdW5jdGlvbiBjbGFzc05hbWVzRWxlbWVudEZpbHRlcihuYW1lcykge1xyXG4gIHJldHVybiBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgY2xhc3NBdHRyID0gZS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyk7XHJcbiAgICBpZiAoIWNsYXNzQXR0cikgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmFyIGNsYXNzZXMgPSBjbGFzc0F0dHIudHJpbSgpLnNwbGl0KC9cXHMrLyk7XHJcbiAgICByZXR1cm4gbmFtZXMuZXZlcnkoZnVuY3Rpb24obikge1xyXG4gICAgICByZXR1cm4gY2xhc3Nlcy5pbmRleE9mKG4pICE9PSAtMTtcclxuICAgIH0pO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVsZW1lbnROYW1lRmlsdGVyKG5hbWUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oZSkge1xyXG4gICAgcmV0dXJuIGUuZ2V0QXR0cmlidXRlKCduYW1lJykgPT09IG5hbWU7XHJcbiAgfTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZG9taW5vL2xpYi9FbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xyXG5cclxuRXZlbnQuQ0FQVFVSSU5HX1BIQVNFID0gMTtcclxuRXZlbnQuQVRfVEFSR0VUID0gMjtcclxuRXZlbnQuQlVCQkxJTkdfUEhBU0UgPSAzO1xyXG5cclxuZnVuY3Rpb24gRXZlbnQodHlwZSwgZGljdGlvbmFyeSkge1xyXG4gIC8vIEluaXRpYWxpemUgYmFzaWMgZXZlbnQgcHJvcGVydGllc1xyXG4gIHRoaXMudHlwZSA9ICcnO1xyXG4gIHRoaXMudGFyZ2V0ID0gbnVsbDtcclxuICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xyXG4gIHRoaXMuZXZlbnRQaGFzZSA9IEV2ZW50LkFUX1RBUkdFVDtcclxuICB0aGlzLmJ1YmJsZXMgPSBmYWxzZTtcclxuICB0aGlzLmNhbmNlbGFibGUgPSBmYWxzZTtcclxuICB0aGlzLmlzVHJ1c3RlZCA9IGZhbHNlO1xyXG4gIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xyXG4gIHRoaXMudGltZVN0YW1wID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBpbnRlcm5hbCBmbGFnc1xyXG4gIC8vIFhYWDogV291bGQgaXQgYmUgYmV0dGVyIHRvIGluaGVyaXQgdGhlc2UgZGVmYXVsdHMgZnJvbSB0aGUgcHJvdG90eXBlP1xyXG4gIHRoaXMuX3Byb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xyXG4gIHRoaXMuX2ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xyXG4gIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcclxuICB0aGlzLl9kaXNwYXRjaGluZyA9IGZhbHNlO1xyXG5cclxuICAvLyBOb3cgaW5pdGlhbGl6ZSBiYXNlZCBvbiB0aGUgY29uc3RydWN0b3IgYXJndW1lbnRzIChpZiBhbnkpXHJcbiAgaWYgKHR5cGUpIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgaWYgKGRpY3Rpb25hcnkpIHtcclxuICAgIGZvcih2YXIgcCBpbiBkaWN0aW9uYXJ5KSB7XHJcbiAgICAgIHRoaXNbcF0gPSBkaWN0aW9uYXJ5W3BdO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPYmplY3QucHJvdG90eXBlLCB7XHJcbiAgY29uc3RydWN0b3I6IHsgdmFsdWU6IEV2ZW50IH0sXHJcbiAgc3RvcFByb3BhZ2F0aW9uOiB7IHZhbHVlOiBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XHJcbiAgICB0aGlzLl9wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xyXG4gIH19LFxyXG5cclxuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IHsgdmFsdWU6IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcclxuICAgIHRoaXMuX3Byb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XHJcbiAgICB0aGlzLl9pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xyXG4gIH19LFxyXG5cclxuICBwcmV2ZW50RGVmYXVsdDogeyB2YWx1ZTogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XHJcbiAgICBpZiAodGhpcy5jYW5jZWxhYmxlKSB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xyXG4gIH19LFxyXG5cclxuICBpbml0RXZlbnQ6IHsgdmFsdWU6IGZ1bmN0aW9uIGluaXRFdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlKSB7XHJcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICBpZiAodGhpcy5fZGlzcGF0Y2hpbmcpIHJldHVybjtcclxuXHJcbiAgICB0aGlzLl9wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLmlzVHJ1c3RlZCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB0aGlzLmJ1YmJsZXMgPSBidWJibGVzO1xyXG4gICAgdGhpcy5jYW5jZWxhYmxlID0gY2FuY2VsYWJsZTtcclxuICB9fSxcclxuXHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZG9taW5vL2xpYi9FdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBDaGFyYWN0ZXJEYXRhO1xyXG5cclxudmFyIExlYWYgPSByZXF1aXJlKCcuL0xlYWYnKTtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG52YXIgQ2hpbGROb2RlID0gcmVxdWlyZSgnLi9DaGlsZE5vZGUnKTtcclxudmFyIE5vbkRvY3VtZW50VHlwZUNoaWxkTm9kZSA9IHJlcXVpcmUoJy4vTm9uRG9jdW1lbnRUeXBlQ2hpbGROb2RlJyk7XHJcblxyXG5mdW5jdGlvbiBDaGFyYWN0ZXJEYXRhKCkge1xyXG59XHJcblxyXG5DaGFyYWN0ZXJEYXRhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGVhZi5wcm90b3R5cGUsIHtcclxuICAvLyBET01TdHJpbmcgc3Vic3RyaW5nRGF0YSh1bnNpZ25lZCBsb25nIG9mZnNldCxcclxuICAvLyAgICAgICAgICAgICAgIHVuc2lnbmVkIGxvbmcgY291bnQpO1xyXG4gIC8vIFRoZSBzdWJzdHJpbmdEYXRhKG9mZnNldCwgY291bnQpIG1ldGhvZCBtdXN0IHJ1biB0aGVzZSBzdGVwczpcclxuICAvL1xyXG4gIC8vICAgICBJZiBvZmZzZXQgaXMgZ3JlYXRlciB0aGFuIHRoZSBjb250ZXh0IG9iamVjdCdzXHJcbiAgLy8gICAgIGxlbmd0aCwgdGhyb3cgYW4gSU5ERVhfU0laRV9FUlIgZXhjZXB0aW9uIGFuZFxyXG4gIC8vICAgICB0ZXJtaW5hdGUgdGhlc2Ugc3RlcHMuXHJcbiAgLy9cclxuICAvLyAgICAgSWYgb2Zmc2V0K2NvdW50IGlzIGdyZWF0ZXIgdGhhbiB0aGUgY29udGV4dFxyXG4gIC8vICAgICBvYmplY3QncyBsZW5ndGgsIHJldHVybiBhIERPTVN0cmluZyB3aG9zZSB2YWx1ZSBpc1xyXG4gIC8vICAgICB0aGUgVVRGLTE2IGNvZGUgdW5pdHMgZnJvbSB0aGUgb2Zmc2V0dGggVVRGLTE2IGNvZGVcclxuICAvLyAgICAgdW5pdCB0byB0aGUgZW5kIG9mIGRhdGEuXHJcbiAgLy9cclxuICAvLyAgICAgUmV0dXJuIGEgRE9NU3RyaW5nIHdob3NlIHZhbHVlIGlzIHRoZSBVVEYtMTYgY29kZVxyXG4gIC8vICAgICB1bml0cyBmcm9tIHRoZSBvZmZzZXR0aCBVVEYtMTYgY29kZSB1bml0IHRvIHRoZVxyXG4gIC8vICAgICBvZmZzZXQrY291bnR0aCBVVEYtMTYgY29kZSB1bml0IGluIGRhdGEuXHJcbiAgc3Vic3RyaW5nRGF0YTogeyB2YWx1ZTogZnVuY3Rpb24gc3Vic3RyaW5nRGF0YShvZmZzZXQsIGNvdW50KSB7XHJcbiAgICBpZiAob2Zmc2V0ID4gdGhpcy5kYXRhLmxlbmd0aCB8fCBvZmZzZXQgPCAwIHx8IGNvdW50IDwgMCkgXHJcbiAgICAgIHV0aWxzLkluZGV4U2l6ZUVycm9yKCk7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCtjb3VudCk7XHJcbiAgfX0sXHJcblxyXG4gIC8vIHZvaWQgYXBwZW5kRGF0YShET01TdHJpbmcgZGF0YSk7XHJcbiAgLy8gVGhlIGFwcGVuZERhdGEoZGF0YSkgbWV0aG9kIG11c3QgYXBwZW5kIGRhdGEgdG8gdGhlIGNvbnRleHRcclxuICAvLyBvYmplY3QncyBkYXRhLlxyXG4gIGFwcGVuZERhdGE6IHsgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZERhdGEoZGF0YSkge1xyXG4gICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhICsgZGF0YTtcclxuICB9fSxcclxuXHJcbiAgLy8gdm9pZCBpbnNlcnREYXRhKHVuc2lnbmVkIGxvbmcgb2Zmc2V0LCBET01TdHJpbmcgZGF0YSk7XHJcbiAgLy8gVGhlIGluc2VydERhdGEob2Zmc2V0LCBkYXRhKSBtZXRob2QgbXVzdCBydW4gdGhlc2Ugc3RlcHM6XHJcbiAgLy9cclxuICAvLyAgICAgSWYgb2Zmc2V0IGlzIGdyZWF0ZXIgdGhhbiB0aGUgY29udGV4dCBvYmplY3Qnc1xyXG4gIC8vICAgICBsZW5ndGgsIHRocm93IGFuIElOREVYX1NJWkVfRVJSIGV4Y2VwdGlvbiBhbmRcclxuICAvLyAgICAgdGVybWluYXRlIHRoZXNlIHN0ZXBzLlxyXG4gIC8vXHJcbiAgLy8gICAgIEluc2VydCBkYXRhIGludG8gdGhlIGNvbnRleHQgb2JqZWN0J3MgZGF0YSBhZnRlclxyXG4gIC8vICAgICBvZmZzZXQgVVRGLTE2IGNvZGUgdW5pdHMuXHJcbiAgLy9cclxuICBpbnNlcnREYXRhOiB7IHZhbHVlOiBmdW5jdGlvbiBpbnNlcnREYXRhKG9mZnNldCwgZGF0YSkge1xyXG4gICAgdmFyIGN1cnRleHQgPSB0aGlzLmRhdGE7XHJcbiAgICBpZiAob2Zmc2V0ID4gY3VydGV4dC5sZW5ndGggfHwgb2Zmc2V0IDwgMCkgdXRpbHMuSW5kZXhTaXplRXJyb3IoKTtcclxuICAgIHZhciBwcmVmaXggPSBjdXJ0ZXh0LnN1YnN0cmluZygwLCBvZmZzZXQpLFxyXG4gICAgc3VmZml4ID0gY3VydGV4dC5zdWJzdHJpbmcob2Zmc2V0KTtcclxuICAgIHRoaXMuZGF0YSA9IHByZWZpeCArIGRhdGEgKyBzdWZmaXg7XHJcbiAgfX0sXHJcblxyXG5cclxuICAvLyB2b2lkIGRlbGV0ZURhdGEodW5zaWduZWQgbG9uZyBvZmZzZXQsIHVuc2lnbmVkIGxvbmcgY291bnQpO1xyXG4gIC8vIFRoZSBkZWxldGVEYXRhKG9mZnNldCwgY291bnQpIG1ldGhvZCBtdXN0IHJ1biB0aGVzZSBzdGVwczpcclxuICAvL1xyXG4gIC8vICAgICBJZiBvZmZzZXQgaXMgZ3JlYXRlciB0aGFuIHRoZSBjb250ZXh0IG9iamVjdCdzXHJcbiAgLy8gICAgIGxlbmd0aCwgdGhyb3cgYW4gSU5ERVhfU0laRV9FUlIgZXhjZXB0aW9uIGFuZFxyXG4gIC8vICAgICB0ZXJtaW5hdGUgdGhlc2Ugc3RlcHMuXHJcbiAgLy9cclxuICAvLyAgICAgSWYgb2Zmc2V0K2NvdW50IGlzIGdyZWF0ZXIgdGhhbiB0aGUgY29udGV4dFxyXG4gIC8vICAgICBvYmplY3QncyBsZW5ndGggdmFyIGNvdW50IGJlIGxlbmd0aC1vZmZzZXQuXHJcbiAgLy9cclxuICAvLyAgICAgU3RhcnRpbmcgZnJvbSBvZmZzZXQgVVRGLTE2IGNvZGUgdW5pdHMgcmVtb3ZlIGNvdW50XHJcbiAgLy8gICAgIFVURi0xNiBjb2RlIHVuaXRzIGZyb20gdGhlIGNvbnRleHQgb2JqZWN0J3MgZGF0YS5cclxuICBkZWxldGVEYXRhOiB7IHZhbHVlOiBmdW5jdGlvbiBkZWxldGVEYXRhKG9mZnNldCwgY291bnQpIHtcclxuICAgIHZhciBjdXJ0ZXh0ID0gdGhpcy5kYXRhLCBsZW4gPSBjdXJ0ZXh0Lmxlbmd0aDtcclxuXHJcbiAgICBpZiAob2Zmc2V0ID4gbGVuIHx8IG9mZnNldCA8IDApIHV0aWxzLkluZGV4U2l6ZUVycm9yKCk7XHJcblxyXG4gICAgaWYgKG9mZnNldCtjb3VudCA+IGxlbilcclxuICAgICAgY291bnQgPSBsZW4gLSBvZmZzZXQ7XHJcblxyXG4gICAgdmFyIHByZWZpeCA9IGN1cnRleHQuc3Vic3RyaW5nKDAsIG9mZnNldCksXHJcbiAgICBzdWZmaXggPSBjdXJ0ZXh0LnN1YnN0cmluZyhvZmZzZXQrY291bnQpO1xyXG5cclxuICAgIHRoaXMuZGF0YSA9IHByZWZpeCArIHN1ZmZpeDtcclxuICB9fSxcclxuXHJcblxyXG4gIC8vIHZvaWQgcmVwbGFjZURhdGEodW5zaWduZWQgbG9uZyBvZmZzZXQsIHVuc2lnbmVkIGxvbmcgY291bnQsXHJcbiAgLy8gICAgICAgICAgRE9NU3RyaW5nIGRhdGEpO1xyXG4gIC8vXHJcbiAgLy8gVGhlIHJlcGxhY2VEYXRhKG9mZnNldCwgY291bnQsIGRhdGEpIG1ldGhvZCBtdXN0IGFjdCBhc1xyXG4gIC8vIGlmIHRoZSBkZWxldGVEYXRhKCkgbWV0aG9kIGlzIGludm9rZWQgd2l0aCBvZmZzZXQgYW5kXHJcbiAgLy8gY291bnQgYXMgYXJndW1lbnRzIGZvbGxvd2VkIGJ5IHRoZSBpbnNlcnREYXRhKCkgbWV0aG9kXHJcbiAgLy8gd2l0aCBvZmZzZXQgYW5kIGRhdGEgYXMgYXJndW1lbnRzIGFuZCByZS10aHJvdyBhbnlcclxuICAvLyBleGNlcHRpb25zIHRoZXNlIG1ldGhvZHMgbWlnaHQgaGF2ZSB0aHJvd24uXHJcbiAgcmVwbGFjZURhdGE6IHsgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VEYXRhKG9mZnNldCwgY291bnQsIGRhdGEpIHtcclxuICAgIHZhciBjdXJ0ZXh0ID0gdGhpcy5kYXRhLCBsZW4gPSBjdXJ0ZXh0Lmxlbmd0aDtcclxuXHJcbiAgICBpZiAob2Zmc2V0ID4gbGVuIHx8IG9mZnNldCA8IDApIHV0aWxzLkluZGV4U2l6ZUVycm9yKCk7XHJcblxyXG4gICAgaWYgKG9mZnNldCtjb3VudCA+IGxlbilcclxuICAgICAgY291bnQgPSBsZW4gLSBvZmZzZXQ7XHJcblxyXG4gICAgdmFyIHByZWZpeCA9IGN1cnRleHQuc3Vic3RyaW5nKDAsIG9mZnNldCksXHJcbiAgICBzdWZmaXggPSBjdXJ0ZXh0LnN1YnN0cmluZyhvZmZzZXQrY291bnQpO1xyXG5cclxuICAgIHRoaXMuZGF0YSA9IHByZWZpeCArIGRhdGEgKyBzdWZmaXg7XHJcbiAgfX0sXHJcblxyXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRoYXQgTm9kZS5pc0VxdWFsTm9kZSgpIGNhbGxzIHRvIHRlc3QgVGV4dCBhbmRcclxuICAvLyBDb21tZW50IG5vZGVzIGZvciBlcXVhbGl0eS4gIEl0IGlzIG9rYXkgdG8gcHV0IGl0IGhlcmUsIHNpbmNlXHJcbiAgLy8gTm9kZSB3aWxsIGhhdmUgYWxyZWFkeSB2ZXJpZmllZCB0aGF0IG5vZGVUeXBlIGlzIGVxdWFsXHJcbiAgaXNFcXVhbDogeyB2YWx1ZTogZnVuY3Rpb24gaXNFcXVhbChuKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YSA9PT0gbi5fZGF0YTtcclxuICB9fSxcclxuXHJcbiAgbGVuZ3RoOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRhdGEubGVuZ3RoOyB9fVxyXG5cclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaGFyYWN0ZXJEYXRhLnByb3RvdHlwZSwgQ2hpbGROb2RlKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2hhcmFjdGVyRGF0YS5wcm90b3R5cGUsIE5vbkRvY3VtZW50VHlwZUNoaWxkTm9kZSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kb21pbm8vbGliL0NoYXJhY3RlckRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gRE9NSW1wbGVtZW50YXRpb247XHJcblxyXG52YXIgRG9jdW1lbnQgPSByZXF1aXJlKCcuL0RvY3VtZW50Jyk7XHJcbnZhciBEb2N1bWVudFR5cGUgPSByZXF1aXJlKCcuL0RvY3VtZW50VHlwZScpO1xyXG52YXIgSFRNTFBhcnNlciA9IHJlcXVpcmUoJy4vSFRNTFBhcnNlcicpO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbnZhciB4bWwgPSByZXF1aXJlKCcuL3htbG5hbWVzJyk7XHJcblxyXG4vLyBFYWNoIGRvY3VtZW50IG11c3QgaGF2ZSBpdHMgb3duIGluc3RhbmNlIG9mIHRoZSBkb21pbXBsZW1lbnRhdGlvbiBvYmplY3RcclxuLy8gRXZlbiB0aG91Z2ggdGhlc2Ugb2JqZWN0cyBoYXZlIG5vIHN0YXRlXHJcbmZ1bmN0aW9uIERPTUltcGxlbWVudGF0aW9uKCkge31cclxuXHJcblxyXG4vLyBGZWF0dXJlL3ZlcnNpb24gcGFpcnMgdGhhdCBET01JbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCkgcmV0dXJuc1xyXG4vLyB0cnVlIGZvci4gIEl0IHJldHVybnMgZmFsc2UgZm9yIGFueXRoaW5nIGVsc2UuXHJcbnZhciBzdXBwb3J0ZWRGZWF0dXJlcyA9IHtcclxuICAneG1sJzogeyAnJzogdHJ1ZSwgJzEuMCc6IHRydWUsICcyLjAnOiB0cnVlIH0sICAgLy8gRE9NIENvcmVcclxuICAnY29yZSc6IHsgJyc6IHRydWUsICcyLjAnOiB0cnVlIH0sICAgICAgICAgICAgICAgLy8gRE9NIENvcmVcclxuICAnaHRtbCc6IHsgJyc6IHRydWUsICcxLjAnOiB0cnVlLCAnMi4wJzogdHJ1ZX0gLCAgLy8gSFRNTFxyXG4gICd4aHRtbCc6IHsgJyc6IHRydWUsICcxLjAnOiB0cnVlLCAnMi4wJzogdHJ1ZX0gLCAvLyBIVE1MXHJcbn07XHJcblxyXG5ET01JbXBsZW1lbnRhdGlvbi5wcm90b3R5cGUgPSB7XHJcbiAgaGFzRmVhdHVyZTogZnVuY3Rpb24gaGFzRmVhdHVyZShmZWF0dXJlLCB2ZXJzaW9uKSB7XHJcbiAgICB2YXIgZiA9IHN1cHBvcnRlZEZlYXR1cmVzWyhmZWF0dXJlIHx8ICcnKS50b0xvd2VyQ2FzZSgpXTtcclxuICAgIHJldHVybiAoZiAmJiBmW3ZlcnNpb24gfHwgJyddKSB8fCBmYWxzZTtcclxuICB9LFxyXG5cclxuICBjcmVhdGVEb2N1bWVudFR5cGU6IGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50VHlwZShxdWFsaWZpZWROYW1lLCBwdWJsaWNJZCwgc3lzdGVtSWQpIHtcclxuICAgIGlmICgheG1sLmlzVmFsaWROYW1lKHF1YWxpZmllZE5hbWUpKSB1dGlscy5JbnZhbGlkQ2hhcmFjdGVyRXJyb3IoKTtcclxuICAgIGlmICgheG1sLmlzVmFsaWRRTmFtZShxdWFsaWZpZWROYW1lKSkgdXRpbHMuTmFtZXNwYWNlRXJyb3IoKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IERvY3VtZW50VHlwZShxdWFsaWZpZWROYW1lLCBwdWJsaWNJZCwgc3lzdGVtSWQpO1xyXG4gIH0sXHJcblxyXG4gIGNyZWF0ZURvY3VtZW50OiBmdW5jdGlvbiBjcmVhdGVEb2N1bWVudChuYW1lc3BhY2UsIHF1YWxpZmllZE5hbWUsIGRvY3R5cGUpIHtcclxuICAgIC8vXHJcbiAgICAvLyBOb3RlIHRoYXQgdGhlIGN1cnJlbnQgRE9NQ29yZSBzcGVjIG1ha2VzIGl0IGltcG9zc2libGUgdG9cclxuICAgIC8vIGNyZWF0ZSBhbiBIVE1MIGRvY3VtZW50IHdpdGggdGhpcyBmdW5jdGlvbiwgZXZlbiBpZiB0aGVcclxuICAgIC8vIG5hbWVzcGFjZSBhbmQgZG9jdHlwZSBhcmUgcHJvcGVydGx5IHNldC4gIFNlZSB0aGlzIHRocmVhZDpcclxuICAgIC8vIGh0dHA6Ly9saXN0cy53My5vcmcvQXJjaGl2ZXMvUHVibGljL3d3dy1kb20vMjAxMUFwckp1bi8wMTMyLmh0bWxcclxuICAgIC8vXHJcbiAgICB2YXIgZCA9IG5ldyBEb2N1bWVudChmYWxzZSwgbnVsbCk7XHJcbiAgICB2YXIgZTtcclxuXHJcbiAgICBpZiAocXVhbGlmaWVkTmFtZSlcclxuICAgICAgZSA9IGQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgcXVhbGlmaWVkTmFtZSk7XHJcbiAgICBlbHNlXHJcbiAgICAgIGUgPSBudWxsO1xyXG5cclxuICAgIGlmIChkb2N0eXBlKSB7XHJcbiAgICAgIGlmIChkb2N0eXBlLm93bmVyRG9jdW1lbnQpIHV0aWxzLldyb25nRG9jdW1lbnRFcnJvcigpO1xyXG4gICAgICBkLmFwcGVuZENoaWxkKGRvY3R5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlKSBkLmFwcGVuZENoaWxkKGUpO1xyXG5cclxuICAgIHJldHVybiBkO1xyXG4gIH0sXHJcblxyXG4gIGNyZWF0ZUhUTUxEb2N1bWVudDogZnVuY3Rpb24gY3JlYXRlSFRNTERvY3VtZW50KHRpdGxlVGV4dCkge1xyXG4gICAgdmFyIGQgPSBuZXcgRG9jdW1lbnQodHJ1ZSwgbnVsbCk7XHJcbiAgICBkLmFwcGVuZENoaWxkKG5ldyBEb2N1bWVudFR5cGUoJ2h0bWwnKSk7XHJcbiAgICB2YXIgaHRtbCA9IGQuY3JlYXRlRWxlbWVudCgnaHRtbCcpO1xyXG4gICAgZC5hcHBlbmRDaGlsZChodG1sKTtcclxuICAgIHZhciBoZWFkID0gZC5jcmVhdGVFbGVtZW50KCdoZWFkJyk7XHJcbiAgICBodG1sLmFwcGVuZENoaWxkKGhlYWQpO1xyXG4gICAgdmFyIHRpdGxlID0gZC5jcmVhdGVFbGVtZW50KCd0aXRsZScpO1xyXG4gICAgaGVhZC5hcHBlbmRDaGlsZCh0aXRsZSk7XHJcbiAgICB0aXRsZS5hcHBlbmRDaGlsZChkLmNyZWF0ZVRleHROb2RlKHRpdGxlVGV4dCkpO1xyXG4gICAgaHRtbC5hcHBlbmRDaGlsZChkLmNyZWF0ZUVsZW1lbnQoJ2JvZHknKSk7XHJcbiAgICBkLm1vZGNsb2NrID0gMTsgLy8gU3RhcnQgdHJhY2tpbmcgbW9kaWZpY2F0aW9uc1xyXG4gICAgcmV0dXJuIGQ7XHJcbiAgfSxcclxuXHJcbiAgbW96U2V0T3V0cHV0TXV0YXRpb25IYW5kbGVyOiBmdW5jdGlvbihkb2MsIGhhbmRsZXIpIHtcclxuICAgIGRvYy5tdXRhdGlvbkhhbmRsZXIgPSBoYW5kbGVyO1xyXG4gIH0sXHJcblxyXG4gIG1vekdldElucHV0TXV0YXRpb25IYW5kbGVyOiBmdW5jdGlvbihkb2MpIHtcclxuICAgIHV0aWxzLm55aSgpO1xyXG4gIH0sXHJcblxyXG4gIG1vekhUTUxQYXJzZXI6IEhUTUxQYXJzZXIsXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kb21pbm8vbGliL0RPTUltcGxlbWVudGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgTm9kZUZpbHRlciA9IHtcclxuICAvLyBDb25zdGFudHMgZm9yIGFjY2VwdE5vZGUoKVxyXG4gIEZJTFRFUl9BQ0NFUFQ6IDEsXHJcbiAgRklMVEVSX1JFSkVDVDogMixcclxuICBGSUxURVJfU0tJUDogMyxcclxuXHJcbiAgLy8gQ29uc3RhbnRzIGZvciB3aGF0VG9TaG93XHJcbiAgU0hPV19BTEw6IDB4RkZGRkZGRkYsXHJcbiAgU0hPV19FTEVNRU5UOiAweDEsXHJcbiAgU0hPV19BVFRSSUJVVEU6IDB4MiwgLy8gaGlzdG9yaWNhbFxyXG4gIFNIT1dfVEVYVDogMHg0LFxyXG4gIFNIT1dfQ0RBVEFfU0VDVElPTjogMHg4LCAvLyBoaXN0b3JpY2FsXHJcbiAgU0hPV19FTlRJVFlfUkVGRVJFTkNFOiAweDEwLCAvLyBoaXN0b3JpY2FsXHJcbiAgU0hPV19FTlRJVFk6IDB4MjAsIC8vIGhpc3RvcmljYWxcclxuICBTSE9XX1BST0NFU1NJTkdfSU5TVFJVQ1RJT046IDB4NDAsXHJcbiAgU0hPV19DT01NRU5UOiAweDgwLFxyXG4gIFNIT1dfRE9DVU1FTlQ6IDB4MTAwLFxyXG4gIFNIT1dfRE9DVU1FTlRfVFlQRTogMHgyMDAsXHJcbiAgU0hPV19ET0NVTUVOVF9GUkFHTUVOVDogMHg0MDAsXHJcbiAgU0hPV19OT1RBVElPTjogMHg4MDAgLy8gaGlzdG9yaWNhbFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoTm9kZUZpbHRlci5jb25zdHJ1Y3RvciA9IE5vZGVGaWx0ZXIucHJvdG90eXBlID0gTm9kZUZpbHRlcik7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kb21pbm8vbGliL05vZGVGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gTm9kZUxpc3Q7XHJcblxyXG5mdW5jdGlvbiBpdGVtKGkpIHtcclxuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXHJcbiAgcmV0dXJuIHRoaXNbaV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE5vZGVMaXN0KGEpIHtcclxuICBpZiAoIWEpIGEgPSBbXTtcclxuICBhLml0ZW0gPSBpdGVtO1xyXG4gIHJldHVybiBhO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kb21pbm8vbGliL05vZGVMaXN0LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vYnVuZGxlcy9jb21tb24udW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBwYXJzZXJsaWIgPSByZXF1aXJlKCcuL2Nzc3BhcnNlcicpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDU1NTdHlsZURlY2xhcmF0aW9uO1xyXG5cclxuZnVuY3Rpb24gQ1NTU3R5bGVEZWNsYXJhdGlvbihlbHQpIHtcclxuICB0aGlzLl9lbGVtZW50ID0gZWx0O1xyXG59XHJcblxyXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIGZvciBwYXJzaW5nIHN0eWxlIGRlY2xhcmF0aW9uc1xyXG4vLyBQYXNzIGluIGEgc3RyaW5nIGxpa2UgXCJtYXJnaW4tbGVmdDogNXB4OyBib3JkZXItc3R5bGU6IHNvbGlkXCJcclxuLy8gYW5kIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBvYmplY3QgbGlrZVxyXG4vLyB7XCJtYXJnaW4tbGVmdFwiOlwiNXB4XCIsIFwiYm9yZGVyLXN0eWxlXCI6XCJzb2xpZFwifVxyXG5mdW5jdGlvbiBwYXJzZVN0eWxlcyhzKSB7XHJcbiAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZXJsaWIuY3NzLlBhcnNlcigpO1xyXG4gIHZhciByZXN1bHQgPSB7IHByb3BlcnR5OiBPYmplY3QuY3JlYXRlKG51bGwpLCBwcmlvcml0eTogT2JqZWN0LmNyZWF0ZShudWxsKSB9O1xyXG4gIHBhcnNlci5hZGRMaXN0ZW5lcihcInByb3BlcnR5XCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgIGlmIChlLmludmFsaWQpIHJldHVybjsgLy8gU2tpcCBlcnJvcnNcclxuICAgIHJlc3VsdC5wcm9wZXJ0eVtlLnByb3BlcnR5LnRleHRdID0gZS52YWx1ZS50ZXh0O1xyXG4gICAgaWYgKGUuaW1wb3J0YW50KSByZXN1bHQucHJpb3JpdHlbZS5wcm9wZXJ0eS50ZXh0XSA9ICdpbXBvcnRhbnQnO1xyXG4gIH0pO1xyXG4gIHMgPSAoJycrcykucmVwbGFjZSgvXjsvLCAnJyk7XHJcbiAgcGFyc2VyLnBhcnNlU3R5bGVBdHRyaWJ1dGUocyk7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxudmFyIE5PX0NIQU5HRSA9IHt9OyAvLyBQcml2YXRlIG1hcmtlciBvYmplY3RcclxuXHJcbkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPYmplY3QucHJvdG90eXBlLCB7XHJcblxyXG4gIC8vIFJldHVybiB0aGUgcGFyc2VkIGZvcm0gb2YgdGhlIGVsZW1lbnQncyBzdHlsZSBhdHRyaWJ1dGUuXHJcbiAgLy8gSWYgdGhlIGVsZW1lbnQncyBzdHlsZSBhdHRyaWJ1dGUgaGFzIG5ldmVyIGJlZW4gcGFyc2VkXHJcbiAgLy8gb3IgaWYgaXQgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgcGFyc2UsIHRoZW4gcmVwYXJzZSBpdFxyXG4gIC8vIE5vdGUgdGhhdCB0aGUgc3R5bGVzIGRvbid0IGdldCBwYXJzZWQgdW50aWwgdGhleSdyZSBhY3R1YWxseSBuZWVkZWRcclxuICBfcGFyc2VkOiB7IGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoIXRoaXMuX3BhcnNlZFN0eWxlcyB8fCB0aGlzLmNzc1RleHQgIT09IHRoaXMuX2xhc3RQYXJzZWRUZXh0KSB7XHJcbiAgICAgIHZhciB0ZXh0ID0gdGhpcy5jc3NUZXh0O1xyXG4gICAgICB0aGlzLl9wYXJzZWRTdHlsZXMgPSBwYXJzZVN0eWxlcyh0ZXh0KTtcclxuICAgICAgdGhpcy5fbGFzdFBhcnNlZFRleHQgPSB0ZXh0O1xyXG4gICAgICBkZWxldGUgdGhpcy5fbmFtZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkU3R5bGVzO1xyXG4gIH19LFxyXG5cclxuICAvLyBDYWxsIHRoaXMgbWV0aG9kIGFueSB0aW1lIHRoZSBwYXJzZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlXHJcbiAgLy8gc3R5bGUgY2hhbmdlcy4gIEl0IGNvbnZlcnRzIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIHRvIGEgc3RyaW5nIGFuZFxyXG4gIC8vIHNldHMgY3NzVGV4dCBhbmQgdGhlIGVsZW1lbnQncyBzdHlsZSBhdHRyaWJ1dGVcclxuICBfc2VyaWFsaXplOiB7IHZhbHVlOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzdHlsZXMgPSB0aGlzLl9wYXJzZWQ7XHJcbiAgICB2YXIgcyA9IFwiXCI7XHJcblxyXG4gICAgZm9yKHZhciBuYW1lIGluIHN0eWxlcy5wcm9wZXJ0eSkge1xyXG4gICAgICBpZiAocykgcyArPSBcIiBcIjtcclxuICAgICAgcyArPSBuYW1lICsgXCI6IFwiICsgc3R5bGVzLnByb3BlcnR5W25hbWVdO1xyXG4gICAgICBpZiAoc3R5bGVzLnByaW9yaXR5W25hbWVdKSB7XHJcbiAgICAgICAgcyArPSBcIiAhXCIgKyBzdHlsZXMucHJpb3JpdHlbbmFtZV07XHJcbiAgICAgIH1cclxuICAgICAgcyArPSBcIjtcIjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNzc1RleHQgPSBzOyAgICAgIC8vIGFsc28gc2V0cyB0aGUgc3R5bGUgYXR0cmlidXRlXHJcbiAgICB0aGlzLl9sYXN0UGFyc2VkVGV4dCA9IHM7ICAvLyBzbyB3ZSBkb24ndCByZXBhcnNlXHJcbiAgICBkZWxldGUgdGhpcy5fbmFtZXM7XHJcbiAgfX0sXHJcblxyXG4gIGNzc1RleHQ6IHtcclxuICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIC8vIFhYWDogdGhpcyBpcyBhIENTU1N0eWxlRGVjbGFyYXRpb24gZm9yIGFuIGVsZW1lbnQuXHJcbiAgICAgIC8vIEEgZGlmZmVyZW50IGltcGwgbWlnaHQgYmUgbmVjZXNzYXJ5IGZvciBhIHNldCBvZiBzdHlsZXNcclxuICAgICAgLy8gYXNzb2NpYXRlZCByZXR1cm5lZCBieSBnZXRDb21wdXRlZFN0eWxlKCksIGUuZy5cclxuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAvLyBYWFg6IEkgc2hvdWxkIHBhcnNlIGFuZCBzZXJpYWxpemUgdGhlIHZhbHVlIHRvXHJcbiAgICAgIC8vIG5vcm1hbGl6ZSBpdCBhbmQgcmVtb3ZlIGVycm9ycy4gRkYgYW5kIGNocm9tZSBkbyB0aGF0LlxyXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIHZhbHVlKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBsZW5ndGg6IHsgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgIGlmICghdGhpcy5fbmFtZXMpXHJcbiAgICAgIHRoaXMuX25hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fcGFyc2VkLnByb3BlcnR5KTtcclxuICAgIHJldHVybiB0aGlzLl9uYW1lcy5sZW5ndGg7XHJcbiAgfX0sXHJcblxyXG4gIGl0ZW06IHsgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcclxuICAgIGlmICghdGhpcy5fbmFtZXMpXHJcbiAgICAgIHRoaXMuX25hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fcGFyc2VkLnByb3BlcnR5KTtcclxuICAgIHJldHVybiB0aGlzLl9uYW1lc1tuXTtcclxuICB9fSxcclxuXHJcbiAgZ2V0UHJvcGVydHlWYWx1ZTogeyB2YWx1ZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcclxuICAgIHByb3BlcnR5ID0gcHJvcGVydHkudG9Mb3dlckNhc2UoKTtcclxuICAgIHJldHVybiB0aGlzLl9wYXJzZWQucHJvcGVydHlbcHJvcGVydHldIHx8IFwiXCI7XHJcbiAgfX0sXHJcblxyXG4gIGdldFByb3BlcnR5UHJpb3JpdHk6IHsgdmFsdWU6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XHJcbiAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkLnByaW9yaXR5W3Byb3BlcnR5XSB8fCBcIlwiO1xyXG4gIH19LFxyXG5cclxuICBzZXRQcm9wZXJ0eTogeyB2YWx1ZTogZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlLCBwcmlvcml0eSkge1xyXG4gICAgcHJvcGVydHkgPSBwcm9wZXJ0eS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdmFsdWUgPSBcIlwiO1xyXG4gICAgfVxyXG4gICAgaWYgKHByaW9yaXR5ID09PSBudWxsIHx8IHByaW9yaXR5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcHJpb3JpdHkgPSBcIlwiO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0cmluZyBjb2VyY2lvblxyXG4gICAgaWYgKHZhbHVlICE9PSBOT19DSEFOR0UpIHtcclxuICAgICAgdmFsdWUgPSBcIlwiICsgdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlUHJvcGVydHkocHJvcGVydHkpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByaW9yaXR5ICE9PSBcIlwiICYmIHByaW9yaXR5ICE9PSBOT19DSEFOR0UgJiZcclxuICAgICAgICAhL15pbXBvcnRhbnQkL2kudGVzdChwcmlvcml0eSkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzdHlsZXMgPSB0aGlzLl9wYXJzZWQ7XHJcbiAgICBpZiAodmFsdWUgPT09IE5PX0NIQU5HRSkge1xyXG4gICAgICBpZiAoIXN0eWxlcy5wcm9wZXJ0eVtwcm9wZXJ0eV0pIHtcclxuICAgICAgICByZXR1cm47IC8vIE5vdCBhIHZhbGlkIHByb3BlcnR5IG5hbWUuXHJcbiAgICAgIH1cclxuICAgICAgaWYgKHByaW9yaXR5ICE9PSBcIlwiKSB7XHJcbiAgICAgICAgc3R5bGVzLnByaW9yaXR5W3Byb3BlcnR5XSA9IFwiaW1wb3J0YW50XCI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGVsZXRlIHN0eWxlcy5wcmlvcml0eVtwcm9wZXJ0eV07XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFdlIGRvbid0IGp1c3QgYWNjZXB0IHRoZSBwcm9wZXJ0eSB2YWx1ZS4gIEluc3RlYWRcclxuICAgICAgLy8gd2UgcGFyc2UgaXQgdG8gZW5zdXJlIHRoYXQgaXQgaXMgc29tZXRoaW5nIHZhbGlkLlxyXG4gICAgICAvLyBJZiBpdCBjb250YWlucyBhIHNlbWljb2xvbiBpdCBpcyBpbnZhbGlkXHJcbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKFwiO1wiKSAhPT0gLTEpIHJldHVybjtcclxuXHJcbiAgICAgIHZhciBuZXdwcm9wcyA9IHBhcnNlU3R5bGVzKHByb3BlcnR5ICsgXCI6XCIgKyB2YWx1ZSk7XHJcbiAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuZXdwcm9wcy5wcm9wZXJ0eSkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuOyAvLyBubyB2YWxpZCBwcm9wZXJ0eSBmb3VuZFxyXG4gICAgICB9XHJcbiAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuZXdwcm9wcy5wcmlvcml0eSkubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuOyAvLyBpZiB0aGUgdmFsdWUgaW5jbHVkZWQgJyFpbXBvcnRhbnQnIGl0IHdhc24ndCB2YWxpZC5cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gWFhYIGhhbmRsZSBzaG9ydGhhbmQgcHJvcGVydGllc1xyXG5cclxuICAgICAgZm9yICh2YXIgcCBpbiBuZXdwcm9wcy5wcm9wZXJ0eSkge1xyXG4gICAgICAgIHN0eWxlcy5wcm9wZXJ0eVtwXSA9IG5ld3Byb3BzLnByb3BlcnR5W3BdO1xyXG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gTk9fQ0hBTkdFKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHByaW9yaXR5ICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICBzdHlsZXMucHJpb3JpdHlbcF0gPSBcImltcG9ydGFudFwiO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGVzLnByaW9yaXR5W3BdKSB7XHJcbiAgICAgICAgICBkZWxldGUgc3R5bGVzLnByaW9yaXR5W3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNlcmlhbGl6ZSBhbmQgdXBkYXRlIGNzc1RleHQgYW5kIGVsZW1lbnQuc3R5bGUhXHJcbiAgICB0aGlzLl9zZXJpYWxpemUoKTtcclxuICB9fSxcclxuXHJcbiAgc2V0UHJvcGVydHlWYWx1ZTogeyB2YWx1ZTogZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIE5PX0NIQU5HRSk7XHJcbiAgfX0sXHJcblxyXG4gIHNldFByb3BlcnR5UHJpb3JpdHk6IHsgdmFsdWU6IGZ1bmN0aW9uKHByb3BlcnR5LCBwcmlvcml0eSkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0UHJvcGVydHkocHJvcGVydHksIE5PX0NIQU5HRSwgcHJpb3JpdHkpO1xyXG4gIH19LFxyXG5cclxuICByZW1vdmVQcm9wZXJ0eTogeyB2YWx1ZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcclxuICAgIHByb3BlcnR5ID0gcHJvcGVydHkudG9Mb3dlckNhc2UoKTtcclxuICAgIHZhciBzdHlsZXMgPSB0aGlzLl9wYXJzZWQ7XHJcbiAgICBpZiAocHJvcGVydHkgaW4gc3R5bGVzLnByb3BlcnR5KSB7XHJcbiAgICAgIGRlbGV0ZSBzdHlsZXMucHJvcGVydHlbcHJvcGVydHldO1xyXG4gICAgICBkZWxldGUgc3R5bGVzLnByaW9yaXR5W3Byb3BlcnR5XTtcclxuXHJcbiAgICAgIC8vIFNlcmlhbGl6ZSBhbmQgdXBkYXRlIGNzc1RleHQgYW5kIGVsZW1lbnQuc3R5bGUhXHJcbiAgICAgIHRoaXMuX3NlcmlhbGl6ZSgpO1xyXG4gICAgfVxyXG4gIH19LFxyXG59KTtcclxuXHJcbnZhciBjc3NQcm9wZXJ0aWVzID0ge1xyXG4gIGJhY2tncm91bmQ6IFwiYmFja2dyb3VuZFwiLFxyXG4gIGJhY2tncm91bmRBdHRhY2htZW50OiBcImJhY2tncm91bmQtYXR0YWNobWVudFwiLFxyXG4gIGJhY2tncm91bmRDb2xvcjogXCJiYWNrZ3JvdW5kLWNvbG9yXCIsXHJcbiAgYmFja2dyb3VuZEltYWdlOiBcImJhY2tncm91bmQtaW1hZ2VcIixcclxuICBiYWNrZ3JvdW5kUG9zaXRpb246IFwiYmFja2dyb3VuZC1wb3NpdGlvblwiLFxyXG4gIGJhY2tncm91bmRSZXBlYXQ6IFwiYmFja2dyb3VuZC1yZXBlYXRcIixcclxuICBib3JkZXI6IFwiYm9yZGVyXCIsXHJcbiAgYm9yZGVyQ29sbGFwc2U6IFwiYm9yZGVyLWNvbGxhcHNlXCIsXHJcbiAgYm9yZGVyQ29sb3I6IFwiYm9yZGVyLWNvbG9yXCIsXHJcbiAgYm9yZGVyU3BhY2luZzogXCJib3JkZXItc3BhY2luZ1wiLFxyXG4gIGJvcmRlclN0eWxlOiBcImJvcmRlci1zdHlsZVwiLFxyXG4gIGJvcmRlclRvcDogXCJib3JkZXItdG9wXCIsXHJcbiAgYm9yZGVyUmlnaHQ6IFwiYm9yZGVyLXJpZ2h0XCIsXHJcbiAgYm9yZGVyQm90dG9tOiBcImJvcmRlci1ib3R0b21cIixcclxuICBib3JkZXJMZWZ0OiBcImJvcmRlci1sZWZ0XCIsXHJcbiAgYm9yZGVyVG9wQ29sb3I6IFwiYm9yZGVyLXRvcC1jb2xvclwiLFxyXG4gIGJvcmRlclJpZ2h0Q29sb3I6IFwiYm9yZGVyLXJpZ2h0LWNvbG9yXCIsXHJcbiAgYm9yZGVyQm90dG9tQ29sb3I6IFwiYm9yZGVyLWJvdHRvbS1jb2xvclwiLFxyXG4gIGJvcmRlckxlZnRDb2xvcjogXCJib3JkZXItbGVmdC1jb2xvclwiLFxyXG4gIGJvcmRlclRvcFN0eWxlOiBcImJvcmRlci10b3Atc3R5bGVcIixcclxuICBib3JkZXJSaWdodFN0eWxlOiBcImJvcmRlci1yaWdodC1zdHlsZVwiLFxyXG4gIGJvcmRlckJvdHRvbVN0eWxlOiBcImJvcmRlci1ib3R0b20tc3R5bGVcIixcclxuICBib3JkZXJMZWZ0U3R5bGU6IFwiYm9yZGVyLWxlZnQtc3R5bGVcIixcclxuICBib3JkZXJUb3BXaWR0aDogXCJib3JkZXItdG9wLXdpZHRoXCIsXHJcbiAgYm9yZGVyUmlnaHRXaWR0aDogXCJib3JkZXItcmlnaHQtd2lkdGhcIixcclxuICBib3JkZXJCb3R0b21XaWR0aDogXCJib3JkZXItYm90dG9tLXdpZHRoXCIsXHJcbiAgYm9yZGVyTGVmdFdpZHRoOiBcImJvcmRlci1sZWZ0LXdpZHRoXCIsXHJcbiAgYm9yZGVyV2lkdGg6IFwiYm9yZGVyLXdpZHRoXCIsXHJcbiAgYm90dG9tOiBcImJvdHRvbVwiLFxyXG4gIGNhcHRpb25TaWRlOiBcImNhcHRpb24tc2lkZVwiLFxyXG4gIGNsZWFyOiBcImNsZWFyXCIsXHJcbiAgY2xpcDogXCJjbGlwXCIsXHJcbiAgY29sb3I6IFwiY29sb3JcIixcclxuICBjb250ZW50OiBcImNvbnRlbnRcIixcclxuICBjb3VudGVySW5jcmVtZW50OiBcImNvdW50ZXItaW5jcmVtZW50XCIsXHJcbiAgY291bnRlclJlc2V0OiBcImNvdW50ZXItcmVzZXRcIixcclxuICBjdXJzb3I6IFwiY3Vyc29yXCIsXHJcbiAgZGlyZWN0aW9uOiBcImRpcmVjdGlvblwiLFxyXG4gIGRpc3BsYXk6IFwiZGlzcGxheVwiLFxyXG4gIGVtcHR5Q2VsbHM6IFwiZW1wdHktY2VsbHNcIixcclxuICBjc3NGbG9hdDogXCJmbG9hdFwiLFxyXG4gIGZvbnQ6IFwiZm9udFwiLFxyXG4gIGZvbnRGYW1pbHk6IFwiZm9udC1mYW1pbHlcIixcclxuICBmb250U2l6ZTogXCJmb250LXNpemVcIixcclxuICBmb250U2l6ZUFkanVzdDogXCJmb250LXNpemUtYWRqdXN0XCIsXHJcbiAgZm9udFN0cmV0Y2g6IFwiZm9udC1zdHJldGNoXCIsXHJcbiAgZm9udFN0eWxlOiBcImZvbnQtc3R5bGVcIixcclxuICBmb250VmFyaWFudDogXCJmb250LXZhcmlhbnRcIixcclxuICBmb250V2VpZ2h0OiBcImZvbnQtd2VpZ2h0XCIsXHJcbiAgaGVpZ2h0OiBcImhlaWdodFwiLFxyXG4gIGxlZnQ6IFwibGVmdFwiLFxyXG4gIGxldHRlclNwYWNpbmc6IFwibGV0dGVyLXNwYWNpbmdcIixcclxuICBsaW5lSGVpZ2h0OiBcImxpbmUtaGVpZ2h0XCIsXHJcbiAgbGlzdFN0eWxlOiBcImxpc3Qtc3R5bGVcIixcclxuICBsaXN0U3R5bGVJbWFnZTogXCJsaXN0LXN0eWxlLWltYWdlXCIsXHJcbiAgbGlzdFN0eWxlUG9zaXRpb246IFwibGlzdC1zdHlsZS1wb3NpdGlvblwiLFxyXG4gIGxpc3RTdHlsZVR5cGU6IFwibGlzdC1zdHlsZS10eXBlXCIsXHJcbiAgbWFyZ2luOiBcIm1hcmdpblwiLFxyXG4gIG1hcmdpblRvcDogXCJtYXJnaW4tdG9wXCIsXHJcbiAgbWFyZ2luUmlnaHQ6IFwibWFyZ2luLXJpZ2h0XCIsXHJcbiAgbWFyZ2luQm90dG9tOiBcIm1hcmdpbi1ib3R0b21cIixcclxuICBtYXJnaW5MZWZ0OiBcIm1hcmdpbi1sZWZ0XCIsXHJcbiAgbWFya2VyT2Zmc2V0OiBcIm1hcmtlci1vZmZzZXRcIixcclxuICBtYXJrczogXCJtYXJrc1wiLFxyXG4gIG1heEhlaWdodDogXCJtYXgtaGVpZ2h0XCIsXHJcbiAgbWF4V2lkdGg6IFwibWF4LXdpZHRoXCIsXHJcbiAgbWluSGVpZ2h0OiBcIm1pbi1oZWlnaHRcIixcclxuICBtaW5XaWR0aDogXCJtaW4td2lkdGhcIixcclxuICBvcGFjaXR5OiBcIm9wYWNpdHlcIixcclxuICBvcnBoYW5zOiBcIm9ycGhhbnNcIixcclxuICBvdXRsaW5lOiBcIm91dGxpbmVcIixcclxuICBvdXRsaW5lQ29sb3I6IFwib3V0bGluZS1jb2xvclwiLFxyXG4gIG91dGxpbmVTdHlsZTogXCJvdXRsaW5lLXN0eWxlXCIsXHJcbiAgb3V0bGluZVdpZHRoOiBcIm91dGxpbmUtd2lkdGhcIixcclxuICBvdmVyZmxvdzogXCJvdmVyZmxvd1wiLFxyXG4gIHBhZGRpbmc6IFwicGFkZGluZ1wiLFxyXG4gIHBhZGRpbmdUb3A6IFwicGFkZGluZy10b3BcIixcclxuICBwYWRkaW5nUmlnaHQ6IFwicGFkZGluZy1yaWdodFwiLFxyXG4gIHBhZGRpbmdCb3R0b206IFwicGFkZGluZy1ib3R0b21cIixcclxuICBwYWRkaW5nTGVmdDogXCJwYWRkaW5nLWxlZnRcIixcclxuICBwYWdlOiBcInBhZ2VcIixcclxuICBwYWdlQnJlYWtBZnRlcjogXCJwYWdlLWJyZWFrLWFmdGVyXCIsXHJcbiAgcGFnZUJyZWFrQmVmb3JlOiBcInBhZ2UtYnJlYWstYmVmb3JlXCIsXHJcbiAgcGFnZUJyZWFrSW5zaWRlOiBcInBhZ2UtYnJlYWstaW5zaWRlXCIsXHJcbiAgcG9zaXRpb246IFwicG9zaXRpb25cIixcclxuICBxdW90ZXM6IFwicXVvdGVzXCIsXHJcbiAgcmlnaHQ6IFwicmlnaHRcIixcclxuICBzaXplOiBcInNpemVcIixcclxuICB0YWJsZUxheW91dDogXCJ0YWJsZS1sYXlvdXRcIixcclxuICB0ZXh0QWxpZ246IFwidGV4dC1hbGlnblwiLFxyXG4gIHRleHREZWNvcmF0aW9uOiBcInRleHQtZGVjb3JhdGlvblwiLFxyXG4gIHRleHRJbmRlbnQ6IFwidGV4dC1pbmRlbnRcIixcclxuICB0ZXh0U2hhZG93OiBcInRleHQtc2hhZG93XCIsXHJcbiAgdGV4dFRyYW5zZm9ybTogXCJ0ZXh0LXRyYW5zZm9ybVwiLFxyXG4gIHRvcDogXCJ0b3BcIixcclxuICB1bmljb2RlQmlkaTogXCJ1bmljb2RlLWJpZGlcIixcclxuICB2ZXJ0aWNhbEFsaWduOiBcInZlcnRpY2FsLWFsaWduXCIsXHJcbiAgdmlzaWJpbGl0eTogXCJ2aXNpYmlsaXR5XCIsXHJcbiAgd2hpdGVTcGFjZTogXCJ3aGl0ZS1zcGFjZVwiLFxyXG4gIHdpZG93czogXCJ3aWRvd3NcIixcclxuICB3aWR0aDogXCJ3aWR0aFwiLFxyXG4gIHdvcmRTcGFjaW5nOiBcIndvcmQtc3BhY2luZ1wiLFxyXG4gIHpJbmRleDogXCJ6LWluZGV4XCIsXHJcbn07XHJcblxyXG5mb3IodmFyIHByb3AgaW4gY3NzUHJvcGVydGllcykgZGVmaW5lU3R5bGVQcm9wZXJ0eShwcm9wKTtcclxuXHJcbmZ1bmN0aW9uIGRlZmluZVN0eWxlUHJvcGVydHkoanNuYW1lKSB7XHJcbiAgdmFyIGNzc25hbWUgPSBjc3NQcm9wZXJ0aWVzW2pzbmFtZV07XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLCBqc25hbWUsIHtcclxuICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldFByb3BlcnR5VmFsdWUoY3NzbmFtZSk7XHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICB0aGlzLnNldFByb3BlcnR5KGNzc25hbWUsIHZhbHVlKTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZG9taW5vL2xpYi9DU1NTdHlsZURlY2xhcmF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XHJcblxyXG52YXIgY3JlYXRlRG9jdW1lbnRGcmFnbWVudEZyb21Bcmd1bWVudHMgPSBmdW5jdGlvbihkb2N1bWVudCwgYXJncykge1xyXG4gIHZhciBkb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG5cclxuICBmb3IgKHZhciBpPTA7IGk8YXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGFyZ0l0ZW0gPSBhcmdzW2ldO1xyXG4gICAgdmFyIGlzTm9kZSA9IGFyZ0l0ZW0gaW5zdGFuY2VvZiBOb2RlO1xyXG4gICAgZG9jRnJhZy5hcHBlbmRDaGlsZChpc05vZGUgPyBhcmdJdGVtIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGFyZ0l0ZW0pKSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZG9jRnJhZztcclxufTtcclxuXHJcbi8vIFRoZSBDaGlsZE5vZGUgaW50ZXJmYWNlIGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBhcmUgcGFydGljdWxhciB0byBgTm9kZWBcclxuLy8gb2JqZWN0cyB0aGF0IGNhbiBoYXZlIGEgcGFyZW50LiAgSXQgaXMgaW1wbGVtZW50ZWQgYnkgYEVsZW1lbnRgLFxyXG4vLyBgRG9jdW1lbnRUeXBlYCwgYW5kIGBDaGFyYWN0ZXJEYXRhYCBvYmplY3RzLlxyXG52YXIgQ2hpbGROb2RlID0ge1xyXG5cclxuICAvLyBJbnNlcnRzIGEgc2V0IG9mIE5vZGUgb3IgU3RyaW5nIG9iamVjdHMgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgb2YgdGhpc1xyXG4gIC8vIENoaWxkTm9kZSdzIHBhcmVudCwganVzdCBhZnRlciB0aGlzIENoaWxkTm9kZS4gIFN0cmluZyBvYmplY3RzIGFyZVxyXG4gIC8vIGluc2VydGVkIGFzIHRoZSBlcXVpdmFsZW50IFRleHQgbm9kZXMuXHJcbiAgYWZ0ZXI6IHsgdmFsdWU6IGZ1bmN0aW9uIGFmdGVyKCkge1xyXG4gICAgdmFyIGFyZ0FyciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZSwgbmV4dFNpYmxpbmcgPSB0aGlzLm5leHRTaWJsaW5nO1xyXG4gICAgaWYgKHBhcmVudE5vZGUgPT09IG51bGwpIHsgcmV0dXJuOyB9XHJcbiAgICAvLyBGaW5kIFwidmlhYmxlIG5leHQgc2libGluZ1wiOyB0aGF0IGlzLCBuZXh0IG9uZSBub3QgaW4gYXJnQXJyXHJcbiAgICB3aGlsZSAobmV4dFNpYmxpbmcgJiYgYXJnQXJyLnNvbWUoZnVuY3Rpb24odikgeyByZXR1cm4gdj09PW5leHRTaWJsaW5nOyB9KSlcclxuICAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5uZXh0U2libGluZztcclxuICAgIC8vIG9rLCBwYXJlbnQgYW5kIHNpYmxpbmcgYXJlIHNhdmVkIGF3YXkgc2luY2UgdGhpcyBub2RlIGNvdWxkIGl0c2VsZlxyXG4gICAgLy8gYXBwZWFyIGluIGFyZ0FyciBhbmQgd2UncmUgYWJvdXQgdG8gbW92ZSBhcmdBcnIgdG8gYSBkb2N1bWVudCBmcmFnbWVudC5cclxuICAgIHZhciBkb2NGcmFnID0gY3JlYXRlRG9jdW1lbnRGcmFnbWVudEZyb21Bcmd1bWVudHModGhpcy5kb2MsIGFyZ0Fycik7XHJcblxyXG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZG9jRnJhZywgbmV4dFNpYmxpbmcpO1xyXG4gIH19LFxyXG5cclxuICAvLyBJbnNlcnRzIGEgc2V0IG9mIE5vZGUgb3IgU3RyaW5nIG9iamVjdHMgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgb2YgdGhpc1xyXG4gIC8vIENoaWxkTm9kZSdzIHBhcmVudCwganVzdCBiZWZvcmUgdGhpcyBDaGlsZE5vZGUuICBTdHJpbmcgb2JqZWN0cyBhcmVcclxuICAvLyBpbnNlcnRlZCBhcyB0aGUgZXF1aXZhbGVudCBUZXh0IG5vZGVzLlxyXG4gIGJlZm9yZTogeyB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlKCkge1xyXG4gICAgdmFyIGFyZ0FyciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZSwgcHJldlNpYmxpbmcgPSB0aGlzLnByZXZpb3VzU2libGluZztcclxuICAgIGlmIChwYXJlbnROb2RlID09PSBudWxsKSB7IHJldHVybjsgfVxyXG4gICAgLy8gRmluZCBcInZpYWJsZSBwcmV2IHNpYmxpbmdcIjsgdGhhdCBpcywgcHJldiBvbmUgbm90IGluIGFyZ0FyclxyXG4gICAgd2hpbGUgKHByZXZTaWJsaW5nICYmIGFyZ0Fyci5zb21lKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHY9PT1wcmV2U2libGluZzsgfSkpXHJcbiAgICAgIHByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcucHJldmlvdXNTaWJsaW5nO1xyXG4gICAgLy8gb2ssIHBhcmVudCBhbmQgc2libGluZyBhcmUgc2F2ZWQgYXdheSBzaW5jZSB0aGlzIG5vZGUgY291bGQgaXRzZWxmXHJcbiAgICAvLyBhcHBlYXIgaW4gYXJnQXJyIGFuZCB3ZSdyZSBhYm91dCB0byBtb3ZlIGFyZ0FyciB0byBhIGRvY3VtZW50IGZyYWdtZW50LlxyXG4gICAgdmFyIGRvY0ZyYWcgPSBjcmVhdGVEb2N1bWVudEZyYWdtZW50RnJvbUFyZ3VtZW50cyh0aGlzLmRvYywgYXJnQXJyKTtcclxuXHJcbiAgICB2YXIgbmV4dFNpYmxpbmcgPVxyXG4gICAgICAgIHByZXZTaWJsaW5nID8gcHJldlNpYmxpbmcubmV4dFNpYmxpbmcgOiBwYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XHJcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShkb2NGcmFnLCBuZXh0U2libGluZyk7XHJcbiAgfX0sXHJcblxyXG4gIC8vIFJlbW92ZSB0aGlzIG5vZGUgZnJvbSBpdHMgcGFyZW50XHJcbiAgcmVtb3ZlOiB7IHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XHJcbiAgICBpZiAodGhpcy5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm47XHJcblxyXG4gICAgLy8gU2VuZCBtdXRhdGlvbiBldmVudHMgaWYgbmVjZXNzYXJ5XHJcbiAgICBpZiAodGhpcy5yb290ZWQgJiYgdGhpcy5kb2MpIHRoaXMuZG9jLm11dGF0ZVJlbW92ZSh0aGlzKTtcclxuXHJcbiAgICAvLyBSZW1vdmUgdGhpcyBub2RlIGZyb20gaXRzIHBhcmVudHMgYXJyYXkgb2YgY2hpbGRyZW5cclxuICAgIHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzLnNwbGljZSh0aGlzLmluZGV4LCAxKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIHN0cnVjdHVyZSBpZCBmb3IgYWxsIGFuY2VzdG9yc1xyXG4gICAgdGhpcy5wYXJlbnROb2RlLm1vZGlmeSgpO1xyXG5cclxuICAgIC8vIEZvcmdldCB0aGlzIG5vZGUncyBwYXJlbnRcclxuICAgIHRoaXMucGFyZW50Tm9kZSA9IG51bGw7XHJcbiAgfX0sXHJcblxyXG4gIC8vIFJlcGxhY2UgdGhpcyBub2RlIHdpdGggdGhlIG5vZGVzIG9yIHN0cmluZ3MgcHJvdmlkZWQgYXMgYXJndW1lbnRzLlxyXG4gIHJlcGxhY2VXaXRoOiB7IHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlV2l0aCgpIHtcclxuICAgIHZhciBhcmdBcnIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLnBhcmVudE5vZGUsIG5leHRTaWJsaW5nID0gdGhpcy5uZXh0U2libGluZztcclxuICAgIGlmIChwYXJlbnROb2RlID09PSBudWxsKSB7IHJldHVybjsgfVxyXG4gICAgLy8gRmluZCBcInZpYWJsZSBuZXh0IHNpYmxpbmdcIjsgdGhhdCBpcywgbmV4dCBvbmUgbm90IGluIGFyZ0FyclxyXG4gICAgd2hpbGUgKG5leHRTaWJsaW5nICYmIGFyZ0Fyci5zb21lKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHY9PT1uZXh0U2libGluZzsgfSkpXHJcbiAgICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcubmV4dFNpYmxpbmc7XHJcbiAgICAvLyBvaywgcGFyZW50IGFuZCBzaWJsaW5nIGFyZSBzYXZlZCBhd2F5IHNpbmNlIHRoaXMgbm9kZSBjb3VsZCBpdHNlbGZcclxuICAgIC8vIGFwcGVhciBpbiBhcmdBcnIgYW5kIHdlJ3JlIGFib3V0IHRvIG1vdmUgYXJnQXJyIHRvIGEgZG9jdW1lbnQgZnJhZ21lbnQuXHJcbiAgICB2YXIgZG9jRnJhZyA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnRGcm9tQXJndW1lbnRzKHRoaXMuZG9jLCBhcmdBcnIpO1xyXG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZSA9PT0gcGFyZW50Tm9kZSkge1xyXG4gICAgICBwYXJlbnROb2RlLnJlcGxhY2VDaGlsZChkb2NGcmFnLCB0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGB0aGlzYCB3YXMgaW5zZXJ0ZWQgaW50byBkb2NGcmFnXHJcbiAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRvY0ZyYWcsIG5leHRTaWJsaW5nKTtcclxuICAgIH1cclxuICB9fSxcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENoaWxkTm9kZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvQ2hpbGROb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBEb2N1bWVudDtcclxuXHJcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XHJcbnZhciBOb2RlTGlzdCA9IHJlcXVpcmUoJy4vTm9kZUxpc3QnKTtcclxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuL0VsZW1lbnQnKTtcclxudmFyIFRleHQgPSByZXF1aXJlKCcuL1RleHQnKTtcclxudmFyIENvbW1lbnQgPSByZXF1aXJlKCcuL0NvbW1lbnQnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9FdmVudCcpO1xyXG52YXIgRG9jdW1lbnRGcmFnbWVudCA9IHJlcXVpcmUoJy4vRG9jdW1lbnRGcmFnbWVudCcpO1xyXG52YXIgUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gcmVxdWlyZSgnLi9Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24nKTtcclxudmFyIERPTUltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9ET01JbXBsZW1lbnRhdGlvbicpO1xyXG52YXIgVHJlZVdhbGtlciA9IHJlcXVpcmUoJy4vVHJlZVdhbGtlcicpO1xyXG52YXIgTm9kZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi9Ob2RlSXRlcmF0b3InKTtcclxudmFyIE5vZGVGaWx0ZXIgPSByZXF1aXJlKCcuL05vZGVGaWx0ZXInKTtcclxudmFyIFVSTCA9IHJlcXVpcmUoJy4vVVJMJyk7XHJcbnZhciBzZWxlY3QgPSByZXF1aXJlKCcuL3NlbGVjdCcpO1xyXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnLi9ldmVudHMnKTtcclxudmFyIHhtbCA9IHJlcXVpcmUoJy4veG1sbmFtZXMnKTtcclxudmFyIGh0bWwgPSByZXF1aXJlKCcuL2h0bWxlbHRzJyk7XHJcbnZhciBzdmcgPSByZXF1aXJlKCcuL3N2ZycpO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbnZhciBNVVRBVEUgPSByZXF1aXJlKCcuL011dGF0aW9uQ29uc3RhbnRzJyk7XHJcbnZhciBOQU1FU1BBQ0UgPSB1dGlscy5OQU1FU1BBQ0U7XHJcbnZhciBpc0FwaVdyaXRhYmxlID0gcmVxdWlyZShcIi4vY29uZmlnXCIpLmlzQXBpV3JpdGFibGU7XHJcblxyXG5mdW5jdGlvbiBEb2N1bWVudChpc0hUTUwsIGFkZHJlc3MpIHtcclxuICB0aGlzLm5vZGVUeXBlID0gTm9kZS5ET0NVTUVOVF9OT0RFO1xyXG4gIHRoaXMuaXNIVE1MID0gaXNIVE1MO1xyXG4gIHRoaXMuX2FkZHJlc3MgPSBhZGRyZXNzIHx8ICdhYm91dDpibGFuayc7XHJcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2xvYWRpbmcnO1xyXG4gIHRoaXMuaW1wbGVtZW50YXRpb24gPSBuZXcgRE9NSW1wbGVtZW50YXRpb24oKTtcclxuXHJcbiAgLy8gRE9NQ29yZSBzYXlzIHRoYXQgZG9jdW1lbnRzIGFyZSBhbHdheXMgYXNzb2NpYXRlZCB3aXRoIHRoZW1zZWx2ZXNcclxuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBudWxsOyAvLyAuLi4gYnV0IFczQyB0ZXN0cyBleHBlY3QgbnVsbFxyXG5cclxuICAvLyBUaGVzZSB3aWxsIGJlIGluaXRpYWxpemVkIGJ5IG91ciBjdXN0b20gdmVyc2lvbnMgb2ZcclxuICAvLyBhcHBlbmRDaGlsZCBhbmQgaW5zZXJ0QmVmb3JlIHRoYXQgb3ZlcnJpZGUgdGhlIGluaGVyaXRlZFxyXG4gIC8vIE5vZGUgbWV0aG9kcy5cclxuICAvLyBYWFg6IG92ZXJyaWRlIHRob3NlIG1ldGhvZHMhXHJcbiAgdGhpcy5kb2N0eXBlID0gbnVsbDtcclxuICB0aGlzLmRvY3VtZW50RWxlbWVudCA9IG51bGw7XHJcbiAgdGhpcy5jaGlsZE5vZGVzID0gbmV3IE5vZGVMaXN0KCk7XHJcblxyXG4gIC8vIFwiQXNzb2NpYXRlZCBpbmVydCB0ZW1wbGF0ZSBkb2N1bWVudFwiXHJcbiAgdGhpcy5fdGVtcGxhdGVEb2NDYWNoZSA9IG51bGw7XHJcblxyXG4gIC8vIERvY3VtZW50cyBhcmUgYWx3YXlzIHJvb3RlZCwgYnkgZGVmaW5pdGlvblxyXG4gIHRoaXMuX25pZCA9IDE7XHJcbiAgdGhpcy5fbmV4dG5pZCA9IDI7IC8vIEZvciBudW1iZXJpbmcgY2hpbGRyZW4gb2YgdGhlIGRvY3VtZW50XHJcbiAgdGhpcy5fbm9kZXMgPSBbbnVsbCwgdGhpc107ICAvLyBuaWQgdG8gbm9kZSBtYXBcclxuXHJcbiAgLy8gVGhpcyBtYWludGFpbnMgdGhlIG1hcHBpbmcgZnJvbSBlbGVtZW50IGlkcyB0byBlbGVtZW50IG5vZGVzLlxyXG4gIC8vIFdlIG1heSBuZWVkIHRvIHVwZGF0ZSB0aGlzIG1hcHBpbmcgZXZlcnkgdGltZSBhIG5vZGUgaXMgcm9vdGVkXHJcbiAgLy8gb3IgdXByb290ZWQsIGFuZCBhbnkgdGltZSBhbiBhdHRyaWJ1dGUgaXMgYWRkZWQsIHJlbW92ZWQgb3IgY2hhbmdlZFxyXG4gIC8vIG9uIGEgcm9vdGVkIGVsZW1lbnQuXHJcbiAgdGhpcy5ieUlkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHJcbiAgLy8gVGhpcyBwcm9wZXJ0eSBob2xkcyBhIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyB2YWx1ZSBha2luIHRvXHJcbiAgLy8gYSB0aW1lc3RhbXAgdXNlZCB0byByZWNvcmQgdGhlIGxhc3QgbW9kaWZpY2F0aW9uIHRpbWUgb2Ygbm9kZXNcclxuICAvLyBhbmQgdGhlaXIgc3VidHJlZXMuIFNlZSB0aGUgbGFzdE1vZFRpbWUgYXR0cmlidXRlIGFuZCBtb2RpZnkoKVxyXG4gIC8vIG1ldGhvZCBvZiB0aGUgTm9kZSBjbGFzcy4gQW5kIHNlZSBGaWx0ZXJlZEVsZW1lbnRMaXN0IGZvciBhbiBleGFtcGxlXHJcbiAgLy8gb2YgdGhlIHVzZSBvZiBsYXN0TW9kVGltZVxyXG4gIHRoaXMubW9kY2xvY2sgPSAwO1xyXG59XHJcblxyXG4vLyBNYXAgZnJvbSBsb3dlcmNhc2UgZXZlbnQgY2F0ZWdvcnkgbmFtZXMgKHVzZWQgYXMgYXJndW1lbnRzIHRvXHJcbi8vIGNyZWF0ZUV2ZW50KCkpIHRvIHRoZSBwcm9wZXJ0eSBuYW1lIGluIHRoZSBpbXBsIG9iamVjdCBvZiB0aGVcclxuLy8gZXZlbnQgY29uc3RydWN0b3IuXHJcbnZhciBzdXBwb3J0ZWRFdmVudHMgPSB7XHJcbiAgZXZlbnQ6ICdFdmVudCcsXHJcbiAgY3VzdG9tZXZlbnQ6ICdDdXN0b21FdmVudCcsXHJcbiAgdWlldmVudDogJ1VJRXZlbnQnLFxyXG4gIG1vdXNlZXZlbnQ6ICdNb3VzZUV2ZW50J1xyXG59O1xyXG5cclxuLy8gQ2VydGFpbiBhcmd1bWVudHMgdG8gZG9jdW1lbnQuY3JlYXRlRXZlbnQoKSBtdXN0IGJlIHRyZWF0ZWQgc3BlY2lhbGx5XHJcbnZhciByZXBsYWNlbWVudEV2ZW50ID0ge1xyXG4gIGV2ZW50czogJ2V2ZW50JyxcclxuICBodG1sZXZlbnRzOiAnZXZlbnQnLFxyXG4gIG1vdXNlZXZlbnRzOiAnbW91c2VldmVudCcsXHJcbiAgbXV0YXRpb25ldmVudHM6ICdtdXRhdGlvbmV2ZW50JyxcclxuICB1aWV2ZW50czogJ3VpZXZlbnQnXHJcbn07XHJcblxyXG52YXIgbWlycm9yQXR0ciA9IGZ1bmN0aW9uKGYsIG5hbWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgbyA9IGYuY2FsbCh0aGlzKTtcclxuICAgICAgaWYgKG8pIHsgcmV0dXJuIG9bbmFtZV07IH1cclxuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIHZhciBvID0gZi5jYWxsKHRoaXMpO1xyXG4gICAgICBpZiAobykgeyBvW25hbWVdID0gdmFsdWU7IH1cclxuICAgIH0sXHJcbiAgfTtcclxufTtcclxuXHJcbkRvY3VtZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUsIHtcclxuICAvLyBUaGlzIG1ldGhvZCBhbGxvd3MgZG9tLmpzIHRvIGNvbW11bmljYXRlIHdpdGggYSByZW5kZXJlclxyXG4gIC8vIHRoYXQgZGlzcGxheXMgdGhlIGRvY3VtZW50IGluIHNvbWUgd2F5XHJcbiAgLy8gWFhYOiBJIHNob3VsZCBwcm9iYWJseSBtb3ZlIHRoaXMgdG8gdGhlIHdpbmRvdyBvYmplY3RcclxuICBfc2V0TXV0YXRpb25IYW5kbGVyOiB7IHZhbHVlOiBmdW5jdGlvbihoYW5kbGVyKSB7XHJcbiAgICB0aGlzLm11dGF0aW9uSGFuZGxlciA9IGhhbmRsZXI7XHJcbiAgfX0sXHJcblxyXG4gIC8vIFRoaXMgbWV0aG9kIGFsbG93cyBkb20uanMgdG8gcmVjZWl2ZSBldmVudCBub3RpZmljYXRpb25zXHJcbiAgLy8gZnJvbSB0aGUgcmVuZGVyZXIuXHJcbiAgLy8gWFhYOiBJIHNob3VsZCBwcm9iYWJseSBtb3ZlIHRoaXMgdG8gdGhlIHdpbmRvdyBvYmplY3RcclxuICBfZGlzcGF0Y2hSZW5kZXJlckV2ZW50OiB7IHZhbHVlOiBmdW5jdGlvbih0YXJnZXROaWQsIHR5cGUsIGRldGFpbHMpIHtcclxuICAgIHZhciB0YXJnZXQgPSB0aGlzLl9ub2Rlc1t0YXJnZXROaWRdO1xyXG4gICAgaWYgKCF0YXJnZXQpIHJldHVybjtcclxuICAgIHRhcmdldC5fZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQodHlwZSwgZGV0YWlscyksIHRydWUpO1xyXG4gIH19LFxyXG5cclxuICBub2RlTmFtZTogeyB2YWx1ZTogJyNkb2N1bWVudCd9LFxyXG4gIG5vZGVWYWx1ZToge1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbigpIHt9XHJcbiAgfSxcclxuXHJcbiAgLy8gWFhYOiBET01Db3JlIG1heSByZW1vdmUgZG9jdW1lbnRVUkksIHNvIGl0IGlzIE5ZSSBmb3Igbm93XHJcbiAgZG9jdW1lbnRVUkk6IHsgZ2V0OiB1dGlscy5ueWksIHNldDogdXRpbHMubnlpIH0sXHJcbiAgY29tcGF0TW9kZTogeyBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gVGhlIF9xdWlya3MgcHJvcGVydHkgaXMgc2V0IGJ5IHRoZSBIVE1MIHBhcnNlclxyXG4gICAgcmV0dXJuIHRoaXMuX3F1aXJrcyA/ICdCYWNrQ29tcGF0JyA6ICdDU1MxQ29tcGF0JztcclxuICB9fSxcclxuICBwYXJlbnROb2RlOiB7IHZhbHVlOiBudWxsIH0sXHJcblxyXG4gIGNyZWF0ZVRleHROb2RlOiB7IHZhbHVlOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICByZXR1cm4gbmV3IFRleHQodGhpcywgJycgKyBkYXRhKTtcclxuICB9fSxcclxuICBjcmVhdGVDb21tZW50OiB7IHZhbHVlOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICByZXR1cm4gbmV3IENvbW1lbnQodGhpcywgZGF0YSk7XHJcbiAgfX0sXHJcbiAgY3JlYXRlRG9jdW1lbnRGcmFnbWVudDogeyB2YWx1ZTogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gbmV3IERvY3VtZW50RnJhZ21lbnQodGhpcyk7XHJcbiAgfX0sXHJcbiAgY3JlYXRlUHJvY2Vzc2luZ0luc3RydWN0aW9uOiB7IHZhbHVlOiBmdW5jdGlvbih0YXJnZXQsIGRhdGEpIHtcclxuICAgIGlmICgheG1sLmlzVmFsaWROYW1lKHRhcmdldCkgfHwgZGF0YS5pbmRleE9mKCc/PicpICE9PSAtMSlcclxuICAgICAgdXRpbHMuSW52YWxpZENoYXJhY3RlckVycm9yKCk7XHJcbiAgICByZXR1cm4gbmV3IFByb2Nlc3NpbmdJbnN0cnVjdGlvbih0aGlzLCB0YXJnZXQsIGRhdGEpO1xyXG4gIH19LFxyXG5cclxuICBjcmVhdGVFbGVtZW50OiB7IHZhbHVlOiBmdW5jdGlvbihsb2NhbE5hbWUpIHtcclxuICAgIGlmICgheG1sLmlzVmFsaWROYW1lKGxvY2FsTmFtZSkpIHV0aWxzLkludmFsaWRDaGFyYWN0ZXJFcnJvcigpO1xyXG4gICAgaWYgKHRoaXMuaXNIVE1MKSBsb2NhbE5hbWUgPSB1dGlscy50b0FTQ0lJTG93ZXJDYXNlKGxvY2FsTmFtZSk7XHJcbiAgICByZXR1cm4gaHRtbC5jcmVhdGVFbGVtZW50KHRoaXMsIGxvY2FsTmFtZSwgbnVsbCk7XHJcbiAgfSwgd3JpdGFibGU6IGlzQXBpV3JpdGFibGUgfSxcclxuXHJcbiAgY3JlYXRlRWxlbWVudE5TOiB7IHZhbHVlOiBmdW5jdGlvbihuYW1lc3BhY2UsIHF1YWxpZmllZE5hbWUpIHtcclxuICAgIGlmICgheG1sLmlzVmFsaWROYW1lKHF1YWxpZmllZE5hbWUpKSB1dGlscy5JbnZhbGlkQ2hhcmFjdGVyRXJyb3IoKTtcclxuICAgIGlmICgheG1sLmlzVmFsaWRRTmFtZShxdWFsaWZpZWROYW1lKSkgdXRpbHMuTmFtZXNwYWNlRXJyb3IoKTtcclxuXHJcbiAgICB2YXIgcG9zLCBwcmVmaXgsIGxvY2FsTmFtZTtcclxuICAgIGlmICgocG9zID0gcXVhbGlmaWVkTmFtZS5pbmRleE9mKCc6JykpICE9PSAtMSkge1xyXG4gICAgICBwcmVmaXggPSBxdWFsaWZpZWROYW1lLnN1YnN0cmluZygwLCBwb3MpO1xyXG4gICAgICBsb2NhbE5hbWUgPSBxdWFsaWZpZWROYW1lLnN1YnN0cmluZyhwb3MrMSk7XHJcblxyXG4gICAgICBpZiAobmFtZXNwYWNlID09PSAnJyB8fFxyXG4gICAgICAgIChwcmVmaXggPT09ICd4bWwnICYmIG5hbWVzcGFjZSAhPT0gTkFNRVNQQUNFLlhNTCkpXHJcbiAgICAgICAgdXRpbHMuTmFtZXNwYWNlRXJyb3IoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBwcmVmaXggPSBudWxsO1xyXG4gICAgICBsb2NhbE5hbWUgPSBxdWFsaWZpZWROYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgoKHF1YWxpZmllZE5hbWUgPT09ICd4bWxucycgfHwgcHJlZml4ID09PSAneG1sbnMnKSAmJlxyXG4gICAgICAgbmFtZXNwYWNlICE9PSBOQU1FU1BBQ0UuWE1MTlMpIHx8XHJcbiAgICAgIChuYW1lc3BhY2UgPT09IE5BTUVTUEFDRS5YTUxOUyAmJlxyXG4gICAgICAgcXVhbGlmaWVkTmFtZSAhPT0gJ3htbG5zJyAmJlxyXG4gICAgICAgcHJlZml4ICE9PSAneG1sbnMnKSlcclxuICAgICAgdXRpbHMuTmFtZXNwYWNlRXJyb3IoKTtcclxuXHJcbiAgICBpZiAobmFtZXNwYWNlID09PSBOQU1FU1BBQ0UuSFRNTCkge1xyXG4gICAgICByZXR1cm4gaHRtbC5jcmVhdGVFbGVtZW50KHRoaXMsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5hbWVzcGFjZSA9PT0gTkFNRVNQQUNFLlNWRykge1xyXG4gICAgICByZXR1cm4gc3ZnLmNyZWF0ZUVsZW1lbnQodGhpcywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgRWxlbWVudCh0aGlzLCBsb2NhbE5hbWUsIG5hbWVzcGFjZSwgcHJlZml4KTtcclxuICB9LCB3cml0YWJsZTogaXNBcGlXcml0YWJsZSB9LFxyXG5cclxuICBjcmVhdGVFdmVudDogeyB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRXZlbnQoaW50ZXJmYWNlTmFtZSkge1xyXG4gICAgaW50ZXJmYWNlTmFtZSA9IGludGVyZmFjZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIHZhciBuYW1lID0gcmVwbGFjZW1lbnRFdmVudFtpbnRlcmZhY2VOYW1lXSB8fCBpbnRlcmZhY2VOYW1lO1xyXG4gICAgdmFyIGNvbnN0cnVjdG9yID0gZXZlbnRzW3N1cHBvcnRlZEV2ZW50c1tuYW1lXV07XHJcblxyXG4gICAgaWYgKGNvbnN0cnVjdG9yKSB7XHJcbiAgICAgIHZhciBlID0gbmV3IGNvbnN0cnVjdG9yKCk7XHJcbiAgICAgIGUuX2luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgIHJldHVybiBlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHV0aWxzLk5vdFN1cHBvcnRlZEVycm9yKCk7XHJcbiAgICB9XHJcbiAgfX0sXHJcblxyXG4gIC8vIFNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvZG9tLyNkb20tZG9jdW1lbnQtY3JlYXRldHJlZXdhbGtlclxyXG4gIGNyZWF0ZVRyZWVXYWxrZXI6IHt2YWx1ZTogZnVuY3Rpb24gKHJvb3QsIHdoYXRUb1Nob3csIGZpbHRlcikge1xyXG4gICAgd2hhdFRvU2hvdyA9IHdoYXRUb1Nob3cgPT09IHVuZGVmaW5lZCA/IE5vZGVGaWx0ZXIuU0hPV19BTEwgOiB3aGF0VG9TaG93O1xyXG5cclxuICAgIGlmIChmaWx0ZXIgJiYgdHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICB0eXBlb2YgZmlsdGVyLmFjY2VwdE5vZGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgZmlsdGVyID0gZmlsdGVyLmFjY2VwdE5vZGUuYmluZChmaWx0ZXIpO1xyXG4gICAgICAvLyBTdXBwb3J0IGZpbHRlciBiZWluZyBhIGZ1bmN0aW9uXHJcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL2RvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXJcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXIgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgZmlsdGVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgVHJlZVdhbGtlcihyb290LCB3aGF0VG9TaG93LCBmaWx0ZXIpO1xyXG4gIH19LFxyXG5cclxuICAvLyBTZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jZG9tLWRvY3VtZW50LWNyZWF0ZW5vZGVpdGVyYXRvclxyXG4gIGNyZWF0ZU5vZGVJdGVyYXRvcjoge3ZhbHVlOiBmdW5jdGlvbiAocm9vdCwgd2hhdFRvU2hvdywgZmlsdGVyKSB7XHJcbiAgICB3aGF0VG9TaG93ID0gd2hhdFRvU2hvdyA9PT0gdW5kZWZpbmVkID8gTm9kZUZpbHRlci5TSE9XX0FMTCA6IHdoYXRUb1Nob3c7XHJcblxyXG4gICAgaWYgKGZpbHRlciAmJiB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgIHR5cGVvZiBmaWx0ZXIuYWNjZXB0Tm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBmaWx0ZXIgPSBmaWx0ZXIuYWNjZXB0Tm9kZS5iaW5kKGZpbHRlcik7XHJcbiAgICAgIC8vIFN1cHBvcnQgZmlsdGVyIGJlaW5nIGEgZnVuY3Rpb25cclxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vZG9jdW1lbnQuY3JlYXRlTm9kZUl0ZXJhdG9yXHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZmlsdGVyICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGZpbHRlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IE5vZGVJdGVyYXRvcihyb290LCB3aGF0VG9TaG93LCBmaWx0ZXIpO1xyXG4gIH19LFxyXG5cclxuICAvLyBNYWludGFpbiB0aGUgZG9jdW1lbnRFbGVtZW50IGFuZFxyXG4gIC8vIGRvY3R5cGUgcHJvcGVydGllcyBvZiB0aGUgZG9jdW1lbnQuICBFYWNoIG9mIHRoZSBmb2xsb3dpbmdcclxuICAvLyBtZXRob2RzIGNoYWlucyB0byB0aGUgTm9kZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgbWV0aG9kXHJcbiAgLy8gdG8gZG8gdGhlIGFjdHVhbCBpbnNlcnRpbmcsIHJlbW92YWwgb3IgcmVwbGFjZW1lbnQuXHJcblxyXG4gIF91cGRhdGVEb2NUeXBlRWxlbWVudDogeyB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZURvY1R5cGVFbGVtZW50KCkge1xyXG4gICAgdmFyIGksIG4sIG5vZGVzID0gdGhpcy5jaGlsZE5vZGVzLCBsZW5ndGggPSBub2Rlcy5sZW5ndGg7XHJcbiAgICB0aGlzLmRvY3R5cGUgPSB0aGlzLmRvY3VtZW50RWxlbWVudCA9IG51bGw7XHJcbiAgICBmb3IgKGk9MDsgaTxsZW5ndGg7IGkrKykge1xyXG4gICAgICBuID0gbm9kZXNbaV07XHJcbiAgICAgIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX1RZUEVfTk9ERSlcclxuICAgICAgICB0aGlzLmRvY3R5cGUgPSBuO1xyXG4gICAgICBlbHNlIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSlcclxuICAgICAgICB0aGlzLmRvY3VtZW50RWxlbWVudCA9IG47XHJcbiAgICB9XHJcbiAgfX0sXHJcblxyXG4gIGluc2VydEJlZm9yZTogeyB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKGNoaWxkLCByZWZDaGlsZCkge1xyXG4gICAgTm9kZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlLmNhbGwodGhpcywgY2hpbGQsIHJlZkNoaWxkKTtcclxuICAgIHRoaXMuX3VwZGF0ZURvY1R5cGVFbGVtZW50KCk7XHJcbiAgICByZXR1cm4gY2hpbGQ7XHJcbiAgfX0sXHJcblxyXG4gIHJlcGxhY2VDaGlsZDogeyB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZUNoaWxkKG5vZGUsIGNoaWxkKSB7XHJcbiAgICBOb2RlLnByb3RvdHlwZS5yZXBsYWNlQ2hpbGQuY2FsbCh0aGlzLCBub2RlLCBjaGlsZCk7XHJcbiAgICB0aGlzLl91cGRhdGVEb2NUeXBlRWxlbWVudCgpO1xyXG4gICAgcmV0dXJuIGNoaWxkO1xyXG4gIH19LFxyXG5cclxuICByZW1vdmVDaGlsZDogeyB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcclxuICAgIE5vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkLmNhbGwodGhpcywgY2hpbGQpO1xyXG4gICAgdGhpcy5fdXBkYXRlRG9jVHlwZUVsZW1lbnQoKTtcclxuICAgIHJldHVybiBjaGlsZDtcclxuICB9fSxcclxuXHJcbiAgZ2V0RWxlbWVudEJ5SWQ6IHsgdmFsdWU6IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICB2YXIgbiA9IHRoaXMuYnlJZFtpZF07XHJcbiAgICBpZiAoIW4pIHJldHVybiBudWxsO1xyXG4gICAgaWYgKG4gaW5zdGFuY2VvZiBNdWx0aUlkKSB7IC8vIHRoZXJlIHdhcyBtb3JlIHRoYW4gb25lIGVsZW1lbnQgd2l0aCB0aGlzIGlkXHJcbiAgICAgIHJldHVybiBuLmdldEZpcnN0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbjtcclxuICB9fSxcclxuXHJcbiAgX2hhc011bHRpcGxlRWxlbWVudHNXaXRoSWQ6IHsgdmFsdWU6IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAvLyBVc2VkIGludGVybmFsbHkgYnkgcXVlcnlTZWxlY3RvckFsbCBvcHRpbWl6YXRpb25cclxuICAgIHJldHVybiAodGhpcy5ieUlkW2lkXSBpbnN0YW5jZW9mIE11bHRpSWQpO1xyXG4gIH19LFxyXG5cclxuICAvLyBKdXN0IGNvcHkgdGhpcyBtZXRob2QgZnJvbSB0aGUgRWxlbWVudCBwcm90b3R5cGVcclxuICBnZXRFbGVtZW50c0J5TmFtZTogeyB2YWx1ZTogRWxlbWVudC5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeU5hbWUgfSxcclxuICBnZXRFbGVtZW50c0J5VGFnTmFtZTogeyB2YWx1ZTogRWxlbWVudC5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUgfSxcclxuICBnZXRFbGVtZW50c0J5VGFnTmFtZU5TOiB7IHZhbHVlOiBFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZU5TIH0sXHJcbiAgZ2V0RWxlbWVudHNCeUNsYXNzTmFtZTogeyB2YWx1ZTogRWxlbWVudC5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSB9LFxyXG5cclxuICBhZG9wdE5vZGU6IHsgdmFsdWU6IGZ1bmN0aW9uIGFkb3B0Tm9kZShub2RlKSB7XHJcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB1dGlscy5Ob3RTdXBwb3J0ZWRFcnJvcigpO1xyXG5cclxuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcclxuXHJcbiAgICBpZiAobm9kZS5vd25lckRvY3VtZW50ICE9PSB0aGlzKVxyXG4gICAgICByZWN1cnNpdmVseVNldE93bmVyKG5vZGUsIHRoaXMpO1xyXG5cclxuICAgIHJldHVybiBub2RlO1xyXG4gIH19LFxyXG5cclxuICBpbXBvcnROb2RlOiB7IHZhbHVlOiBmdW5jdGlvbiBpbXBvcnROb2RlKG5vZGUsIGRlZXApIHtcclxuICAgIHJldHVybiB0aGlzLmFkb3B0Tm9kZShub2RlLmNsb25lTm9kZShkZWVwKSk7XHJcbiAgfSwgd3JpdGFibGU6IGlzQXBpV3JpdGFibGUgfSxcclxuXHJcbiAgLy8gVGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzIGFuZCBtZXRob2RzIGFyZSBmcm9tIHRoZSBIVE1MIHNwZWNcclxuICBVUkw6IHsgZ2V0OiB1dGlscy5ueWkgfSxcclxuICBkb21haW46IHsgZ2V0OiB1dGlscy5ueWksIHNldDogdXRpbHMubnlpIH0sXHJcbiAgcmVmZXJyZXI6IHsgZ2V0OiB1dGlscy5ueWkgfSxcclxuICBjb29raWU6IHsgZ2V0OiB1dGlscy5ueWksIHNldDogdXRpbHMubnlpIH0sXHJcbiAgbGFzdE1vZGlmaWVkOiB7IGdldDogdXRpbHMubnlpIH0sXHJcbiAgbG9jYXRpb246IHtcclxuXHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdCAgcmV0dXJuIHRoaXMuZGVmYXVsdFZpZXcgPyB0aGlzLmRlZmF1bHRWaWV3LmxvY2F0aW9uIDogbnVsbDsgLy8gZ2ggIzc1XHJcblx0fSxcclxuXHRzZXQ6IHV0aWxzLm55aVxyXG4gIH0sXHJcbiAgX3RpdGxlRWxlbWVudDoge1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgLy8gVGhlIHRpdGxlIGVsZW1lbnQgb2YgYSBkb2N1bWVudCBpcyB0aGUgZmlyc3QgdGl0bGUgZWxlbWVudCBpbiB0aGVcclxuICAgICAgLy8gZG9jdW1lbnQgaW4gdHJlZSBvcmRlciwgaWYgdGhlcmUgaXMgb25lLCBvciBudWxsIG90aGVyd2lzZS5cclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RpdGxlJykuaXRlbSgwKSB8fCBudWxsO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgdGl0bGU6IHtcclxuICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBlbHQgPSB0aGlzLl90aXRsZUVsZW1lbnQ7XHJcbiAgICAgIC8vIFRoZSBjaGlsZCB0ZXh0IGNvbnRlbnQgb2YgdGhlIHRpdGxlIGVsZW1lbnQsIG9yICcnIGlmIG51bGwuXHJcbiAgICAgIHZhciB2YWx1ZSA9IGVsdCA/IGVsdC50ZXh0Q29udGVudCA6ICcnO1xyXG4gICAgICAvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBpbiB2YWx1ZVxyXG4gICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvWyBcXHRcXG5cXHJcXGZdKy9nLCAnICcpLnRyaW0oKTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIHZhciBlbHQgPSB0aGlzLl90aXRsZUVsZW1lbnQ7XHJcbiAgICAgIHZhciBoZWFkID0gdGhpcy5oZWFkO1xyXG4gICAgICBpZiAoIWVsdCAmJiAhaGVhZCkgeyByZXR1cm47IC8qIGFjY29yZGluZyB0byBzcGVjICovIH1cclxuICAgICAgaWYgKCFlbHQpIHtcclxuICAgICAgICBlbHQgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ3RpdGxlJyk7XHJcbiAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChlbHQpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsdC50ZXh0Q29udGVudCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgZGlyOiBtaXJyb3JBdHRyKGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGh0bWxFbGVtZW50ID0gdGhpcy5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICBpZiAoaHRtbEVsZW1lbnQgJiYgaHRtbEVsZW1lbnQudGFnTmFtZSA9PT0gJ0hUTUwnKSB7IHJldHVybiBodG1sRWxlbWVudDsgfVxyXG4gIH0sICdkaXInLCAnJyksXHJcbiAgZmdDb2xvcjogbWlycm9yQXR0cihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuYm9keTsgfSwgJ3RleHQnLCAnJyksXHJcbiAgbGlua0NvbG9yOiBtaXJyb3JBdHRyKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ib2R5OyB9LCAnbGluaycsICcnKSxcclxuICB2bGlua0NvbG9yOiBtaXJyb3JBdHRyKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ib2R5OyB9LCAndkxpbmsnLCAnJyksXHJcbiAgYWxpbmtDb2xvcjogbWlycm9yQXR0cihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuYm9keTsgfSwgJ2FMaW5rJywgJycpLFxyXG4gIGJnQ29sb3I6IG1pcnJvckF0dHIoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmJvZHk7IH0sICdiZ0NvbG9yJywgJycpLFxyXG5cclxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IDxib2R5PiBjaGlsZCBvZiB0aGUgZG9jdW1lbnQgZWxlbWVudC5cclxuICAvLyBYWFggRm9yIG5vdywgc2V0dGluZyB0aGlzIGF0dHJpYnV0ZSBpcyBub3QgaW1wbGVtZW50ZWQuXHJcbiAgYm9keToge1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIG5hbWVkSFRNTENoaWxkKHRoaXMuZG9jdW1lbnRFbGVtZW50LCAnYm9keScpO1xyXG4gICAgfSxcclxuICAgIHNldDogdXRpbHMubnlpXHJcbiAgfSxcclxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IDxoZWFkPiBjaGlsZCBvZiB0aGUgZG9jdW1lbnQgZWxlbWVudC5cclxuICBoZWFkOiB7IGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gbmFtZWRIVE1MQ2hpbGQodGhpcy5kb2N1bWVudEVsZW1lbnQsICdoZWFkJyk7XHJcbiAgfX0sXHJcbiAgaW1hZ2VzOiB7IGdldDogdXRpbHMubnlpIH0sXHJcbiAgZW1iZWRzOiB7IGdldDogdXRpbHMubnlpIH0sXHJcbiAgcGx1Z2luczogeyBnZXQ6IHV0aWxzLm55aSB9LFxyXG4gIGxpbmtzOiB7IGdldDogdXRpbHMubnlpIH0sXHJcbiAgZm9ybXM6IHsgZ2V0OiB1dGlscy5ueWkgfSxcclxuICBzY3JpcHRzOiB7IGdldDogdXRpbHMubnlpIH0sXHJcbiAgaW5uZXJIVE1MOiB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTsgfSxcclxuICAgIHNldDogdXRpbHMubnlpXHJcbiAgfSxcclxuICBvdXRlckhUTUw6IHtcclxuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpOyB9LFxyXG4gICAgc2V0OiB1dGlscy5ueWlcclxuICB9LFxyXG5cclxuICB3cml0ZTogeyB2YWx1ZTogZnVuY3Rpb24oYXJncykge1xyXG4gICAgaWYgKCF0aGlzLmlzSFRNTCkgdXRpbHMuSW52YWxpZFN0YXRlRXJyb3IoKTtcclxuXHJcbiAgICAvLyBYWFg6IHN0aWxsIGhhdmUgdG8gaW1wbGVtZW50IHRoZSBpZ25vcmUgcGFydFxyXG4gICAgaWYgKCF0aGlzLl9wYXJzZXIgLyogJiYgdGhpcy5faWdub3JlX2Rlc3RydWN0aXZlX3dyaXRlcyA+IDAgKi8gKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgaWYgKCF0aGlzLl9wYXJzZXIpIHtcclxuICAgICAgLy8gWFhYIGNhbGwgZG9jdW1lbnQub3BlbiwgZXRjLlxyXG4gICAgfVxyXG5cclxuICAgIHZhciBzID0gYXJndW1lbnRzLmpvaW4oJycpO1xyXG5cclxuICAgIC8vIElmIHRoZSBEb2N1bWVudCBvYmplY3QncyByZWxvYWQgb3ZlcnJpZGUgZmxhZyBpcyBzZXQsIHRoZW5cclxuICAgIC8vIGFwcGVuZCB0aGUgc3RyaW5nIGNvbnNpc3Rpbmcgb2YgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRoZVxyXG4gICAgLy8gYXJndW1lbnRzIHRvIHRoZSBtZXRob2QgdG8gdGhlIERvY3VtZW50J3MgcmVsb2FkIG92ZXJyaWRlXHJcbiAgICAvLyBidWZmZXIuXHJcbiAgICAvLyBYWFg6IGRvbid0IGtub3cgd2hhdCB0aGlzIGlzIGFib3V0LiAgU3RpbGwgaGF2ZSB0byBkbyBpdFxyXG5cclxuICAgIC8vIElmIHRoZXJlIGlzIG5vIHBlbmRpbmcgcGFyc2luZy1ibG9ja2luZyBzY3JpcHQsIGhhdmUgdGhlXHJcbiAgICAvLyB0b2tlbml6ZXIgcHJvY2VzcyB0aGUgY2hhcmFjdGVycyB0aGF0IHdlcmUgaW5zZXJ0ZWQsIG9uZSBhdCBhXHJcbiAgICAvLyB0aW1lLCBwcm9jZXNzaW5nIHJlc3VsdGluZyB0b2tlbnMgYXMgdGhleSBhcmUgZW1pdHRlZCwgYW5kXHJcbiAgICAvLyBzdG9wcGluZyB3aGVuIHRoZSB0b2tlbml6ZXIgcmVhY2hlcyB0aGUgaW5zZXJ0aW9uIHBvaW50IG9yIHdoZW5cclxuICAgIC8vIHRoZSBwcm9jZXNzaW5nIG9mIHRoZSB0b2tlbml6ZXIgaXMgYWJvcnRlZCBieSB0aGUgdHJlZVxyXG4gICAgLy8gY29uc3RydWN0aW9uIHN0YWdlICh0aGlzIGNhbiBoYXBwZW4gaWYgYSBzY3JpcHQgZW5kIHRhZyB0b2tlbiBpc1xyXG4gICAgLy8gZW1pdHRlZCBieSB0aGUgdG9rZW5pemVyKS5cclxuXHJcbiAgICAvLyBYWFg6IHN0aWxsIGhhdmUgdG8gZG8gdGhlIGFib3ZlLiBTb3VuZHMgYXMgaWYgd2UgZG9uJ3RcclxuICAgIC8vIGFsd2F5cyBjYWxsIHBhcnNlKCkgaGVyZS4gIElmIHdlJ3JlIGJsb2NrZWQsIHRoZW4gd2UganVzdFxyXG4gICAgLy8gaW5zZXJ0IHRoZSB0ZXh0IGludG8gdGhlIHN0cmVhbSBidXQgZG9uJ3QgcGFyc2UgaXQgcmVlbnRyYW50bHkuLi5cclxuXHJcbiAgICAvLyBJbnZva2UgdGhlIHBhcnNlciByZWVudHJhbnRseVxyXG4gICAgdGhpcy5fcGFyc2VyLnBhcnNlKHMpO1xyXG4gIH19LFxyXG5cclxuICB3cml0ZWxuOiB7IHZhbHVlOiBmdW5jdGlvbiB3cml0ZWxuKGFyZ3MpIHtcclxuICAgIHRoaXMud3JpdGUoQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsICcnKSArICdcXG4nKTtcclxuICB9fSxcclxuXHJcbiAgb3BlbjogeyB2YWx1ZTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmRvY3VtZW50RWxlbWVudCA9IG51bGw7XHJcbiAgfX0sXHJcblxyXG4gIGNsb3NlOiB7IHZhbHVlOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjb21wbGV0ZSc7XHJcbiAgICB2YXIgZXYgPSBuZXcgRXZlbnQoJ0RPTUNvbnRlbnRMb2FkZWQnKTtcclxuICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoZXYsIHRydWUpO1xyXG4gICAgaWYgKHRoaXMuZGVmYXVsdFZpZXcpIHtcclxuICAgICAgZXYgPSBuZXcgRXZlbnQoJ2xvYWQnKTtcclxuICAgICAgdGhpcy5kZWZhdWx0Vmlldy5fZGlzcGF0Y2hFdmVudChldiwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgfX0sXHJcblxyXG4gIC8vIFV0aWxpdHkgbWV0aG9kc1xyXG4gIGNsb25lOiB7IHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcclxuICAgIC8vIENhbid0IGNsb25lIGFuIGVudGlyZSBkb2N1bWVudFxyXG4gICAgdXRpbHMuRGF0YUNsb25lRXJyb3IoKTtcclxuICB9fSxcclxuXHJcbiAgaXNFcXVhbDogeyB2YWx1ZTogZnVuY3Rpb24gaXNFcXVhbChuKSB7XHJcbiAgICAvLyBBbnkgdHdvIGRvY3VtZW50cyBhcmUgc2hhbGxvd2x5IGVxdWFsLlxyXG4gICAgLy8gTm9kZS5pc0VxdWFsTm9kZSB3aWxsIGFsc28gdGVzdCB0aGUgY2hpbGRyZW5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH19LFxyXG5cclxuICAvLyBJbXBsZW1lbnRhdGlvbi1zcGVjaWZpYyBmdW5jdGlvbi4gIENhbGxlZCB3aGVuIGEgdGV4dCwgY29tbWVudCxcclxuICAvLyBvciBwaSB2YWx1ZSBjaGFuZ2VzLlxyXG4gIG11dGF0ZVZhbHVlOiB7IHZhbHVlOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICBpZiAodGhpcy5tdXRhdGlvbkhhbmRsZXIpIHtcclxuICAgICAgdGhpcy5tdXRhdGlvbkhhbmRsZXIoe1xyXG4gICAgICAgIHR5cGU6IE1VVEFURS5WQUxVRSxcclxuICAgICAgICB0YXJnZXQ6IG5vZGUsXHJcbiAgICAgICAgZGF0YTogbm9kZS5kYXRhXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH19LFxyXG5cclxuICAvLyBJbnZva2VkIHdoZW4gYW4gYXR0cmlidXRlJ3MgdmFsdWUgY2hhbmdlcy4gQXR0ciBob2xkcyB0aGUgbmV3XHJcbiAgLy8gdmFsdWUuICBvbGR2YWwgaXMgdGhlIG9sZCB2YWx1ZS4gIEF0dHJpYnV0ZSBtdXRhdGlvbnMgY2FuIGFsc29cclxuICAvLyBpbnZvbHZlIGNoYW5nZXMgdG8gdGhlIHByZWZpeCAoYW5kIHRoZXJlZm9yZSB0aGUgcXVhbGlmaWVkIG5hbWUpXHJcbiAgbXV0YXRlQXR0cjogeyB2YWx1ZTogZnVuY3Rpb24oYXR0ciwgb2xkdmFsKSB7XHJcbiAgICAvLyBNYW5hZ2UgaWQtPmVsZW1lbnQgbWFwcGluZyBmb3IgZ2V0RWxlbWVudHNCeUlkKClcclxuICAgIC8vIFhYWDogdGhpcyBzcGVjaWFsIGNhc2UgaWQgaGFuZGxpbmcgc2hvdWxkIG5vdCBnbyBoZXJlLFxyXG4gICAgLy8gYnV0IGluIHRoZSBhdHRyaWJ1dGUgZGVjbGFyYXRpb24gZm9yIHRoZSBpZCBhdHRyaWJ1dGVcclxuICAgIC8qXHJcbiAgICBpZiAoYXR0ci5sb2NhbE5hbWUgPT09ICdpZCcgJiYgYXR0ci5uYW1lc3BhY2VVUkkgPT09IG51bGwpIHtcclxuICAgICAgaWYgKG9sZHZhbCkgZGVsSWQob2xkdmFsLCBhdHRyLm93bmVyRWxlbWVudCk7XHJcbiAgICAgIGFkZElkKGF0dHIudmFsdWUsIGF0dHIub3duZXJFbGVtZW50KTtcclxuICAgIH1cclxuICAgICovXHJcbiAgICBpZiAodGhpcy5tdXRhdGlvbkhhbmRsZXIpIHtcclxuICAgICAgdGhpcy5tdXRhdGlvbkhhbmRsZXIoe1xyXG4gICAgICAgIHR5cGU6IE1VVEFURS5BVFRSLFxyXG4gICAgICAgIHRhcmdldDogYXR0ci5vd25lckVsZW1lbnQsXHJcbiAgICAgICAgYXR0cjogYXR0clxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9fSxcclxuXHJcbiAgLy8gVXNlZCBieSByZW1vdmVBdHRyaWJ1dGUgYW5kIHJlbW92ZUF0dHJpYnV0ZU5TIGZvciBhdHRyaWJ1dGVzLlxyXG4gIG11dGF0ZVJlbW92ZUF0dHI6IHsgdmFsdWU6IGZ1bmN0aW9uKGF0dHIpIHtcclxuLypcclxuKiBUaGlzIGlzIG5vdyBoYW5kbGVkIGluIEF0dHJpYnV0ZXMuanNcclxuICAgIC8vIE1hbmFnZSBpZCB0byBlbGVtZW50IG1hcHBpbmdcclxuICAgIGlmIChhdHRyLmxvY2FsTmFtZSA9PT0gJ2lkJyAmJiBhdHRyLm5hbWVzcGFjZVVSSSA9PT0gbnVsbCkge1xyXG4gICAgICB0aGlzLmRlbElkKGF0dHIudmFsdWUsIGF0dHIub3duZXJFbGVtZW50KTtcclxuICAgIH1cclxuKi9cclxuICAgIGlmICh0aGlzLm11dGF0aW9uSGFuZGxlcikge1xyXG4gICAgICB0aGlzLm11dGF0aW9uSGFuZGxlcih7XHJcbiAgICAgICAgdHlwZTogTVVUQVRFLlJFTU9WRV9BVFRSLFxyXG4gICAgICAgIHRhcmdldDogYXR0ci5vd25lckVsZW1lbnQsXHJcbiAgICAgICAgYXR0cjogYXR0clxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9fSxcclxuXHJcbiAgLy8gQ2FsbGVkIGJ5IE5vZGUucmVtb3ZlQ2hpbGQsIGV0Yy4gdG8gcmVtb3ZlIGEgcm9vdGVkIGVsZW1lbnQgZnJvbVxyXG4gIC8vIHRoZSB0cmVlLiBPbmx5IG5lZWRzIHRvIGdlbmVyYXRlIGEgc2luZ2xlIG11dGF0aW9uIGV2ZW50IHdoZW4gYVxyXG4gIC8vIG5vZGUgaXMgcmVtb3ZlZCwgYnV0IG11c3QgcmVjdXJzaXZlbHkgbWFyayBhbGwgZGVzY2VuZGFudHMgYXMgbm90XHJcbiAgLy8gcm9vdGVkLlxyXG4gIG11dGF0ZVJlbW92ZTogeyB2YWx1ZTogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgLy8gU2VuZCBhIHNpbmdsZSBtdXRhdGlvbiBldmVudFxyXG4gICAgaWYgKHRoaXMubXV0YXRpb25IYW5kbGVyKSB7XHJcbiAgICAgIHRoaXMubXV0YXRpb25IYW5kbGVyKHtcclxuICAgICAgICB0eXBlOiBNVVRBVEUuUkVNT1ZFLFxyXG4gICAgICAgIHRhcmdldDogbm9kZS5wYXJlbnROb2RlLFxyXG4gICAgICAgIG5vZGU6IG5vZGVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFyayB0aGlzIGFuZCBhbGwgZGVzY2VuZGFudHMgYXMgbm90IHJvb3RlZFxyXG4gICAgcmVjdXJzaXZlbHlVcHJvb3Qobm9kZSk7XHJcbiAgfX0sXHJcblxyXG4gIC8vIENhbGxlZCB3aGVuIGEgbmV3IGVsZW1lbnQgYmVjb21lcyByb290ZWQuICBJdCBtdXN0IHJlY3Vyc2l2ZWx5XHJcbiAgLy8gZ2VuZXJhdGUgbXV0YXRpb24gZXZlbnRzIGZvciBlYWNoIG9mIHRoZSBjaGlsZHJlbiwgYW5kIG1hcmsgdGhlbSBhbGxcclxuICAvLyBhcyByb290ZWQuXHJcbiAgbXV0YXRlSW5zZXJ0OiB7IHZhbHVlOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAvLyBNYXJrIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50cyBhcyByb290ZWRcclxuICAgIHJlY3Vyc2l2ZWx5Um9vdChub2RlKTtcclxuXHJcbiAgICAvLyBTZW5kIGEgc2luZ2xlIG11dGF0aW9uIGV2ZW50XHJcbiAgICBpZiAodGhpcy5tdXRhdGlvbkhhbmRsZXIpIHtcclxuICAgICAgdGhpcy5tdXRhdGlvbkhhbmRsZXIoe1xyXG4gICAgICAgIHR5cGU6IE1VVEFURS5JTlNFUlQsXHJcbiAgICAgICAgdGFyZ2V0OiBub2RlLnBhcmVudE5vZGUsXHJcbiAgICAgICAgbm9kZTogbm9kZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9fSxcclxuXHJcbiAgLy8gQ2FsbGVkIHdoZW4gYSByb290ZWQgZWxlbWVudCBpcyBtb3ZlZCB3aXRoaW4gdGhlIGRvY3VtZW50XHJcbiAgbXV0YXRlTW92ZTogeyB2YWx1ZTogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgaWYgKHRoaXMubXV0YXRpb25IYW5kbGVyKSB7XHJcbiAgICAgIHRoaXMubXV0YXRpb25IYW5kbGVyKHtcclxuICAgICAgICB0eXBlOiBNVVRBVEUuTU9WRSxcclxuICAgICAgICB0YXJnZXQ6IG5vZGVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfX0sXHJcblxyXG5cclxuICAvLyBBZGQgYSBtYXBwaW5nIGZyb20gIGlkIHRvIG4gZm9yIG4ub3duZXJEb2N1bWVudFxyXG4gIGFkZElkOiB7IHZhbHVlOiBmdW5jdGlvbiBhZGRJZChpZCwgbikge1xyXG4gICAgdmFyIHZhbCA9IHRoaXMuYnlJZFtpZF07XHJcbiAgICBpZiAoIXZhbCkge1xyXG4gICAgICB0aGlzLmJ5SWRbaWRdID0gbjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAvLyBUT0RPOiBBZGQgYSB3YXkgdG8gb3B0LW91dCBjb25zb2xlIHdhcm5pbmdzXHJcbiAgICAgIC8vY29uc29sZS53YXJuKCdEdXBsaWNhdGUgZWxlbWVudCBpZCAnICsgaWQpO1xyXG4gICAgICBpZiAoISh2YWwgaW5zdGFuY2VvZiBNdWx0aUlkKSkge1xyXG4gICAgICAgIHZhbCA9IG5ldyBNdWx0aUlkKHZhbCk7XHJcbiAgICAgICAgdGhpcy5ieUlkW2lkXSA9IHZhbDtcclxuICAgICAgfVxyXG4gICAgICB2YWwuYWRkKG4pO1xyXG4gICAgfVxyXG4gIH19LFxyXG5cclxuICAvLyBEZWxldGUgdGhlIG1hcHBpbmcgZnJvbSBpZCB0byBuIGZvciBuLm93bmVyRG9jdW1lbnRcclxuICBkZWxJZDogeyB2YWx1ZTogZnVuY3Rpb24gZGVsSWQoaWQsIG4pIHtcclxuICAgIHZhciB2YWwgPSB0aGlzLmJ5SWRbaWRdO1xyXG4gICAgdXRpbHMuYXNzZXJ0KHZhbCk7XHJcblxyXG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIE11bHRpSWQpIHtcclxuICAgICAgdmFsLmRlbChuKTtcclxuICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHsgLy8gY29udmVydCBiYWNrIHRvIGEgc2luZ2xlIG5vZGVcclxuICAgICAgICB0aGlzLmJ5SWRbaWRdID0gdmFsLmRvd25ncmFkZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy5ieUlkW2lkXSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9fSxcclxuXHJcbiAgX3Jlc29sdmU6IHsgdmFsdWU6IGZ1bmN0aW9uKGhyZWYpIHtcclxuICAgIC8vWFhYOiBDYWNoZSB0aGUgVVJMXHJcbiAgICByZXR1cm4gbmV3IFVSTCh0aGlzLl9kb2N1bWVudEJhc2VVUkwpLnJlc29sdmUoaHJlZik7XHJcbiAgfX0sXHJcblxyXG4gIF9kb2N1bWVudEJhc2VVUkw6IHsgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgIC8vIFhYWDogVGhpcyBpcyBub3QgaW1wbGVtZW50ZWQgY29ycmVjdGx5IHlldFxyXG4gICAgdmFyIHVybCA9IHRoaXMuX2FkZHJlc3M7XHJcbiAgICBpZiAodXJsID09PSAnYWJvdXQ6YmxhbmsnKSB1cmwgPSAnLyc7XHJcblxyXG4gICAgdmFyIGJhc2UgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2Jhc2VbaHJlZl0nKTtcclxuICAgIGlmIChiYXNlKSB7XHJcbiAgICAgIHJldHVybiBuZXcgVVJMKHVybCkucmVzb2x2ZShiYXNlLmdldEF0dHJpYnV0ZSgnaHJlZicpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1cmw7XHJcblxyXG4gICAgLy8gVGhlIGRvY3VtZW50IGJhc2UgVVJMIG9mIGEgRG9jdW1lbnQgb2JqZWN0IGlzIHRoZVxyXG4gICAgLy8gYWJzb2x1dGUgVVJMIG9idGFpbmVkIGJ5IHJ1bm5pbmcgdGhlc2Ugc3Vic3RlcHM6XHJcblxyXG4gICAgLy8gICAgIExldCBmYWxsYmFjayBiYXNlIHVybCBiZSB0aGUgZG9jdW1lbnQncyBhZGRyZXNzLlxyXG5cclxuICAgIC8vICAgICBJZiBmYWxsYmFjayBiYXNlIHVybCBpcyBhYm91dDpibGFuaywgYW5kIHRoZVxyXG4gICAgLy8gICAgIERvY3VtZW50J3MgYnJvd3NpbmcgY29udGV4dCBoYXMgYSBjcmVhdG9yIGJyb3dzaW5nXHJcbiAgICAvLyAgICAgY29udGV4dCwgdGhlbiBsZXQgZmFsbGJhY2sgYmFzZSB1cmwgYmUgdGhlIGRvY3VtZW50XHJcbiAgICAvLyAgICAgYmFzZSBVUkwgb2YgdGhlIGNyZWF0b3IgRG9jdW1lbnQgaW5zdGVhZC5cclxuXHJcbiAgICAvLyAgICAgSWYgdGhlIERvY3VtZW50IGlzIGFuIGlmcmFtZSBzcmNkb2MgZG9jdW1lbnQsIHRoZW5cclxuICAgIC8vICAgICBsZXQgZmFsbGJhY2sgYmFzZSB1cmwgYmUgdGhlIGRvY3VtZW50IGJhc2UgVVJMIG9mXHJcbiAgICAvLyAgICAgdGhlIERvY3VtZW50J3MgYnJvd3NpbmcgY29udGV4dCdzIGJyb3dzaW5nIGNvbnRleHRcclxuICAgIC8vICAgICBjb250YWluZXIncyBEb2N1bWVudCBpbnN0ZWFkLlxyXG5cclxuICAgIC8vICAgICBJZiB0aGVyZSBpcyBubyBiYXNlIGVsZW1lbnQgdGhhdCBoYXMgYW4gaHJlZlxyXG4gICAgLy8gICAgIGF0dHJpYnV0ZSwgdGhlbiB0aGUgZG9jdW1lbnQgYmFzZSBVUkwgaXMgZmFsbGJhY2tcclxuICAgIC8vICAgICBiYXNlIHVybDsgYWJvcnQgdGhlc2Ugc3RlcHMuIE90aGVyd2lzZSwgbGV0IHVybCBiZVxyXG4gICAgLy8gICAgIHRoZSB2YWx1ZSBvZiB0aGUgaHJlZiBhdHRyaWJ1dGUgb2YgdGhlIGZpcnN0IHN1Y2hcclxuICAgIC8vICAgICBlbGVtZW50LlxyXG5cclxuICAgIC8vICAgICBSZXNvbHZlIHVybCByZWxhdGl2ZSB0byBmYWxsYmFjayBiYXNlIHVybCAodGh1cyxcclxuICAgIC8vICAgICB0aGUgYmFzZSBocmVmIGF0dHJpYnV0ZSBpc24ndCBhZmZlY3RlZCBieSB4bWw6YmFzZVxyXG4gICAgLy8gICAgIGF0dHJpYnV0ZXMpLlxyXG5cclxuICAgIC8vICAgICBUaGUgZG9jdW1lbnQgYmFzZSBVUkwgaXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXNcclxuICAgIC8vICAgICBzdGVwIGlmIGl0IHdhcyBzdWNjZXNzZnVsOyBvdGhlcndpc2UgaXQgaXMgZmFsbGJhY2tcclxuICAgIC8vICAgICBiYXNlIHVybC5cclxuICB9fSxcclxuXHJcbiAgX3RlbXBsYXRlRG9jOiB7IGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoIXRoaXMuX3RlbXBsYXRlRG9jQ2FjaGUpIHtcclxuICAgICAgLy8gXCJhc3NvY2lhdGVkIGluZXJ0IHRlbXBsYXRlIGRvY3VtZW50XCJcclxuICAgICAgdmFyIG5ld0RvYyA9IG5ldyBEb2N1bWVudCh0aGlzLmlzSFRNTCwgdGhpcy5fYWRkcmVzcyk7XHJcbiAgICAgIHRoaXMuX3RlbXBsYXRlRG9jQ2FjaGUgPSBuZXdEb2MuX3RlbXBsYXRlRG9jQ2FjaGUgPSBuZXdEb2M7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVEb2NDYWNoZTtcclxuICB9fSxcclxuXHJcbiAgcXVlcnlTZWxlY3RvcjogeyB2YWx1ZTogZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICAgIHJldHVybiBzZWxlY3Qoc2VsZWN0b3IsIHRoaXMpWzBdO1xyXG4gIH19LFxyXG5cclxuICBxdWVyeVNlbGVjdG9yQWxsOiB7IHZhbHVlOiBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgdmFyIG5vZGVzID0gc2VsZWN0KHNlbGVjdG9yLCB0aGlzKTtcclxuICAgIHJldHVybiBub2Rlcy5pdGVtID8gbm9kZXMgOiBuZXcgTm9kZUxpc3Qobm9kZXMpO1xyXG4gIH19XHJcblxyXG59KTtcclxuXHJcblxyXG52YXIgZXZlbnRIYW5kbGVyVHlwZXMgPSBbXHJcbiAgJ2Fib3J0JywgJ2NhbnBsYXknLCAnY2FucGxheXRocm91Z2gnLCAnY2hhbmdlJywgJ2NsaWNrJywgJ2NvbnRleHRtZW51JyxcclxuICAnY3VlY2hhbmdlJywgJ2RibGNsaWNrJywgJ2RyYWcnLCAnZHJhZ2VuZCcsICdkcmFnZW50ZXInLCAnZHJhZ2xlYXZlJyxcclxuICAnZHJhZ292ZXInLCAnZHJhZ3N0YXJ0JywgJ2Ryb3AnLCAnZHVyYXRpb25jaGFuZ2UnLCAnZW1wdGllZCcsICdlbmRlZCcsXHJcbiAgJ2lucHV0JywgJ2ludmFsaWQnLCAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCcsICdsb2FkZWRkYXRhJyxcclxuICAnbG9hZGVkbWV0YWRhdGEnLCAnbG9hZHN0YXJ0JywgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2VvdXQnLFxyXG4gICdtb3VzZW92ZXInLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ3BhdXNlJywgJ3BsYXknLCAncGxheWluZycsXHJcbiAgJ3Byb2dyZXNzJywgJ3JhdGVjaGFuZ2UnLCAncmVhZHlzdGF0ZWNoYW5nZScsICdyZXNldCcsICdzZWVrZWQnLFxyXG4gICdzZWVraW5nJywgJ3NlbGVjdCcsICdzaG93JywgJ3N0YWxsZWQnLCAnc3VibWl0JywgJ3N1c3BlbmQnLFxyXG4gICd0aW1ldXBkYXRlJywgJ3ZvbHVtZWNoYW5nZScsICd3YWl0aW5nJyxcclxuXHJcbiAgJ2JsdXInLCAnZXJyb3InLCAnZm9jdXMnLCAnbG9hZCcsICdzY3JvbGwnXHJcbl07XHJcblxyXG4vLyBBZGQgZXZlbnQgaGFuZGxlciBpZGwgYXR0cmlidXRlIGdldHRlcnMgYW5kIHNldHRlcnMgdG8gRG9jdW1lbnRcclxuZXZlbnRIYW5kbGVyVHlwZXMuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XHJcbiAgLy8gRGVmaW5lIHRoZSBldmVudCBoYW5kbGVyIHJlZ2lzdHJhdGlvbiBJREwgYXR0cmlidXRlIGZvciB0aGlzIHR5cGVcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jdW1lbnQucHJvdG90eXBlLCAnb24nICsgdHlwZSwge1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2dldEV2ZW50SGFuZGxlcih0eXBlKTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgdGhpcy5fc2V0RXZlbnRIYW5kbGVyKHR5cGUsIHYpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIG5hbWVkSFRNTENoaWxkKHBhcmVudCwgbmFtZSkge1xyXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LmlzSFRNTCkge1xyXG4gICAgdmFyIGtpZHMgPSBwYXJlbnQuY2hpbGROb2RlcztcclxuICAgIGZvcih2YXIgaSA9IDAsIG4gPSBraWRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICBpZiAoa2lkc1tpXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiZcclxuICAgICAgICBraWRzW2ldLmxvY2FsTmFtZSA9PT0gbmFtZSAmJlxyXG4gICAgICAgIGtpZHNbaV0ubmFtZXNwYWNlVVJJID09PSBOQU1FU1BBQ0UuSFRNTCkge1xyXG4gICAgICAgIHJldHVybiBraWRzW2ldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiByb290KG4pIHtcclxuICBuLl9uaWQgPSBuLm93bmVyRG9jdW1lbnQuX25leHRuaWQrKztcclxuICBuLm93bmVyRG9jdW1lbnQuX25vZGVzW24uX25pZF0gPSBuO1xyXG4gIC8vIE1hbmFnZSBpZCB0byBlbGVtZW50IG1hcHBpbmdcclxuICBpZiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgIHZhciBpZCA9IG4uZ2V0QXR0cmlidXRlKCdpZCcpO1xyXG4gICAgaWYgKGlkKSBuLm93bmVyRG9jdW1lbnQuYWRkSWQoaWQsIG4pO1xyXG5cclxuICAgIC8vIFNjcmlwdCBlbGVtZW50cyBuZWVkIHRvIGtub3cgd2hlbiB0aGV5J3JlIGluc2VydGVkXHJcbiAgICAvLyBpbnRvIHRoZSBkb2N1bWVudFxyXG4gICAgaWYgKG4uX3Jvb3Rob29rKSBuLl9yb290aG9vaygpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXByb290KG4pIHtcclxuICAvLyBNYW5hZ2UgaWQgdG8gZWxlbWVudCBtYXBwaW5nXHJcbiAgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XHJcbiAgICB2YXIgaWQgPSBuLmdldEF0dHJpYnV0ZSgnaWQnKTtcclxuICAgIGlmIChpZCkgbi5vd25lckRvY3VtZW50LmRlbElkKGlkLCBuKTtcclxuICB9XHJcbiAgbi5vd25lckRvY3VtZW50Ll9ub2Rlc1tuLl9uaWRdID0gdW5kZWZpbmVkO1xyXG4gIG4uX25pZCA9IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVjdXJzaXZlbHlSb290KG5vZGUpIHtcclxuICByb290KG5vZGUpO1xyXG4gIC8vIFhYWDpcclxuICAvLyBhY2Nlc3NpbmcgY2hpbGROb2RlcyBvbiBhIGxlYWYgbm9kZSBjcmVhdGVzIGEgbmV3IGFycmF5IHRoZVxyXG4gIC8vIGZpcnN0IHRpbWUsIHNvIGJlIGNhcmVmdWwgdG8gd3JpdGUgdGhpcyBsb29wIHNvIHRoYXQgaXRcclxuICAvLyBkb2Vzbid0IGRvIHRoYXQuIG5vZGUgaXMgcG9seW1vcnBoaWMsIHNvIG1heWJlIHRoaXMgaXMgaGFyZCB0b1xyXG4gIC8vIG9wdGltaXplPyAgVHJ5IHN3aXRjaGluZyBvbiBub2RlVHlwZT9cclxuLypcclxuICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICAgIHZhciBraWRzID0gbm9kZS5jaGlsZE5vZGVzO1xyXG4gICAgZm9yKHZhciBpID0gMCwgbiA9IGtpZHMubGVuZ3RoOyAgaSA8IG47IGkrKylcclxuICAgICAgcmVjdXJzaXZlbHlSb290KGtpZHNbaV0pO1xyXG4gIH1cclxuKi9cclxuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgIHZhciBraWRzID0gbm9kZS5jaGlsZE5vZGVzO1xyXG4gICAgZm9yKHZhciBpID0gMCwgbiA9IGtpZHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgICByZWN1cnNpdmVseVJvb3Qoa2lkc1tpXSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZWN1cnNpdmVseVVwcm9vdChub2RlKSB7XHJcbiAgdXByb290KG5vZGUpO1xyXG4gIGZvcih2YXIgaSA9IDAsIG4gPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgcmVjdXJzaXZlbHlVcHJvb3Qobm9kZS5jaGlsZE5vZGVzW2ldKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVjdXJzaXZlbHlTZXRPd25lcihub2RlLCBvd25lcikge1xyXG4gIG5vZGUub3duZXJEb2N1bWVudCA9IG93bmVyO1xyXG4gIG5vZGUuX2xhc3RNb2RUaW1lID0gdW5kZWZpbmVkOyAvLyBtb2QgdGltZXMgYXJlIGRvY3VtZW50LWJhc2VkXHJcbiAgdmFyIGtpZHMgPSBub2RlLmNoaWxkTm9kZXM7XHJcbiAgZm9yKHZhciBpID0gMCwgbiA9IGtpZHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgcmVjdXJzaXZlbHlTZXRPd25lcihraWRzW2ldLCBvd25lcik7XHJcbn1cclxuXHJcbi8vIEEgY2xhc3MgZm9yIHN0b3JpbmcgbXVsdGlwbGUgbm9kZXMgd2l0aCB0aGUgc2FtZSBJRFxyXG5mdW5jdGlvbiBNdWx0aUlkKG5vZGUpIHtcclxuICB0aGlzLm5vZGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICB0aGlzLm5vZGVzW25vZGUuX25pZF0gPSBub2RlO1xyXG4gIHRoaXMubGVuZ3RoID0gMTtcclxuICB0aGlzLmZpcnN0Tm9kZSA9IHVuZGVmaW5lZDtcclxufVxyXG5cclxuLy8gQWRkIGEgbm9kZSB0byB0aGUgbGlzdCwgd2l0aCBPKDEpIHRpbWVcclxuTXVsdGlJZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obm9kZSkge1xyXG4gIGlmICghdGhpcy5ub2Rlc1tub2RlLl9uaWRdKSB7XHJcbiAgICB0aGlzLm5vZGVzW25vZGUuX25pZF0gPSBub2RlO1xyXG4gICAgdGhpcy5sZW5ndGgrKztcclxuICAgIHRoaXMuZmlyc3ROb2RlID0gdW5kZWZpbmVkO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIFJlbW92ZSBhIG5vZGUgZnJvbSB0aGUgbGlzdCwgd2l0aCBPKDEpIHRpbWVcclxuTXVsdGlJZC5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24obm9kZSkge1xyXG4gIGlmICh0aGlzLm5vZGVzW25vZGUuX25pZF0pIHtcclxuICAgIGRlbGV0ZSB0aGlzLm5vZGVzW25vZGUuX25pZF07XHJcbiAgICB0aGlzLmxlbmd0aC0tO1xyXG4gICAgdGhpcy5maXJzdE5vZGUgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gR2V0IHRoZSBmaXJzdCBub2RlIGZyb20gdGhlIGxpc3QsIGluIHRoZSBkb2N1bWVudCBvcmRlclxyXG4vLyBUYWtlcyBPKE4pIHRpbWUgaW4gdGhlIHNpemUgb2YgdGhlIGxpc3QsIHdpdGggYSBjYWNoZSB0aGF0IGlzIGludmFsaWRhdGVkXHJcbi8vIHdoZW4gdGhlIGxpc3QgaXMgbW9kaWZpZWQuXHJcbk11bHRpSWQucHJvdG90eXBlLmdldEZpcnN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXHJcbiAgaWYgKCF0aGlzLmZpcnN0Tm9kZSkge1xyXG4gICAgdmFyIG5pZDtcclxuICAgIGZvciAobmlkIGluIHRoaXMubm9kZXMpIHtcclxuICAgICAgaWYgKHRoaXMuZmlyc3ROb2RlID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICB0aGlzLmZpcnN0Tm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzLm5vZGVzW25pZF0pICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcpIHtcclxuICAgICAgICB0aGlzLmZpcnN0Tm9kZSA9IHRoaXMubm9kZXNbbmlkXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcy5maXJzdE5vZGU7XHJcbn07XHJcblxyXG4vLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSBub2RlIGxlZnQsIHJldHVybiBpdC4gT3RoZXJ3aXNlIHJldHVybiBcInRoaXNcIi5cclxuTXVsdGlJZC5wcm90b3R5cGUuZG93bmdyYWRlID0gZnVuY3Rpb24oKSB7XHJcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICB2YXIgbmlkO1xyXG4gICAgZm9yIChuaWQgaW4gdGhpcy5ub2Rlcykge1xyXG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc1tuaWRdO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvRG9jdW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50VHlwZTtcclxuXHJcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XHJcbnZhciBMZWFmID0gcmVxdWlyZSgnLi9MZWFmJyk7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxudmFyIENoaWxkTm9kZSA9IHJlcXVpcmUoJy4vQ2hpbGROb2RlJyk7XHJcblxyXG5mdW5jdGlvbiBEb2N1bWVudFR5cGUobmFtZSwgcHVibGljSWQsIHN5c3RlbUlkKSB7XHJcbiAgLy8gVW5saWtlIG90aGVyIG5vZGVzLCBkb2N0eXBlIG5vZGVzIGFsd2F5cyBzdGFydCBvZmYgdW5vd25lZFxyXG4gIC8vIHVudGlsIGluc2VydGVkXHJcbiAgdGhpcy5ub2RlVHlwZSA9IE5vZGUuRE9DVU1FTlRfVFlQRV9OT0RFO1xyXG4gIHRoaXMub3duZXJEb2N1bWVudCA9IG51bGw7XHJcbiAgdGhpcy5uYW1lID0gbmFtZTtcclxuICB0aGlzLnB1YmxpY0lkID0gcHVibGljSWQgfHwgXCJcIjtcclxuICB0aGlzLnN5c3RlbUlkID0gc3lzdGVtSWQgfHwgXCJcIjtcclxufVxyXG5cclxuRG9jdW1lbnRUeXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGVhZi5wcm90b3R5cGUsIHtcclxuICBub2RlTmFtZTogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5uYW1lOyB9fSxcclxuICBub2RlVmFsdWU6IHtcclxuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBudWxsOyB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbigpIHt9XHJcbiAgfSxcclxuXHJcbiAgLy8gVXRpbGl0eSBtZXRob2RzXHJcbiAgY2xvbmU6IHsgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xyXG4gICAgdXRpbHMuRGF0YUNsb25lRXJyb3IoKTtcclxuICB9fSxcclxuXHJcbiAgaXNFcXVhbDogeyB2YWx1ZTogZnVuY3Rpb24gaXNFcXVhbChuKSB7XHJcbiAgICByZXR1cm4gdGhpcy5uYW1lID09PSBuLm5hbWUgJiZcclxuICAgICAgdGhpcy5wdWJsaWNJZCA9PT0gbi5wdWJsaWNJZCAmJlxyXG4gICAgICB0aGlzLnN5c3RlbUlkID09PSBuLnN5c3RlbUlkO1xyXG4gIH19XHJcbn0pO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRG9jdW1lbnRUeXBlLnByb3RvdHlwZSwgQ2hpbGROb2RlKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvRG9jdW1lbnRUeXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBIVE1MUGFyc2VyO1xyXG5cclxudmFyIERvY3VtZW50ID0gcmVxdWlyZSgnLi9Eb2N1bWVudCcpO1xyXG52YXIgRG9jdW1lbnRUeXBlID0gcmVxdWlyZSgnLi9Eb2N1bWVudFR5cGUnKTtcclxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcclxudmFyIE5BTUVTUEFDRSA9IHJlcXVpcmUoJy4vdXRpbHMnKS5OQU1FU1BBQ0U7XHJcbnZhciBodG1sID0gcmVxdWlyZSgnLi9odG1sZWx0cycpO1xyXG52YXIgaW1wbCA9IGh0bWwuZWxlbWVudHM7XHJcblxyXG52YXIgcHVzaEFsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5iaW5kKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcclxuXHJcbi8qXHJcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgSFRNTCBwYXJzaW5nIGFsZ29yaXRobS5cclxuICogVGhlIGFsZ29yaXRobSBhbmQgdGhlIGltcGxlbWVudGF0aW9uIGFyZSBjb21wbGV4IGJlY2F1c2UgSFRNTFxyXG4gKiBleHBsaWNpdGx5IGRlZmluZXMgaG93IHRoZSBwYXJzZXIgc2hvdWxkIGJlaGF2ZSBmb3IgYWxsIHBvc3NpYmxlXHJcbiAqIHZhbGlkIGFuZCBpbnZhbGlkIGlucHV0cy5cclxuICpcclxuICogVXNhZ2U6XHJcbiAqXHJcbiAqIFRoZSBmaWxlIGRlZmluZXMgYSBzaW5nbGUgSFRNTFBhcnNlcigpIGZ1bmN0aW9uLCB3aGljaCBkb20uanMgZXhwb3Nlc1xyXG4gKiBwdWJsaWNseSBhcyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5tb3pIVE1MUGFyc2VyKCkuIFRoaXMgaXMgYVxyXG4gKiBmYWN0b3J5IGZ1bmN0aW9uLCBub3QgYSBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogV2hlbiB5b3UgY2FsbCBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5tb3pIVE1MUGFyc2VyKCksIGl0IHJldHVybnNcclxuICogYW4gb2JqZWN0IHRoYXQgaGFzIHBhcnNlKCkgYW5kIGRvY3VtZW50KCkgbWV0aG9kcy4gVG8gcGFyc2UgSFRNTCB0ZXh0LFxyXG4gKiBwYXNzIHRoZSB0ZXh0IChpbiBvbmUgb3IgbW9yZSBjaHVua3MpIHRvIHRoZSBwYXJzZSgpIG1ldGhvZC4gIFdoZW5cclxuICogeW91J3ZlIHBhc3NlZCBhbGwgdGhlIHRleHQgKG9uIHRoZSBsYXN0IGNodW5rLCBvciBhZnRlcndhcmQpIHBhc3NcclxuICogdHJ1ZSBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHBhcnNlKCkgdG8gdGVsbCB0aGUgcGFyc2VyIHRoYXQgdGhlcmVcclxuICogaXMgbm8gbW9yZSBjb21pbmcuIENhbGwgZG9jdW1lbnQoKSB0byBnZXQgdGhlIGRvY3VtZW50IG9iamVjdCB0aGF0XHJcbiAqIHRoZSBwYXJzZXIgaXMgcGFyc2luZyBpbnRvLiAgWW91IGNhbiBjYWxsIHRoaXMgYXQgYW55IHRpbWUsIGJlZm9yZVxyXG4gKiBvciBhZnRlciBjYWxsaW5nIHBhcnNlKCkuXHJcbiAqXHJcbiAqIFRoZSBmaXJzdCBhcmd1bWVudCB0byBtb3pIVE1MUGFyc2VyIGlzIHRoZSBhYnNvbHV0ZSBVUkwgb2YgdGhlIGRvY3VtZW50LlxyXG4gKlxyXG4gKiBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGFuZCBpcyBmb3IgaW50ZXJuYWwgdXNlIG9ubHkuICBQYXNzIGFuXHJcbiAqIGVsZW1lbnQgYXMgdGhlIGZyYWdtZW50Q29udGV4dCB0byBkbyBpbm5lckhUTUwgcGFyc2luZyBmb3IgdGhlXHJcbiAqIGVsZW1lbnQuICBUbyBkbyBpbm5lckhUTUwgcGFyc2luZyBvbiBhIGRvY3VtZW50LCBwYXNzIG51bGwuIE90aGVyd2lzZSxcclxuICogb21pdCB0aGUgMm5kIGFyZ3VtZW50LiBTZWUgSFRNTEVsZW1lbnQuaW5uZXJIVE1MIGZvciBhbiBleGFtcGxlLiAgTm90ZVxyXG4gKiB0aGF0IGlmIHlvdSBwYXNzIGEgY29udGV4dCBlbGVtZW50LCB0aGUgZW5kKCkgbWV0aG9kIHdpbGwgcmV0dXJuIGFuXHJcbiAqIHVud3JhcHBlZCBkb2N1bWVudCBpbnN0ZWFkIG9mIGEgd3JhcHBlZCBvbmUuXHJcbiAqXHJcbiAqIEltcGxlbWVudGF0aW9uIGRldGFpbHM6XHJcbiAqXHJcbiAqIFRoaXMgaXMgYSBsb25nIGZpbGUgb2YgYWxtb3N0IDcwMDAgbGluZXMuIEl0IGlzIHN0cnVjdHVyZWQgYXMgb25lXHJcbiAqIGJpZyBmdW5jdGlvbiBuZXN0ZWQgd2l0aGluIGFub3RoZXIgYmlnIGZ1bmN0aW9uLiAgVGhlIG91dGVyXHJcbiAqIGZ1bmN0aW9uIGRlZmluZXMgYSBidW5jaCBvZiBjb25zdGFudCBkYXRhLCB1dGlsaXR5IGZ1bmN0aW9uc1xyXG4gKiB0aGF0IHVzZSB0aGF0IGRhdGEsIGFuZCBhIGNvdXBsZSBvZiBjbGFzc2VzIHVzZWQgYnkgdGhlIHBhcnNlci5cclxuICogVGhlIG91dGVyIGZ1bmN0aW9uIGFsc28gZGVmaW5lcyBhbmQgcmV0dXJucyB0aGVcclxuICogaW5uZXIgZnVuY3Rpb24uIFRoaXMgaW5uZXIgZnVuY3Rpb24gaXMgdGhlIEhUTUxQYXJzZXIgZmFjdG9yeVxyXG4gKiBmdW5jdGlvbiB0aGF0IGltcGxlbWVudHMgdGhlIHBhcnNlciBhbmQgaG9sZHMgYWxsIHRoZSBwYXJzZXIgc3RhdGVcclxuICogYXMgbG9jYWwgdmFyaWFibGVzLiAgVGhlIEhUTUxQYXJzZXIgZnVuY3Rpb24gaXMgcXVpdGUgYmlnIGJlY2F1c2VcclxuICogaXQgZGVmaW5lcyBtYW55IG5lc3RlZCBmdW5jdGlvbnMgdGhhdCB1c2UgdGhvc2UgbG9jYWwgdmFyaWFibGVzLlxyXG4gKlxyXG4gKiBUaGVyZSBhcmUgdGhyZWUgdGlnaHRseSBjb3VwbGVkIHBhcnNlciBzdGFnZXM6IGEgc2Nhbm5lciwgYVxyXG4gKiB0b2tlbml6ZXIgYW5kIGEgdHJlZSBidWlsZGVyLiBJbiBhIChwb3NzaWJseSBtaXNndWlkZWQpIGF0dGVtcHQgYXRcclxuICogZWZmaWNpZW5jeSwgdGhlIHN0YWdlcyBhcmUgbm90IGltcGxlbWVudGVkIGFzIHNlcGFyYXRlIGNsYXNzZXM6XHJcbiAqIGV2ZXJ5dGhpbmcgc2hhcmVzIHN0YXRlIGFuZCBpcyAobW9zdGx5KSBpbXBsZW1lbnRlZCBpbiBpbXBlcmF0aXZlXHJcbiAqIChyYXRoZXIgdGhhbiBPTykgc3R5bGUuXHJcbiAqXHJcbiAqIFRoZSBzdGFnZXMgb2YgdGhlIHBhcnNlciB3b3JrIGxpa2UgdGhpczogV2hlbiB0aGUgY2xpZW50IGNvZGUgY2FsbHNcclxuICogdGhlIHBhcnNlcidzIHBhcnNlKCkgbWV0aG9kLCB0aGUgc3BlY2lmaWVkIHN0cmluZyBpcyBwYXNzZWQgdG9cclxuICogc2NhbkNoYXJzKCkuIFRoZSBzY2FubmVyIGxvb3BzIHRocm91Z2ggdGhhdCBzdHJpbmcgYW5kIHBhc3NlcyBjaGFyYWN0ZXJzXHJcbiAqIChzb21ldGltZXMgb25lIGF0IGEgdGltZSwgc29tZXRpbWVzIGluIGNodW5rcykgdG8gdGhlIHRva2VuaXplciBzdGFnZS5cclxuICogVGhlIHRva2VuaXplciBncm91cHMgdGhlIGNoYXJhY3RlcnMgaW50byB0b2tlbnM6IHRhZ3MsIGVuZHRhZ3MsIHJ1bnNcclxuICogb2YgdGV4dCwgY29tbWVudHMsIGRvY3R5cGUgZGVjbGFyYXRpb25zLCBhbmQgdGhlIGVuZC1vZi1maWxlIChFT0YpXHJcbiAqIHRva2VuLiAgVGhlc2UgdG9rZW5zIGFyZSB0aGVuIHBhc3NlZCB0byB0aGUgdHJlZSBidWlsZGluZyBzdGFnZSB2aWFcclxuICogdGhlIGluc2VydFRva2VuKCkgZnVuY3Rpb24uICBUaGUgdHJlZSBidWlsZGluZyBzdGFnZSBidWlsZHMgdXAgdGhlXHJcbiAqIGRvY3VtZW50IHRyZWUuXHJcbiAqXHJcbiAqIFRoZSB0b2tlbml6ZXIgc3RhZ2UgaXMgYSBmaW5pdGUgc3RhdGUgbWFjaGluZS4gIEVhY2ggc3RhdGUgaXNcclxuICogaW1wbGVtZW50ZWQgYXMgYSBmdW5jdGlvbiB3aXRoIGEgbmFtZSB0aGF0IGVuZHMgaW4gXCJfc3RhdGVcIi4gIFRoZVxyXG4gKiBpbml0aWFsIHN0YXRlIGlzIGRhdGFfc3RhdGUoKS4gVGhlIGN1cnJlbnQgdG9rZW5pemVyIHN0YXRlIGlzIHN0b3JlZFxyXG4gKiBpbiB0aGUgdmFyaWFibGUgJ3Rva2VuaXplcicuICBNb3N0IHN0YXRlIGZ1bmN0aW9ucyBleHBlY3QgYSBzaW5nbGVcclxuICogaW50ZWdlciBhcmd1bWVudCB3aGljaCByZXByZXNlbnRzIGEgc2luZ2xlIFVURi0xNiBjb2RlcG9pbnQuICBTb21lXHJcbiAqIHN0YXRlcyB3YW50IG1vcmUgY2hhcmFjdGVycyBhbmQgc2V0IGEgbG9va2FoZWFkIHByb3BlcnR5IG9uXHJcbiAqIHRoZW1zZWx2ZXMuICBUaGUgc2NhbkNoYXJzKCkgZnVuY3Rpb24gaW4gdGhlIHNjYW5uZXIgY2hlY2tzIGZvciB0aGlzXHJcbiAqIGxvb2thaGVhZCBwcm9wZXJ0eS4gIElmIGl0IGRvZXNuJ3QgZXhpc3QsIHRoZW4gc2NhbkNoYXJzKCkganVzdCBwYXNzZXNcclxuICogdGhlIG5leHQgaW5wdXQgY2hhcmFjdGVyIHRvIHRoZSBjdXJyZW50IHRva2VuaXplciBzdGF0ZSBmdW5jdGlvbi5cclxuICogT3RoZXJ3aXNlLCBzY2FuQ2hhcnMoKSBsb29rcyBhaGVhZCAoYSBnaXZlbiAjIG9mIGNoYXJhY3RlcnMsIG9yIGZvciBhXHJcbiAqIG1hdGNoaW5nIHN0cmluZywgb3IgZm9yIGEgbWF0Y2hpbmcgcmVnZXhwKSBhbmQgcGFzc2VzIGEgc3RyaW5nIG9mXHJcbiAqIGNoYXJhY3RlcnMgdG8gdGhlIGN1cnJlbnQgdG9rZW5pemVyIHN0YXRlIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBBcyBhIHNob3J0Y3V0LCBjZXJ0YWluIHN0YXRlcyBvZiB0aGUgdG9rZW5pemVyIHVzZSByZWd1bGFyIGV4cHJlc3Npb25zXHJcbiAqIHRvIGxvb2sgYWhlYWQgaW4gdGhlIHNjYW5uZXIncyBpbnB1dCBidWZmZXIgZm9yIHJ1bnMgb2YgdGV4dCwgc2ltcGxlXHJcbiAqIHRhZ3MgYW5kIGF0dHJpYnV0ZXMuICBGb3Igd2VsbC1mb3JtZWQgaW5wdXQsIHRoZXNlIHNob3J0Y3V0cyBza2lwIGFcclxuICogbG90IG9mIHN0YXRlIHRyYW5zaXRpb25zIGFuZCBzcGVlZCB0aGluZ3MgdXAgYSBiaXQuXHJcbiAqXHJcbiAqIFdoZW4gYSB0b2tlbml6ZXIgc3RhdGUgZnVuY3Rpb24gaGFzIGNvbnN1bWVkIGEgY29tcGxldGUgdG9rZW4sIGl0XHJcbiAqIGVtaXRzIHRoYXQgdG9rZW4sIGJ5IGNhbGxpbmcgaW5zZXJ0VG9rZW4oKSwgb3IgYnkgY2FsbGluZyBhIHV0aWxpdHlcclxuICogZnVuY3Rpb24gdGhhdCBpdHNlbGYgY2FsbHMgaW5zZXJ0VG9rZW4oKS4gIFRoZXNlIHRva2VucyBhcmUgcGFzc2VkIHRvXHJcbiAqIHRoZSB0cmVlIGJ1aWxkaW5nIHN0YWdlLCB3aGljaCBpcyBhbHNvIGEgc3RhdGUgbWFjaGluZS4gIExpa2UgdGhlXHJcbiAqIHRva2VuaXplciwgdGhlIHRyZWUgYnVpbGRpbmcgc3RhdGVzIGFyZSBpbXBsZW1lbnRlZCBhcyBmdW5jdGlvbnMsIGFuZFxyXG4gKiB0aGVzZSBmdW5jdGlvbnMgaGF2ZSBuYW1lcyB0aGF0IGVuZCB3aXRoIF9tb2RlIChiZWNhdXNlIHRoZSBIVE1MIHNwZWNcclxuICogcmVmZXJzIHRvIHRoZW0gYXMgaW5zZXJ0aW9uIG1vZGVzKS4gVGhlIGN1cnJlbnQgaW5zZXJ0aW9uIG1vZGUgaXMgaGVsZFxyXG4gKiBieSB0aGUgJ3BhcnNlcicgdmFyaWFibGUuICBFYWNoIGluc2VydGlvbiBtb2RlIGZ1bmN0aW9uIHRha2VzIHVwIHRvIDRcclxuICogYXJndW1lbnRzLiAgVGhlIGZpcnN0IGlzIGEgdG9rZW4gdHlwZSwgcmVwcmVzZW50ZWQgYnkgdGhlIGNvbnN0YW50c1xyXG4gKiBUQUcsIEVORFRBRywgVEVYVCwgQ09NTUVOVCwgRE9DVFlQRSBhbmQgRU9GLiAgVGhlIHNlY29uZCBhcmd1bWVudCBpc1xyXG4gKiB0aGUgdmFsdWUgb2YgdGhlIHRva2VuOiB0aGUgdGV4dCBvciBjb21tZW50IGRhdGEsIG9yIHRhZ25hbWUgb3JcclxuICogZG9jdHlwZS4gIEZvciB0YWdzLCB0aGUgM3JkIGFyZ3VtZW50IGlzIGFuIGFycmF5IG9mIGF0dHJpYnV0ZXMuICBGb3JcclxuICogRE9DVFlQRVMgaXQgaXMgdGhlIG9wdGlvbmFsIHB1YmxpYyBpZC4gIEZvciB0YWdzLCB0aGUgNHRoIGFyZ3VtZW50IGlzXHJcbiAqIHRydWUgaWYgdGhlIHRhZyBpcyBzZWxmLWNsb3NpbmcuIEZvciBkb2N0eXBlcywgdGhlIDR0aCBhcmd1bWVudCBpcyB0aGVcclxuICogb3B0aW9uYWwgc3lzdGVtIGlkLlxyXG4gKlxyXG4gKiBTZWFyY2ggZm9yIFwiKioqXCIgdG8gZmluZCB0aGUgbWFqb3Igc3ViLWRpdmlzaW9ucyBpbiB0aGUgY29kZS5cclxuICovXHJcblxyXG5cclxuLyoqKlxyXG4gKiBEYXRhIHByb2xvZy4gIExvdHMgb2YgY29uc3RhbnRzIGRlY2xhcmVkIGhlcmUsIGluY2x1ZGluZyBzb21lXHJcbiAqIHZlcnkgbGFyZ2Ugb2JqZWN0cy4gIFRoZXkncmUgdXNlZCB0aHJvdWdob3V0IHRoZSBjb2RlIHRoYXQgZm9sbG93c1xyXG4gKi9cclxuLy8gVG9rZW4gdHlwZXMgZm9yIHRoZSB0cmVlIGJ1aWxkZXIuXHJcbnZhciBFT0YgPSAtMTtcclxudmFyIFRFWFQgPSAxO1xyXG52YXIgVEFHID0gMjtcclxudmFyIEVORFRBRyA9IDM7XHJcbnZhciBDT01NRU5UID0gNDtcclxudmFyIERPQ1RZUEUgPSA1O1xyXG5cclxuLy8gQSByZS11c2FibGUgZW1wdHkgYXJyYXlcclxudmFyIE5PQVRUUlMgPSBbXTtcclxuXHJcbi8vIFRoZXNlIERURCBwdWJsaWMgaWRzIHB1dCB0aGUgYnJvd3NlciBpbiBxdWlya3MgbW9kZVxyXG52YXIgcXVpcmt5UHVibGljSWRzID0gL15IVE1MJHxeLVxcL1xcL1czT1xcL1xcL0RURCBXMyBIVE1MIFN0cmljdCAzXFwuMFxcL1xcL0VOXFwvXFwvJHxeLVxcL1czQ1xcL0RURCBIVE1MIDRcXC4wIFRyYW5zaXRpb25hbFxcL0VOJHxeXFwrXFwvXFwvU2lsbWFyaWxcXC9cXC9kdGQgaHRtbCBQcm8gdjByMTEgMTk5NzAxMDFcXC9cXC98Xi1cXC9cXC9BZHZhU29mdCBMdGRcXC9cXC9EVEQgSFRNTCAzXFwuMCBhc1dlZGl0IFxcKyBleHRlbnNpb25zXFwvXFwvfF4tXFwvXFwvQVNcXC9cXC9EVEQgSFRNTCAzXFwuMCBhc1dlZGl0IFxcKyBleHRlbnNpb25zXFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIDJcXC4wIExldmVsIDFcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgMlxcLjAgTGV2ZWwgMlxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCAyXFwuMCBTdHJpY3QgTGV2ZWwgMVxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCAyXFwuMCBTdHJpY3QgTGV2ZWwgMlxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCAyXFwuMCBTdHJpY3RcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgMlxcLjBcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgMlxcLjFFXFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIDNcXC4wXFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIDNcXC4yIEZpbmFsXFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIDNcXC4yXFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIDNcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgTGV2ZWwgMFxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCBMZXZlbCAxXFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIExldmVsIDJcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgTGV2ZWwgM1xcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCBTdHJpY3QgTGV2ZWwgMFxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCBTdHJpY3QgTGV2ZWwgMVxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCBTdHJpY3QgTGV2ZWwgMlxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCBTdHJpY3QgTGV2ZWwgM1xcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCBTdHJpY3RcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUxcXC9cXC98Xi1cXC9cXC9NZXRyaXVzXFwvXFwvRFREIE1ldHJpdXMgUHJlc2VudGF0aW9uYWxcXC9cXC98Xi1cXC9cXC9NaWNyb3NvZnRcXC9cXC9EVEQgSW50ZXJuZXQgRXhwbG9yZXIgMlxcLjAgSFRNTCBTdHJpY3RcXC9cXC98Xi1cXC9cXC9NaWNyb3NvZnRcXC9cXC9EVEQgSW50ZXJuZXQgRXhwbG9yZXIgMlxcLjAgSFRNTFxcL1xcL3xeLVxcL1xcL01pY3Jvc29mdFxcL1xcL0RURCBJbnRlcm5ldCBFeHBsb3JlciAyXFwuMCBUYWJsZXNcXC9cXC98Xi1cXC9cXC9NaWNyb3NvZnRcXC9cXC9EVEQgSW50ZXJuZXQgRXhwbG9yZXIgM1xcLjAgSFRNTCBTdHJpY3RcXC9cXC98Xi1cXC9cXC9NaWNyb3NvZnRcXC9cXC9EVEQgSW50ZXJuZXQgRXhwbG9yZXIgM1xcLjAgSFRNTFxcL1xcL3xeLVxcL1xcL01pY3Jvc29mdFxcL1xcL0RURCBJbnRlcm5ldCBFeHBsb3JlciAzXFwuMCBUYWJsZXNcXC9cXC98Xi1cXC9cXC9OZXRzY2FwZSBDb21tXFwuIENvcnBcXC5cXC9cXC9EVEQgSFRNTFxcL1xcL3xeLVxcL1xcL05ldHNjYXBlIENvbW1cXC4gQ29ycFxcLlxcL1xcL0RURCBTdHJpY3QgSFRNTFxcL1xcL3xeLVxcL1xcL08nUmVpbGx5IGFuZCBBc3NvY2lhdGVzXFwvXFwvRFREIEhUTUwgMlxcLjBcXC9cXC98Xi1cXC9cXC9PJ1JlaWxseSBhbmQgQXNzb2NpYXRlc1xcL1xcL0RURCBIVE1MIEV4dGVuZGVkIDFcXC4wXFwvXFwvfF4tXFwvXFwvTydSZWlsbHkgYW5kIEFzc29jaWF0ZXNcXC9cXC9EVEQgSFRNTCBFeHRlbmRlZCBSZWxheGVkIDFcXC4wXFwvXFwvfF4tXFwvXFwvU29mdFF1YWQgU29mdHdhcmVcXC9cXC9EVEQgSG9UTWV0YUwgUFJPIDZcXC4wOjoxOTk5MDYwMTo6ZXh0ZW5zaW9ucyB0byBIVE1MIDRcXC4wXFwvXFwvfF4tXFwvXFwvU29mdFF1YWRcXC9cXC9EVEQgSG9UTWV0YUwgUFJPIDRcXC4wOjoxOTk3MTAxMDo6ZXh0ZW5zaW9ucyB0byBIVE1MIDRcXC4wXFwvXFwvfF4tXFwvXFwvU3B5Z2xhc3NcXC9cXC9EVEQgSFRNTCAyXFwuMCBFeHRlbmRlZFxcL1xcL3xeLVxcL1xcL1NRXFwvXFwvRFREIEhUTUwgMlxcLjAgSG9UTWV0YUwgXFwrIGV4dGVuc2lvbnNcXC9cXC98Xi1cXC9cXC9TdW4gTWljcm9zeXN0ZW1zIENvcnBcXC5cXC9cXC9EVEQgSG90SmF2YSBIVE1MXFwvXFwvfF4tXFwvXFwvU3VuIE1pY3Jvc3lzdGVtcyBDb3JwXFwuXFwvXFwvRFREIEhvdEphdmEgU3RyaWN0IEhUTUxcXC9cXC98Xi1cXC9cXC9XM0NcXC9cXC9EVEQgSFRNTCAzIDE5OTUtMDMtMjRcXC9cXC98Xi1cXC9cXC9XM0NcXC9cXC9EVEQgSFRNTCAzXFwuMiBEcmFmdFxcL1xcL3xeLVxcL1xcL1czQ1xcL1xcL0RURCBIVE1MIDNcXC4yIEZpbmFsXFwvXFwvfF4tXFwvXFwvVzNDXFwvXFwvRFREIEhUTUwgM1xcLjJcXC9cXC98Xi1cXC9cXC9XM0NcXC9cXC9EVEQgSFRNTCAzXFwuMlMgRHJhZnRcXC9cXC98Xi1cXC9cXC9XM0NcXC9cXC9EVEQgSFRNTCA0XFwuMCBGcmFtZXNldFxcL1xcL3xeLVxcL1xcL1czQ1xcL1xcL0RURCBIVE1MIDRcXC4wIFRyYW5zaXRpb25hbFxcL1xcL3xeLVxcL1xcL1czQ1xcL1xcL0RURCBIVE1MIEV4cGVyaW1lbnRhbCAxOTk2MDcxMlxcL1xcL3xeLVxcL1xcL1czQ1xcL1xcL0RURCBIVE1MIEV4cGVyaW1lbnRhbCA5NzA0MjFcXC9cXC98Xi1cXC9cXC9XM0NcXC9cXC9EVEQgVzMgSFRNTFxcL1xcL3xeLVxcL1xcL1czT1xcL1xcL0RURCBXMyBIVE1MIDNcXC4wXFwvXFwvfF4tXFwvXFwvV2ViVGVjaHNcXC9cXC9EVEQgTW96aWxsYSBIVE1MIDJcXC4wXFwvXFwvfF4tXFwvXFwvV2ViVGVjaHNcXC9cXC9EVEQgTW96aWxsYSBIVE1MXFwvXFwvL2k7XHJcblxyXG52YXIgcXVpcmt5U3lzdGVtSWQgPSBcImh0dHA6Ly93d3cuaWJtLmNvbS9kYXRhL2R0ZC92MTEvaWJteGh0bWwxLXRyYW5zaXRpb25hbC5kdGRcIjtcclxuXHJcbnZhciBjb25kaXRpb25hbGx5UXVpcmt5UHVibGljSWRzID0gL14tXFwvXFwvVzNDXFwvXFwvRFREIEhUTUwgNFxcLjAxIEZyYW1lc2V0XFwvXFwvfF4tXFwvXFwvVzNDXFwvXFwvRFREIEhUTUwgNFxcLjAxIFRyYW5zaXRpb25hbFxcL1xcLy9pO1xyXG5cclxuLy8gVGhlc2UgRFREIHB1YmxpYyBpZHMgcHV0IHRoZSBicm93c2VyIGluIGxpbWl0ZWQgcXVpcmtzIG1vZGVcclxudmFyIGxpbWl0ZWRRdWlya3lQdWJsaWNJZHMgPSAvXi1cXC9cXC9XM0NcXC9cXC9EVEQgWEhUTUwgMVxcLjAgRnJhbWVzZXRcXC9cXC98Xi1cXC9cXC9XM0NcXC9cXC9EVEQgWEhUTUwgMVxcLjAgVHJhbnNpdGlvbmFsXFwvXFwvL2k7XHJcblxyXG5cclxuLy8gRWxlbWVudCBzZXRzIGJlbG93LiBTZWUgdGhlIGlzQSgpIGZ1bmN0aW9uIGZvciBhIHdheSB0byB0ZXN0XHJcbi8vIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBhIG1lbWJlciBvZiBhIHNldFxyXG52YXIgc3BlY2lhbFNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbnNwZWNpYWxTZXRbTkFNRVNQQUNFLkhUTUxdID0ge1xyXG4gIF9fcHJvdG9fXzogbnVsbCxcclxuICBcImFkZHJlc3NcIjp0cnVlLCBcImFwcGxldFwiOnRydWUsIFwiYXJlYVwiOnRydWUsIFwiYXJ0aWNsZVwiOnRydWUsXHJcbiAgXCJhc2lkZVwiOnRydWUsIFwiYmFzZVwiOnRydWUsIFwiYmFzZWZvbnRcIjp0cnVlLCBcImJnc291bmRcIjp0cnVlLFxyXG4gIFwiYmxvY2txdW90ZVwiOnRydWUsIFwiYm9keVwiOnRydWUsIFwiYnJcIjp0cnVlLCBcImJ1dHRvblwiOnRydWUsXHJcbiAgXCJjYXB0aW9uXCI6dHJ1ZSwgXCJjZW50ZXJcIjp0cnVlLCBcImNvbFwiOnRydWUsIFwiY29sZ3JvdXBcIjp0cnVlLFxyXG4gIFwiZGRcIjp0cnVlLCBcImRldGFpbHNcIjp0cnVlLCBcImRpclwiOnRydWUsXHJcbiAgXCJkaXZcIjp0cnVlLCBcImRsXCI6dHJ1ZSwgXCJkdFwiOnRydWUsIFwiZW1iZWRcIjp0cnVlLFxyXG4gIFwiZmllbGRzZXRcIjp0cnVlLCBcImZpZ2NhcHRpb25cIjp0cnVlLCBcImZpZ3VyZVwiOnRydWUsIFwiZm9vdGVyXCI6dHJ1ZSxcclxuICBcImZvcm1cIjp0cnVlLCBcImZyYW1lXCI6dHJ1ZSwgXCJmcmFtZXNldFwiOnRydWUsIFwiaDFcIjp0cnVlLFxyXG4gIFwiaDJcIjp0cnVlLCBcImgzXCI6dHJ1ZSwgXCJoNFwiOnRydWUsIFwiaDVcIjp0cnVlLFxyXG4gIFwiaDZcIjp0cnVlLCBcImhlYWRcIjp0cnVlLCBcImhlYWRlclwiOnRydWUsIFwiaGdyb3VwXCI6dHJ1ZSxcclxuICBcImhyXCI6dHJ1ZSwgXCJodG1sXCI6dHJ1ZSwgXCJpZnJhbWVcIjp0cnVlLCBcImltZ1wiOnRydWUsXHJcbiAgXCJpbnB1dFwiOnRydWUsIFwibGlcIjp0cnVlLCBcImxpbmtcIjp0cnVlLFxyXG4gIFwibGlzdGluZ1wiOnRydWUsIFwibWFpblwiOnRydWUsIFwibWFycXVlZVwiOnRydWUsIFwibWVudVwiOnRydWUsIFwibWV0YVwiOnRydWUsXHJcbiAgXCJuYXZcIjp0cnVlLCBcIm5vZW1iZWRcIjp0cnVlLCBcIm5vZnJhbWVzXCI6dHJ1ZSwgXCJub3NjcmlwdFwiOnRydWUsXHJcbiAgXCJvYmplY3RcIjp0cnVlLCBcIm9sXCI6dHJ1ZSwgXCJwXCI6dHJ1ZSwgXCJwYXJhbVwiOnRydWUsXHJcbiAgXCJwbGFpbnRleHRcIjp0cnVlLCBcInByZVwiOnRydWUsIFwic2NyaXB0XCI6dHJ1ZSwgXCJzZWN0aW9uXCI6dHJ1ZSxcclxuICBcInNlbGVjdFwiOnRydWUsIFwic291cmNlXCI6dHJ1ZSwgXCJzdHlsZVwiOnRydWUsIFwic3VtbWFyeVwiOnRydWUsIFwidGFibGVcIjp0cnVlLFxyXG4gIFwidGJvZHlcIjp0cnVlLCBcInRkXCI6dHJ1ZSwgXCJ0ZW1wbGF0ZVwiOnRydWUsIFwidGV4dGFyZWFcIjp0cnVlLCBcInRmb290XCI6dHJ1ZSxcclxuICBcInRoXCI6dHJ1ZSwgXCJ0aGVhZFwiOnRydWUsIFwidGl0bGVcIjp0cnVlLCBcInRyXCI6dHJ1ZSwgXCJ0cmFja1wiOnRydWUsXHJcbiAgLy8gTm90ZSB0aGF0IFwieG1wXCIgd2FzIHJlbW92ZWQgZnJvbSB0aGUgXCJzcGVjaWFsXCIgc2V0IGluIHRoZSBsYXRlc3RcclxuICAvLyBzcGVjLCBhcHBhcmVudGx5IGJ5IGFjY2lkZW50OyBzZWVcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvcHVsbC8xOTE5XHJcbiAgXCJ1bFwiOnRydWUsIFwid2JyXCI6dHJ1ZSwgXCJ4bXBcIjp0cnVlXHJcbn07XHJcbnNwZWNpYWxTZXRbTkFNRVNQQUNFLlNWR10gPSB7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIFwiZm9yZWlnbk9iamVjdFwiOiB0cnVlLCBcImRlc2NcIjogdHJ1ZSwgXCJ0aXRsZVwiOiB0cnVlXHJcbn07XHJcbnNwZWNpYWxTZXRbTkFNRVNQQUNFLk1BVEhNTF0gPSB7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIFwibWlcIjp0cnVlLCBcIm1vXCI6dHJ1ZSwgXCJtblwiOnRydWUsIFwibXNcIjp0cnVlLFxyXG4gIFwibXRleHRcIjp0cnVlLCBcImFubm90YXRpb24teG1sXCI6dHJ1ZVxyXG59O1xyXG5cclxuLy8gVGhlIHNldCBvZiBhZGRyZXNzLCBkaXYsIGFuZCBwIEhUTUwgdGFnc1xyXG52YXIgYWRkcmVzc2RpdnBTZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5hZGRyZXNzZGl2cFNldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIFwiYWRkcmVzc1wiOnRydWUsIFwiZGl2XCI6dHJ1ZSwgXCJwXCI6dHJ1ZVxyXG59O1xyXG5cclxudmFyIGRkZHRTZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5kZGR0U2V0W05BTUVTUEFDRS5IVE1MXSA9IHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgXCJkZFwiOnRydWUsIFwiZHRcIjp0cnVlXHJcbn07XHJcblxyXG52YXIgdGFibGVzZWN0aW9ucm93U2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxudGFibGVzZWN0aW9ucm93U2V0W05BTUVTUEFDRS5IVE1MXSA9IHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgXCJ0YWJsZVwiOnRydWUsIFwidGhlYWRcIjp0cnVlLCBcInRib2R5XCI6dHJ1ZSwgXCJ0Zm9vdFwiOnRydWUsIFwidHJcIjp0cnVlXHJcbn07XHJcblxyXG52YXIgaW1wbGllZEVuZFRhZ3NTZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5pbXBsaWVkRW5kVGFnc1NldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIFwiZGRcIjogdHJ1ZSwgXCJkdFwiOiB0cnVlLCBcImxpXCI6IHRydWUsIFwibWVudWl0ZW1cIjogdHJ1ZSwgXCJvcHRncm91cFwiOiB0cnVlLFxyXG4gIFwib3B0aW9uXCI6IHRydWUsIFwicFwiOiB0cnVlLCBcInJiXCI6IHRydWUsIFwicnBcIjogdHJ1ZSwgXCJydFwiOiB0cnVlLCBcInJ0Y1wiOiB0cnVlXHJcbn07XHJcblxyXG52YXIgdGhvcm91Z2hJbXBsaWVkRW5kVGFnc1NldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbnRob3JvdWdoSW1wbGllZEVuZFRhZ3NTZXRbTkFNRVNQQUNFLkhUTUxdID0ge1xyXG4gIF9fcHJvdG9fXzogbnVsbCxcclxuICBcImNhcHRpb25cIjogdHJ1ZSwgXCJjb2xncm91cFwiOiB0cnVlLCBcImRkXCI6IHRydWUsIFwiZHRcIjogdHJ1ZSwgXCJsaVwiOiB0cnVlLFxyXG4gIFwib3B0Z3JvdXBcIjogdHJ1ZSwgXCJvcHRpb25cIjogdHJ1ZSwgXCJwXCI6IHRydWUsIFwicmJcIjogdHJ1ZSwgXCJycFwiOiB0cnVlLFxyXG4gIFwicnRcIjogdHJ1ZSwgXCJydGNcIjogdHJ1ZSwgXCJ0Ym9keVwiOiB0cnVlLCBcInRkXCI6IHRydWUsIFwidGZvb3RcIjogdHJ1ZSxcclxuICBcInRoXCI6IHRydWUsIFwidGhlYWRcIjogdHJ1ZSwgXCJ0clwiOiB0cnVlXHJcbn07XHJcblxyXG52YXIgdGFibGVDb250ZXh0U2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxudGFibGVDb250ZXh0U2V0W05BTUVTUEFDRS5IVE1MXSA9IHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgXCJ0YWJsZVwiOiB0cnVlLCBcInRlbXBsYXRlXCI6IHRydWUsIFwiaHRtbFwiOiB0cnVlXHJcbn07XHJcblxyXG52YXIgdGFibGVCb2R5Q29udGV4dFNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbnRhYmxlQm9keUNvbnRleHRTZXRbTkFNRVNQQUNFLkhUTUxdID0ge1xyXG4gIF9fcHJvdG9fXzogbnVsbCxcclxuICBcInRib2R5XCI6IHRydWUsIFwidGZvb3RcIjogdHJ1ZSwgXCJ0aGVhZFwiOiB0cnVlLCBcInRlbXBsYXRlXCI6IHRydWUsIFwiaHRtbFwiOiB0cnVlXHJcbn07XHJcblxyXG52YXIgdGFibGVSb3dDb250ZXh0U2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxudGFibGVSb3dDb250ZXh0U2V0W05BTUVTUEFDRS5IVE1MXSA9IHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgXCJ0clwiOiB0cnVlLCBcInRlbXBsYXRlXCI6IHRydWUsIFwiaHRtbFwiOiB0cnVlXHJcbn07XHJcblxyXG4vLyBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCNmb3JtLWFzc29jaWF0ZWQtZWxlbWVudFxyXG52YXIgZm9ybWFzc29jaWF0ZWRTZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5mb3JtYXNzb2NpYXRlZFNldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIFwiYnV0dG9uXCI6IHRydWUsIFwiZmllbGRzZXRcIjogdHJ1ZSwgXCJpbnB1dFwiOiB0cnVlLCBcImtleWdlblwiOiB0cnVlLFxyXG4gIFwib2JqZWN0XCI6IHRydWUsIFwib3V0cHV0XCI6IHRydWUsIFwic2VsZWN0XCI6IHRydWUsIFwidGV4dGFyZWFcIjogdHJ1ZSxcclxuICBcImltZ1wiOiB0cnVlXHJcbn07XHJcblxyXG52YXIgaW5TY29wZVNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbmluU2NvcGVTZXRbTkFNRVNQQUNFLkhUTUxdPSB7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIFwiYXBwbGV0XCI6dHJ1ZSwgXCJjYXB0aW9uXCI6dHJ1ZSwgXCJodG1sXCI6dHJ1ZSwgXCJ0YWJsZVwiOnRydWUsXHJcbiAgXCJ0ZFwiOnRydWUsIFwidGhcIjp0cnVlLCBcIm1hcnF1ZWVcIjp0cnVlLCBcIm9iamVjdFwiOnRydWUsXHJcbiAgXCJ0ZW1wbGF0ZVwiOnRydWVcclxufTtcclxuaW5TY29wZVNldFtOQU1FU1BBQ0UuTUFUSE1MXSA9IHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgXCJtaVwiOnRydWUsIFwibW9cIjp0cnVlLCBcIm1uXCI6dHJ1ZSwgXCJtc1wiOnRydWUsXHJcbiAgXCJtdGV4dFwiOnRydWUsIFwiYW5ub3RhdGlvbi14bWxcIjp0cnVlXHJcbn07XHJcbmluU2NvcGVTZXRbTkFNRVNQQUNFLlNWR10gPSB7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIFwiZm9yZWlnbk9iamVjdFwiOnRydWUsIFwiZGVzY1wiOnRydWUsIFwidGl0bGVcIjp0cnVlXHJcbn07XHJcblxyXG52YXIgaW5MaXN0SXRlbVNjb3BlU2V0ID0gT2JqZWN0LmNyZWF0ZShpblNjb3BlU2V0KTtcclxuaW5MaXN0SXRlbVNjb3BlU2V0W05BTUVTUEFDRS5IVE1MXSA9XHJcbiAgT2JqZWN0LmNyZWF0ZShpblNjb3BlU2V0W05BTUVTUEFDRS5IVE1MXSk7XHJcbmluTGlzdEl0ZW1TY29wZVNldFtOQU1FU1BBQ0UuSFRNTF0ub2wgPSB0cnVlO1xyXG5pbkxpc3RJdGVtU2NvcGVTZXRbTkFNRVNQQUNFLkhUTUxdLnVsID0gdHJ1ZTtcclxuXHJcbnZhciBpbkJ1dHRvblNjb3BlU2V0ID0gT2JqZWN0LmNyZWF0ZShpblNjb3BlU2V0KTtcclxuaW5CdXR0b25TY29wZVNldFtOQU1FU1BBQ0UuSFRNTF0gPVxyXG4gIE9iamVjdC5jcmVhdGUoaW5TY29wZVNldFtOQU1FU1BBQ0UuSFRNTF0pO1xyXG5pbkJ1dHRvblNjb3BlU2V0W05BTUVTUEFDRS5IVE1MXS5idXR0b24gPSB0cnVlO1xyXG5cclxudmFyIGluVGFibGVTY29wZVNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbmluVGFibGVTY29wZVNldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIFwiaHRtbFwiOnRydWUsIFwidGFibGVcIjp0cnVlLCBcInRlbXBsYXRlXCI6dHJ1ZVxyXG59O1xyXG5cclxuLy8gVGhlIHNldCBvZiBlbGVtZW50cyBmb3Igc2VsZWN0IHNjb3BlIGlzIHRoZSBldmVyeXRoaW5nICpleGNlcHQqIHRoZXNlXHJcbnZhciBpbnZlcnRlZFNlbGVjdFNjb3BlU2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuaW52ZXJ0ZWRTZWxlY3RTY29wZVNldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIFwib3B0Z3JvdXBcIjp0cnVlLCBcIm9wdGlvblwiOnRydWVcclxufTtcclxuXHJcbnZhciBtYXRobWxUZXh0SW50ZWdyYXRpb25Qb2ludFNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbm1hdGhtbFRleHRJbnRlZ3JhdGlvblBvaW50U2V0W05BTUVTUEFDRS5NQVRITUxdID0ge1xyXG4gIF9fcHJvdG9fXzogbnVsbCxcclxuICBtaTogdHJ1ZSxcclxuICBtbzogdHJ1ZSxcclxuICBtbjogdHJ1ZSxcclxuICBtczogdHJ1ZSxcclxuICBtdGV4dDogdHJ1ZVxyXG59O1xyXG5cclxudmFyIGh0bWxJbnRlZ3JhdGlvblBvaW50U2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuaHRtbEludGVncmF0aW9uUG9pbnRTZXRbTkFNRVNQQUNFLlNWR10gPSB7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIGZvcmVpZ25PYmplY3Q6IHRydWUsXHJcbiAgZGVzYzogdHJ1ZSxcclxuICB0aXRsZTogdHJ1ZVxyXG59O1xyXG5cclxudmFyIGZvcmVpZ25BdHRyaWJ1dGVzID0ge1xyXG4gIF9fcHJvdG9fXzogbnVsbCxcclxuICBcInhsaW5rOmFjdHVhdGVcIjogTkFNRVNQQUNFLlhMSU5LLCBcInhsaW5rOmFyY3JvbGVcIjogTkFNRVNQQUNFLlhMSU5LLFxyXG4gIFwieGxpbms6aHJlZlwiOiAgIE5BTUVTUEFDRS5YTElOSywgIFwieGxpbms6cm9sZVwiOiAgICBOQU1FU1BBQ0UuWExJTkssXHJcbiAgXCJ4bGluazpzaG93XCI6ICAgTkFNRVNQQUNFLlhMSU5LLCAgXCJ4bGluazp0aXRsZVwiOiAgIE5BTUVTUEFDRS5YTElOSyxcclxuICBcInhsaW5rOnR5cGVcIjogICBOQU1FU1BBQ0UuWExJTkssICBcInhtbDpiYXNlXCI6ICAgICAgTkFNRVNQQUNFLlhNTCxcclxuICBcInhtbDpsYW5nXCI6ICAgICBOQU1FU1BBQ0UuWE1MLCAgICBcInhtbDpzcGFjZVwiOiAgICAgTkFNRVNQQUNFLlhNTCxcclxuICBcInhtbG5zXCI6ICAgICAgICBOQU1FU1BBQ0UuWE1MTlMsICBcInhtbG5zOnhsaW5rXCI6ICAgTkFNRVNQQUNFLlhNTE5TXHJcbn07XHJcblxyXG5cclxuLy8gTG93ZXJjYXNlIHRvIG1peGVkIGNhc2UgbWFwcGluZyBmb3IgU1ZHIGF0dHJpYnV0ZXMgYW5kIHRhZ25hbWVzXHJcbnZhciBzdmdBdHRyQWRqdXN0bWVudHMgPSB7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIGF0dHJpYnV0ZW5hbWU6IFwiYXR0cmlidXRlTmFtZVwiLCBhdHRyaWJ1dGV0eXBlOiBcImF0dHJpYnV0ZVR5cGVcIixcclxuICBiYXNlZnJlcXVlbmN5OiBcImJhc2VGcmVxdWVuY3lcIiwgYmFzZXByb2ZpbGU6IFwiYmFzZVByb2ZpbGVcIixcclxuICBjYWxjbW9kZTogXCJjYWxjTW9kZVwiLCBjbGlwcGF0aHVuaXRzOiBcImNsaXBQYXRoVW5pdHNcIixcclxuICBkaWZmdXNlY29uc3RhbnQ6IFwiZGlmZnVzZUNvbnN0YW50XCIsXHJcbiAgZWRnZW1vZGU6IFwiZWRnZU1vZGVcIixcclxuICBmaWx0ZXJ1bml0czogXCJmaWx0ZXJVbml0c1wiLFxyXG4gIGdseXBocmVmOiBcImdseXBoUmVmXCIsIGdyYWRpZW50dHJhbnNmb3JtOiBcImdyYWRpZW50VHJhbnNmb3JtXCIsXHJcbiAgZ3JhZGllbnR1bml0czogXCJncmFkaWVudFVuaXRzXCIsIGtlcm5lbG1hdHJpeDogXCJrZXJuZWxNYXRyaXhcIixcclxuICBrZXJuZWx1bml0bGVuZ3RoOiBcImtlcm5lbFVuaXRMZW5ndGhcIiwga2V5cG9pbnRzOiBcImtleVBvaW50c1wiLFxyXG4gIGtleXNwbGluZXM6IFwia2V5U3BsaW5lc1wiLCBrZXl0aW1lczogXCJrZXlUaW1lc1wiLFxyXG4gIGxlbmd0aGFkanVzdDogXCJsZW5ndGhBZGp1c3RcIiwgbGltaXRpbmdjb25lYW5nbGU6IFwibGltaXRpbmdDb25lQW5nbGVcIixcclxuICBtYXJrZXJoZWlnaHQ6IFwibWFya2VySGVpZ2h0XCIsIG1hcmtlcnVuaXRzOiBcIm1hcmtlclVuaXRzXCIsXHJcbiAgbWFya2Vyd2lkdGg6IFwibWFya2VyV2lkdGhcIiwgbWFza2NvbnRlbnR1bml0czogXCJtYXNrQ29udGVudFVuaXRzXCIsXHJcbiAgbWFza3VuaXRzOiBcIm1hc2tVbml0c1wiLCBudW1vY3RhdmVzOiBcIm51bU9jdGF2ZXNcIixcclxuICBwYXRobGVuZ3RoOiBcInBhdGhMZW5ndGhcIiwgcGF0dGVybmNvbnRlbnR1bml0czogXCJwYXR0ZXJuQ29udGVudFVuaXRzXCIsXHJcbiAgcGF0dGVybnRyYW5zZm9ybTogXCJwYXR0ZXJuVHJhbnNmb3JtXCIsIHBhdHRlcm51bml0czogXCJwYXR0ZXJuVW5pdHNcIixcclxuICBwb2ludHNhdHg6IFwicG9pbnRzQXRYXCIsIHBvaW50c2F0eTogXCJwb2ludHNBdFlcIixcclxuICBwb2ludHNhdHo6IFwicG9pbnRzQXRaXCIsIHByZXNlcnZlYWxwaGE6IFwicHJlc2VydmVBbHBoYVwiLFxyXG4gIHByZXNlcnZlYXNwZWN0cmF0aW86IFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLFxyXG4gIHByaW1pdGl2ZXVuaXRzOiBcInByaW1pdGl2ZVVuaXRzXCIsIHJlZng6IFwicmVmWFwiLFxyXG4gIHJlZnk6IFwicmVmWVwiLCByZXBlYXRjb3VudDogXCJyZXBlYXRDb3VudFwiLFxyXG4gIHJlcGVhdGR1cjogXCJyZXBlYXREdXJcIiwgcmVxdWlyZWRleHRlbnNpb25zOiBcInJlcXVpcmVkRXh0ZW5zaW9uc1wiLFxyXG4gIHJlcXVpcmVkZmVhdHVyZXM6IFwicmVxdWlyZWRGZWF0dXJlc1wiLFxyXG4gIHNwZWN1bGFyY29uc3RhbnQ6IFwic3BlY3VsYXJDb25zdGFudFwiLFxyXG4gIHNwZWN1bGFyZXhwb25lbnQ6IFwic3BlY3VsYXJFeHBvbmVudFwiLCBzcHJlYWRtZXRob2Q6IFwic3ByZWFkTWV0aG9kXCIsXHJcbiAgc3RhcnRvZmZzZXQ6IFwic3RhcnRPZmZzZXRcIiwgc3RkZGV2aWF0aW9uOiBcInN0ZERldmlhdGlvblwiLFxyXG4gIHN0aXRjaHRpbGVzOiBcInN0aXRjaFRpbGVzXCIsIHN1cmZhY2VzY2FsZTogXCJzdXJmYWNlU2NhbGVcIixcclxuICBzeXN0ZW1sYW5ndWFnZTogXCJzeXN0ZW1MYW5ndWFnZVwiLCB0YWJsZXZhbHVlczogXCJ0YWJsZVZhbHVlc1wiLFxyXG4gIHRhcmdldHg6IFwidGFyZ2V0WFwiLCB0YXJnZXR5OiBcInRhcmdldFlcIixcclxuICB0ZXh0bGVuZ3RoOiBcInRleHRMZW5ndGhcIiwgdmlld2JveDogXCJ2aWV3Qm94XCIsXHJcbiAgdmlld3RhcmdldDogXCJ2aWV3VGFyZ2V0XCIsIHhjaGFubmVsc2VsZWN0b3I6IFwieENoYW5uZWxTZWxlY3RvclwiLFxyXG4gIHljaGFubmVsc2VsZWN0b3I6IFwieUNoYW5uZWxTZWxlY3RvclwiLCB6b29tYW5kcGFuOiBcInpvb21BbmRQYW5cIlxyXG59O1xyXG5cclxudmFyIHN2Z1RhZ05hbWVBZGp1c3RtZW50cyA9IHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgYWx0Z2x5cGg6IFwiYWx0R2x5cGhcIiwgYWx0Z2x5cGhkZWY6IFwiYWx0R2x5cGhEZWZcIixcclxuICBhbHRnbHlwaGl0ZW06IFwiYWx0R2x5cGhJdGVtXCIsIGFuaW1hdGVjb2xvcjogXCJhbmltYXRlQ29sb3JcIixcclxuICBhbmltYXRlbW90aW9uOiBcImFuaW1hdGVNb3Rpb25cIiwgYW5pbWF0ZXRyYW5zZm9ybTogXCJhbmltYXRlVHJhbnNmb3JtXCIsXHJcbiAgY2xpcHBhdGg6IFwiY2xpcFBhdGhcIiwgZmVibGVuZDogXCJmZUJsZW5kXCIsXHJcbiAgZmVjb2xvcm1hdHJpeDogXCJmZUNvbG9yTWF0cml4XCIsXHJcbiAgZmVjb21wb25lbnR0cmFuc2ZlcjogXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIsIGZlY29tcG9zaXRlOiBcImZlQ29tcG9zaXRlXCIsXHJcbiAgZmVjb252b2x2ZW1hdHJpeDogXCJmZUNvbnZvbHZlTWF0cml4XCIsXHJcbiAgZmVkaWZmdXNlbGlnaHRpbmc6IFwiZmVEaWZmdXNlTGlnaHRpbmdcIixcclxuICBmZWRpc3BsYWNlbWVudG1hcDogXCJmZURpc3BsYWNlbWVudE1hcFwiLFxyXG4gIGZlZGlzdGFudGxpZ2h0OiBcImZlRGlzdGFudExpZ2h0XCIsIGZlZmxvb2Q6IFwiZmVGbG9vZFwiLFxyXG4gIGZlZnVuY2E6IFwiZmVGdW5jQVwiLCBmZWZ1bmNiOiBcImZlRnVuY0JcIixcclxuICBmZWZ1bmNnOiBcImZlRnVuY0dcIiwgZmVmdW5jcjogXCJmZUZ1bmNSXCIsXHJcbiAgZmVnYXVzc2lhbmJsdXI6IFwiZmVHYXVzc2lhbkJsdXJcIiwgZmVpbWFnZTogXCJmZUltYWdlXCIsXHJcbiAgZmVtZXJnZTogXCJmZU1lcmdlXCIsIGZlbWVyZ2Vub2RlOiBcImZlTWVyZ2VOb2RlXCIsXHJcbiAgZmVtb3JwaG9sb2d5OiBcImZlTW9ycGhvbG9neVwiLCBmZW9mZnNldDogXCJmZU9mZnNldFwiLFxyXG4gIGZlcG9pbnRsaWdodDogXCJmZVBvaW50TGlnaHRcIiwgZmVzcGVjdWxhcmxpZ2h0aW5nOiBcImZlU3BlY3VsYXJMaWdodGluZ1wiLFxyXG4gIGZlc3BvdGxpZ2h0OiBcImZlU3BvdExpZ2h0XCIsIGZldGlsZTogXCJmZVRpbGVcIixcclxuICBmZXR1cmJ1bGVuY2U6IFwiZmVUdXJidWxlbmNlXCIsIGZvcmVpZ25vYmplY3Q6IFwiZm9yZWlnbk9iamVjdFwiLFxyXG4gIGdseXBocmVmOiBcImdseXBoUmVmXCIsIGxpbmVhcmdyYWRpZW50OiBcImxpbmVhckdyYWRpZW50XCIsXHJcbiAgcmFkaWFsZ3JhZGllbnQ6IFwicmFkaWFsR3JhZGllbnRcIiwgdGV4dHBhdGg6IFwidGV4dFBhdGhcIlxyXG59O1xyXG5cclxuXHJcbi8vIERhdGEgZm9yIHBhcnNpbmcgbnVtZXJpYyBhbmQgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXNcclxuLy8gVGhlc2UgbmV4dCAzIG9iamVjdHMgYXJlIGRpcmVjdCB0cmFuc2xhdGlvbnMgb2YgdGFibGVzXHJcbi8vIGluIHRoZSBIVE1MIHNwZWMgaW50byBKYXZhU2NyaXB0IG9iamVjdCBmb3JtYXRcclxudmFyIG51bWVyaWNDaGFyUmVmUmVwbGFjZW1lbnRzID0ge1xyXG4gIF9fcHJvdG9fXzogbnVsbCxcclxuICAweDAwOjB4RkZGRCwgMHg4MDoweDIwQUMsIDB4ODI6MHgyMDFBLCAweDgzOjB4MDE5MiwgMHg4NDoweDIwMUUsXHJcbiAgMHg4NToweDIwMjYsIDB4ODY6MHgyMDIwLCAweDg3OjB4MjAyMSwgMHg4ODoweDAyQzYsIDB4ODk6MHgyMDMwLFxyXG4gIDB4OEE6MHgwMTYwLCAweDhCOjB4MjAzOSwgMHg4QzoweDAxNTIsIDB4OEU6MHgwMTdELCAweDkxOjB4MjAxOCxcclxuICAweDkyOjB4MjAxOSwgMHg5MzoweDIwMUMsIDB4OTQ6MHgyMDFELCAweDk1OjB4MjAyMiwgMHg5NjoweDIwMTMsXHJcbiAgMHg5NzoweDIwMTQsIDB4OTg6MHgwMkRDLCAweDk5OjB4MjEyMiwgMHg5QToweDAxNjEsIDB4OUI6MHgyMDNBLFxyXG4gIDB4OUM6MHgwMTUzLCAweDlFOjB4MDE3RSwgMHg5RjoweDAxNzhcclxufTtcclxuXHJcbi8qXHJcbiAqIFRoaXMgdGFibGUgaXMgZ2VuZXJhdGVkIHdpdGggdGVzdC90b29scy91cGRhdGUtZW50aXRpZXMuanNcclxuICovXHJcbnZhciBuYW1lZENoYXJSZWZzID0ge1xyXG4gIF9fcHJvdG9fXzogbnVsbCxcclxuICBcIkFFbGlnXCI6MHhjNiwgXCJBRWxpZztcIjoweGM2LFxyXG4gIFwiQU1QXCI6MHgyNiwgXCJBTVA7XCI6MHgyNixcclxuICBcIkFhY3V0ZVwiOjB4YzEsIFwiQWFjdXRlO1wiOjB4YzEsXHJcbiAgXCJBYnJldmU7XCI6MHgxMDIsIFwiQWNpcmNcIjoweGMyLFxyXG4gIFwiQWNpcmM7XCI6MHhjMiwgXCJBY3k7XCI6MHg0MTAsXHJcbiAgXCJBZnI7XCI6WzB4ZDgzNSwweGRkMDRdLCBcIkFncmF2ZVwiOjB4YzAsXHJcbiAgXCJBZ3JhdmU7XCI6MHhjMCwgXCJBbHBoYTtcIjoweDM5MSxcclxuICBcIkFtYWNyO1wiOjB4MTAwLCBcIkFuZDtcIjoweDJhNTMsXHJcbiAgXCJBb2dvbjtcIjoweDEwNCwgXCJBb3BmO1wiOlsweGQ4MzUsMHhkZDM4XSxcclxuICBcIkFwcGx5RnVuY3Rpb247XCI6MHgyMDYxLCBcIkFyaW5nXCI6MHhjNSxcclxuICBcIkFyaW5nO1wiOjB4YzUsIFwiQXNjcjtcIjpbMHhkODM1LDB4ZGM5Y10sXHJcbiAgXCJBc3NpZ247XCI6MHgyMjU0LCBcIkF0aWxkZVwiOjB4YzMsXHJcbiAgXCJBdGlsZGU7XCI6MHhjMywgXCJBdW1sXCI6MHhjNCxcclxuICBcIkF1bWw7XCI6MHhjNCwgXCJCYWNrc2xhc2g7XCI6MHgyMjE2LFxyXG4gIFwiQmFydjtcIjoweDJhZTcsIFwiQmFyd2VkO1wiOjB4MjMwNixcclxuICBcIkJjeTtcIjoweDQxMSwgXCJCZWNhdXNlO1wiOjB4MjIzNSxcclxuICBcIkJlcm5vdWxsaXM7XCI6MHgyMTJjLCBcIkJldGE7XCI6MHgzOTIsXHJcbiAgXCJCZnI7XCI6WzB4ZDgzNSwweGRkMDVdLCBcIkJvcGY7XCI6WzB4ZDgzNSwweGRkMzldLFxyXG4gIFwiQnJldmU7XCI6MHgyZDgsIFwiQnNjcjtcIjoweDIxMmMsXHJcbiAgXCJCdW1wZXE7XCI6MHgyMjRlLCBcIkNIY3k7XCI6MHg0MjcsXHJcbiAgXCJDT1BZXCI6MHhhOSwgXCJDT1BZO1wiOjB4YTksXHJcbiAgXCJDYWN1dGU7XCI6MHgxMDYsIFwiQ2FwO1wiOjB4MjJkMixcclxuICBcIkNhcGl0YWxEaWZmZXJlbnRpYWxEO1wiOjB4MjE0NSwgXCJDYXlsZXlzO1wiOjB4MjEyZCxcclxuICBcIkNjYXJvbjtcIjoweDEwYywgXCJDY2VkaWxcIjoweGM3LFxyXG4gIFwiQ2NlZGlsO1wiOjB4YzcsIFwiQ2NpcmM7XCI6MHgxMDgsXHJcbiAgXCJDY29uaW50O1wiOjB4MjIzMCwgXCJDZG90O1wiOjB4MTBhLFxyXG4gIFwiQ2VkaWxsYTtcIjoweGI4LCBcIkNlbnRlckRvdDtcIjoweGI3LFxyXG4gIFwiQ2ZyO1wiOjB4MjEyZCwgXCJDaGk7XCI6MHgzYTcsXHJcbiAgXCJDaXJjbGVEb3Q7XCI6MHgyMjk5LCBcIkNpcmNsZU1pbnVzO1wiOjB4MjI5NixcclxuICBcIkNpcmNsZVBsdXM7XCI6MHgyMjk1LCBcIkNpcmNsZVRpbWVzO1wiOjB4MjI5NyxcclxuICBcIkNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDtcIjoweDIyMzIsIFwiQ2xvc2VDdXJseURvdWJsZVF1b3RlO1wiOjB4MjAxZCxcclxuICBcIkNsb3NlQ3VybHlRdW90ZTtcIjoweDIwMTksIFwiQ29sb247XCI6MHgyMjM3LFxyXG4gIFwiQ29sb25lO1wiOjB4MmE3NCwgXCJDb25ncnVlbnQ7XCI6MHgyMjYxLFxyXG4gIFwiQ29uaW50O1wiOjB4MjIyZiwgXCJDb250b3VySW50ZWdyYWw7XCI6MHgyMjJlLFxyXG4gIFwiQ29wZjtcIjoweDIxMDIsIFwiQ29wcm9kdWN0O1wiOjB4MjIxMCxcclxuICBcIkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWw7XCI6MHgyMjMzLCBcIkNyb3NzO1wiOjB4MmEyZixcclxuICBcIkNzY3I7XCI6WzB4ZDgzNSwweGRjOWVdLCBcIkN1cDtcIjoweDIyZDMsXHJcbiAgXCJDdXBDYXA7XCI6MHgyMjRkLCBcIkREO1wiOjB4MjE0NSxcclxuICBcIkREb3RyYWhkO1wiOjB4MjkxMSwgXCJESmN5O1wiOjB4NDAyLFxyXG4gIFwiRFNjeTtcIjoweDQwNSwgXCJEWmN5O1wiOjB4NDBmLFxyXG4gIFwiRGFnZ2VyO1wiOjB4MjAyMSwgXCJEYXJyO1wiOjB4MjFhMSxcclxuICBcIkRhc2h2O1wiOjB4MmFlNCwgXCJEY2Fyb247XCI6MHgxMGUsXHJcbiAgXCJEY3k7XCI6MHg0MTQsIFwiRGVsO1wiOjB4MjIwNyxcclxuICBcIkRlbHRhO1wiOjB4Mzk0LCBcIkRmcjtcIjpbMHhkODM1LDB4ZGQwN10sXHJcbiAgXCJEaWFjcml0aWNhbEFjdXRlO1wiOjB4YjQsIFwiRGlhY3JpdGljYWxEb3Q7XCI6MHgyZDksXHJcbiAgXCJEaWFjcml0aWNhbERvdWJsZUFjdXRlO1wiOjB4MmRkLCBcIkRpYWNyaXRpY2FsR3JhdmU7XCI6MHg2MCxcclxuICBcIkRpYWNyaXRpY2FsVGlsZGU7XCI6MHgyZGMsIFwiRGlhbW9uZDtcIjoweDIyYzQsXHJcbiAgXCJEaWZmZXJlbnRpYWxEO1wiOjB4MjE0NiwgXCJEb3BmO1wiOlsweGQ4MzUsMHhkZDNiXSxcclxuICBcIkRvdDtcIjoweGE4LCBcIkRvdERvdDtcIjoweDIwZGMsXHJcbiAgXCJEb3RFcXVhbDtcIjoweDIyNTAsIFwiRG91YmxlQ29udG91ckludGVncmFsO1wiOjB4MjIyZixcclxuICBcIkRvdWJsZURvdDtcIjoweGE4LCBcIkRvdWJsZURvd25BcnJvdztcIjoweDIxZDMsXHJcbiAgXCJEb3VibGVMZWZ0QXJyb3c7XCI6MHgyMWQwLCBcIkRvdWJsZUxlZnRSaWdodEFycm93O1wiOjB4MjFkNCxcclxuICBcIkRvdWJsZUxlZnRUZWU7XCI6MHgyYWU0LCBcIkRvdWJsZUxvbmdMZWZ0QXJyb3c7XCI6MHgyN2Y4LFxyXG4gIFwiRG91YmxlTG9uZ0xlZnRSaWdodEFycm93O1wiOjB4MjdmYSwgXCJEb3VibGVMb25nUmlnaHRBcnJvdztcIjoweDI3ZjksXHJcbiAgXCJEb3VibGVSaWdodEFycm93O1wiOjB4MjFkMiwgXCJEb3VibGVSaWdodFRlZTtcIjoweDIyYTgsXHJcbiAgXCJEb3VibGVVcEFycm93O1wiOjB4MjFkMSwgXCJEb3VibGVVcERvd25BcnJvdztcIjoweDIxZDUsXHJcbiAgXCJEb3VibGVWZXJ0aWNhbEJhcjtcIjoweDIyMjUsIFwiRG93bkFycm93O1wiOjB4MjE5MyxcclxuICBcIkRvd25BcnJvd0JhcjtcIjoweDI5MTMsIFwiRG93bkFycm93VXBBcnJvdztcIjoweDIxZjUsXHJcbiAgXCJEb3duQnJldmU7XCI6MHgzMTEsIFwiRG93bkxlZnRSaWdodFZlY3RvcjtcIjoweDI5NTAsXHJcbiAgXCJEb3duTGVmdFRlZVZlY3RvcjtcIjoweDI5NWUsIFwiRG93bkxlZnRWZWN0b3I7XCI6MHgyMWJkLFxyXG4gIFwiRG93bkxlZnRWZWN0b3JCYXI7XCI6MHgyOTU2LCBcIkRvd25SaWdodFRlZVZlY3RvcjtcIjoweDI5NWYsXHJcbiAgXCJEb3duUmlnaHRWZWN0b3I7XCI6MHgyMWMxLCBcIkRvd25SaWdodFZlY3RvckJhcjtcIjoweDI5NTcsXHJcbiAgXCJEb3duVGVlO1wiOjB4MjJhNCwgXCJEb3duVGVlQXJyb3c7XCI6MHgyMWE3LFxyXG4gIFwiRG93bmFycm93O1wiOjB4MjFkMywgXCJEc2NyO1wiOlsweGQ4MzUsMHhkYzlmXSxcclxuICBcIkRzdHJvaztcIjoweDExMCwgXCJFTkc7XCI6MHgxNGEsXHJcbiAgXCJFVEhcIjoweGQwLCBcIkVUSDtcIjoweGQwLFxyXG4gIFwiRWFjdXRlXCI6MHhjOSwgXCJFYWN1dGU7XCI6MHhjOSxcclxuICBcIkVjYXJvbjtcIjoweDExYSwgXCJFY2lyY1wiOjB4Y2EsXHJcbiAgXCJFY2lyYztcIjoweGNhLCBcIkVjeTtcIjoweDQyZCxcclxuICBcIkVkb3Q7XCI6MHgxMTYsIFwiRWZyO1wiOlsweGQ4MzUsMHhkZDA4XSxcclxuICBcIkVncmF2ZVwiOjB4YzgsIFwiRWdyYXZlO1wiOjB4YzgsXHJcbiAgXCJFbGVtZW50O1wiOjB4MjIwOCwgXCJFbWFjcjtcIjoweDExMixcclxuICBcIkVtcHR5U21hbGxTcXVhcmU7XCI6MHgyNWZiLCBcIkVtcHR5VmVyeVNtYWxsU3F1YXJlO1wiOjB4MjVhYixcclxuICBcIkVvZ29uO1wiOjB4MTE4LCBcIkVvcGY7XCI6WzB4ZDgzNSwweGRkM2NdLFxyXG4gIFwiRXBzaWxvbjtcIjoweDM5NSwgXCJFcXVhbDtcIjoweDJhNzUsXHJcbiAgXCJFcXVhbFRpbGRlO1wiOjB4MjI0MiwgXCJFcXVpbGlicml1bTtcIjoweDIxY2MsXHJcbiAgXCJFc2NyO1wiOjB4MjEzMCwgXCJFc2ltO1wiOjB4MmE3MyxcclxuICBcIkV0YTtcIjoweDM5NywgXCJFdW1sXCI6MHhjYixcclxuICBcIkV1bWw7XCI6MHhjYiwgXCJFeGlzdHM7XCI6MHgyMjAzLFxyXG4gIFwiRXhwb25lbnRpYWxFO1wiOjB4MjE0NywgXCJGY3k7XCI6MHg0MjQsXHJcbiAgXCJGZnI7XCI6WzB4ZDgzNSwweGRkMDldLCBcIkZpbGxlZFNtYWxsU3F1YXJlO1wiOjB4MjVmYyxcclxuICBcIkZpbGxlZFZlcnlTbWFsbFNxdWFyZTtcIjoweDI1YWEsIFwiRm9wZjtcIjpbMHhkODM1LDB4ZGQzZF0sXHJcbiAgXCJGb3JBbGw7XCI6MHgyMjAwLCBcIkZvdXJpZXJ0cmY7XCI6MHgyMTMxLFxyXG4gIFwiRnNjcjtcIjoweDIxMzEsIFwiR0pjeTtcIjoweDQwMyxcclxuICBcIkdUXCI6MHgzZSwgXCJHVDtcIjoweDNlLFxyXG4gIFwiR2FtbWE7XCI6MHgzOTMsIFwiR2FtbWFkO1wiOjB4M2RjLFxyXG4gIFwiR2JyZXZlO1wiOjB4MTFlLCBcIkdjZWRpbDtcIjoweDEyMixcclxuICBcIkdjaXJjO1wiOjB4MTFjLCBcIkdjeTtcIjoweDQxMyxcclxuICBcIkdkb3Q7XCI6MHgxMjAsIFwiR2ZyO1wiOlsweGQ4MzUsMHhkZDBhXSxcclxuICBcIkdnO1wiOjB4MjJkOSwgXCJHb3BmO1wiOlsweGQ4MzUsMHhkZDNlXSxcclxuICBcIkdyZWF0ZXJFcXVhbDtcIjoweDIyNjUsIFwiR3JlYXRlckVxdWFsTGVzcztcIjoweDIyZGIsXHJcbiAgXCJHcmVhdGVyRnVsbEVxdWFsO1wiOjB4MjI2NywgXCJHcmVhdGVyR3JlYXRlcjtcIjoweDJhYTIsXHJcbiAgXCJHcmVhdGVyTGVzcztcIjoweDIyNzcsIFwiR3JlYXRlclNsYW50RXF1YWw7XCI6MHgyYTdlLFxyXG4gIFwiR3JlYXRlclRpbGRlO1wiOjB4MjI3MywgXCJHc2NyO1wiOlsweGQ4MzUsMHhkY2EyXSxcclxuICBcIkd0O1wiOjB4MjI2YiwgXCJIQVJEY3k7XCI6MHg0MmEsXHJcbiAgXCJIYWNlaztcIjoweDJjNywgXCJIYXQ7XCI6MHg1ZSxcclxuICBcIkhjaXJjO1wiOjB4MTI0LCBcIkhmcjtcIjoweDIxMGMsXHJcbiAgXCJIaWxiZXJ0U3BhY2U7XCI6MHgyMTBiLCBcIkhvcGY7XCI6MHgyMTBkLFxyXG4gIFwiSG9yaXpvbnRhbExpbmU7XCI6MHgyNTAwLCBcIkhzY3I7XCI6MHgyMTBiLFxyXG4gIFwiSHN0cm9rO1wiOjB4MTI2LCBcIkh1bXBEb3duSHVtcDtcIjoweDIyNGUsXHJcbiAgXCJIdW1wRXF1YWw7XCI6MHgyMjRmLCBcIklFY3k7XCI6MHg0MTUsXHJcbiAgXCJJSmxpZztcIjoweDEzMiwgXCJJT2N5O1wiOjB4NDAxLFxyXG4gIFwiSWFjdXRlXCI6MHhjZCwgXCJJYWN1dGU7XCI6MHhjZCxcclxuICBcIkljaXJjXCI6MHhjZSwgXCJJY2lyYztcIjoweGNlLFxyXG4gIFwiSWN5O1wiOjB4NDE4LCBcIklkb3Q7XCI6MHgxMzAsXHJcbiAgXCJJZnI7XCI6MHgyMTExLCBcIklncmF2ZVwiOjB4Y2MsXHJcbiAgXCJJZ3JhdmU7XCI6MHhjYywgXCJJbTtcIjoweDIxMTEsXHJcbiAgXCJJbWFjcjtcIjoweDEyYSwgXCJJbWFnaW5hcnlJO1wiOjB4MjE0OCxcclxuICBcIkltcGxpZXM7XCI6MHgyMWQyLCBcIkludDtcIjoweDIyMmMsXHJcbiAgXCJJbnRlZ3JhbDtcIjoweDIyMmIsIFwiSW50ZXJzZWN0aW9uO1wiOjB4MjJjMixcclxuICBcIkludmlzaWJsZUNvbW1hO1wiOjB4MjA2MywgXCJJbnZpc2libGVUaW1lcztcIjoweDIwNjIsXHJcbiAgXCJJb2dvbjtcIjoweDEyZSwgXCJJb3BmO1wiOlsweGQ4MzUsMHhkZDQwXSxcclxuICBcIklvdGE7XCI6MHgzOTksIFwiSXNjcjtcIjoweDIxMTAsXHJcbiAgXCJJdGlsZGU7XCI6MHgxMjgsIFwiSXVrY3k7XCI6MHg0MDYsXHJcbiAgXCJJdW1sXCI6MHhjZiwgXCJJdW1sO1wiOjB4Y2YsXHJcbiAgXCJKY2lyYztcIjoweDEzNCwgXCJKY3k7XCI6MHg0MTksXHJcbiAgXCJKZnI7XCI6WzB4ZDgzNSwweGRkMGRdLCBcIkpvcGY7XCI6WzB4ZDgzNSwweGRkNDFdLFxyXG4gIFwiSnNjcjtcIjpbMHhkODM1LDB4ZGNhNV0sIFwiSnNlcmN5O1wiOjB4NDA4LFxyXG4gIFwiSnVrY3k7XCI6MHg0MDQsIFwiS0hjeTtcIjoweDQyNSxcclxuICBcIktKY3k7XCI6MHg0MGMsIFwiS2FwcGE7XCI6MHgzOWEsXHJcbiAgXCJLY2VkaWw7XCI6MHgxMzYsIFwiS2N5O1wiOjB4NDFhLFxyXG4gIFwiS2ZyO1wiOlsweGQ4MzUsMHhkZDBlXSwgXCJLb3BmO1wiOlsweGQ4MzUsMHhkZDQyXSxcclxuICBcIktzY3I7XCI6WzB4ZDgzNSwweGRjYTZdLCBcIkxKY3k7XCI6MHg0MDksXHJcbiAgXCJMVFwiOjB4M2MsIFwiTFQ7XCI6MHgzYyxcclxuICBcIkxhY3V0ZTtcIjoweDEzOSwgXCJMYW1iZGE7XCI6MHgzOWIsXHJcbiAgXCJMYW5nO1wiOjB4MjdlYSwgXCJMYXBsYWNldHJmO1wiOjB4MjExMixcclxuICBcIkxhcnI7XCI6MHgyMTllLCBcIkxjYXJvbjtcIjoweDEzZCxcclxuICBcIkxjZWRpbDtcIjoweDEzYiwgXCJMY3k7XCI6MHg0MWIsXHJcbiAgXCJMZWZ0QW5nbGVCcmFja2V0O1wiOjB4MjdlOCwgXCJMZWZ0QXJyb3c7XCI6MHgyMTkwLFxyXG4gIFwiTGVmdEFycm93QmFyO1wiOjB4MjFlNCwgXCJMZWZ0QXJyb3dSaWdodEFycm93O1wiOjB4MjFjNixcclxuICBcIkxlZnRDZWlsaW5nO1wiOjB4MjMwOCwgXCJMZWZ0RG91YmxlQnJhY2tldDtcIjoweDI3ZTYsXHJcbiAgXCJMZWZ0RG93blRlZVZlY3RvcjtcIjoweDI5NjEsIFwiTGVmdERvd25WZWN0b3I7XCI6MHgyMWMzLFxyXG4gIFwiTGVmdERvd25WZWN0b3JCYXI7XCI6MHgyOTU5LCBcIkxlZnRGbG9vcjtcIjoweDIzMGEsXHJcbiAgXCJMZWZ0UmlnaHRBcnJvdztcIjoweDIxOTQsIFwiTGVmdFJpZ2h0VmVjdG9yO1wiOjB4Mjk0ZSxcclxuICBcIkxlZnRUZWU7XCI6MHgyMmEzLCBcIkxlZnRUZWVBcnJvdztcIjoweDIxYTQsXHJcbiAgXCJMZWZ0VGVlVmVjdG9yO1wiOjB4Mjk1YSwgXCJMZWZ0VHJpYW5nbGU7XCI6MHgyMmIyLFxyXG4gIFwiTGVmdFRyaWFuZ2xlQmFyO1wiOjB4MjljZiwgXCJMZWZ0VHJpYW5nbGVFcXVhbDtcIjoweDIyYjQsXHJcbiAgXCJMZWZ0VXBEb3duVmVjdG9yO1wiOjB4Mjk1MSwgXCJMZWZ0VXBUZWVWZWN0b3I7XCI6MHgyOTYwLFxyXG4gIFwiTGVmdFVwVmVjdG9yO1wiOjB4MjFiZiwgXCJMZWZ0VXBWZWN0b3JCYXI7XCI6MHgyOTU4LFxyXG4gIFwiTGVmdFZlY3RvcjtcIjoweDIxYmMsIFwiTGVmdFZlY3RvckJhcjtcIjoweDI5NTIsXHJcbiAgXCJMZWZ0YXJyb3c7XCI6MHgyMWQwLCBcIkxlZnRyaWdodGFycm93O1wiOjB4MjFkNCxcclxuICBcIkxlc3NFcXVhbEdyZWF0ZXI7XCI6MHgyMmRhLCBcIkxlc3NGdWxsRXF1YWw7XCI6MHgyMjY2LFxyXG4gIFwiTGVzc0dyZWF0ZXI7XCI6MHgyMjc2LCBcIkxlc3NMZXNzO1wiOjB4MmFhMSxcclxuICBcIkxlc3NTbGFudEVxdWFsO1wiOjB4MmE3ZCwgXCJMZXNzVGlsZGU7XCI6MHgyMjcyLFxyXG4gIFwiTGZyO1wiOlsweGQ4MzUsMHhkZDBmXSwgXCJMbDtcIjoweDIyZDgsXHJcbiAgXCJMbGVmdGFycm93O1wiOjB4MjFkYSwgXCJMbWlkb3Q7XCI6MHgxM2YsXHJcbiAgXCJMb25nTGVmdEFycm93O1wiOjB4MjdmNSwgXCJMb25nTGVmdFJpZ2h0QXJyb3c7XCI6MHgyN2Y3LFxyXG4gIFwiTG9uZ1JpZ2h0QXJyb3c7XCI6MHgyN2Y2LCBcIkxvbmdsZWZ0YXJyb3c7XCI6MHgyN2Y4LFxyXG4gIFwiTG9uZ2xlZnRyaWdodGFycm93O1wiOjB4MjdmYSwgXCJMb25ncmlnaHRhcnJvdztcIjoweDI3ZjksXHJcbiAgXCJMb3BmO1wiOlsweGQ4MzUsMHhkZDQzXSwgXCJMb3dlckxlZnRBcnJvdztcIjoweDIxOTksXHJcbiAgXCJMb3dlclJpZ2h0QXJyb3c7XCI6MHgyMTk4LCBcIkxzY3I7XCI6MHgyMTEyLFxyXG4gIFwiTHNoO1wiOjB4MjFiMCwgXCJMc3Ryb2s7XCI6MHgxNDEsXHJcbiAgXCJMdDtcIjoweDIyNmEsIFwiTWFwO1wiOjB4MjkwNSxcclxuICBcIk1jeTtcIjoweDQxYywgXCJNZWRpdW1TcGFjZTtcIjoweDIwNWYsXHJcbiAgXCJNZWxsaW50cmY7XCI6MHgyMTMzLCBcIk1mcjtcIjpbMHhkODM1LDB4ZGQxMF0sXHJcbiAgXCJNaW51c1BsdXM7XCI6MHgyMjEzLCBcIk1vcGY7XCI6WzB4ZDgzNSwweGRkNDRdLFxyXG4gIFwiTXNjcjtcIjoweDIxMzMsIFwiTXU7XCI6MHgzOWMsXHJcbiAgXCJOSmN5O1wiOjB4NDBhLCBcIk5hY3V0ZTtcIjoweDE0MyxcclxuICBcIk5jYXJvbjtcIjoweDE0NywgXCJOY2VkaWw7XCI6MHgxNDUsXHJcbiAgXCJOY3k7XCI6MHg0MWQsIFwiTmVnYXRpdmVNZWRpdW1TcGFjZTtcIjoweDIwMGIsXHJcbiAgXCJOZWdhdGl2ZVRoaWNrU3BhY2U7XCI6MHgyMDBiLCBcIk5lZ2F0aXZlVGhpblNwYWNlO1wiOjB4MjAwYixcclxuICBcIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZTtcIjoweDIwMGIsIFwiTmVzdGVkR3JlYXRlckdyZWF0ZXI7XCI6MHgyMjZiLFxyXG4gIFwiTmVzdGVkTGVzc0xlc3M7XCI6MHgyMjZhLCBcIk5ld0xpbmU7XCI6MHhhLFxyXG4gIFwiTmZyO1wiOlsweGQ4MzUsMHhkZDExXSwgXCJOb0JyZWFrO1wiOjB4MjA2MCxcclxuICBcIk5vbkJyZWFraW5nU3BhY2U7XCI6MHhhMCwgXCJOb3BmO1wiOjB4MjExNSxcclxuICBcIk5vdDtcIjoweDJhZWMsIFwiTm90Q29uZ3J1ZW50O1wiOjB4MjI2MixcclxuICBcIk5vdEN1cENhcDtcIjoweDIyNmQsIFwiTm90RG91YmxlVmVydGljYWxCYXI7XCI6MHgyMjI2LFxyXG4gIFwiTm90RWxlbWVudDtcIjoweDIyMDksIFwiTm90RXF1YWw7XCI6MHgyMjYwLFxyXG4gIFwiTm90RXF1YWxUaWxkZTtcIjpbMHgyMjQyLDB4MzM4XSwgXCJOb3RFeGlzdHM7XCI6MHgyMjA0LFxyXG4gIFwiTm90R3JlYXRlcjtcIjoweDIyNmYsIFwiTm90R3JlYXRlckVxdWFsO1wiOjB4MjI3MSxcclxuICBcIk5vdEdyZWF0ZXJGdWxsRXF1YWw7XCI6WzB4MjI2NywweDMzOF0sIFwiTm90R3JlYXRlckdyZWF0ZXI7XCI6WzB4MjI2YiwweDMzOF0sXHJcbiAgXCJOb3RHcmVhdGVyTGVzcztcIjoweDIyNzksIFwiTm90R3JlYXRlclNsYW50RXF1YWw7XCI6WzB4MmE3ZSwweDMzOF0sXHJcbiAgXCJOb3RHcmVhdGVyVGlsZGU7XCI6MHgyMjc1LCBcIk5vdEh1bXBEb3duSHVtcDtcIjpbMHgyMjRlLDB4MzM4XSxcclxuICBcIk5vdEh1bXBFcXVhbDtcIjpbMHgyMjRmLDB4MzM4XSwgXCJOb3RMZWZ0VHJpYW5nbGU7XCI6MHgyMmVhLFxyXG4gIFwiTm90TGVmdFRyaWFuZ2xlQmFyO1wiOlsweDI5Y2YsMHgzMzhdLCBcIk5vdExlZnRUcmlhbmdsZUVxdWFsO1wiOjB4MjJlYyxcclxuICBcIk5vdExlc3M7XCI6MHgyMjZlLCBcIk5vdExlc3NFcXVhbDtcIjoweDIyNzAsXHJcbiAgXCJOb3RMZXNzR3JlYXRlcjtcIjoweDIyNzgsIFwiTm90TGVzc0xlc3M7XCI6WzB4MjI2YSwweDMzOF0sXHJcbiAgXCJOb3RMZXNzU2xhbnRFcXVhbDtcIjpbMHgyYTdkLDB4MzM4XSwgXCJOb3RMZXNzVGlsZGU7XCI6MHgyMjc0LFxyXG4gIFwiTm90TmVzdGVkR3JlYXRlckdyZWF0ZXI7XCI6WzB4MmFhMiwweDMzOF0sIFwiTm90TmVzdGVkTGVzc0xlc3M7XCI6WzB4MmFhMSwweDMzOF0sXHJcbiAgXCJOb3RQcmVjZWRlcztcIjoweDIyODAsIFwiTm90UHJlY2VkZXNFcXVhbDtcIjpbMHgyYWFmLDB4MzM4XSxcclxuICBcIk5vdFByZWNlZGVzU2xhbnRFcXVhbDtcIjoweDIyZTAsIFwiTm90UmV2ZXJzZUVsZW1lbnQ7XCI6MHgyMjBjLFxyXG4gIFwiTm90UmlnaHRUcmlhbmdsZTtcIjoweDIyZWIsIFwiTm90UmlnaHRUcmlhbmdsZUJhcjtcIjpbMHgyOWQwLDB4MzM4XSxcclxuICBcIk5vdFJpZ2h0VHJpYW5nbGVFcXVhbDtcIjoweDIyZWQsIFwiTm90U3F1YXJlU3Vic2V0O1wiOlsweDIyOGYsMHgzMzhdLFxyXG4gIFwiTm90U3F1YXJlU3Vic2V0RXF1YWw7XCI6MHgyMmUyLCBcIk5vdFNxdWFyZVN1cGVyc2V0O1wiOlsweDIyOTAsMHgzMzhdLFxyXG4gIFwiTm90U3F1YXJlU3VwZXJzZXRFcXVhbDtcIjoweDIyZTMsIFwiTm90U3Vic2V0O1wiOlsweDIyODIsMHgyMGQyXSxcclxuICBcIk5vdFN1YnNldEVxdWFsO1wiOjB4MjI4OCwgXCJOb3RTdWNjZWVkcztcIjoweDIyODEsXHJcbiAgXCJOb3RTdWNjZWVkc0VxdWFsO1wiOlsweDJhYjAsMHgzMzhdLCBcIk5vdFN1Y2NlZWRzU2xhbnRFcXVhbDtcIjoweDIyZTEsXHJcbiAgXCJOb3RTdWNjZWVkc1RpbGRlO1wiOlsweDIyN2YsMHgzMzhdLCBcIk5vdFN1cGVyc2V0O1wiOlsweDIyODMsMHgyMGQyXSxcclxuICBcIk5vdFN1cGVyc2V0RXF1YWw7XCI6MHgyMjg5LCBcIk5vdFRpbGRlO1wiOjB4MjI0MSxcclxuICBcIk5vdFRpbGRlRXF1YWw7XCI6MHgyMjQ0LCBcIk5vdFRpbGRlRnVsbEVxdWFsO1wiOjB4MjI0NyxcclxuICBcIk5vdFRpbGRlVGlsZGU7XCI6MHgyMjQ5LCBcIk5vdFZlcnRpY2FsQmFyO1wiOjB4MjIyNCxcclxuICBcIk5zY3I7XCI6WzB4ZDgzNSwweGRjYTldLCBcIk50aWxkZVwiOjB4ZDEsXHJcbiAgXCJOdGlsZGU7XCI6MHhkMSwgXCJOdTtcIjoweDM5ZCxcclxuICBcIk9FbGlnO1wiOjB4MTUyLCBcIk9hY3V0ZVwiOjB4ZDMsXHJcbiAgXCJPYWN1dGU7XCI6MHhkMywgXCJPY2lyY1wiOjB4ZDQsXHJcbiAgXCJPY2lyYztcIjoweGQ0LCBcIk9jeTtcIjoweDQxZSxcclxuICBcIk9kYmxhYztcIjoweDE1MCwgXCJPZnI7XCI6WzB4ZDgzNSwweGRkMTJdLFxyXG4gIFwiT2dyYXZlXCI6MHhkMiwgXCJPZ3JhdmU7XCI6MHhkMixcclxuICBcIk9tYWNyO1wiOjB4MTRjLCBcIk9tZWdhO1wiOjB4M2E5LFxyXG4gIFwiT21pY3JvbjtcIjoweDM5ZiwgXCJPb3BmO1wiOlsweGQ4MzUsMHhkZDQ2XSxcclxuICBcIk9wZW5DdXJseURvdWJsZVF1b3RlO1wiOjB4MjAxYywgXCJPcGVuQ3VybHlRdW90ZTtcIjoweDIwMTgsXHJcbiAgXCJPcjtcIjoweDJhNTQsIFwiT3NjcjtcIjpbMHhkODM1LDB4ZGNhYV0sXHJcbiAgXCJPc2xhc2hcIjoweGQ4LCBcIk9zbGFzaDtcIjoweGQ4LFxyXG4gIFwiT3RpbGRlXCI6MHhkNSwgXCJPdGlsZGU7XCI6MHhkNSxcclxuICBcIk90aW1lcztcIjoweDJhMzcsIFwiT3VtbFwiOjB4ZDYsXHJcbiAgXCJPdW1sO1wiOjB4ZDYsIFwiT3ZlckJhcjtcIjoweDIwM2UsXHJcbiAgXCJPdmVyQnJhY2U7XCI6MHgyM2RlLCBcIk92ZXJCcmFja2V0O1wiOjB4MjNiNCxcclxuICBcIk92ZXJQYXJlbnRoZXNpcztcIjoweDIzZGMsIFwiUGFydGlhbEQ7XCI6MHgyMjAyLFxyXG4gIFwiUGN5O1wiOjB4NDFmLCBcIlBmcjtcIjpbMHhkODM1LDB4ZGQxM10sXHJcbiAgXCJQaGk7XCI6MHgzYTYsIFwiUGk7XCI6MHgzYTAsXHJcbiAgXCJQbHVzTWludXM7XCI6MHhiMSwgXCJQb2luY2FyZXBsYW5lO1wiOjB4MjEwYyxcclxuICBcIlBvcGY7XCI6MHgyMTE5LCBcIlByO1wiOjB4MmFiYixcclxuICBcIlByZWNlZGVzO1wiOjB4MjI3YSwgXCJQcmVjZWRlc0VxdWFsO1wiOjB4MmFhZixcclxuICBcIlByZWNlZGVzU2xhbnRFcXVhbDtcIjoweDIyN2MsIFwiUHJlY2VkZXNUaWxkZTtcIjoweDIyN2UsXHJcbiAgXCJQcmltZTtcIjoweDIwMzMsIFwiUHJvZHVjdDtcIjoweDIyMGYsXHJcbiAgXCJQcm9wb3J0aW9uO1wiOjB4MjIzNywgXCJQcm9wb3J0aW9uYWw7XCI6MHgyMjFkLFxyXG4gIFwiUHNjcjtcIjpbMHhkODM1LDB4ZGNhYl0sIFwiUHNpO1wiOjB4M2E4LFxyXG4gIFwiUVVPVFwiOjB4MjIsIFwiUVVPVDtcIjoweDIyLFxyXG4gIFwiUWZyO1wiOlsweGQ4MzUsMHhkZDE0XSwgXCJRb3BmO1wiOjB4MjExYSxcclxuICBcIlFzY3I7XCI6WzB4ZDgzNSwweGRjYWNdLCBcIlJCYXJyO1wiOjB4MjkxMCxcclxuICBcIlJFR1wiOjB4YWUsIFwiUkVHO1wiOjB4YWUsXHJcbiAgXCJSYWN1dGU7XCI6MHgxNTQsIFwiUmFuZztcIjoweDI3ZWIsXHJcbiAgXCJSYXJyO1wiOjB4MjFhMCwgXCJSYXJydGw7XCI6MHgyOTE2LFxyXG4gIFwiUmNhcm9uO1wiOjB4MTU4LCBcIlJjZWRpbDtcIjoweDE1NixcclxuICBcIlJjeTtcIjoweDQyMCwgXCJSZTtcIjoweDIxMWMsXHJcbiAgXCJSZXZlcnNlRWxlbWVudDtcIjoweDIyMGIsIFwiUmV2ZXJzZUVxdWlsaWJyaXVtO1wiOjB4MjFjYixcclxuICBcIlJldmVyc2VVcEVxdWlsaWJyaXVtO1wiOjB4Mjk2ZiwgXCJSZnI7XCI6MHgyMTFjLFxyXG4gIFwiUmhvO1wiOjB4M2ExLCBcIlJpZ2h0QW5nbGVCcmFja2V0O1wiOjB4MjdlOSxcclxuICBcIlJpZ2h0QXJyb3c7XCI6MHgyMTkyLCBcIlJpZ2h0QXJyb3dCYXI7XCI6MHgyMWU1LFxyXG4gIFwiUmlnaHRBcnJvd0xlZnRBcnJvdztcIjoweDIxYzQsIFwiUmlnaHRDZWlsaW5nO1wiOjB4MjMwOSxcclxuICBcIlJpZ2h0RG91YmxlQnJhY2tldDtcIjoweDI3ZTcsIFwiUmlnaHREb3duVGVlVmVjdG9yO1wiOjB4Mjk1ZCxcclxuICBcIlJpZ2h0RG93blZlY3RvcjtcIjoweDIxYzIsIFwiUmlnaHREb3duVmVjdG9yQmFyO1wiOjB4Mjk1NSxcclxuICBcIlJpZ2h0Rmxvb3I7XCI6MHgyMzBiLCBcIlJpZ2h0VGVlO1wiOjB4MjJhMixcclxuICBcIlJpZ2h0VGVlQXJyb3c7XCI6MHgyMWE2LCBcIlJpZ2h0VGVlVmVjdG9yO1wiOjB4Mjk1YixcclxuICBcIlJpZ2h0VHJpYW5nbGU7XCI6MHgyMmIzLCBcIlJpZ2h0VHJpYW5nbGVCYXI7XCI6MHgyOWQwLFxyXG4gIFwiUmlnaHRUcmlhbmdsZUVxdWFsO1wiOjB4MjJiNSwgXCJSaWdodFVwRG93blZlY3RvcjtcIjoweDI5NGYsXHJcbiAgXCJSaWdodFVwVGVlVmVjdG9yO1wiOjB4Mjk1YywgXCJSaWdodFVwVmVjdG9yO1wiOjB4MjFiZSxcclxuICBcIlJpZ2h0VXBWZWN0b3JCYXI7XCI6MHgyOTU0LCBcIlJpZ2h0VmVjdG9yO1wiOjB4MjFjMCxcclxuICBcIlJpZ2h0VmVjdG9yQmFyO1wiOjB4Mjk1MywgXCJSaWdodGFycm93O1wiOjB4MjFkMixcclxuICBcIlJvcGY7XCI6MHgyMTFkLCBcIlJvdW5kSW1wbGllcztcIjoweDI5NzAsXHJcbiAgXCJScmlnaHRhcnJvdztcIjoweDIxZGIsIFwiUnNjcjtcIjoweDIxMWIsXHJcbiAgXCJSc2g7XCI6MHgyMWIxLCBcIlJ1bGVEZWxheWVkO1wiOjB4MjlmNCxcclxuICBcIlNIQ0hjeTtcIjoweDQyOSwgXCJTSGN5O1wiOjB4NDI4LFxyXG4gIFwiU09GVGN5O1wiOjB4NDJjLCBcIlNhY3V0ZTtcIjoweDE1YSxcclxuICBcIlNjO1wiOjB4MmFiYywgXCJTY2Fyb247XCI6MHgxNjAsXHJcbiAgXCJTY2VkaWw7XCI6MHgxNWUsIFwiU2NpcmM7XCI6MHgxNWMsXHJcbiAgXCJTY3k7XCI6MHg0MjEsIFwiU2ZyO1wiOlsweGQ4MzUsMHhkZDE2XSxcclxuICBcIlNob3J0RG93bkFycm93O1wiOjB4MjE5MywgXCJTaG9ydExlZnRBcnJvdztcIjoweDIxOTAsXHJcbiAgXCJTaG9ydFJpZ2h0QXJyb3c7XCI6MHgyMTkyLCBcIlNob3J0VXBBcnJvdztcIjoweDIxOTEsXHJcbiAgXCJTaWdtYTtcIjoweDNhMywgXCJTbWFsbENpcmNsZTtcIjoweDIyMTgsXHJcbiAgXCJTb3BmO1wiOlsweGQ4MzUsMHhkZDRhXSwgXCJTcXJ0O1wiOjB4MjIxYSxcclxuICBcIlNxdWFyZTtcIjoweDI1YTEsIFwiU3F1YXJlSW50ZXJzZWN0aW9uO1wiOjB4MjI5MyxcclxuICBcIlNxdWFyZVN1YnNldDtcIjoweDIyOGYsIFwiU3F1YXJlU3Vic2V0RXF1YWw7XCI6MHgyMjkxLFxyXG4gIFwiU3F1YXJlU3VwZXJzZXQ7XCI6MHgyMjkwLCBcIlNxdWFyZVN1cGVyc2V0RXF1YWw7XCI6MHgyMjkyLFxyXG4gIFwiU3F1YXJlVW5pb247XCI6MHgyMjk0LCBcIlNzY3I7XCI6WzB4ZDgzNSwweGRjYWVdLFxyXG4gIFwiU3RhcjtcIjoweDIyYzYsIFwiU3ViO1wiOjB4MjJkMCxcclxuICBcIlN1YnNldDtcIjoweDIyZDAsIFwiU3Vic2V0RXF1YWw7XCI6MHgyMjg2LFxyXG4gIFwiU3VjY2VlZHM7XCI6MHgyMjdiLCBcIlN1Y2NlZWRzRXF1YWw7XCI6MHgyYWIwLFxyXG4gIFwiU3VjY2VlZHNTbGFudEVxdWFsO1wiOjB4MjI3ZCwgXCJTdWNjZWVkc1RpbGRlO1wiOjB4MjI3ZixcclxuICBcIlN1Y2hUaGF0O1wiOjB4MjIwYiwgXCJTdW07XCI6MHgyMjExLFxyXG4gIFwiU3VwO1wiOjB4MjJkMSwgXCJTdXBlcnNldDtcIjoweDIyODMsXHJcbiAgXCJTdXBlcnNldEVxdWFsO1wiOjB4MjI4NywgXCJTdXBzZXQ7XCI6MHgyMmQxLFxyXG4gIFwiVEhPUk5cIjoweGRlLCBcIlRIT1JOO1wiOjB4ZGUsXHJcbiAgXCJUUkFERTtcIjoweDIxMjIsIFwiVFNIY3k7XCI6MHg0MGIsXHJcbiAgXCJUU2N5O1wiOjB4NDI2LCBcIlRhYjtcIjoweDksXHJcbiAgXCJUYXU7XCI6MHgzYTQsIFwiVGNhcm9uO1wiOjB4MTY0LFxyXG4gIFwiVGNlZGlsO1wiOjB4MTYyLCBcIlRjeTtcIjoweDQyMixcclxuICBcIlRmcjtcIjpbMHhkODM1LDB4ZGQxN10sIFwiVGhlcmVmb3JlO1wiOjB4MjIzNCxcclxuICBcIlRoZXRhO1wiOjB4Mzk4LCBcIlRoaWNrU3BhY2U7XCI6WzB4MjA1ZiwweDIwMGFdLFxyXG4gIFwiVGhpblNwYWNlO1wiOjB4MjAwOSwgXCJUaWxkZTtcIjoweDIyM2MsXHJcbiAgXCJUaWxkZUVxdWFsO1wiOjB4MjI0MywgXCJUaWxkZUZ1bGxFcXVhbDtcIjoweDIyNDUsXHJcbiAgXCJUaWxkZVRpbGRlO1wiOjB4MjI0OCwgXCJUb3BmO1wiOlsweGQ4MzUsMHhkZDRiXSxcclxuICBcIlRyaXBsZURvdDtcIjoweDIwZGIsIFwiVHNjcjtcIjpbMHhkODM1LDB4ZGNhZl0sXHJcbiAgXCJUc3Ryb2s7XCI6MHgxNjYsIFwiVWFjdXRlXCI6MHhkYSxcclxuICBcIlVhY3V0ZTtcIjoweGRhLCBcIlVhcnI7XCI6MHgyMTlmLFxyXG4gIFwiVWFycm9jaXI7XCI6MHgyOTQ5LCBcIlVicmN5O1wiOjB4NDBlLFxyXG4gIFwiVWJyZXZlO1wiOjB4MTZjLCBcIlVjaXJjXCI6MHhkYixcclxuICBcIlVjaXJjO1wiOjB4ZGIsIFwiVWN5O1wiOjB4NDIzLFxyXG4gIFwiVWRibGFjO1wiOjB4MTcwLCBcIlVmcjtcIjpbMHhkODM1LDB4ZGQxOF0sXHJcbiAgXCJVZ3JhdmVcIjoweGQ5LCBcIlVncmF2ZTtcIjoweGQ5LFxyXG4gIFwiVW1hY3I7XCI6MHgxNmEsIFwiVW5kZXJCYXI7XCI6MHg1ZixcclxuICBcIlVuZGVyQnJhY2U7XCI6MHgyM2RmLCBcIlVuZGVyQnJhY2tldDtcIjoweDIzYjUsXHJcbiAgXCJVbmRlclBhcmVudGhlc2lzO1wiOjB4MjNkZCwgXCJVbmlvbjtcIjoweDIyYzMsXHJcbiAgXCJVbmlvblBsdXM7XCI6MHgyMjhlLCBcIlVvZ29uO1wiOjB4MTcyLFxyXG4gIFwiVW9wZjtcIjpbMHhkODM1LDB4ZGQ0Y10sIFwiVXBBcnJvdztcIjoweDIxOTEsXHJcbiAgXCJVcEFycm93QmFyO1wiOjB4MjkxMiwgXCJVcEFycm93RG93bkFycm93O1wiOjB4MjFjNSxcclxuICBcIlVwRG93bkFycm93O1wiOjB4MjE5NSwgXCJVcEVxdWlsaWJyaXVtO1wiOjB4Mjk2ZSxcclxuICBcIlVwVGVlO1wiOjB4MjJhNSwgXCJVcFRlZUFycm93O1wiOjB4MjFhNSxcclxuICBcIlVwYXJyb3c7XCI6MHgyMWQxLCBcIlVwZG93bmFycm93O1wiOjB4MjFkNSxcclxuICBcIlVwcGVyTGVmdEFycm93O1wiOjB4MjE5NiwgXCJVcHBlclJpZ2h0QXJyb3c7XCI6MHgyMTk3LFxyXG4gIFwiVXBzaTtcIjoweDNkMiwgXCJVcHNpbG9uO1wiOjB4M2E1LFxyXG4gIFwiVXJpbmc7XCI6MHgxNmUsIFwiVXNjcjtcIjpbMHhkODM1LDB4ZGNiMF0sXHJcbiAgXCJVdGlsZGU7XCI6MHgxNjgsIFwiVXVtbFwiOjB4ZGMsXHJcbiAgXCJVdW1sO1wiOjB4ZGMsIFwiVkRhc2g7XCI6MHgyMmFiLFxyXG4gIFwiVmJhcjtcIjoweDJhZWIsIFwiVmN5O1wiOjB4NDEyLFxyXG4gIFwiVmRhc2g7XCI6MHgyMmE5LCBcIlZkYXNobDtcIjoweDJhZTYsXHJcbiAgXCJWZWU7XCI6MHgyMmMxLCBcIlZlcmJhcjtcIjoweDIwMTYsXHJcbiAgXCJWZXJ0O1wiOjB4MjAxNiwgXCJWZXJ0aWNhbEJhcjtcIjoweDIyMjMsXHJcbiAgXCJWZXJ0aWNhbExpbmU7XCI6MHg3YywgXCJWZXJ0aWNhbFNlcGFyYXRvcjtcIjoweDI3NTgsXHJcbiAgXCJWZXJ0aWNhbFRpbGRlO1wiOjB4MjI0MCwgXCJWZXJ5VGhpblNwYWNlO1wiOjB4MjAwYSxcclxuICBcIlZmcjtcIjpbMHhkODM1LDB4ZGQxOV0sIFwiVm9wZjtcIjpbMHhkODM1LDB4ZGQ0ZF0sXHJcbiAgXCJWc2NyO1wiOlsweGQ4MzUsMHhkY2IxXSwgXCJWdmRhc2g7XCI6MHgyMmFhLFxyXG4gIFwiV2NpcmM7XCI6MHgxNzQsIFwiV2VkZ2U7XCI6MHgyMmMwLFxyXG4gIFwiV2ZyO1wiOlsweGQ4MzUsMHhkZDFhXSwgXCJXb3BmO1wiOlsweGQ4MzUsMHhkZDRlXSxcclxuICBcIldzY3I7XCI6WzB4ZDgzNSwweGRjYjJdLCBcIlhmcjtcIjpbMHhkODM1LDB4ZGQxYl0sXHJcbiAgXCJYaTtcIjoweDM5ZSwgXCJYb3BmO1wiOlsweGQ4MzUsMHhkZDRmXSxcclxuICBcIlhzY3I7XCI6WzB4ZDgzNSwweGRjYjNdLCBcIllBY3k7XCI6MHg0MmYsXHJcbiAgXCJZSWN5O1wiOjB4NDA3LCBcIllVY3k7XCI6MHg0MmUsXHJcbiAgXCJZYWN1dGVcIjoweGRkLCBcIllhY3V0ZTtcIjoweGRkLFxyXG4gIFwiWWNpcmM7XCI6MHgxNzYsIFwiWWN5O1wiOjB4NDJiLFxyXG4gIFwiWWZyO1wiOlsweGQ4MzUsMHhkZDFjXSwgXCJZb3BmO1wiOlsweGQ4MzUsMHhkZDUwXSxcclxuICBcIllzY3I7XCI6WzB4ZDgzNSwweGRjYjRdLCBcIll1bWw7XCI6MHgxNzgsXHJcbiAgXCJaSGN5O1wiOjB4NDE2LCBcIlphY3V0ZTtcIjoweDE3OSxcclxuICBcIlpjYXJvbjtcIjoweDE3ZCwgXCJaY3k7XCI6MHg0MTcsXHJcbiAgXCJaZG90O1wiOjB4MTdiLCBcIlplcm9XaWR0aFNwYWNlO1wiOjB4MjAwYixcclxuICBcIlpldGE7XCI6MHgzOTYsIFwiWmZyO1wiOjB4MjEyOCxcclxuICBcIlpvcGY7XCI6MHgyMTI0LCBcIlpzY3I7XCI6WzB4ZDgzNSwweGRjYjVdLFxyXG4gIFwiYWFjdXRlXCI6MHhlMSwgXCJhYWN1dGU7XCI6MHhlMSxcclxuICBcImFicmV2ZTtcIjoweDEwMywgXCJhYztcIjoweDIyM2UsXHJcbiAgXCJhY0U7XCI6WzB4MjIzZSwweDMzM10sIFwiYWNkO1wiOjB4MjIzZixcclxuICBcImFjaXJjXCI6MHhlMiwgXCJhY2lyYztcIjoweGUyLFxyXG4gIFwiYWN1dGVcIjoweGI0LCBcImFjdXRlO1wiOjB4YjQsXHJcbiAgXCJhY3k7XCI6MHg0MzAsIFwiYWVsaWdcIjoweGU2LFxyXG4gIFwiYWVsaWc7XCI6MHhlNiwgXCJhZjtcIjoweDIwNjEsXHJcbiAgXCJhZnI7XCI6WzB4ZDgzNSwweGRkMWVdLCBcImFncmF2ZVwiOjB4ZTAsXHJcbiAgXCJhZ3JhdmU7XCI6MHhlMCwgXCJhbGVmc3ltO1wiOjB4MjEzNSxcclxuICBcImFsZXBoO1wiOjB4MjEzNSwgXCJhbHBoYTtcIjoweDNiMSxcclxuICBcImFtYWNyO1wiOjB4MTAxLCBcImFtYWxnO1wiOjB4MmEzZixcclxuICBcImFtcFwiOjB4MjYsIFwiYW1wO1wiOjB4MjYsXHJcbiAgXCJhbmQ7XCI6MHgyMjI3LCBcImFuZGFuZDtcIjoweDJhNTUsXHJcbiAgXCJhbmRkO1wiOjB4MmE1YywgXCJhbmRzbG9wZTtcIjoweDJhNTgsXHJcbiAgXCJhbmR2O1wiOjB4MmE1YSwgXCJhbmc7XCI6MHgyMjIwLFxyXG4gIFwiYW5nZTtcIjoweDI5YTQsIFwiYW5nbGU7XCI6MHgyMjIwLFxyXG4gIFwiYW5nbXNkO1wiOjB4MjIyMSwgXCJhbmdtc2RhYTtcIjoweDI5YTgsXHJcbiAgXCJhbmdtc2RhYjtcIjoweDI5YTksIFwiYW5nbXNkYWM7XCI6MHgyOWFhLFxyXG4gIFwiYW5nbXNkYWQ7XCI6MHgyOWFiLCBcImFuZ21zZGFlO1wiOjB4MjlhYyxcclxuICBcImFuZ21zZGFmO1wiOjB4MjlhZCwgXCJhbmdtc2RhZztcIjoweDI5YWUsXHJcbiAgXCJhbmdtc2RhaDtcIjoweDI5YWYsIFwiYW5ncnQ7XCI6MHgyMjFmLFxyXG4gIFwiYW5ncnR2YjtcIjoweDIyYmUsIFwiYW5ncnR2YmQ7XCI6MHgyOTlkLFxyXG4gIFwiYW5nc3BoO1wiOjB4MjIyMiwgXCJhbmdzdDtcIjoweGM1LFxyXG4gIFwiYW5nemFycjtcIjoweDIzN2MsIFwiYW9nb247XCI6MHgxMDUsXHJcbiAgXCJhb3BmO1wiOlsweGQ4MzUsMHhkZDUyXSwgXCJhcDtcIjoweDIyNDgsXHJcbiAgXCJhcEU7XCI6MHgyYTcwLCBcImFwYWNpcjtcIjoweDJhNmYsXHJcbiAgXCJhcGU7XCI6MHgyMjRhLCBcImFwaWQ7XCI6MHgyMjRiLFxyXG4gIFwiYXBvcztcIjoweDI3LCBcImFwcHJveDtcIjoweDIyNDgsXHJcbiAgXCJhcHByb3hlcTtcIjoweDIyNGEsIFwiYXJpbmdcIjoweGU1LFxyXG4gIFwiYXJpbmc7XCI6MHhlNSwgXCJhc2NyO1wiOlsweGQ4MzUsMHhkY2I2XSxcclxuICBcImFzdDtcIjoweDJhLCBcImFzeW1wO1wiOjB4MjI0OCxcclxuICBcImFzeW1wZXE7XCI6MHgyMjRkLCBcImF0aWxkZVwiOjB4ZTMsXHJcbiAgXCJhdGlsZGU7XCI6MHhlMywgXCJhdW1sXCI6MHhlNCxcclxuICBcImF1bWw7XCI6MHhlNCwgXCJhd2NvbmludDtcIjoweDIyMzMsXHJcbiAgXCJhd2ludDtcIjoweDJhMTEsIFwiYk5vdDtcIjoweDJhZWQsXHJcbiAgXCJiYWNrY29uZztcIjoweDIyNGMsIFwiYmFja2Vwc2lsb247XCI6MHgzZjYsXHJcbiAgXCJiYWNrcHJpbWU7XCI6MHgyMDM1LCBcImJhY2tzaW07XCI6MHgyMjNkLFxyXG4gIFwiYmFja3NpbWVxO1wiOjB4MjJjZCwgXCJiYXJ2ZWU7XCI6MHgyMmJkLFxyXG4gIFwiYmFyd2VkO1wiOjB4MjMwNSwgXCJiYXJ3ZWRnZTtcIjoweDIzMDUsXHJcbiAgXCJiYnJrO1wiOjB4MjNiNSwgXCJiYnJrdGJyaztcIjoweDIzYjYsXHJcbiAgXCJiY29uZztcIjoweDIyNGMsIFwiYmN5O1wiOjB4NDMxLFxyXG4gIFwiYmRxdW87XCI6MHgyMDFlLCBcImJlY2F1cztcIjoweDIyMzUsXHJcbiAgXCJiZWNhdXNlO1wiOjB4MjIzNSwgXCJiZW1wdHl2O1wiOjB4MjliMCxcclxuICBcImJlcHNpO1wiOjB4M2Y2LCBcImJlcm5vdTtcIjoweDIxMmMsXHJcbiAgXCJiZXRhO1wiOjB4M2IyLCBcImJldGg7XCI6MHgyMTM2LFxyXG4gIFwiYmV0d2VlbjtcIjoweDIyNmMsIFwiYmZyO1wiOlsweGQ4MzUsMHhkZDFmXSxcclxuICBcImJpZ2NhcDtcIjoweDIyYzIsIFwiYmlnY2lyYztcIjoweDI1ZWYsXHJcbiAgXCJiaWdjdXA7XCI6MHgyMmMzLCBcImJpZ29kb3Q7XCI6MHgyYTAwLFxyXG4gIFwiYmlnb3BsdXM7XCI6MHgyYTAxLCBcImJpZ290aW1lcztcIjoweDJhMDIsXHJcbiAgXCJiaWdzcWN1cDtcIjoweDJhMDYsIFwiYmlnc3RhcjtcIjoweDI2MDUsXHJcbiAgXCJiaWd0cmlhbmdsZWRvd247XCI6MHgyNWJkLCBcImJpZ3RyaWFuZ2xldXA7XCI6MHgyNWIzLFxyXG4gIFwiYmlndXBsdXM7XCI6MHgyYTA0LCBcImJpZ3ZlZTtcIjoweDIyYzEsXHJcbiAgXCJiaWd3ZWRnZTtcIjoweDIyYzAsIFwiYmthcm93O1wiOjB4MjkwZCxcclxuICBcImJsYWNrbG96ZW5nZTtcIjoweDI5ZWIsIFwiYmxhY2tzcXVhcmU7XCI6MHgyNWFhLFxyXG4gIFwiYmxhY2t0cmlhbmdsZTtcIjoweDI1YjQsIFwiYmxhY2t0cmlhbmdsZWRvd247XCI6MHgyNWJlLFxyXG4gIFwiYmxhY2t0cmlhbmdsZWxlZnQ7XCI6MHgyNWMyLCBcImJsYWNrdHJpYW5nbGVyaWdodDtcIjoweDI1YjgsXHJcbiAgXCJibGFuaztcIjoweDI0MjMsIFwiYmxrMTI7XCI6MHgyNTkyLFxyXG4gIFwiYmxrMTQ7XCI6MHgyNTkxLCBcImJsazM0O1wiOjB4MjU5MyxcclxuICBcImJsb2NrO1wiOjB4MjU4OCwgXCJibmU7XCI6WzB4M2QsMHgyMGU1XSxcclxuICBcImJuZXF1aXY7XCI6WzB4MjI2MSwweDIwZTVdLCBcImJub3Q7XCI6MHgyMzEwLFxyXG4gIFwiYm9wZjtcIjpbMHhkODM1LDB4ZGQ1M10sIFwiYm90O1wiOjB4MjJhNSxcclxuICBcImJvdHRvbTtcIjoweDIyYTUsIFwiYm93dGllO1wiOjB4MjJjOCxcclxuICBcImJveERMO1wiOjB4MjU1NywgXCJib3hEUjtcIjoweDI1NTQsXHJcbiAgXCJib3hEbDtcIjoweDI1NTYsIFwiYm94RHI7XCI6MHgyNTUzLFxyXG4gIFwiYm94SDtcIjoweDI1NTAsIFwiYm94SEQ7XCI6MHgyNTY2LFxyXG4gIFwiYm94SFU7XCI6MHgyNTY5LCBcImJveEhkO1wiOjB4MjU2NCxcclxuICBcImJveEh1O1wiOjB4MjU2NywgXCJib3hVTDtcIjoweDI1NWQsXHJcbiAgXCJib3hVUjtcIjoweDI1NWEsIFwiYm94VWw7XCI6MHgyNTVjLFxyXG4gIFwiYm94VXI7XCI6MHgyNTU5LCBcImJveFY7XCI6MHgyNTUxLFxyXG4gIFwiYm94Vkg7XCI6MHgyNTZjLCBcImJveFZMO1wiOjB4MjU2MyxcclxuICBcImJveFZSO1wiOjB4MjU2MCwgXCJib3hWaDtcIjoweDI1NmIsXHJcbiAgXCJib3hWbDtcIjoweDI1NjIsIFwiYm94VnI7XCI6MHgyNTVmLFxyXG4gIFwiYm94Ym94O1wiOjB4MjljOSwgXCJib3hkTDtcIjoweDI1NTUsXHJcbiAgXCJib3hkUjtcIjoweDI1NTIsIFwiYm94ZGw7XCI6MHgyNTEwLFxyXG4gIFwiYm94ZHI7XCI6MHgyNTBjLCBcImJveGg7XCI6MHgyNTAwLFxyXG4gIFwiYm94aEQ7XCI6MHgyNTY1LCBcImJveGhVO1wiOjB4MjU2OCxcclxuICBcImJveGhkO1wiOjB4MjUyYywgXCJib3hodTtcIjoweDI1MzQsXHJcbiAgXCJib3htaW51cztcIjoweDIyOWYsIFwiYm94cGx1cztcIjoweDIyOWUsXHJcbiAgXCJib3h0aW1lcztcIjoweDIyYTAsIFwiYm94dUw7XCI6MHgyNTViLFxyXG4gIFwiYm94dVI7XCI6MHgyNTU4LCBcImJveHVsO1wiOjB4MjUxOCxcclxuICBcImJveHVyO1wiOjB4MjUxNCwgXCJib3h2O1wiOjB4MjUwMixcclxuICBcImJveHZIO1wiOjB4MjU2YSwgXCJib3h2TDtcIjoweDI1NjEsXHJcbiAgXCJib3h2UjtcIjoweDI1NWUsIFwiYm94dmg7XCI6MHgyNTNjLFxyXG4gIFwiYm94dmw7XCI6MHgyNTI0LCBcImJveHZyO1wiOjB4MjUxYyxcclxuICBcImJwcmltZTtcIjoweDIwMzUsIFwiYnJldmU7XCI6MHgyZDgsXHJcbiAgXCJicnZiYXJcIjoweGE2LCBcImJydmJhcjtcIjoweGE2LFxyXG4gIFwiYnNjcjtcIjpbMHhkODM1LDB4ZGNiN10sIFwiYnNlbWk7XCI6MHgyMDRmLFxyXG4gIFwiYnNpbTtcIjoweDIyM2QsIFwiYnNpbWU7XCI6MHgyMmNkLFxyXG4gIFwiYnNvbDtcIjoweDVjLCBcImJzb2xiO1wiOjB4MjljNSxcclxuICBcImJzb2xoc3ViO1wiOjB4MjdjOCwgXCJidWxsO1wiOjB4MjAyMixcclxuICBcImJ1bGxldDtcIjoweDIwMjIsIFwiYnVtcDtcIjoweDIyNGUsXHJcbiAgXCJidW1wRTtcIjoweDJhYWUsIFwiYnVtcGU7XCI6MHgyMjRmLFxyXG4gIFwiYnVtcGVxO1wiOjB4MjI0ZiwgXCJjYWN1dGU7XCI6MHgxMDcsXHJcbiAgXCJjYXA7XCI6MHgyMjI5LCBcImNhcGFuZDtcIjoweDJhNDQsXHJcbiAgXCJjYXBicmN1cDtcIjoweDJhNDksIFwiY2FwY2FwO1wiOjB4MmE0YixcclxuICBcImNhcGN1cDtcIjoweDJhNDcsIFwiY2FwZG90O1wiOjB4MmE0MCxcclxuICBcImNhcHM7XCI6WzB4MjIyOSwweGZlMDBdLCBcImNhcmV0O1wiOjB4MjA0MSxcclxuICBcImNhcm9uO1wiOjB4MmM3LCBcImNjYXBzO1wiOjB4MmE0ZCxcclxuICBcImNjYXJvbjtcIjoweDEwZCwgXCJjY2VkaWxcIjoweGU3LFxyXG4gIFwiY2NlZGlsO1wiOjB4ZTcsIFwiY2NpcmM7XCI6MHgxMDksXHJcbiAgXCJjY3VwcztcIjoweDJhNGMsIFwiY2N1cHNzbTtcIjoweDJhNTAsXHJcbiAgXCJjZG90O1wiOjB4MTBiLCBcImNlZGlsXCI6MHhiOCxcclxuICBcImNlZGlsO1wiOjB4YjgsIFwiY2VtcHR5djtcIjoweDI5YjIsXHJcbiAgXCJjZW50XCI6MHhhMiwgXCJjZW50O1wiOjB4YTIsXHJcbiAgXCJjZW50ZXJkb3Q7XCI6MHhiNywgXCJjZnI7XCI6WzB4ZDgzNSwweGRkMjBdLFxyXG4gIFwiY2hjeTtcIjoweDQ0NywgXCJjaGVjaztcIjoweDI3MTMsXHJcbiAgXCJjaGVja21hcms7XCI6MHgyNzEzLCBcImNoaTtcIjoweDNjNyxcclxuICBcImNpcjtcIjoweDI1Y2IsIFwiY2lyRTtcIjoweDI5YzMsXHJcbiAgXCJjaXJjO1wiOjB4MmM2LCBcImNpcmNlcTtcIjoweDIyNTcsXHJcbiAgXCJjaXJjbGVhcnJvd2xlZnQ7XCI6MHgyMWJhLCBcImNpcmNsZWFycm93cmlnaHQ7XCI6MHgyMWJiLFxyXG4gIFwiY2lyY2xlZFI7XCI6MHhhZSwgXCJjaXJjbGVkUztcIjoweDI0YzgsXHJcbiAgXCJjaXJjbGVkYXN0O1wiOjB4MjI5YiwgXCJjaXJjbGVkY2lyYztcIjoweDIyOWEsXHJcbiAgXCJjaXJjbGVkZGFzaDtcIjoweDIyOWQsIFwiY2lyZTtcIjoweDIyNTcsXHJcbiAgXCJjaXJmbmludDtcIjoweDJhMTAsIFwiY2lybWlkO1wiOjB4MmFlZixcclxuICBcImNpcnNjaXI7XCI6MHgyOWMyLCBcImNsdWJzO1wiOjB4MjY2MyxcclxuICBcImNsdWJzdWl0O1wiOjB4MjY2MywgXCJjb2xvbjtcIjoweDNhLFxyXG4gIFwiY29sb25lO1wiOjB4MjI1NCwgXCJjb2xvbmVxO1wiOjB4MjI1NCxcclxuICBcImNvbW1hO1wiOjB4MmMsIFwiY29tbWF0O1wiOjB4NDAsXHJcbiAgXCJjb21wO1wiOjB4MjIwMSwgXCJjb21wZm47XCI6MHgyMjE4LFxyXG4gIFwiY29tcGxlbWVudDtcIjoweDIyMDEsIFwiY29tcGxleGVzO1wiOjB4MjEwMixcclxuICBcImNvbmc7XCI6MHgyMjQ1LCBcImNvbmdkb3Q7XCI6MHgyYTZkLFxyXG4gIFwiY29uaW50O1wiOjB4MjIyZSwgXCJjb3BmO1wiOlsweGQ4MzUsMHhkZDU0XSxcclxuICBcImNvcHJvZDtcIjoweDIyMTAsIFwiY29weVwiOjB4YTksXHJcbiAgXCJjb3B5O1wiOjB4YTksIFwiY29weXNyO1wiOjB4MjExNyxcclxuICBcImNyYXJyO1wiOjB4MjFiNSwgXCJjcm9zcztcIjoweDI3MTcsXHJcbiAgXCJjc2NyO1wiOlsweGQ4MzUsMHhkY2I4XSwgXCJjc3ViO1wiOjB4MmFjZixcclxuICBcImNzdWJlO1wiOjB4MmFkMSwgXCJjc3VwO1wiOjB4MmFkMCxcclxuICBcImNzdXBlO1wiOjB4MmFkMiwgXCJjdGRvdDtcIjoweDIyZWYsXHJcbiAgXCJjdWRhcnJsO1wiOjB4MjkzOCwgXCJjdWRhcnJyO1wiOjB4MjkzNSxcclxuICBcImN1ZXByO1wiOjB4MjJkZSwgXCJjdWVzYztcIjoweDIyZGYsXHJcbiAgXCJjdWxhcnI7XCI6MHgyMWI2LCBcImN1bGFycnA7XCI6MHgyOTNkLFxyXG4gIFwiY3VwO1wiOjB4MjIyYSwgXCJjdXBicmNhcDtcIjoweDJhNDgsXHJcbiAgXCJjdXBjYXA7XCI6MHgyYTQ2LCBcImN1cGN1cDtcIjoweDJhNGEsXHJcbiAgXCJjdXBkb3Q7XCI6MHgyMjhkLCBcImN1cG9yO1wiOjB4MmE0NSxcclxuICBcImN1cHM7XCI6WzB4MjIyYSwweGZlMDBdLCBcImN1cmFycjtcIjoweDIxYjcsXHJcbiAgXCJjdXJhcnJtO1wiOjB4MjkzYywgXCJjdXJseWVxcHJlYztcIjoweDIyZGUsXHJcbiAgXCJjdXJseWVxc3VjYztcIjoweDIyZGYsIFwiY3VybHl2ZWU7XCI6MHgyMmNlLFxyXG4gIFwiY3VybHl3ZWRnZTtcIjoweDIyY2YsIFwiY3VycmVuXCI6MHhhNCxcclxuICBcImN1cnJlbjtcIjoweGE0LCBcImN1cnZlYXJyb3dsZWZ0O1wiOjB4MjFiNixcclxuICBcImN1cnZlYXJyb3dyaWdodDtcIjoweDIxYjcsIFwiY3V2ZWU7XCI6MHgyMmNlLFxyXG4gIFwiY3V3ZWQ7XCI6MHgyMmNmLCBcImN3Y29uaW50O1wiOjB4MjIzMixcclxuICBcImN3aW50O1wiOjB4MjIzMSwgXCJjeWxjdHk7XCI6MHgyMzJkLFxyXG4gIFwiZEFycjtcIjoweDIxZDMsIFwiZEhhcjtcIjoweDI5NjUsXHJcbiAgXCJkYWdnZXI7XCI6MHgyMDIwLCBcImRhbGV0aDtcIjoweDIxMzgsXHJcbiAgXCJkYXJyO1wiOjB4MjE5MywgXCJkYXNoO1wiOjB4MjAxMCxcclxuICBcImRhc2h2O1wiOjB4MjJhMywgXCJkYmthcm93O1wiOjB4MjkwZixcclxuICBcImRibGFjO1wiOjB4MmRkLCBcImRjYXJvbjtcIjoweDEwZixcclxuICBcImRjeTtcIjoweDQzNCwgXCJkZDtcIjoweDIxNDYsXHJcbiAgXCJkZGFnZ2VyO1wiOjB4MjAyMSwgXCJkZGFycjtcIjoweDIxY2EsXHJcbiAgXCJkZG90c2VxO1wiOjB4MmE3NywgXCJkZWdcIjoweGIwLFxyXG4gIFwiZGVnO1wiOjB4YjAsIFwiZGVsdGE7XCI6MHgzYjQsXHJcbiAgXCJkZW1wdHl2O1wiOjB4MjliMSwgXCJkZmlzaHQ7XCI6MHgyOTdmLFxyXG4gIFwiZGZyO1wiOlsweGQ4MzUsMHhkZDIxXSwgXCJkaGFybDtcIjoweDIxYzMsXHJcbiAgXCJkaGFycjtcIjoweDIxYzIsIFwiZGlhbTtcIjoweDIyYzQsXHJcbiAgXCJkaWFtb25kO1wiOjB4MjJjNCwgXCJkaWFtb25kc3VpdDtcIjoweDI2NjYsXHJcbiAgXCJkaWFtcztcIjoweDI2NjYsIFwiZGllO1wiOjB4YTgsXHJcbiAgXCJkaWdhbW1hO1wiOjB4M2RkLCBcImRpc2luO1wiOjB4MjJmMixcclxuICBcImRpdjtcIjoweGY3LCBcImRpdmlkZVwiOjB4ZjcsXHJcbiAgXCJkaXZpZGU7XCI6MHhmNywgXCJkaXZpZGVvbnRpbWVzO1wiOjB4MjJjNyxcclxuICBcImRpdm9ueDtcIjoweDIyYzcsIFwiZGpjeTtcIjoweDQ1MixcclxuICBcImRsY29ybjtcIjoweDIzMWUsIFwiZGxjcm9wO1wiOjB4MjMwZCxcclxuICBcImRvbGxhcjtcIjoweDI0LCBcImRvcGY7XCI6WzB4ZDgzNSwweGRkNTVdLFxyXG4gIFwiZG90O1wiOjB4MmQ5LCBcImRvdGVxO1wiOjB4MjI1MCxcclxuICBcImRvdGVxZG90O1wiOjB4MjI1MSwgXCJkb3RtaW51cztcIjoweDIyMzgsXHJcbiAgXCJkb3RwbHVzO1wiOjB4MjIxNCwgXCJkb3RzcXVhcmU7XCI6MHgyMmExLFxyXG4gIFwiZG91YmxlYmFyd2VkZ2U7XCI6MHgyMzA2LCBcImRvd25hcnJvdztcIjoweDIxOTMsXHJcbiAgXCJkb3duZG93bmFycm93cztcIjoweDIxY2EsIFwiZG93bmhhcnBvb25sZWZ0O1wiOjB4MjFjMyxcclxuICBcImRvd25oYXJwb29ucmlnaHQ7XCI6MHgyMWMyLCBcImRyYmthcm93O1wiOjB4MjkxMCxcclxuICBcImRyY29ybjtcIjoweDIzMWYsIFwiZHJjcm9wO1wiOjB4MjMwYyxcclxuICBcImRzY3I7XCI6WzB4ZDgzNSwweGRjYjldLCBcImRzY3k7XCI6MHg0NTUsXHJcbiAgXCJkc29sO1wiOjB4MjlmNiwgXCJkc3Ryb2s7XCI6MHgxMTEsXHJcbiAgXCJkdGRvdDtcIjoweDIyZjEsIFwiZHRyaTtcIjoweDI1YmYsXHJcbiAgXCJkdHJpZjtcIjoweDI1YmUsIFwiZHVhcnI7XCI6MHgyMWY1LFxyXG4gIFwiZHVoYXI7XCI6MHgyOTZmLCBcImR3YW5nbGU7XCI6MHgyOWE2LFxyXG4gIFwiZHpjeTtcIjoweDQ1ZiwgXCJkemlncmFycjtcIjoweDI3ZmYsXHJcbiAgXCJlRERvdDtcIjoweDJhNzcsIFwiZURvdDtcIjoweDIyNTEsXHJcbiAgXCJlYWN1dGVcIjoweGU5LCBcImVhY3V0ZTtcIjoweGU5LFxyXG4gIFwiZWFzdGVyO1wiOjB4MmE2ZSwgXCJlY2Fyb247XCI6MHgxMWIsXHJcbiAgXCJlY2lyO1wiOjB4MjI1NiwgXCJlY2lyY1wiOjB4ZWEsXHJcbiAgXCJlY2lyYztcIjoweGVhLCBcImVjb2xvbjtcIjoweDIyNTUsXHJcbiAgXCJlY3k7XCI6MHg0NGQsIFwiZWRvdDtcIjoweDExNyxcclxuICBcImVlO1wiOjB4MjE0NywgXCJlZkRvdDtcIjoweDIyNTIsXHJcbiAgXCJlZnI7XCI6WzB4ZDgzNSwweGRkMjJdLCBcImVnO1wiOjB4MmE5YSxcclxuICBcImVncmF2ZVwiOjB4ZTgsIFwiZWdyYXZlO1wiOjB4ZTgsXHJcbiAgXCJlZ3M7XCI6MHgyYTk2LCBcImVnc2RvdDtcIjoweDJhOTgsXHJcbiAgXCJlbDtcIjoweDJhOTksIFwiZWxpbnRlcnM7XCI6MHgyM2U3LFxyXG4gIFwiZWxsO1wiOjB4MjExMywgXCJlbHM7XCI6MHgyYTk1LFxyXG4gIFwiZWxzZG90O1wiOjB4MmE5NywgXCJlbWFjcjtcIjoweDExMyxcclxuICBcImVtcHR5O1wiOjB4MjIwNSwgXCJlbXB0eXNldDtcIjoweDIyMDUsXHJcbiAgXCJlbXB0eXY7XCI6MHgyMjA1LCBcImVtc3AxMztcIjoweDIwMDQsXHJcbiAgXCJlbXNwMTQ7XCI6MHgyMDA1LCBcImVtc3A7XCI6MHgyMDAzLFxyXG4gIFwiZW5nO1wiOjB4MTRiLCBcImVuc3A7XCI6MHgyMDAyLFxyXG4gIFwiZW9nb247XCI6MHgxMTksIFwiZW9wZjtcIjpbMHhkODM1LDB4ZGQ1Nl0sXHJcbiAgXCJlcGFyO1wiOjB4MjJkNSwgXCJlcGFyc2w7XCI6MHgyOWUzLFxyXG4gIFwiZXBsdXM7XCI6MHgyYTcxLCBcImVwc2k7XCI6MHgzYjUsXHJcbiAgXCJlcHNpbG9uO1wiOjB4M2I1LCBcImVwc2l2O1wiOjB4M2Y1LFxyXG4gIFwiZXFjaXJjO1wiOjB4MjI1NiwgXCJlcWNvbG9uO1wiOjB4MjI1NSxcclxuICBcImVxc2ltO1wiOjB4MjI0MiwgXCJlcXNsYW50Z3RyO1wiOjB4MmE5NixcclxuICBcImVxc2xhbnRsZXNzO1wiOjB4MmE5NSwgXCJlcXVhbHM7XCI6MHgzZCxcclxuICBcImVxdWVzdDtcIjoweDIyNWYsIFwiZXF1aXY7XCI6MHgyMjYxLFxyXG4gIFwiZXF1aXZERDtcIjoweDJhNzgsIFwiZXF2cGFyc2w7XCI6MHgyOWU1LFxyXG4gIFwiZXJEb3Q7XCI6MHgyMjUzLCBcImVyYXJyO1wiOjB4Mjk3MSxcclxuICBcImVzY3I7XCI6MHgyMTJmLCBcImVzZG90O1wiOjB4MjI1MCxcclxuICBcImVzaW07XCI6MHgyMjQyLCBcImV0YTtcIjoweDNiNyxcclxuICBcImV0aFwiOjB4ZjAsIFwiZXRoO1wiOjB4ZjAsXHJcbiAgXCJldW1sXCI6MHhlYiwgXCJldW1sO1wiOjB4ZWIsXHJcbiAgXCJldXJvO1wiOjB4MjBhYywgXCJleGNsO1wiOjB4MjEsXHJcbiAgXCJleGlzdDtcIjoweDIyMDMsIFwiZXhwZWN0YXRpb247XCI6MHgyMTMwLFxyXG4gIFwiZXhwb25lbnRpYWxlO1wiOjB4MjE0NywgXCJmYWxsaW5nZG90c2VxO1wiOjB4MjI1MixcclxuICBcImZjeTtcIjoweDQ0NCwgXCJmZW1hbGU7XCI6MHgyNjQwLFxyXG4gIFwiZmZpbGlnO1wiOjB4ZmIwMywgXCJmZmxpZztcIjoweGZiMDAsXHJcbiAgXCJmZmxsaWc7XCI6MHhmYjA0LCBcImZmcjtcIjpbMHhkODM1LDB4ZGQyM10sXHJcbiAgXCJmaWxpZztcIjoweGZiMDEsIFwiZmpsaWc7XCI6WzB4NjYsMHg2YV0sXHJcbiAgXCJmbGF0O1wiOjB4MjY2ZCwgXCJmbGxpZztcIjoweGZiMDIsXHJcbiAgXCJmbHRucztcIjoweDI1YjEsIFwiZm5vZjtcIjoweDE5MixcclxuICBcImZvcGY7XCI6WzB4ZDgzNSwweGRkNTddLCBcImZvcmFsbDtcIjoweDIyMDAsXHJcbiAgXCJmb3JrO1wiOjB4MjJkNCwgXCJmb3JrdjtcIjoweDJhZDksXHJcbiAgXCJmcGFydGludDtcIjoweDJhMGQsIFwiZnJhYzEyXCI6MHhiZCxcclxuICBcImZyYWMxMjtcIjoweGJkLCBcImZyYWMxMztcIjoweDIxNTMsXHJcbiAgXCJmcmFjMTRcIjoweGJjLCBcImZyYWMxNDtcIjoweGJjLFxyXG4gIFwiZnJhYzE1O1wiOjB4MjE1NSwgXCJmcmFjMTY7XCI6MHgyMTU5LFxyXG4gIFwiZnJhYzE4O1wiOjB4MjE1YiwgXCJmcmFjMjM7XCI6MHgyMTU0LFxyXG4gIFwiZnJhYzI1O1wiOjB4MjE1NiwgXCJmcmFjMzRcIjoweGJlLFxyXG4gIFwiZnJhYzM0O1wiOjB4YmUsIFwiZnJhYzM1O1wiOjB4MjE1NyxcclxuICBcImZyYWMzODtcIjoweDIxNWMsIFwiZnJhYzQ1O1wiOjB4MjE1OCxcclxuICBcImZyYWM1NjtcIjoweDIxNWEsIFwiZnJhYzU4O1wiOjB4MjE1ZCxcclxuICBcImZyYWM3ODtcIjoweDIxNWUsIFwiZnJhc2w7XCI6MHgyMDQ0LFxyXG4gIFwiZnJvd247XCI6MHgyMzIyLCBcImZzY3I7XCI6WzB4ZDgzNSwweGRjYmJdLFxyXG4gIFwiZ0U7XCI6MHgyMjY3LCBcImdFbDtcIjoweDJhOGMsXHJcbiAgXCJnYWN1dGU7XCI6MHgxZjUsIFwiZ2FtbWE7XCI6MHgzYjMsXHJcbiAgXCJnYW1tYWQ7XCI6MHgzZGQsIFwiZ2FwO1wiOjB4MmE4NixcclxuICBcImdicmV2ZTtcIjoweDExZiwgXCJnY2lyYztcIjoweDExZCxcclxuICBcImdjeTtcIjoweDQzMywgXCJnZG90O1wiOjB4MTIxLFxyXG4gIFwiZ2U7XCI6MHgyMjY1LCBcImdlbDtcIjoweDIyZGIsXHJcbiAgXCJnZXE7XCI6MHgyMjY1LCBcImdlcXE7XCI6MHgyMjY3LFxyXG4gIFwiZ2Vxc2xhbnQ7XCI6MHgyYTdlLCBcImdlcztcIjoweDJhN2UsXHJcbiAgXCJnZXNjYztcIjoweDJhYTksIFwiZ2VzZG90O1wiOjB4MmE4MCxcclxuICBcImdlc2RvdG87XCI6MHgyYTgyLCBcImdlc2RvdG9sO1wiOjB4MmE4NCxcclxuICBcImdlc2w7XCI6WzB4MjJkYiwweGZlMDBdLCBcImdlc2xlcztcIjoweDJhOTQsXHJcbiAgXCJnZnI7XCI6WzB4ZDgzNSwweGRkMjRdLCBcImdnO1wiOjB4MjI2YixcclxuICBcImdnZztcIjoweDIyZDksIFwiZ2ltZWw7XCI6MHgyMTM3LFxyXG4gIFwiZ2pjeTtcIjoweDQ1MywgXCJnbDtcIjoweDIyNzcsXHJcbiAgXCJnbEU7XCI6MHgyYTkyLCBcImdsYTtcIjoweDJhYTUsXHJcbiAgXCJnbGo7XCI6MHgyYWE0LCBcImduRTtcIjoweDIyNjksXHJcbiAgXCJnbmFwO1wiOjB4MmE4YSwgXCJnbmFwcHJveDtcIjoweDJhOGEsXHJcbiAgXCJnbmU7XCI6MHgyYTg4LCBcImduZXE7XCI6MHgyYTg4LFxyXG4gIFwiZ25lcXE7XCI6MHgyMjY5LCBcImduc2ltO1wiOjB4MjJlNyxcclxuICBcImdvcGY7XCI6WzB4ZDgzNSwweGRkNThdLCBcImdyYXZlO1wiOjB4NjAsXHJcbiAgXCJnc2NyO1wiOjB4MjEwYSwgXCJnc2ltO1wiOjB4MjI3MyxcclxuICBcImdzaW1lO1wiOjB4MmE4ZSwgXCJnc2ltbDtcIjoweDJhOTAsXHJcbiAgXCJndFwiOjB4M2UsIFwiZ3Q7XCI6MHgzZSxcclxuICBcImd0Y2M7XCI6MHgyYWE3LCBcImd0Y2lyO1wiOjB4MmE3YSxcclxuICBcImd0ZG90O1wiOjB4MjJkNywgXCJndGxQYXI7XCI6MHgyOTk1LFxyXG4gIFwiZ3RxdWVzdDtcIjoweDJhN2MsIFwiZ3RyYXBwcm94O1wiOjB4MmE4NixcclxuICBcImd0cmFycjtcIjoweDI5NzgsIFwiZ3RyZG90O1wiOjB4MjJkNyxcclxuICBcImd0cmVxbGVzcztcIjoweDIyZGIsIFwiZ3RyZXFxbGVzcztcIjoweDJhOGMsXHJcbiAgXCJndHJsZXNzO1wiOjB4MjI3NywgXCJndHJzaW07XCI6MHgyMjczLFxyXG4gIFwiZ3ZlcnRuZXFxO1wiOlsweDIyNjksMHhmZTAwXSwgXCJndm5FO1wiOlsweDIyNjksMHhmZTAwXSxcclxuICBcImhBcnI7XCI6MHgyMWQ0LCBcImhhaXJzcDtcIjoweDIwMGEsXHJcbiAgXCJoYWxmO1wiOjB4YmQsIFwiaGFtaWx0O1wiOjB4MjEwYixcclxuICBcImhhcmRjeTtcIjoweDQ0YSwgXCJoYXJyO1wiOjB4MjE5NCxcclxuICBcImhhcnJjaXI7XCI6MHgyOTQ4LCBcImhhcnJ3O1wiOjB4MjFhZCxcclxuICBcImhiYXI7XCI6MHgyMTBmLCBcImhjaXJjO1wiOjB4MTI1LFxyXG4gIFwiaGVhcnRzO1wiOjB4MjY2NSwgXCJoZWFydHN1aXQ7XCI6MHgyNjY1LFxyXG4gIFwiaGVsbGlwO1wiOjB4MjAyNiwgXCJoZXJjb247XCI6MHgyMmI5LFxyXG4gIFwiaGZyO1wiOlsweGQ4MzUsMHhkZDI1XSwgXCJoa3NlYXJvdztcIjoweDI5MjUsXHJcbiAgXCJoa3N3YXJvdztcIjoweDI5MjYsIFwiaG9hcnI7XCI6MHgyMWZmLFxyXG4gIFwiaG9tdGh0O1wiOjB4MjIzYiwgXCJob29rbGVmdGFycm93O1wiOjB4MjFhOSxcclxuICBcImhvb2tyaWdodGFycm93O1wiOjB4MjFhYSwgXCJob3BmO1wiOlsweGQ4MzUsMHhkZDU5XSxcclxuICBcImhvcmJhcjtcIjoweDIwMTUsIFwiaHNjcjtcIjpbMHhkODM1LDB4ZGNiZF0sXHJcbiAgXCJoc2xhc2g7XCI6MHgyMTBmLCBcImhzdHJvaztcIjoweDEyNyxcclxuICBcImh5YnVsbDtcIjoweDIwNDMsIFwiaHlwaGVuO1wiOjB4MjAxMCxcclxuICBcImlhY3V0ZVwiOjB4ZWQsIFwiaWFjdXRlO1wiOjB4ZWQsXHJcbiAgXCJpYztcIjoweDIwNjMsIFwiaWNpcmNcIjoweGVlLFxyXG4gIFwiaWNpcmM7XCI6MHhlZSwgXCJpY3k7XCI6MHg0MzgsXHJcbiAgXCJpZWN5O1wiOjB4NDM1LCBcImlleGNsXCI6MHhhMSxcclxuICBcImlleGNsO1wiOjB4YTEsIFwiaWZmO1wiOjB4MjFkNCxcclxuICBcImlmcjtcIjpbMHhkODM1LDB4ZGQyNl0sIFwiaWdyYXZlXCI6MHhlYyxcclxuICBcImlncmF2ZTtcIjoweGVjLCBcImlpO1wiOjB4MjE0OCxcclxuICBcImlpaWludDtcIjoweDJhMGMsIFwiaWlpbnQ7XCI6MHgyMjJkLFxyXG4gIFwiaWluZmluO1wiOjB4MjlkYywgXCJpaW90YTtcIjoweDIxMjksXHJcbiAgXCJpamxpZztcIjoweDEzMywgXCJpbWFjcjtcIjoweDEyYixcclxuICBcImltYWdlO1wiOjB4MjExMSwgXCJpbWFnbGluZTtcIjoweDIxMTAsXHJcbiAgXCJpbWFncGFydDtcIjoweDIxMTEsIFwiaW1hdGg7XCI6MHgxMzEsXHJcbiAgXCJpbW9mO1wiOjB4MjJiNywgXCJpbXBlZDtcIjoweDFiNSxcclxuICBcImluO1wiOjB4MjIwOCwgXCJpbmNhcmU7XCI6MHgyMTA1LFxyXG4gIFwiaW5maW47XCI6MHgyMjFlLCBcImluZmludGllO1wiOjB4MjlkZCxcclxuICBcImlub2RvdDtcIjoweDEzMSwgXCJpbnQ7XCI6MHgyMjJiLFxyXG4gIFwiaW50Y2FsO1wiOjB4MjJiYSwgXCJpbnRlZ2VycztcIjoweDIxMjQsXHJcbiAgXCJpbnRlcmNhbDtcIjoweDIyYmEsIFwiaW50bGFyaGs7XCI6MHgyYTE3LFxyXG4gIFwiaW50cHJvZDtcIjoweDJhM2MsIFwiaW9jeTtcIjoweDQ1MSxcclxuICBcImlvZ29uO1wiOjB4MTJmLCBcImlvcGY7XCI6WzB4ZDgzNSwweGRkNWFdLFxyXG4gIFwiaW90YTtcIjoweDNiOSwgXCJpcHJvZDtcIjoweDJhM2MsXHJcbiAgXCJpcXVlc3RcIjoweGJmLCBcImlxdWVzdDtcIjoweGJmLFxyXG4gIFwiaXNjcjtcIjpbMHhkODM1LDB4ZGNiZV0sIFwiaXNpbjtcIjoweDIyMDgsXHJcbiAgXCJpc2luRTtcIjoweDIyZjksIFwiaXNpbmRvdDtcIjoweDIyZjUsXHJcbiAgXCJpc2lucztcIjoweDIyZjQsIFwiaXNpbnN2O1wiOjB4MjJmMyxcclxuICBcImlzaW52O1wiOjB4MjIwOCwgXCJpdDtcIjoweDIwNjIsXHJcbiAgXCJpdGlsZGU7XCI6MHgxMjksIFwiaXVrY3k7XCI6MHg0NTYsXHJcbiAgXCJpdW1sXCI6MHhlZiwgXCJpdW1sO1wiOjB4ZWYsXHJcbiAgXCJqY2lyYztcIjoweDEzNSwgXCJqY3k7XCI6MHg0MzksXHJcbiAgXCJqZnI7XCI6WzB4ZDgzNSwweGRkMjddLCBcImptYXRoO1wiOjB4MjM3LFxyXG4gIFwiam9wZjtcIjpbMHhkODM1LDB4ZGQ1Yl0sIFwianNjcjtcIjpbMHhkODM1LDB4ZGNiZl0sXHJcbiAgXCJqc2VyY3k7XCI6MHg0NTgsIFwianVrY3k7XCI6MHg0NTQsXHJcbiAgXCJrYXBwYTtcIjoweDNiYSwgXCJrYXBwYXY7XCI6MHgzZjAsXHJcbiAgXCJrY2VkaWw7XCI6MHgxMzcsIFwia2N5O1wiOjB4NDNhLFxyXG4gIFwia2ZyO1wiOlsweGQ4MzUsMHhkZDI4XSwgXCJrZ3JlZW47XCI6MHgxMzgsXHJcbiAgXCJraGN5O1wiOjB4NDQ1LCBcImtqY3k7XCI6MHg0NWMsXHJcbiAgXCJrb3BmO1wiOlsweGQ4MzUsMHhkZDVjXSwgXCJrc2NyO1wiOlsweGQ4MzUsMHhkY2MwXSxcclxuICBcImxBYXJyO1wiOjB4MjFkYSwgXCJsQXJyO1wiOjB4MjFkMCxcclxuICBcImxBdGFpbDtcIjoweDI5MWIsIFwibEJhcnI7XCI6MHgyOTBlLFxyXG4gIFwibEU7XCI6MHgyMjY2LCBcImxFZztcIjoweDJhOGIsXHJcbiAgXCJsSGFyO1wiOjB4Mjk2MiwgXCJsYWN1dGU7XCI6MHgxM2EsXHJcbiAgXCJsYWVtcHR5djtcIjoweDI5YjQsIFwibGFncmFuO1wiOjB4MjExMixcclxuICBcImxhbWJkYTtcIjoweDNiYiwgXCJsYW5nO1wiOjB4MjdlOCxcclxuICBcImxhbmdkO1wiOjB4Mjk5MSwgXCJsYW5nbGU7XCI6MHgyN2U4LFxyXG4gIFwibGFwO1wiOjB4MmE4NSwgXCJsYXF1b1wiOjB4YWIsXHJcbiAgXCJsYXF1bztcIjoweGFiLCBcImxhcnI7XCI6MHgyMTkwLFxyXG4gIFwibGFycmI7XCI6MHgyMWU0LCBcImxhcnJiZnM7XCI6MHgyOTFmLFxyXG4gIFwibGFycmZzO1wiOjB4MjkxZCwgXCJsYXJyaGs7XCI6MHgyMWE5LFxyXG4gIFwibGFycmxwO1wiOjB4MjFhYiwgXCJsYXJycGw7XCI6MHgyOTM5LFxyXG4gIFwibGFycnNpbTtcIjoweDI5NzMsIFwibGFycnRsO1wiOjB4MjFhMixcclxuICBcImxhdDtcIjoweDJhYWIsIFwibGF0YWlsO1wiOjB4MjkxOSxcclxuICBcImxhdGU7XCI6MHgyYWFkLCBcImxhdGVzO1wiOlsweDJhYWQsMHhmZTAwXSxcclxuICBcImxiYXJyO1wiOjB4MjkwYywgXCJsYmJyaztcIjoweDI3NzIsXHJcbiAgXCJsYnJhY2U7XCI6MHg3YiwgXCJsYnJhY2s7XCI6MHg1YixcclxuICBcImxicmtlO1wiOjB4Mjk4YiwgXCJsYnJrc2xkO1wiOjB4Mjk4ZixcclxuICBcImxicmtzbHU7XCI6MHgyOThkLCBcImxjYXJvbjtcIjoweDEzZSxcclxuICBcImxjZWRpbDtcIjoweDEzYywgXCJsY2VpbDtcIjoweDIzMDgsXHJcbiAgXCJsY3ViO1wiOjB4N2IsIFwibGN5O1wiOjB4NDNiLFxyXG4gIFwibGRjYTtcIjoweDI5MzYsIFwibGRxdW87XCI6MHgyMDFjLFxyXG4gIFwibGRxdW9yO1wiOjB4MjAxZSwgXCJsZHJkaGFyO1wiOjB4Mjk2NyxcclxuICBcImxkcnVzaGFyO1wiOjB4Mjk0YiwgXCJsZHNoO1wiOjB4MjFiMixcclxuICBcImxlO1wiOjB4MjI2NCwgXCJsZWZ0YXJyb3c7XCI6MHgyMTkwLFxyXG4gIFwibGVmdGFycm93dGFpbDtcIjoweDIxYTIsIFwibGVmdGhhcnBvb25kb3duO1wiOjB4MjFiZCxcclxuICBcImxlZnRoYXJwb29udXA7XCI6MHgyMWJjLCBcImxlZnRsZWZ0YXJyb3dzO1wiOjB4MjFjNyxcclxuICBcImxlZnRyaWdodGFycm93O1wiOjB4MjE5NCwgXCJsZWZ0cmlnaHRhcnJvd3M7XCI6MHgyMWM2LFxyXG4gIFwibGVmdHJpZ2h0aGFycG9vbnM7XCI6MHgyMWNiLCBcImxlZnRyaWdodHNxdWlnYXJyb3c7XCI6MHgyMWFkLFxyXG4gIFwibGVmdHRocmVldGltZXM7XCI6MHgyMmNiLCBcImxlZztcIjoweDIyZGEsXHJcbiAgXCJsZXE7XCI6MHgyMjY0LCBcImxlcXE7XCI6MHgyMjY2LFxyXG4gIFwibGVxc2xhbnQ7XCI6MHgyYTdkLCBcImxlcztcIjoweDJhN2QsXHJcbiAgXCJsZXNjYztcIjoweDJhYTgsIFwibGVzZG90O1wiOjB4MmE3ZixcclxuICBcImxlc2RvdG87XCI6MHgyYTgxLCBcImxlc2RvdG9yO1wiOjB4MmE4MyxcclxuICBcImxlc2c7XCI6WzB4MjJkYSwweGZlMDBdLCBcImxlc2dlcztcIjoweDJhOTMsXHJcbiAgXCJsZXNzYXBwcm94O1wiOjB4MmE4NSwgXCJsZXNzZG90O1wiOjB4MjJkNixcclxuICBcImxlc3NlcWd0cjtcIjoweDIyZGEsIFwibGVzc2VxcWd0cjtcIjoweDJhOGIsXHJcbiAgXCJsZXNzZ3RyO1wiOjB4MjI3NiwgXCJsZXNzc2ltO1wiOjB4MjI3MixcclxuICBcImxmaXNodDtcIjoweDI5N2MsIFwibGZsb29yO1wiOjB4MjMwYSxcclxuICBcImxmcjtcIjpbMHhkODM1LDB4ZGQyOV0sIFwibGc7XCI6MHgyMjc2LFxyXG4gIFwibGdFO1wiOjB4MmE5MSwgXCJsaGFyZDtcIjoweDIxYmQsXHJcbiAgXCJsaGFydTtcIjoweDIxYmMsIFwibGhhcnVsO1wiOjB4Mjk2YSxcclxuICBcImxoYmxrO1wiOjB4MjU4NCwgXCJsamN5O1wiOjB4NDU5LFxyXG4gIFwibGw7XCI6MHgyMjZhLCBcImxsYXJyO1wiOjB4MjFjNyxcclxuICBcImxsY29ybmVyO1wiOjB4MjMxZSwgXCJsbGhhcmQ7XCI6MHgyOTZiLFxyXG4gIFwibGx0cmk7XCI6MHgyNWZhLCBcImxtaWRvdDtcIjoweDE0MCxcclxuICBcImxtb3VzdDtcIjoweDIzYjAsIFwibG1vdXN0YWNoZTtcIjoweDIzYjAsXHJcbiAgXCJsbkU7XCI6MHgyMjY4LCBcImxuYXA7XCI6MHgyYTg5LFxyXG4gIFwibG5hcHByb3g7XCI6MHgyYTg5LCBcImxuZTtcIjoweDJhODcsXHJcbiAgXCJsbmVxO1wiOjB4MmE4NywgXCJsbmVxcTtcIjoweDIyNjgsXHJcbiAgXCJsbnNpbTtcIjoweDIyZTYsIFwibG9hbmc7XCI6MHgyN2VjLFxyXG4gIFwibG9hcnI7XCI6MHgyMWZkLCBcImxvYnJrO1wiOjB4MjdlNixcclxuICBcImxvbmdsZWZ0YXJyb3c7XCI6MHgyN2Y1LCBcImxvbmdsZWZ0cmlnaHRhcnJvdztcIjoweDI3ZjcsXHJcbiAgXCJsb25nbWFwc3RvO1wiOjB4MjdmYywgXCJsb25ncmlnaHRhcnJvdztcIjoweDI3ZjYsXHJcbiAgXCJsb29wYXJyb3dsZWZ0O1wiOjB4MjFhYiwgXCJsb29wYXJyb3dyaWdodDtcIjoweDIxYWMsXHJcbiAgXCJsb3BhcjtcIjoweDI5ODUsIFwibG9wZjtcIjpbMHhkODM1LDB4ZGQ1ZF0sXHJcbiAgXCJsb3BsdXM7XCI6MHgyYTJkLCBcImxvdGltZXM7XCI6MHgyYTM0LFxyXG4gIFwibG93YXN0O1wiOjB4MjIxNywgXCJsb3diYXI7XCI6MHg1ZixcclxuICBcImxvejtcIjoweDI1Y2EsIFwibG96ZW5nZTtcIjoweDI1Y2EsXHJcbiAgXCJsb3pmO1wiOjB4MjllYiwgXCJscGFyO1wiOjB4MjgsXHJcbiAgXCJscGFybHQ7XCI6MHgyOTkzLCBcImxyYXJyO1wiOjB4MjFjNixcclxuICBcImxyY29ybmVyO1wiOjB4MjMxZiwgXCJscmhhcjtcIjoweDIxY2IsXHJcbiAgXCJscmhhcmQ7XCI6MHgyOTZkLCBcImxybTtcIjoweDIwMGUsXHJcbiAgXCJscnRyaTtcIjoweDIyYmYsIFwibHNhcXVvO1wiOjB4MjAzOSxcclxuICBcImxzY3I7XCI6WzB4ZDgzNSwweGRjYzFdLCBcImxzaDtcIjoweDIxYjAsXHJcbiAgXCJsc2ltO1wiOjB4MjI3MiwgXCJsc2ltZTtcIjoweDJhOGQsXHJcbiAgXCJsc2ltZztcIjoweDJhOGYsIFwibHNxYjtcIjoweDViLFxyXG4gIFwibHNxdW87XCI6MHgyMDE4LCBcImxzcXVvcjtcIjoweDIwMWEsXHJcbiAgXCJsc3Ryb2s7XCI6MHgxNDIsIFwibHRcIjoweDNjLFxyXG4gIFwibHQ7XCI6MHgzYywgXCJsdGNjO1wiOjB4MmFhNixcclxuICBcImx0Y2lyO1wiOjB4MmE3OSwgXCJsdGRvdDtcIjoweDIyZDYsXHJcbiAgXCJsdGhyZWU7XCI6MHgyMmNiLCBcImx0aW1lcztcIjoweDIyYzksXHJcbiAgXCJsdGxhcnI7XCI6MHgyOTc2LCBcImx0cXVlc3Q7XCI6MHgyYTdiLFxyXG4gIFwibHRyUGFyO1wiOjB4Mjk5NiwgXCJsdHJpO1wiOjB4MjVjMyxcclxuICBcImx0cmllO1wiOjB4MjJiNCwgXCJsdHJpZjtcIjoweDI1YzIsXHJcbiAgXCJsdXJkc2hhcjtcIjoweDI5NGEsIFwibHVydWhhcjtcIjoweDI5NjYsXHJcbiAgXCJsdmVydG5lcXE7XCI6WzB4MjI2OCwweGZlMDBdLCBcImx2bkU7XCI6WzB4MjI2OCwweGZlMDBdLFxyXG4gIFwibUREb3Q7XCI6MHgyMjNhLCBcIm1hY3JcIjoweGFmLFxyXG4gIFwibWFjcjtcIjoweGFmLCBcIm1hbGU7XCI6MHgyNjQyLFxyXG4gIFwibWFsdDtcIjoweDI3MjAsIFwibWFsdGVzZTtcIjoweDI3MjAsXHJcbiAgXCJtYXA7XCI6MHgyMWE2LCBcIm1hcHN0bztcIjoweDIxYTYsXHJcbiAgXCJtYXBzdG9kb3duO1wiOjB4MjFhNywgXCJtYXBzdG9sZWZ0O1wiOjB4MjFhNCxcclxuICBcIm1hcHN0b3VwO1wiOjB4MjFhNSwgXCJtYXJrZXI7XCI6MHgyNWFlLFxyXG4gIFwibWNvbW1hO1wiOjB4MmEyOSwgXCJtY3k7XCI6MHg0M2MsXHJcbiAgXCJtZGFzaDtcIjoweDIwMTQsIFwibWVhc3VyZWRhbmdsZTtcIjoweDIyMjEsXHJcbiAgXCJtZnI7XCI6WzB4ZDgzNSwweGRkMmFdLCBcIm1obztcIjoweDIxMjcsXHJcbiAgXCJtaWNyb1wiOjB4YjUsIFwibWljcm87XCI6MHhiNSxcclxuICBcIm1pZDtcIjoweDIyMjMsIFwibWlkYXN0O1wiOjB4MmEsXHJcbiAgXCJtaWRjaXI7XCI6MHgyYWYwLCBcIm1pZGRvdFwiOjB4YjcsXHJcbiAgXCJtaWRkb3Q7XCI6MHhiNywgXCJtaW51cztcIjoweDIyMTIsXHJcbiAgXCJtaW51c2I7XCI6MHgyMjlmLCBcIm1pbnVzZDtcIjoweDIyMzgsXHJcbiAgXCJtaW51c2R1O1wiOjB4MmEyYSwgXCJtbGNwO1wiOjB4MmFkYixcclxuICBcIm1sZHI7XCI6MHgyMDI2LCBcIm1ucGx1cztcIjoweDIyMTMsXHJcbiAgXCJtb2RlbHM7XCI6MHgyMmE3LCBcIm1vcGY7XCI6WzB4ZDgzNSwweGRkNWVdLFxyXG4gIFwibXA7XCI6MHgyMjEzLCBcIm1zY3I7XCI6WzB4ZDgzNSwweGRjYzJdLFxyXG4gIFwibXN0cG9zO1wiOjB4MjIzZSwgXCJtdTtcIjoweDNiYyxcclxuICBcIm11bHRpbWFwO1wiOjB4MjJiOCwgXCJtdW1hcDtcIjoweDIyYjgsXHJcbiAgXCJuR2c7XCI6WzB4MjJkOSwweDMzOF0sIFwibkd0O1wiOlsweDIyNmIsMHgyMGQyXSxcclxuICBcIm5HdHY7XCI6WzB4MjI2YiwweDMzOF0sIFwibkxlZnRhcnJvdztcIjoweDIxY2QsXHJcbiAgXCJuTGVmdHJpZ2h0YXJyb3c7XCI6MHgyMWNlLCBcIm5MbDtcIjpbMHgyMmQ4LDB4MzM4XSxcclxuICBcIm5MdDtcIjpbMHgyMjZhLDB4MjBkMl0sIFwibkx0djtcIjpbMHgyMjZhLDB4MzM4XSxcclxuICBcIm5SaWdodGFycm93O1wiOjB4MjFjZiwgXCJuVkRhc2g7XCI6MHgyMmFmLFxyXG4gIFwiblZkYXNoO1wiOjB4MjJhZSwgXCJuYWJsYTtcIjoweDIyMDcsXHJcbiAgXCJuYWN1dGU7XCI6MHgxNDQsIFwibmFuZztcIjpbMHgyMjIwLDB4MjBkMl0sXHJcbiAgXCJuYXA7XCI6MHgyMjQ5LCBcIm5hcEU7XCI6WzB4MmE3MCwweDMzOF0sXHJcbiAgXCJuYXBpZDtcIjpbMHgyMjRiLDB4MzM4XSwgXCJuYXBvcztcIjoweDE0OSxcclxuICBcIm5hcHByb3g7XCI6MHgyMjQ5LCBcIm5hdHVyO1wiOjB4MjY2ZSxcclxuICBcIm5hdHVyYWw7XCI6MHgyNjZlLCBcIm5hdHVyYWxzO1wiOjB4MjExNSxcclxuICBcIm5ic3BcIjoweGEwLCBcIm5ic3A7XCI6MHhhMCxcclxuICBcIm5idW1wO1wiOlsweDIyNGUsMHgzMzhdLCBcIm5idW1wZTtcIjpbMHgyMjRmLDB4MzM4XSxcclxuICBcIm5jYXA7XCI6MHgyYTQzLCBcIm5jYXJvbjtcIjoweDE0OCxcclxuICBcIm5jZWRpbDtcIjoweDE0NiwgXCJuY29uZztcIjoweDIyNDcsXHJcbiAgXCJuY29uZ2RvdDtcIjpbMHgyYTZkLDB4MzM4XSwgXCJuY3VwO1wiOjB4MmE0MixcclxuICBcIm5jeTtcIjoweDQzZCwgXCJuZGFzaDtcIjoweDIwMTMsXHJcbiAgXCJuZTtcIjoweDIyNjAsIFwibmVBcnI7XCI6MHgyMWQ3LFxyXG4gIFwibmVhcmhrO1wiOjB4MjkyNCwgXCJuZWFycjtcIjoweDIxOTcsXHJcbiAgXCJuZWFycm93O1wiOjB4MjE5NywgXCJuZWRvdDtcIjpbMHgyMjUwLDB4MzM4XSxcclxuICBcIm5lcXVpdjtcIjoweDIyNjIsIFwibmVzZWFyO1wiOjB4MjkyOCxcclxuICBcIm5lc2ltO1wiOlsweDIyNDIsMHgzMzhdLCBcIm5leGlzdDtcIjoweDIyMDQsXHJcbiAgXCJuZXhpc3RzO1wiOjB4MjIwNCwgXCJuZnI7XCI6WzB4ZDgzNSwweGRkMmJdLFxyXG4gIFwibmdFO1wiOlsweDIyNjcsMHgzMzhdLCBcIm5nZTtcIjoweDIyNzEsXHJcbiAgXCJuZ2VxO1wiOjB4MjI3MSwgXCJuZ2VxcTtcIjpbMHgyMjY3LDB4MzM4XSxcclxuICBcIm5nZXFzbGFudDtcIjpbMHgyYTdlLDB4MzM4XSwgXCJuZ2VzO1wiOlsweDJhN2UsMHgzMzhdLFxyXG4gIFwibmdzaW07XCI6MHgyMjc1LCBcIm5ndDtcIjoweDIyNmYsXHJcbiAgXCJuZ3RyO1wiOjB4MjI2ZiwgXCJuaEFycjtcIjoweDIxY2UsXHJcbiAgXCJuaGFycjtcIjoweDIxYWUsIFwibmhwYXI7XCI6MHgyYWYyLFxyXG4gIFwibmk7XCI6MHgyMjBiLCBcIm5pcztcIjoweDIyZmMsXHJcbiAgXCJuaXNkO1wiOjB4MjJmYSwgXCJuaXY7XCI6MHgyMjBiLFxyXG4gIFwibmpjeTtcIjoweDQ1YSwgXCJubEFycjtcIjoweDIxY2QsXHJcbiAgXCJubEU7XCI6WzB4MjI2NiwweDMzOF0sIFwibmxhcnI7XCI6MHgyMTlhLFxyXG4gIFwibmxkcjtcIjoweDIwMjUsIFwibmxlO1wiOjB4MjI3MCxcclxuICBcIm5sZWZ0YXJyb3c7XCI6MHgyMTlhLCBcIm5sZWZ0cmlnaHRhcnJvdztcIjoweDIxYWUsXHJcbiAgXCJubGVxO1wiOjB4MjI3MCwgXCJubGVxcTtcIjpbMHgyMjY2LDB4MzM4XSxcclxuICBcIm5sZXFzbGFudDtcIjpbMHgyYTdkLDB4MzM4XSwgXCJubGVzO1wiOlsweDJhN2QsMHgzMzhdLFxyXG4gIFwibmxlc3M7XCI6MHgyMjZlLCBcIm5sc2ltO1wiOjB4MjI3NCxcclxuICBcIm5sdDtcIjoweDIyNmUsIFwibmx0cmk7XCI6MHgyMmVhLFxyXG4gIFwibmx0cmllO1wiOjB4MjJlYywgXCJubWlkO1wiOjB4MjIyNCxcclxuICBcIm5vcGY7XCI6WzB4ZDgzNSwweGRkNWZdLCBcIm5vdFwiOjB4YWMsXHJcbiAgXCJub3Q7XCI6MHhhYywgXCJub3RpbjtcIjoweDIyMDksXHJcbiAgXCJub3RpbkU7XCI6WzB4MjJmOSwweDMzOF0sIFwibm90aW5kb3Q7XCI6WzB4MjJmNSwweDMzOF0sXHJcbiAgXCJub3RpbnZhO1wiOjB4MjIwOSwgXCJub3RpbnZiO1wiOjB4MjJmNyxcclxuICBcIm5vdGludmM7XCI6MHgyMmY2LCBcIm5vdG5pO1wiOjB4MjIwYyxcclxuICBcIm5vdG5pdmE7XCI6MHgyMjBjLCBcIm5vdG5pdmI7XCI6MHgyMmZlLFxyXG4gIFwibm90bml2YztcIjoweDIyZmQsIFwibnBhcjtcIjoweDIyMjYsXHJcbiAgXCJucGFyYWxsZWw7XCI6MHgyMjI2LCBcIm5wYXJzbDtcIjpbMHgyYWZkLDB4MjBlNV0sXHJcbiAgXCJucGFydDtcIjpbMHgyMjAyLDB4MzM4XSwgXCJucG9saW50O1wiOjB4MmExNCxcclxuICBcIm5wcjtcIjoweDIyODAsIFwibnByY3VlO1wiOjB4MjJlMCxcclxuICBcIm5wcmU7XCI6WzB4MmFhZiwweDMzOF0sIFwibnByZWM7XCI6MHgyMjgwLFxyXG4gIFwibnByZWNlcTtcIjpbMHgyYWFmLDB4MzM4XSwgXCJuckFycjtcIjoweDIxY2YsXHJcbiAgXCJucmFycjtcIjoweDIxOWIsIFwibnJhcnJjO1wiOlsweDI5MzMsMHgzMzhdLFxyXG4gIFwibnJhcnJ3O1wiOlsweDIxOWQsMHgzMzhdLCBcIm5yaWdodGFycm93O1wiOjB4MjE5YixcclxuICBcIm5ydHJpO1wiOjB4MjJlYiwgXCJucnRyaWU7XCI6MHgyMmVkLFxyXG4gIFwibnNjO1wiOjB4MjI4MSwgXCJuc2NjdWU7XCI6MHgyMmUxLFxyXG4gIFwibnNjZTtcIjpbMHgyYWIwLDB4MzM4XSwgXCJuc2NyO1wiOlsweGQ4MzUsMHhkY2MzXSxcclxuICBcIm5zaG9ydG1pZDtcIjoweDIyMjQsIFwibnNob3J0cGFyYWxsZWw7XCI6MHgyMjI2LFxyXG4gIFwibnNpbTtcIjoweDIyNDEsIFwibnNpbWU7XCI6MHgyMjQ0LFxyXG4gIFwibnNpbWVxO1wiOjB4MjI0NCwgXCJuc21pZDtcIjoweDIyMjQsXHJcbiAgXCJuc3BhcjtcIjoweDIyMjYsIFwibnNxc3ViZTtcIjoweDIyZTIsXHJcbiAgXCJuc3FzdXBlO1wiOjB4MjJlMywgXCJuc3ViO1wiOjB4MjI4NCxcclxuICBcIm5zdWJFO1wiOlsweDJhYzUsMHgzMzhdLCBcIm5zdWJlO1wiOjB4MjI4OCxcclxuICBcIm5zdWJzZXQ7XCI6WzB4MjI4MiwweDIwZDJdLCBcIm5zdWJzZXRlcTtcIjoweDIyODgsXHJcbiAgXCJuc3Vic2V0ZXFxO1wiOlsweDJhYzUsMHgzMzhdLCBcIm5zdWNjO1wiOjB4MjI4MSxcclxuICBcIm5zdWNjZXE7XCI6WzB4MmFiMCwweDMzOF0sIFwibnN1cDtcIjoweDIyODUsXHJcbiAgXCJuc3VwRTtcIjpbMHgyYWM2LDB4MzM4XSwgXCJuc3VwZTtcIjoweDIyODksXHJcbiAgXCJuc3Vwc2V0O1wiOlsweDIyODMsMHgyMGQyXSwgXCJuc3Vwc2V0ZXE7XCI6MHgyMjg5LFxyXG4gIFwibnN1cHNldGVxcTtcIjpbMHgyYWM2LDB4MzM4XSwgXCJudGdsO1wiOjB4MjI3OSxcclxuICBcIm50aWxkZVwiOjB4ZjEsIFwibnRpbGRlO1wiOjB4ZjEsXHJcbiAgXCJudGxnO1wiOjB4MjI3OCwgXCJudHJpYW5nbGVsZWZ0O1wiOjB4MjJlYSxcclxuICBcIm50cmlhbmdsZWxlZnRlcTtcIjoweDIyZWMsIFwibnRyaWFuZ2xlcmlnaHQ7XCI6MHgyMmViLFxyXG4gIFwibnRyaWFuZ2xlcmlnaHRlcTtcIjoweDIyZWQsIFwibnU7XCI6MHgzYmQsXHJcbiAgXCJudW07XCI6MHgyMywgXCJudW1lcm87XCI6MHgyMTE2LFxyXG4gIFwibnVtc3A7XCI6MHgyMDA3LCBcIm52RGFzaDtcIjoweDIyYWQsXHJcbiAgXCJudkhhcnI7XCI6MHgyOTA0LCBcIm52YXA7XCI6WzB4MjI0ZCwweDIwZDJdLFxyXG4gIFwibnZkYXNoO1wiOjB4MjJhYywgXCJudmdlO1wiOlsweDIyNjUsMHgyMGQyXSxcclxuICBcIm52Z3Q7XCI6WzB4M2UsMHgyMGQyXSwgXCJudmluZmluO1wiOjB4MjlkZSxcclxuICBcIm52bEFycjtcIjoweDI5MDIsIFwibnZsZTtcIjpbMHgyMjY0LDB4MjBkMl0sXHJcbiAgXCJudmx0O1wiOlsweDNjLDB4MjBkMl0sIFwibnZsdHJpZTtcIjpbMHgyMmI0LDB4MjBkMl0sXHJcbiAgXCJudnJBcnI7XCI6MHgyOTAzLCBcIm52cnRyaWU7XCI6WzB4MjJiNSwweDIwZDJdLFxyXG4gIFwibnZzaW07XCI6WzB4MjIzYywweDIwZDJdLCBcIm53QXJyO1wiOjB4MjFkNixcclxuICBcIm53YXJoaztcIjoweDI5MjMsIFwibndhcnI7XCI6MHgyMTk2LFxyXG4gIFwibndhcnJvdztcIjoweDIxOTYsIFwibnduZWFyO1wiOjB4MjkyNyxcclxuICBcIm9TO1wiOjB4MjRjOCwgXCJvYWN1dGVcIjoweGYzLFxyXG4gIFwib2FjdXRlO1wiOjB4ZjMsIFwib2FzdDtcIjoweDIyOWIsXHJcbiAgXCJvY2lyO1wiOjB4MjI5YSwgXCJvY2lyY1wiOjB4ZjQsXHJcbiAgXCJvY2lyYztcIjoweGY0LCBcIm9jeTtcIjoweDQzZSxcclxuICBcIm9kYXNoO1wiOjB4MjI5ZCwgXCJvZGJsYWM7XCI6MHgxNTEsXHJcbiAgXCJvZGl2O1wiOjB4MmEzOCwgXCJvZG90O1wiOjB4MjI5OSxcclxuICBcIm9kc29sZDtcIjoweDI5YmMsIFwib2VsaWc7XCI6MHgxNTMsXHJcbiAgXCJvZmNpcjtcIjoweDI5YmYsIFwib2ZyO1wiOlsweGQ4MzUsMHhkZDJjXSxcclxuICBcIm9nb247XCI6MHgyZGIsIFwib2dyYXZlXCI6MHhmMixcclxuICBcIm9ncmF2ZTtcIjoweGYyLCBcIm9ndDtcIjoweDI5YzEsXHJcbiAgXCJvaGJhcjtcIjoweDI5YjUsIFwib2htO1wiOjB4M2E5LFxyXG4gIFwib2ludDtcIjoweDIyMmUsIFwib2xhcnI7XCI6MHgyMWJhLFxyXG4gIFwib2xjaXI7XCI6MHgyOWJlLCBcIm9sY3Jvc3M7XCI6MHgyOWJiLFxyXG4gIFwib2xpbmU7XCI6MHgyMDNlLCBcIm9sdDtcIjoweDI5YzAsXHJcbiAgXCJvbWFjcjtcIjoweDE0ZCwgXCJvbWVnYTtcIjoweDNjOSxcclxuICBcIm9taWNyb247XCI6MHgzYmYsIFwib21pZDtcIjoweDI5YjYsXHJcbiAgXCJvbWludXM7XCI6MHgyMjk2LCBcIm9vcGY7XCI6WzB4ZDgzNSwweGRkNjBdLFxyXG4gIFwib3BhcjtcIjoweDI5YjcsIFwib3BlcnA7XCI6MHgyOWI5LFxyXG4gIFwib3BsdXM7XCI6MHgyMjk1LCBcIm9yO1wiOjB4MjIyOCxcclxuICBcIm9yYXJyO1wiOjB4MjFiYiwgXCJvcmQ7XCI6MHgyYTVkLFxyXG4gIFwib3JkZXI7XCI6MHgyMTM0LCBcIm9yZGVyb2Y7XCI6MHgyMTM0LFxyXG4gIFwib3JkZlwiOjB4YWEsIFwib3JkZjtcIjoweGFhLFxyXG4gIFwib3JkbVwiOjB4YmEsIFwib3JkbTtcIjoweGJhLFxyXG4gIFwib3JpZ29mO1wiOjB4MjJiNiwgXCJvcm9yO1wiOjB4MmE1NixcclxuICBcIm9yc2xvcGU7XCI6MHgyYTU3LCBcIm9ydjtcIjoweDJhNWIsXHJcbiAgXCJvc2NyO1wiOjB4MjEzNCwgXCJvc2xhc2hcIjoweGY4LFxyXG4gIFwib3NsYXNoO1wiOjB4ZjgsIFwib3NvbDtcIjoweDIyOTgsXHJcbiAgXCJvdGlsZGVcIjoweGY1LCBcIm90aWxkZTtcIjoweGY1LFxyXG4gIFwib3RpbWVzO1wiOjB4MjI5NywgXCJvdGltZXNhcztcIjoweDJhMzYsXHJcbiAgXCJvdW1sXCI6MHhmNiwgXCJvdW1sO1wiOjB4ZjYsXHJcbiAgXCJvdmJhcjtcIjoweDIzM2QsIFwicGFyO1wiOjB4MjIyNSxcclxuICBcInBhcmFcIjoweGI2LCBcInBhcmE7XCI6MHhiNixcclxuICBcInBhcmFsbGVsO1wiOjB4MjIyNSwgXCJwYXJzaW07XCI6MHgyYWYzLFxyXG4gIFwicGFyc2w7XCI6MHgyYWZkLCBcInBhcnQ7XCI6MHgyMjAyLFxyXG4gIFwicGN5O1wiOjB4NDNmLCBcInBlcmNudDtcIjoweDI1LFxyXG4gIFwicGVyaW9kO1wiOjB4MmUsIFwicGVybWlsO1wiOjB4MjAzMCxcclxuICBcInBlcnA7XCI6MHgyMmE1LCBcInBlcnRlbms7XCI6MHgyMDMxLFxyXG4gIFwicGZyO1wiOlsweGQ4MzUsMHhkZDJkXSwgXCJwaGk7XCI6MHgzYzYsXHJcbiAgXCJwaGl2O1wiOjB4M2Q1LCBcInBobW1hdDtcIjoweDIxMzMsXHJcbiAgXCJwaG9uZTtcIjoweDI2MGUsIFwicGk7XCI6MHgzYzAsXHJcbiAgXCJwaXRjaGZvcms7XCI6MHgyMmQ0LCBcInBpdjtcIjoweDNkNixcclxuICBcInBsYW5jaztcIjoweDIxMGYsIFwicGxhbmNraDtcIjoweDIxMGUsXHJcbiAgXCJwbGFua3Y7XCI6MHgyMTBmLCBcInBsdXM7XCI6MHgyYixcclxuICBcInBsdXNhY2lyO1wiOjB4MmEyMywgXCJwbHVzYjtcIjoweDIyOWUsXHJcbiAgXCJwbHVzY2lyO1wiOjB4MmEyMiwgXCJwbHVzZG87XCI6MHgyMjE0LFxyXG4gIFwicGx1c2R1O1wiOjB4MmEyNSwgXCJwbHVzZTtcIjoweDJhNzIsXHJcbiAgXCJwbHVzbW5cIjoweGIxLCBcInBsdXNtbjtcIjoweGIxLFxyXG4gIFwicGx1c3NpbTtcIjoweDJhMjYsIFwicGx1c3R3bztcIjoweDJhMjcsXHJcbiAgXCJwbTtcIjoweGIxLCBcInBvaW50aW50O1wiOjB4MmExNSxcclxuICBcInBvcGY7XCI6WzB4ZDgzNSwweGRkNjFdLCBcInBvdW5kXCI6MHhhMyxcclxuICBcInBvdW5kO1wiOjB4YTMsIFwicHI7XCI6MHgyMjdhLFxyXG4gIFwicHJFO1wiOjB4MmFiMywgXCJwcmFwO1wiOjB4MmFiNyxcclxuICBcInByY3VlO1wiOjB4MjI3YywgXCJwcmU7XCI6MHgyYWFmLFxyXG4gIFwicHJlYztcIjoweDIyN2EsIFwicHJlY2FwcHJveDtcIjoweDJhYjcsXHJcbiAgXCJwcmVjY3VybHllcTtcIjoweDIyN2MsIFwicHJlY2VxO1wiOjB4MmFhZixcclxuICBcInByZWNuYXBwcm94O1wiOjB4MmFiOSwgXCJwcmVjbmVxcTtcIjoweDJhYjUsXHJcbiAgXCJwcmVjbnNpbTtcIjoweDIyZTgsIFwicHJlY3NpbTtcIjoweDIyN2UsXHJcbiAgXCJwcmltZTtcIjoweDIwMzIsIFwicHJpbWVzO1wiOjB4MjExOSxcclxuICBcInBybkU7XCI6MHgyYWI1LCBcInBybmFwO1wiOjB4MmFiOSxcclxuICBcInBybnNpbTtcIjoweDIyZTgsIFwicHJvZDtcIjoweDIyMGYsXHJcbiAgXCJwcm9mYWxhcjtcIjoweDIzMmUsIFwicHJvZmxpbmU7XCI6MHgyMzEyLFxyXG4gIFwicHJvZnN1cmY7XCI6MHgyMzEzLCBcInByb3A7XCI6MHgyMjFkLFxyXG4gIFwicHJvcHRvO1wiOjB4MjIxZCwgXCJwcnNpbTtcIjoweDIyN2UsXHJcbiAgXCJwcnVyZWw7XCI6MHgyMmIwLCBcInBzY3I7XCI6WzB4ZDgzNSwweGRjYzVdLFxyXG4gIFwicHNpO1wiOjB4M2M4LCBcInB1bmNzcDtcIjoweDIwMDgsXHJcbiAgXCJxZnI7XCI6WzB4ZDgzNSwweGRkMmVdLCBcInFpbnQ7XCI6MHgyYTBjLFxyXG4gIFwicW9wZjtcIjpbMHhkODM1LDB4ZGQ2Ml0sIFwicXByaW1lO1wiOjB4MjA1NyxcclxuICBcInFzY3I7XCI6WzB4ZDgzNSwweGRjYzZdLCBcInF1YXRlcm5pb25zO1wiOjB4MjEwZCxcclxuICBcInF1YXRpbnQ7XCI6MHgyYTE2LCBcInF1ZXN0O1wiOjB4M2YsXHJcbiAgXCJxdWVzdGVxO1wiOjB4MjI1ZiwgXCJxdW90XCI6MHgyMixcclxuICBcInF1b3Q7XCI6MHgyMiwgXCJyQWFycjtcIjoweDIxZGIsXHJcbiAgXCJyQXJyO1wiOjB4MjFkMiwgXCJyQXRhaWw7XCI6MHgyOTFjLFxyXG4gIFwickJhcnI7XCI6MHgyOTBmLCBcInJIYXI7XCI6MHgyOTY0LFxyXG4gIFwicmFjZTtcIjpbMHgyMjNkLDB4MzMxXSwgXCJyYWN1dGU7XCI6MHgxNTUsXHJcbiAgXCJyYWRpYztcIjoweDIyMWEsIFwicmFlbXB0eXY7XCI6MHgyOWIzLFxyXG4gIFwicmFuZztcIjoweDI3ZTksIFwicmFuZ2Q7XCI6MHgyOTkyLFxyXG4gIFwicmFuZ2U7XCI6MHgyOWE1LCBcInJhbmdsZTtcIjoweDI3ZTksXHJcbiAgXCJyYXF1b1wiOjB4YmIsIFwicmFxdW87XCI6MHhiYixcclxuICBcInJhcnI7XCI6MHgyMTkyLCBcInJhcnJhcDtcIjoweDI5NzUsXHJcbiAgXCJyYXJyYjtcIjoweDIxZTUsIFwicmFycmJmcztcIjoweDI5MjAsXHJcbiAgXCJyYXJyYztcIjoweDI5MzMsIFwicmFycmZzO1wiOjB4MjkxZSxcclxuICBcInJhcnJoaztcIjoweDIxYWEsIFwicmFycmxwO1wiOjB4MjFhYyxcclxuICBcInJhcnJwbDtcIjoweDI5NDUsIFwicmFycnNpbTtcIjoweDI5NzQsXHJcbiAgXCJyYXJydGw7XCI6MHgyMWEzLCBcInJhcnJ3O1wiOjB4MjE5ZCxcclxuICBcInJhdGFpbDtcIjoweDI5MWEsIFwicmF0aW87XCI6MHgyMjM2LFxyXG4gIFwicmF0aW9uYWxzO1wiOjB4MjExYSwgXCJyYmFycjtcIjoweDI5MGQsXHJcbiAgXCJyYmJyaztcIjoweDI3NzMsIFwicmJyYWNlO1wiOjB4N2QsXHJcbiAgXCJyYnJhY2s7XCI6MHg1ZCwgXCJyYnJrZTtcIjoweDI5OGMsXHJcbiAgXCJyYnJrc2xkO1wiOjB4Mjk4ZSwgXCJyYnJrc2x1O1wiOjB4Mjk5MCxcclxuICBcInJjYXJvbjtcIjoweDE1OSwgXCJyY2VkaWw7XCI6MHgxNTcsXHJcbiAgXCJyY2VpbDtcIjoweDIzMDksIFwicmN1YjtcIjoweDdkLFxyXG4gIFwicmN5O1wiOjB4NDQwLCBcInJkY2E7XCI6MHgyOTM3LFxyXG4gIFwicmRsZGhhcjtcIjoweDI5NjksIFwicmRxdW87XCI6MHgyMDFkLFxyXG4gIFwicmRxdW9yO1wiOjB4MjAxZCwgXCJyZHNoO1wiOjB4MjFiMyxcclxuICBcInJlYWw7XCI6MHgyMTFjLCBcInJlYWxpbmU7XCI6MHgyMTFiLFxyXG4gIFwicmVhbHBhcnQ7XCI6MHgyMTFjLCBcInJlYWxzO1wiOjB4MjExZCxcclxuICBcInJlY3Q7XCI6MHgyNWFkLCBcInJlZ1wiOjB4YWUsXHJcbiAgXCJyZWc7XCI6MHhhZSwgXCJyZmlzaHQ7XCI6MHgyOTdkLFxyXG4gIFwicmZsb29yO1wiOjB4MjMwYiwgXCJyZnI7XCI6WzB4ZDgzNSwweGRkMmZdLFxyXG4gIFwicmhhcmQ7XCI6MHgyMWMxLCBcInJoYXJ1O1wiOjB4MjFjMCxcclxuICBcInJoYXJ1bDtcIjoweDI5NmMsIFwicmhvO1wiOjB4M2MxLFxyXG4gIFwicmhvdjtcIjoweDNmMSwgXCJyaWdodGFycm93O1wiOjB4MjE5MixcclxuICBcInJpZ2h0YXJyb3d0YWlsO1wiOjB4MjFhMywgXCJyaWdodGhhcnBvb25kb3duO1wiOjB4MjFjMSxcclxuICBcInJpZ2h0aGFycG9vbnVwO1wiOjB4MjFjMCwgXCJyaWdodGxlZnRhcnJvd3M7XCI6MHgyMWM0LFxyXG4gIFwicmlnaHRsZWZ0aGFycG9vbnM7XCI6MHgyMWNjLCBcInJpZ2h0cmlnaHRhcnJvd3M7XCI6MHgyMWM5LFxyXG4gIFwicmlnaHRzcXVpZ2Fycm93O1wiOjB4MjE5ZCwgXCJyaWdodHRocmVldGltZXM7XCI6MHgyMmNjLFxyXG4gIFwicmluZztcIjoweDJkYSwgXCJyaXNpbmdkb3RzZXE7XCI6MHgyMjUzLFxyXG4gIFwicmxhcnI7XCI6MHgyMWM0LCBcInJsaGFyO1wiOjB4MjFjYyxcclxuICBcInJsbTtcIjoweDIwMGYsIFwicm1vdXN0O1wiOjB4MjNiMSxcclxuICBcInJtb3VzdGFjaGU7XCI6MHgyM2IxLCBcInJubWlkO1wiOjB4MmFlZSxcclxuICBcInJvYW5nO1wiOjB4MjdlZCwgXCJyb2FycjtcIjoweDIxZmUsXHJcbiAgXCJyb2JyaztcIjoweDI3ZTcsIFwicm9wYXI7XCI6MHgyOTg2LFxyXG4gIFwicm9wZjtcIjpbMHhkODM1LDB4ZGQ2M10sIFwicm9wbHVzO1wiOjB4MmEyZSxcclxuICBcInJvdGltZXM7XCI6MHgyYTM1LCBcInJwYXI7XCI6MHgyOSxcclxuICBcInJwYXJndDtcIjoweDI5OTQsIFwicnBwb2xpbnQ7XCI6MHgyYTEyLFxyXG4gIFwicnJhcnI7XCI6MHgyMWM5LCBcInJzYXF1bztcIjoweDIwM2EsXHJcbiAgXCJyc2NyO1wiOlsweGQ4MzUsMHhkY2M3XSwgXCJyc2g7XCI6MHgyMWIxLFxyXG4gIFwicnNxYjtcIjoweDVkLCBcInJzcXVvO1wiOjB4MjAxOSxcclxuICBcInJzcXVvcjtcIjoweDIwMTksIFwicnRocmVlO1wiOjB4MjJjYyxcclxuICBcInJ0aW1lcztcIjoweDIyY2EsIFwicnRyaTtcIjoweDI1YjksXHJcbiAgXCJydHJpZTtcIjoweDIyYjUsIFwicnRyaWY7XCI6MHgyNWI4LFxyXG4gIFwicnRyaWx0cmk7XCI6MHgyOWNlLCBcInJ1bHVoYXI7XCI6MHgyOTY4LFxyXG4gIFwicng7XCI6MHgyMTFlLCBcInNhY3V0ZTtcIjoweDE1YixcclxuICBcInNicXVvO1wiOjB4MjAxYSwgXCJzYztcIjoweDIyN2IsXHJcbiAgXCJzY0U7XCI6MHgyYWI0LCBcInNjYXA7XCI6MHgyYWI4LFxyXG4gIFwic2Nhcm9uO1wiOjB4MTYxLCBcInNjY3VlO1wiOjB4MjI3ZCxcclxuICBcInNjZTtcIjoweDJhYjAsIFwic2NlZGlsO1wiOjB4MTVmLFxyXG4gIFwic2NpcmM7XCI6MHgxNWQsIFwic2NuRTtcIjoweDJhYjYsXHJcbiAgXCJzY25hcDtcIjoweDJhYmEsIFwic2Nuc2ltO1wiOjB4MjJlOSxcclxuICBcInNjcG9saW50O1wiOjB4MmExMywgXCJzY3NpbTtcIjoweDIyN2YsXHJcbiAgXCJzY3k7XCI6MHg0NDEsIFwic2RvdDtcIjoweDIyYzUsXHJcbiAgXCJzZG90YjtcIjoweDIyYTEsIFwic2RvdGU7XCI6MHgyYTY2LFxyXG4gIFwic2VBcnI7XCI6MHgyMWQ4LCBcInNlYXJoaztcIjoweDI5MjUsXHJcbiAgXCJzZWFycjtcIjoweDIxOTgsIFwic2VhcnJvdztcIjoweDIxOTgsXHJcbiAgXCJzZWN0XCI6MHhhNywgXCJzZWN0O1wiOjB4YTcsXHJcbiAgXCJzZW1pO1wiOjB4M2IsIFwic2Vzd2FyO1wiOjB4MjkyOSxcclxuICBcInNldG1pbnVzO1wiOjB4MjIxNiwgXCJzZXRtbjtcIjoweDIyMTYsXHJcbiAgXCJzZXh0O1wiOjB4MjczNiwgXCJzZnI7XCI6WzB4ZDgzNSwweGRkMzBdLFxyXG4gIFwic2Zyb3duO1wiOjB4MjMyMiwgXCJzaGFycDtcIjoweDI2NmYsXHJcbiAgXCJzaGNoY3k7XCI6MHg0NDksIFwic2hjeTtcIjoweDQ0OCxcclxuICBcInNob3J0bWlkO1wiOjB4MjIyMywgXCJzaG9ydHBhcmFsbGVsO1wiOjB4MjIyNSxcclxuICBcInNoeVwiOjB4YWQsIFwic2h5O1wiOjB4YWQsXHJcbiAgXCJzaWdtYTtcIjoweDNjMywgXCJzaWdtYWY7XCI6MHgzYzIsXHJcbiAgXCJzaWdtYXY7XCI6MHgzYzIsIFwic2ltO1wiOjB4MjIzYyxcclxuICBcInNpbWRvdDtcIjoweDJhNmEsIFwic2ltZTtcIjoweDIyNDMsXHJcbiAgXCJzaW1lcTtcIjoweDIyNDMsIFwic2ltZztcIjoweDJhOWUsXHJcbiAgXCJzaW1nRTtcIjoweDJhYTAsIFwic2ltbDtcIjoweDJhOWQsXHJcbiAgXCJzaW1sRTtcIjoweDJhOWYsIFwic2ltbmU7XCI6MHgyMjQ2LFxyXG4gIFwic2ltcGx1cztcIjoweDJhMjQsIFwic2ltcmFycjtcIjoweDI5NzIsXHJcbiAgXCJzbGFycjtcIjoweDIxOTAsIFwic21hbGxzZXRtaW51cztcIjoweDIyMTYsXHJcbiAgXCJzbWFzaHA7XCI6MHgyYTMzLCBcInNtZXBhcnNsO1wiOjB4MjllNCxcclxuICBcInNtaWQ7XCI6MHgyMjIzLCBcInNtaWxlO1wiOjB4MjMyMyxcclxuICBcInNtdDtcIjoweDJhYWEsIFwic210ZTtcIjoweDJhYWMsXHJcbiAgXCJzbXRlcztcIjpbMHgyYWFjLDB4ZmUwMF0sIFwic29mdGN5O1wiOjB4NDRjLFxyXG4gIFwic29sO1wiOjB4MmYsIFwic29sYjtcIjoweDI5YzQsXHJcbiAgXCJzb2xiYXI7XCI6MHgyMzNmLCBcInNvcGY7XCI6WzB4ZDgzNSwweGRkNjRdLFxyXG4gIFwic3BhZGVzO1wiOjB4MjY2MCwgXCJzcGFkZXN1aXQ7XCI6MHgyNjYwLFxyXG4gIFwic3BhcjtcIjoweDIyMjUsIFwic3FjYXA7XCI6MHgyMjkzLFxyXG4gIFwic3FjYXBzO1wiOlsweDIyOTMsMHhmZTAwXSwgXCJzcWN1cDtcIjoweDIyOTQsXHJcbiAgXCJzcWN1cHM7XCI6WzB4MjI5NCwweGZlMDBdLCBcInNxc3ViO1wiOjB4MjI4ZixcclxuICBcInNxc3ViZTtcIjoweDIyOTEsIFwic3FzdWJzZXQ7XCI6MHgyMjhmLFxyXG4gIFwic3FzdWJzZXRlcTtcIjoweDIyOTEsIFwic3FzdXA7XCI6MHgyMjkwLFxyXG4gIFwic3FzdXBlO1wiOjB4MjI5MiwgXCJzcXN1cHNldDtcIjoweDIyOTAsXHJcbiAgXCJzcXN1cHNldGVxO1wiOjB4MjI5MiwgXCJzcXU7XCI6MHgyNWExLFxyXG4gIFwic3F1YXJlO1wiOjB4MjVhMSwgXCJzcXVhcmY7XCI6MHgyNWFhLFxyXG4gIFwic3F1ZjtcIjoweDI1YWEsIFwic3JhcnI7XCI6MHgyMTkyLFxyXG4gIFwic3NjcjtcIjpbMHhkODM1LDB4ZGNjOF0sIFwic3NldG1uO1wiOjB4MjIxNixcclxuICBcInNzbWlsZTtcIjoweDIzMjMsIFwic3N0YXJmO1wiOjB4MjJjNixcclxuICBcInN0YXI7XCI6MHgyNjA2LCBcInN0YXJmO1wiOjB4MjYwNSxcclxuICBcInN0cmFpZ2h0ZXBzaWxvbjtcIjoweDNmNSwgXCJzdHJhaWdodHBoaTtcIjoweDNkNSxcclxuICBcInN0cm5zO1wiOjB4YWYsIFwic3ViO1wiOjB4MjI4MixcclxuICBcInN1YkU7XCI6MHgyYWM1LCBcInN1YmRvdDtcIjoweDJhYmQsXHJcbiAgXCJzdWJlO1wiOjB4MjI4NiwgXCJzdWJlZG90O1wiOjB4MmFjMyxcclxuICBcInN1Ym11bHQ7XCI6MHgyYWMxLCBcInN1Ym5FO1wiOjB4MmFjYixcclxuICBcInN1Ym5lO1wiOjB4MjI4YSwgXCJzdWJwbHVzO1wiOjB4MmFiZixcclxuICBcInN1YnJhcnI7XCI6MHgyOTc5LCBcInN1YnNldDtcIjoweDIyODIsXHJcbiAgXCJzdWJzZXRlcTtcIjoweDIyODYsIFwic3Vic2V0ZXFxO1wiOjB4MmFjNSxcclxuICBcInN1YnNldG5lcTtcIjoweDIyOGEsIFwic3Vic2V0bmVxcTtcIjoweDJhY2IsXHJcbiAgXCJzdWJzaW07XCI6MHgyYWM3LCBcInN1YnN1YjtcIjoweDJhZDUsXHJcbiAgXCJzdWJzdXA7XCI6MHgyYWQzLCBcInN1Y2M7XCI6MHgyMjdiLFxyXG4gIFwic3VjY2FwcHJveDtcIjoweDJhYjgsIFwic3VjY2N1cmx5ZXE7XCI6MHgyMjdkLFxyXG4gIFwic3VjY2VxO1wiOjB4MmFiMCwgXCJzdWNjbmFwcHJveDtcIjoweDJhYmEsXHJcbiAgXCJzdWNjbmVxcTtcIjoweDJhYjYsIFwic3VjY25zaW07XCI6MHgyMmU5LFxyXG4gIFwic3VjY3NpbTtcIjoweDIyN2YsIFwic3VtO1wiOjB4MjIxMSxcclxuICBcInN1bmc7XCI6MHgyNjZhLCBcInN1cDFcIjoweGI5LFxyXG4gIFwic3VwMTtcIjoweGI5LCBcInN1cDJcIjoweGIyLFxyXG4gIFwic3VwMjtcIjoweGIyLCBcInN1cDNcIjoweGIzLFxyXG4gIFwic3VwMztcIjoweGIzLCBcInN1cDtcIjoweDIyODMsXHJcbiAgXCJzdXBFO1wiOjB4MmFjNiwgXCJzdXBkb3Q7XCI6MHgyYWJlLFxyXG4gIFwic3VwZHN1YjtcIjoweDJhZDgsIFwic3VwZTtcIjoweDIyODcsXHJcbiAgXCJzdXBlZG90O1wiOjB4MmFjNCwgXCJzdXBoc29sO1wiOjB4MjdjOSxcclxuICBcInN1cGhzdWI7XCI6MHgyYWQ3LCBcInN1cGxhcnI7XCI6MHgyOTdiLFxyXG4gIFwic3VwbXVsdDtcIjoweDJhYzIsIFwic3VwbkU7XCI6MHgyYWNjLFxyXG4gIFwic3VwbmU7XCI6MHgyMjhiLCBcInN1cHBsdXM7XCI6MHgyYWMwLFxyXG4gIFwic3Vwc2V0O1wiOjB4MjI4MywgXCJzdXBzZXRlcTtcIjoweDIyODcsXHJcbiAgXCJzdXBzZXRlcXE7XCI6MHgyYWM2LCBcInN1cHNldG5lcTtcIjoweDIyOGIsXHJcbiAgXCJzdXBzZXRuZXFxO1wiOjB4MmFjYywgXCJzdXBzaW07XCI6MHgyYWM4LFxyXG4gIFwic3Vwc3ViO1wiOjB4MmFkNCwgXCJzdXBzdXA7XCI6MHgyYWQ2LFxyXG4gIFwic3dBcnI7XCI6MHgyMWQ5LCBcInN3YXJoaztcIjoweDI5MjYsXHJcbiAgXCJzd2FycjtcIjoweDIxOTksIFwic3dhcnJvdztcIjoweDIxOTksXHJcbiAgXCJzd253YXI7XCI6MHgyOTJhLCBcInN6bGlnXCI6MHhkZixcclxuICBcInN6bGlnO1wiOjB4ZGYsIFwidGFyZ2V0O1wiOjB4MjMxNixcclxuICBcInRhdTtcIjoweDNjNCwgXCJ0YnJrO1wiOjB4MjNiNCxcclxuICBcInRjYXJvbjtcIjoweDE2NSwgXCJ0Y2VkaWw7XCI6MHgxNjMsXHJcbiAgXCJ0Y3k7XCI6MHg0NDIsIFwidGRvdDtcIjoweDIwZGIsXHJcbiAgXCJ0ZWxyZWM7XCI6MHgyMzE1LCBcInRmcjtcIjpbMHhkODM1LDB4ZGQzMV0sXHJcbiAgXCJ0aGVyZTQ7XCI6MHgyMjM0LCBcInRoZXJlZm9yZTtcIjoweDIyMzQsXHJcbiAgXCJ0aGV0YTtcIjoweDNiOCwgXCJ0aGV0YXN5bTtcIjoweDNkMSxcclxuICBcInRoZXRhdjtcIjoweDNkMSwgXCJ0aGlja2FwcHJveDtcIjoweDIyNDgsXHJcbiAgXCJ0aGlja3NpbTtcIjoweDIyM2MsIFwidGhpbnNwO1wiOjB4MjAwOSxcclxuICBcInRoa2FwO1wiOjB4MjI0OCwgXCJ0aGtzaW07XCI6MHgyMjNjLFxyXG4gIFwidGhvcm5cIjoweGZlLCBcInRob3JuO1wiOjB4ZmUsXHJcbiAgXCJ0aWxkZTtcIjoweDJkYywgXCJ0aW1lc1wiOjB4ZDcsXHJcbiAgXCJ0aW1lcztcIjoweGQ3LCBcInRpbWVzYjtcIjoweDIyYTAsXHJcbiAgXCJ0aW1lc2JhcjtcIjoweDJhMzEsIFwidGltZXNkO1wiOjB4MmEzMCxcclxuICBcInRpbnQ7XCI6MHgyMjJkLCBcInRvZWE7XCI6MHgyOTI4LFxyXG4gIFwidG9wO1wiOjB4MjJhNCwgXCJ0b3Bib3Q7XCI6MHgyMzM2LFxyXG4gIFwidG9wY2lyO1wiOjB4MmFmMSwgXCJ0b3BmO1wiOlsweGQ4MzUsMHhkZDY1XSxcclxuICBcInRvcGZvcms7XCI6MHgyYWRhLCBcInRvc2E7XCI6MHgyOTI5LFxyXG4gIFwidHByaW1lO1wiOjB4MjAzNCwgXCJ0cmFkZTtcIjoweDIxMjIsXHJcbiAgXCJ0cmlhbmdsZTtcIjoweDI1YjUsIFwidHJpYW5nbGVkb3duO1wiOjB4MjViZixcclxuICBcInRyaWFuZ2xlbGVmdDtcIjoweDI1YzMsIFwidHJpYW5nbGVsZWZ0ZXE7XCI6MHgyMmI0LFxyXG4gIFwidHJpYW5nbGVxO1wiOjB4MjI1YywgXCJ0cmlhbmdsZXJpZ2h0O1wiOjB4MjViOSxcclxuICBcInRyaWFuZ2xlcmlnaHRlcTtcIjoweDIyYjUsIFwidHJpZG90O1wiOjB4MjVlYyxcclxuICBcInRyaWU7XCI6MHgyMjVjLCBcInRyaW1pbnVzO1wiOjB4MmEzYSxcclxuICBcInRyaXBsdXM7XCI6MHgyYTM5LCBcInRyaXNiO1wiOjB4MjljZCxcclxuICBcInRyaXRpbWU7XCI6MHgyYTNiLCBcInRycGV6aXVtO1wiOjB4MjNlMixcclxuICBcInRzY3I7XCI6WzB4ZDgzNSwweGRjYzldLCBcInRzY3k7XCI6MHg0NDYsXHJcbiAgXCJ0c2hjeTtcIjoweDQ1YiwgXCJ0c3Ryb2s7XCI6MHgxNjcsXHJcbiAgXCJ0d2l4dDtcIjoweDIyNmMsIFwidHdvaGVhZGxlZnRhcnJvdztcIjoweDIxOWUsXHJcbiAgXCJ0d29oZWFkcmlnaHRhcnJvdztcIjoweDIxYTAsIFwidUFycjtcIjoweDIxZDEsXHJcbiAgXCJ1SGFyO1wiOjB4Mjk2MywgXCJ1YWN1dGVcIjoweGZhLFxyXG4gIFwidWFjdXRlO1wiOjB4ZmEsIFwidWFycjtcIjoweDIxOTEsXHJcbiAgXCJ1YnJjeTtcIjoweDQ1ZSwgXCJ1YnJldmU7XCI6MHgxNmQsXHJcbiAgXCJ1Y2lyY1wiOjB4ZmIsIFwidWNpcmM7XCI6MHhmYixcclxuICBcInVjeTtcIjoweDQ0MywgXCJ1ZGFycjtcIjoweDIxYzUsXHJcbiAgXCJ1ZGJsYWM7XCI6MHgxNzEsIFwidWRoYXI7XCI6MHgyOTZlLFxyXG4gIFwidWZpc2h0O1wiOjB4Mjk3ZSwgXCJ1ZnI7XCI6WzB4ZDgzNSwweGRkMzJdLFxyXG4gIFwidWdyYXZlXCI6MHhmOSwgXCJ1Z3JhdmU7XCI6MHhmOSxcclxuICBcInVoYXJsO1wiOjB4MjFiZiwgXCJ1aGFycjtcIjoweDIxYmUsXHJcbiAgXCJ1aGJsaztcIjoweDI1ODAsIFwidWxjb3JuO1wiOjB4MjMxYyxcclxuICBcInVsY29ybmVyO1wiOjB4MjMxYywgXCJ1bGNyb3A7XCI6MHgyMzBmLFxyXG4gIFwidWx0cmk7XCI6MHgyNWY4LCBcInVtYWNyO1wiOjB4MTZiLFxyXG4gIFwidW1sXCI6MHhhOCwgXCJ1bWw7XCI6MHhhOCxcclxuICBcInVvZ29uO1wiOjB4MTczLCBcInVvcGY7XCI6WzB4ZDgzNSwweGRkNjZdLFxyXG4gIFwidXBhcnJvdztcIjoweDIxOTEsIFwidXBkb3duYXJyb3c7XCI6MHgyMTk1LFxyXG4gIFwidXBoYXJwb29ubGVmdDtcIjoweDIxYmYsIFwidXBoYXJwb29ucmlnaHQ7XCI6MHgyMWJlLFxyXG4gIFwidXBsdXM7XCI6MHgyMjhlLCBcInVwc2k7XCI6MHgzYzUsXHJcbiAgXCJ1cHNpaDtcIjoweDNkMiwgXCJ1cHNpbG9uO1wiOjB4M2M1LFxyXG4gIFwidXB1cGFycm93cztcIjoweDIxYzgsIFwidXJjb3JuO1wiOjB4MjMxZCxcclxuICBcInVyY29ybmVyO1wiOjB4MjMxZCwgXCJ1cmNyb3A7XCI6MHgyMzBlLFxyXG4gIFwidXJpbmc7XCI6MHgxNmYsIFwidXJ0cmk7XCI6MHgyNWY5LFxyXG4gIFwidXNjcjtcIjpbMHhkODM1LDB4ZGNjYV0sIFwidXRkb3Q7XCI6MHgyMmYwLFxyXG4gIFwidXRpbGRlO1wiOjB4MTY5LCBcInV0cmk7XCI6MHgyNWI1LFxyXG4gIFwidXRyaWY7XCI6MHgyNWI0LCBcInV1YXJyO1wiOjB4MjFjOCxcclxuICBcInV1bWxcIjoweGZjLCBcInV1bWw7XCI6MHhmYyxcclxuICBcInV3YW5nbGU7XCI6MHgyOWE3LCBcInZBcnI7XCI6MHgyMWQ1LFxyXG4gIFwidkJhcjtcIjoweDJhZTgsIFwidkJhcnY7XCI6MHgyYWU5LFxyXG4gIFwidkRhc2g7XCI6MHgyMmE4LCBcInZhbmdydDtcIjoweDI5OWMsXHJcbiAgXCJ2YXJlcHNpbG9uO1wiOjB4M2Y1LCBcInZhcmthcHBhO1wiOjB4M2YwLFxyXG4gIFwidmFybm90aGluZztcIjoweDIyMDUsIFwidmFycGhpO1wiOjB4M2Q1LFxyXG4gIFwidmFycGk7XCI6MHgzZDYsIFwidmFycHJvcHRvO1wiOjB4MjIxZCxcclxuICBcInZhcnI7XCI6MHgyMTk1LCBcInZhcnJobztcIjoweDNmMSxcclxuICBcInZhcnNpZ21hO1wiOjB4M2MyLCBcInZhcnN1YnNldG5lcTtcIjpbMHgyMjhhLDB4ZmUwMF0sXHJcbiAgXCJ2YXJzdWJzZXRuZXFxO1wiOlsweDJhY2IsMHhmZTAwXSwgXCJ2YXJzdXBzZXRuZXE7XCI6WzB4MjI4YiwweGZlMDBdLFxyXG4gIFwidmFyc3Vwc2V0bmVxcTtcIjpbMHgyYWNjLDB4ZmUwMF0sIFwidmFydGhldGE7XCI6MHgzZDEsXHJcbiAgXCJ2YXJ0cmlhbmdsZWxlZnQ7XCI6MHgyMmIyLCBcInZhcnRyaWFuZ2xlcmlnaHQ7XCI6MHgyMmIzLFxyXG4gIFwidmN5O1wiOjB4NDMyLCBcInZkYXNoO1wiOjB4MjJhMixcclxuICBcInZlZTtcIjoweDIyMjgsIFwidmVlYmFyO1wiOjB4MjJiYixcclxuICBcInZlZWVxO1wiOjB4MjI1YSwgXCJ2ZWxsaXA7XCI6MHgyMmVlLFxyXG4gIFwidmVyYmFyO1wiOjB4N2MsIFwidmVydDtcIjoweDdjLFxyXG4gIFwidmZyO1wiOlsweGQ4MzUsMHhkZDMzXSwgXCJ2bHRyaTtcIjoweDIyYjIsXHJcbiAgXCJ2bnN1YjtcIjpbMHgyMjgyLDB4MjBkMl0sIFwidm5zdXA7XCI6WzB4MjI4MywweDIwZDJdLFxyXG4gIFwidm9wZjtcIjpbMHhkODM1LDB4ZGQ2N10sIFwidnByb3A7XCI6MHgyMjFkLFxyXG4gIFwidnJ0cmk7XCI6MHgyMmIzLCBcInZzY3I7XCI6WzB4ZDgzNSwweGRjY2JdLFxyXG4gIFwidnN1Ym5FO1wiOlsweDJhY2IsMHhmZTAwXSwgXCJ2c3VibmU7XCI6WzB4MjI4YSwweGZlMDBdLFxyXG4gIFwidnN1cG5FO1wiOlsweDJhY2MsMHhmZTAwXSwgXCJ2c3VwbmU7XCI6WzB4MjI4YiwweGZlMDBdLFxyXG4gIFwidnppZ3phZztcIjoweDI5OWEsIFwid2NpcmM7XCI6MHgxNzUsXHJcbiAgXCJ3ZWRiYXI7XCI6MHgyYTVmLCBcIndlZGdlO1wiOjB4MjIyNyxcclxuICBcIndlZGdlcTtcIjoweDIyNTksIFwid2VpZXJwO1wiOjB4MjExOCxcclxuICBcIndmcjtcIjpbMHhkODM1LDB4ZGQzNF0sIFwid29wZjtcIjpbMHhkODM1LDB4ZGQ2OF0sXHJcbiAgXCJ3cDtcIjoweDIxMTgsIFwid3I7XCI6MHgyMjQwLFxyXG4gIFwid3JlYXRoO1wiOjB4MjI0MCwgXCJ3c2NyO1wiOlsweGQ4MzUsMHhkY2NjXSxcclxuICBcInhjYXA7XCI6MHgyMmMyLCBcInhjaXJjO1wiOjB4MjVlZixcclxuICBcInhjdXA7XCI6MHgyMmMzLCBcInhkdHJpO1wiOjB4MjViZCxcclxuICBcInhmcjtcIjpbMHhkODM1LDB4ZGQzNV0sIFwieGhBcnI7XCI6MHgyN2ZhLFxyXG4gIFwieGhhcnI7XCI6MHgyN2Y3LCBcInhpO1wiOjB4M2JlLFxyXG4gIFwieGxBcnI7XCI6MHgyN2Y4LCBcInhsYXJyO1wiOjB4MjdmNSxcclxuICBcInhtYXA7XCI6MHgyN2ZjLCBcInhuaXM7XCI6MHgyMmZiLFxyXG4gIFwieG9kb3Q7XCI6MHgyYTAwLCBcInhvcGY7XCI6WzB4ZDgzNSwweGRkNjldLFxyXG4gIFwieG9wbHVzO1wiOjB4MmEwMSwgXCJ4b3RpbWU7XCI6MHgyYTAyLFxyXG4gIFwieHJBcnI7XCI6MHgyN2Y5LCBcInhyYXJyO1wiOjB4MjdmNixcclxuICBcInhzY3I7XCI6WzB4ZDgzNSwweGRjY2RdLCBcInhzcWN1cDtcIjoweDJhMDYsXHJcbiAgXCJ4dXBsdXM7XCI6MHgyYTA0LCBcInh1dHJpO1wiOjB4MjViMyxcclxuICBcInh2ZWU7XCI6MHgyMmMxLCBcInh3ZWRnZTtcIjoweDIyYzAsXHJcbiAgXCJ5YWN1dGVcIjoweGZkLCBcInlhY3V0ZTtcIjoweGZkLFxyXG4gIFwieWFjeTtcIjoweDQ0ZiwgXCJ5Y2lyYztcIjoweDE3NyxcclxuICBcInljeTtcIjoweDQ0YiwgXCJ5ZW5cIjoweGE1LFxyXG4gIFwieWVuO1wiOjB4YTUsIFwieWZyO1wiOlsweGQ4MzUsMHhkZDM2XSxcclxuICBcInlpY3k7XCI6MHg0NTcsIFwieW9wZjtcIjpbMHhkODM1LDB4ZGQ2YV0sXHJcbiAgXCJ5c2NyO1wiOlsweGQ4MzUsMHhkY2NlXSwgXCJ5dWN5O1wiOjB4NDRlLFxyXG4gIFwieXVtbFwiOjB4ZmYsIFwieXVtbDtcIjoweGZmLFxyXG4gIFwiemFjdXRlO1wiOjB4MTdhLCBcInpjYXJvbjtcIjoweDE3ZSxcclxuICBcInpjeTtcIjoweDQzNywgXCJ6ZG90O1wiOjB4MTdjLFxyXG4gIFwiemVldHJmO1wiOjB4MjEyOCwgXCJ6ZXRhO1wiOjB4M2I2LFxyXG4gIFwiemZyO1wiOlsweGQ4MzUsMHhkZDM3XSwgXCJ6aGN5O1wiOjB4NDM2LFxyXG4gIFwiemlncmFycjtcIjoweDIxZGQsIFwiem9wZjtcIjpbMHhkODM1LDB4ZGQ2Yl0sXHJcbiAgXCJ6c2NyO1wiOlsweGQ4MzUsMHhkY2NmXSwgXCJ6d2o7XCI6MHgyMDBkLFxyXG4gIFwienduajtcIjoweDIwMGMsXHJcbn07XHJcbi8qXHJcbiAqIFRoaXMgcmVnZXhwIGlzIGdlbmVyYXRlZCB3aXRoIHRlc3QvdG9vbHMvdXBkYXRlLWVudGl0aWVzLmpzXHJcbiAqIEl0IHdpbGwgYWx3YXlzIG1hdGNoIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgLS0gYnV0IG5vdGUgdGhhdCB0aGVyZVxyXG4gKiBhcmUgbm8gZW50aXRpZXMgd2hvc2UgbmFtZXMgYXJlIGEgc2luZ2xlIGNoYXJhY3RlciBsb25nLlxyXG4gKi9cclxudmFyIE5BTUVEQ0hBUlJFRiA9IC8oQSg/OkVsaWc7P3xNUDs/fGFjdXRlOz98YnJldmU7fGMoPzppcmM7P3x5Oyl8ZnI7fGdyYXZlOz98bHBoYTt8bWFjcjt8bmQ7fG8oPzpnb247fHBmOyl8cHBseUZ1bmN0aW9uO3xyaW5nOz98cyg/OmNyO3xzaWduOyl8dGlsZGU7P3x1bWw7Pyl8Qig/OmEoPzpja3NsYXNoO3xyKD86djt8d2VkOykpfGN5O3xlKD86Y2F1c2U7fHJub3VsbGlzO3x0YTspfGZyO3xvcGY7fHJldmU7fHNjcjt8dW1wZXE7KXxDKD86SGN5O3xPUFk7P3xhKD86Y3V0ZTt8cCg/Ojt8aXRhbERpZmZlcmVudGlhbEQ7KXx5bGV5czspfGMoPzphcm9uO3xlZGlsOz98aXJjO3xvbmludDspfGRvdDt8ZSg/OmRpbGxhO3xudGVyRG90Oyl8ZnI7fGhpO3xpcmNsZSg/OkRvdDt8TWludXM7fFBsdXM7fFRpbWVzOyl8bG8oPzpja3dpc2VDb250b3VySW50ZWdyYWw7fHNlQ3VybHkoPzpEb3VibGVRdW90ZTt8UXVvdGU7KSl8byg/Omxvbig/Ojt8ZTspfG4oPzpncnVlbnQ7fGludDt8dG91ckludGVncmFsOyl8cCg/OmY7fHJvZHVjdDspfHVudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsOyl8cm9zczt8c2NyO3x1cCg/Ojt8Q2FwOykpfEQoPzpEKD86O3xvdHJhaGQ7KXxKY3k7fFNjeTt8WmN5O3xhKD86Z2dlcjt8cnI7fHNodjspfGMoPzphcm9uO3x5Oyl8ZWwoPzo7fHRhOyl8ZnI7fGkoPzphKD86Y3JpdGljYWwoPzpBY3V0ZTt8RG8oPzp0O3x1YmxlQWN1dGU7KXxHcmF2ZTt8VGlsZGU7KXxtb25kOyl8ZmZlcmVudGlhbEQ7KXxvKD86cGY7fHQoPzo7fERvdDt8RXF1YWw7KXx1YmxlKD86Q29udG91ckludGVncmFsO3xEbyg/OnQ7fHduQXJyb3c7KXxMKD86ZWZ0KD86QXJyb3c7fFJpZ2h0QXJyb3c7fFRlZTspfG9uZyg/OkxlZnQoPzpBcnJvdzt8UmlnaHRBcnJvdzspfFJpZ2h0QXJyb3c7KSl8UmlnaHQoPzpBcnJvdzt8VGVlOyl8VXAoPzpBcnJvdzt8RG93bkFycm93Oyl8VmVydGljYWxCYXI7KXx3big/OkFycm93KD86O3xCYXI7fFVwQXJyb3c7KXxCcmV2ZTt8TGVmdCg/OlJpZ2h0VmVjdG9yO3xUZWVWZWN0b3I7fFZlY3Rvcig/Ojt8QmFyOykpfFJpZ2h0KD86VGVlVmVjdG9yO3xWZWN0b3IoPzo7fEJhcjspKXxUZWUoPzo7fEFycm93Oyl8YXJyb3c7KSl8cyg/OmNyO3x0cm9rOykpfEUoPzpORzt8VEg7P3xhY3V0ZTs/fGMoPzphcm9uO3xpcmM7P3x5Oyl8ZG90O3xmcjt8Z3JhdmU7P3xsZW1lbnQ7fG0oPzphY3I7fHB0eSg/OlNtYWxsU3F1YXJlO3xWZXJ5U21hbGxTcXVhcmU7KSl8byg/Omdvbjt8cGY7KXxwc2lsb247fHF1KD86YWwoPzo7fFRpbGRlOyl8aWxpYnJpdW07KXxzKD86Y3I7fGltOyl8dGE7fHVtbDs/fHgoPzppc3RzO3xwb25lbnRpYWxFOykpfEYoPzpjeTt8ZnI7fGlsbGVkKD86U21hbGxTcXVhcmU7fFZlcnlTbWFsbFNxdWFyZTspfG8oPzpwZjt8ckFsbDt8dXJpZXJ0cmY7KXxzY3I7KXxHKD86SmN5O3xUOz98YW1tYSg/Ojt8ZDspfGJyZXZlO3xjKD86ZWRpbDt8aXJjO3x5Oyl8ZG90O3xmcjt8Zzt8b3BmO3xyZWF0ZXIoPzpFcXVhbCg/Ojt8TGVzczspfEZ1bGxFcXVhbDt8R3JlYXRlcjt8TGVzczt8U2xhbnRFcXVhbDt8VGlsZGU7KXxzY3I7fHQ7KXxIKD86QVJEY3k7fGEoPzpjZWs7fHQ7KXxjaXJjO3xmcjt8aWxiZXJ0U3BhY2U7fG8oPzpwZjt8cml6b250YWxMaW5lOyl8cyg/OmNyO3x0cm9rOyl8dW1wKD86RG93bkh1bXA7fEVxdWFsOykpfEkoPzpFY3k7fEpsaWc7fE9jeTt8YWN1dGU7P3xjKD86aXJjOz98eTspfGRvdDt8ZnI7fGdyYXZlOz98bSg/Ojt8YSg/OmNyO3xnaW5hcnlJOyl8cGxpZXM7KXxuKD86dCg/Ojt8ZSg/OmdyYWw7fHJzZWN0aW9uOykpfHZpc2libGUoPzpDb21tYTt8VGltZXM7KSl8byg/Omdvbjt8cGY7fHRhOyl8c2NyO3x0aWxkZTt8dSg/OmtjeTt8bWw7PykpfEooPzpjKD86aXJjO3x5Oyl8ZnI7fG9wZjt8cyg/OmNyO3xlcmN5Oyl8dWtjeTspfEsoPzpIY3k7fEpjeTt8YXBwYTt8Yyg/OmVkaWw7fHk7KXxmcjt8b3BmO3xzY3I7KXxMKD86SmN5O3xUOz98YSg/OmN1dGU7fG1iZGE7fG5nO3xwbGFjZXRyZjt8cnI7KXxjKD86YXJvbjt8ZWRpbDt8eTspfGUoPzpmdCg/OkEoPzpuZ2xlQnJhY2tldDt8cnJvdyg/Ojt8QmFyO3xSaWdodEFycm93OykpfENlaWxpbmc7fERvKD86dWJsZUJyYWNrZXQ7fHduKD86VGVlVmVjdG9yO3xWZWN0b3IoPzo7fEJhcjspKSl8Rmxvb3I7fFJpZ2h0KD86QXJyb3c7fFZlY3RvcjspfFQoPzplZSg/Ojt8QXJyb3c7fFZlY3RvcjspfHJpYW5nbGUoPzo7fEJhcjt8RXF1YWw7KSl8VXAoPzpEb3duVmVjdG9yO3xUZWVWZWN0b3I7fFZlY3Rvcig/Ojt8QmFyOykpfFZlY3Rvcig/Ojt8QmFyOyl8YXJyb3c7fHJpZ2h0YXJyb3c7KXxzcyg/OkVxdWFsR3JlYXRlcjt8RnVsbEVxdWFsO3xHcmVhdGVyO3xMZXNzO3xTbGFudEVxdWFsO3xUaWxkZTspKXxmcjt8bCg/Ojt8ZWZ0YXJyb3c7KXxtaWRvdDt8byg/Om5nKD86TGVmdCg/OkFycm93O3xSaWdodEFycm93Oyl8UmlnaHRBcnJvdzt8bGVmdCg/OmFycm93O3xyaWdodGFycm93Oyl8cmlnaHRhcnJvdzspfHBmO3x3ZXIoPzpMZWZ0QXJyb3c7fFJpZ2h0QXJyb3c7KSl8cyg/OmNyO3xoO3x0cm9rOyl8dDspfE0oPzphcDt8Y3k7fGUoPzpkaXVtU3BhY2U7fGxsaW50cmY7KXxmcjt8aW51c1BsdXM7fG9wZjt8c2NyO3x1Oyl8Tig/OkpjeTt8YWN1dGU7fGMoPzphcm9uO3xlZGlsO3x5Oyl8ZSg/OmdhdGl2ZSg/Ok1lZGl1bVNwYWNlO3xUaGkoPzpja1NwYWNlO3xuU3BhY2U7KXxWZXJ5VGhpblNwYWNlOyl8c3RlZCg/OkdyZWF0ZXJHcmVhdGVyO3xMZXNzTGVzczspfHdMaW5lOyl8ZnI7fG8oPzpCcmVhazt8bkJyZWFraW5nU3BhY2U7fHBmO3x0KD86O3xDKD86b25ncnVlbnQ7fHVwQ2FwOyl8RG91YmxlVmVydGljYWxCYXI7fEUoPzpsZW1lbnQ7fHF1YWwoPzo7fFRpbGRlOyl8eGlzdHM7KXxHcmVhdGVyKD86O3xFcXVhbDt8RnVsbEVxdWFsO3xHcmVhdGVyO3xMZXNzO3xTbGFudEVxdWFsO3xUaWxkZTspfEh1bXAoPzpEb3duSHVtcDt8RXF1YWw7KXxMZSg/OmZ0VHJpYW5nbGUoPzo7fEJhcjt8RXF1YWw7KXxzcyg/Ojt8RXF1YWw7fEdyZWF0ZXI7fExlc3M7fFNsYW50RXF1YWw7fFRpbGRlOykpfE5lc3RlZCg/OkdyZWF0ZXJHcmVhdGVyO3xMZXNzTGVzczspfFByZWNlZGVzKD86O3xFcXVhbDt8U2xhbnRFcXVhbDspfFIoPzpldmVyc2VFbGVtZW50O3xpZ2h0VHJpYW5nbGUoPzo7fEJhcjt8RXF1YWw7KSl8Uyg/OnF1YXJlU3UoPzpic2V0KD86O3xFcXVhbDspfHBlcnNldCg/Ojt8RXF1YWw7KSl8dSg/OmJzZXQoPzo7fEVxdWFsOyl8Y2NlZWRzKD86O3xFcXVhbDt8U2xhbnRFcXVhbDt8VGlsZGU7KXxwZXJzZXQoPzo7fEVxdWFsOykpKXxUaWxkZSg/Ojt8RXF1YWw7fEZ1bGxFcXVhbDt8VGlsZGU7KXxWZXJ0aWNhbEJhcjspKXxzY3I7fHRpbGRlOz98dTspfE8oPzpFbGlnO3xhY3V0ZTs/fGMoPzppcmM7P3x5Oyl8ZGJsYWM7fGZyO3xncmF2ZTs/fG0oPzphY3I7fGVnYTt8aWNyb247KXxvcGY7fHBlbkN1cmx5KD86RG91YmxlUXVvdGU7fFF1b3RlOyl8cjt8cyg/OmNyO3xsYXNoOz8pfHRpKD86bGRlOz98bWVzOyl8dW1sOz98dmVyKD86Qig/OmFyO3xyYWMoPzplO3xrZXQ7KSl8UGFyZW50aGVzaXM7KSl8UCg/OmFydGlhbEQ7fGN5O3xmcjt8aGk7fGk7fGx1c01pbnVzO3xvKD86aW5jYXJlcGxhbmU7fHBmOyl8cig/Ojt8ZWNlZGVzKD86O3xFcXVhbDt8U2xhbnRFcXVhbDt8VGlsZGU7KXxpbWU7fG8oPzpkdWN0O3xwb3J0aW9uKD86O3xhbDspKSl8cyg/OmNyO3xpOykpfFEoPzpVT1Q7P3xmcjt8b3BmO3xzY3I7KXxSKD86QmFycjt8RUc7P3xhKD86Y3V0ZTt8bmc7fHJyKD86O3x0bDspKXxjKD86YXJvbjt8ZWRpbDt8eTspfGUoPzo7fHZlcnNlKD86RSg/OmxlbWVudDt8cXVpbGlicml1bTspfFVwRXF1aWxpYnJpdW07KSl8ZnI7fGhvO3xpZ2h0KD86QSg/Om5nbGVCcmFja2V0O3xycm93KD86O3xCYXI7fExlZnRBcnJvdzspKXxDZWlsaW5nO3xEbyg/OnVibGVCcmFja2V0O3x3big/OlRlZVZlY3Rvcjt8VmVjdG9yKD86O3xCYXI7KSkpfEZsb29yO3xUKD86ZWUoPzo7fEFycm93O3xWZWN0b3I7KXxyaWFuZ2xlKD86O3xCYXI7fEVxdWFsOykpfFVwKD86RG93blZlY3Rvcjt8VGVlVmVjdG9yO3xWZWN0b3IoPzo7fEJhcjspKXxWZWN0b3IoPzo7fEJhcjspfGFycm93Oyl8byg/OnBmO3x1bmRJbXBsaWVzOyl8cmlnaHRhcnJvdzt8cyg/OmNyO3xoOyl8dWxlRGVsYXllZDspfFMoPzpIKD86Q0hjeTt8Y3k7KXxPRlRjeTt8YWN1dGU7fGMoPzo7fGFyb247fGVkaWw7fGlyYzt8eTspfGZyO3xob3J0KD86RG93bkFycm93O3xMZWZ0QXJyb3c7fFJpZ2h0QXJyb3c7fFVwQXJyb3c7KXxpZ21hO3xtYWxsQ2lyY2xlO3xvcGY7fHEoPzpydDt8dWFyZSg/Ojt8SW50ZXJzZWN0aW9uO3xTdSg/OmJzZXQoPzo7fEVxdWFsOyl8cGVyc2V0KD86O3xFcXVhbDspKXxVbmlvbjspKXxzY3I7fHRhcjt8dSg/OmIoPzo7fHNldCg/Ojt8RXF1YWw7KSl8Yyg/OmNlZWRzKD86O3xFcXVhbDt8U2xhbnRFcXVhbDt8VGlsZGU7KXxoVGhhdDspfG07fHAoPzo7fGVyc2V0KD86O3xFcXVhbDspfHNldDspKSl8VCg/OkhPUk47P3xSQURFO3xTKD86SGN5O3xjeTspfGEoPzpiO3x1Oyl8Yyg/OmFyb247fGVkaWw7fHk7KXxmcjt8aCg/OmUoPzpyZWZvcmU7fHRhOyl8aSg/OmNrU3BhY2U7fG5TcGFjZTspKXxpbGRlKD86O3xFcXVhbDt8RnVsbEVxdWFsO3xUaWxkZTspfG9wZjt8cmlwbGVEb3Q7fHMoPzpjcjt8dHJvazspKXxVKD86YSg/OmN1dGU7P3xycig/Ojt8b2NpcjspKXxicig/OmN5O3xldmU7KXxjKD86aXJjOz98eTspfGRibGFjO3xmcjt8Z3JhdmU7P3xtYWNyO3xuKD86ZGVyKD86Qig/OmFyO3xyYWMoPzplO3xrZXQ7KSl8UGFyZW50aGVzaXM7KXxpb24oPzo7fFBsdXM7KSl8byg/Omdvbjt8cGY7KXxwKD86QXJyb3coPzo7fEJhcjt8RG93bkFycm93Oyl8RG93bkFycm93O3xFcXVpbGlicml1bTt8VGVlKD86O3xBcnJvdzspfGFycm93O3xkb3duYXJyb3c7fHBlcig/OkxlZnRBcnJvdzt8UmlnaHRBcnJvdzspfHNpKD86O3xsb247KSl8cmluZzt8c2NyO3x0aWxkZTt8dW1sOz8pfFYoPzpEYXNoO3xiYXI7fGN5O3xkYXNoKD86O3xsOyl8ZSg/OmU7fHIoPzpiYXI7fHQoPzo7fGljYWwoPzpCYXI7fExpbmU7fFNlcGFyYXRvcjt8VGlsZGU7KSl8eVRoaW5TcGFjZTspKXxmcjt8b3BmO3xzY3I7fHZkYXNoOyl8Vyg/OmNpcmM7fGVkZ2U7fGZyO3xvcGY7fHNjcjspfFgoPzpmcjt8aTt8b3BmO3xzY3I7KXxZKD86QWN5O3xJY3k7fFVjeTt8YWN1dGU7P3xjKD86aXJjO3x5Oyl8ZnI7fG9wZjt8c2NyO3x1bWw7KXxaKD86SGN5O3xhY3V0ZTt8Yyg/OmFyb247fHk7KXxkb3Q7fGUoPzpyb1dpZHRoU3BhY2U7fHRhOyl8ZnI7fG9wZjt8c2NyOyl8YSg/OmFjdXRlOz98YnJldmU7fGMoPzo7fEU7fGQ7fGlyYzs/fHV0ZTs/fHk7KXxlbGlnOz98Zig/Ojt8cjspfGdyYXZlOz98bCg/OmUoPzpmc3ltO3xwaDspfHBoYTspfG0oPzphKD86Y3I7fGxnOyl8cDs/KXxuKD86ZCg/Ojt8YW5kO3xkO3xzbG9wZTt8djspfGcoPzo7fGU7fGxlO3xtc2QoPzo7fGEoPzphO3xiO3xjO3xkO3xlO3xmO3xnO3xoOykpfHJ0KD86O3x2Yig/Ojt8ZDspKXxzKD86cGg7fHQ7KXx6YXJyOykpfG8oPzpnb247fHBmOyl8cCg/Ojt8RTt8YWNpcjt8ZTt8aWQ7fG9zO3xwcm94KD86O3xlcTspKXxyaW5nOz98cyg/OmNyO3x0O3x5bXAoPzo7fGVxOykpfHRpbGRlOz98dW1sOz98dyg/OmNvbmludDt8aW50OykpfGIoPzpOb3Q7fGEoPzpjayg/OmNvbmc7fGVwc2lsb247fHByaW1lO3xzaW0oPzo7fGVxOykpfHIoPzp2ZWU7fHdlZCg/Ojt8Z2U7KSkpfGJyayg/Ojt8dGJyazspfGMoPzpvbmc7fHk7KXxkcXVvO3xlKD86Y2F1cyg/Ojt8ZTspfG1wdHl2O3xwc2k7fHJub3U7fHQoPzphO3xoO3x3ZWVuOykpfGZyO3xpZyg/OmMoPzphcDt8aXJjO3x1cDspfG8oPzpkb3Q7fHBsdXM7fHRpbWVzOyl8cyg/OnFjdXA7fHRhcjspfHRyaWFuZ2xlKD86ZG93bjt8dXA7KXx1cGx1czt8dmVlO3x3ZWRnZTspfGthcm93O3xsKD86YSg/OmNrKD86bG96ZW5nZTt8c3F1YXJlO3x0cmlhbmdsZSg/Ojt8ZG93bjt8bGVmdDt8cmlnaHQ7KSl8bms7KXxrKD86MSg/OjI7fDQ7KXwzNDspfG9jazspfG4oPzplKD86O3xxdWl2Oyl8b3Q7KXxvKD86cGY7fHQoPzo7fHRvbTspfHd0aWU7fHgoPzpEKD86TDt8Ujt8bDt8cjspfEgoPzo7fEQ7fFU7fGQ7fHU7KXxVKD86TDt8Ujt8bDt8cjspfFYoPzo7fEg7fEw7fFI7fGg7fGw7fHI7KXxib3g7fGQoPzpMO3xSO3xsO3xyOyl8aCg/Ojt8RDt8VTt8ZDt8dTspfG1pbnVzO3xwbHVzO3x0aW1lczt8dSg/Okw7fFI7fGw7fHI7KXx2KD86O3xIO3xMO3xSO3xoO3xsO3xyOykpKXxwcmltZTt8cig/OmV2ZTt8dmJhcjs/KXxzKD86Y3I7fGVtaTt8aW0oPzo7fGU7KXxvbCg/Ojt8Yjt8aHN1YjspKXx1KD86bGwoPzo7fGV0Oyl8bXAoPzo7fEU7fGUoPzo7fHE7KSkpKXxjKD86YSg/OmN1dGU7fHAoPzo7fGFuZDt8YnJjdXA7fGMoPzphcDt8dXA7KXxkb3Q7fHM7KXxyKD86ZXQ7fG9uOykpfGMoPzphKD86cHM7fHJvbjspfGVkaWw7P3xpcmM7fHVwcyg/Ojt8c207KSl8ZG90O3xlKD86ZGlsOz98bXB0eXY7fG50KD86O3xlcmRvdDt8KSl8ZnI7fGgoPzpjeTt8ZWNrKD86O3xtYXJrOyl8aTspfGlyKD86O3xFO3xjKD86O3xlcTt8bGUoPzphcnJvdyg/OmxlZnQ7fHJpZ2h0Oyl8ZCg/OlI7fFM7fGFzdDt8Y2lyYzt8ZGFzaDspKSl8ZTt8Zm5pbnQ7fG1pZDt8c2NpcjspfGx1YnMoPzo7fHVpdDspfG8oPzpsb24oPzo7fGUoPzo7fHE7KSl8bSg/Om1hKD86O3x0Oyl8cCg/Ojt8Zm47fGxlKD86bWVudDt8eGVzOykpKXxuKD86Zyg/Ojt8ZG90Oyl8aW50Oyl8cCg/OmY7fHJvZDt8eSg/Ojt8c3I7fCkpKXxyKD86YXJyO3xvc3M7KXxzKD86Y3I7fHUoPzpiKD86O3xlOyl8cCg/Ojt8ZTspKSl8dGRvdDt8dSg/OmRhcnIoPzpsO3xyOyl8ZSg/OnByO3xzYzspfGxhcnIoPzo7fHA7KXxwKD86O3xicmNhcDt8Yyg/OmFwO3x1cDspfGRvdDt8b3I7fHM7KXxyKD86YXJyKD86O3xtOyl8bHkoPzplcSg/OnByZWM7fHN1Y2M7KXx2ZWU7fHdlZGdlOyl8cmVuOz98dmVhcnJvdyg/OmxlZnQ7fHJpZ2h0OykpfHZlZTt8d2VkOyl8dyg/OmNvbmludDt8aW50Oyl8eWxjdHk7KXxkKD86QXJyO3xIYXI7fGEoPzpnZ2VyO3xsZXRoO3xycjt8c2goPzo7fHY7KSl8Yig/Omthcm93O3xsYWM7KXxjKD86YXJvbjt8eTspfGQoPzo7fGEoPzpnZ2VyO3xycjspfG90c2VxOyl8ZSg/Omc7P3xsdGE7fG1wdHl2Oyl8Zig/OmlzaHQ7fHI7KXxoYXIoPzpsO3xyOyl8aSg/OmFtKD86O3xvbmQoPzo7fHN1aXQ7KXxzOyl8ZTt8Z2FtbWE7fHNpbjt8dig/Ojt8aWRlKD86O3xvbnRpbWVzO3wpfG9ueDspKXxqY3k7fGxjKD86b3JuO3xyb3A7KXxvKD86bGxhcjt8cGY7fHQoPzo7fGVxKD86O3xkb3Q7KXxtaW51czt8cGx1czt8c3F1YXJlOyl8dWJsZWJhcndlZGdlO3x3big/OmFycm93O3xkb3duYXJyb3dzO3xoYXJwb29uKD86bGVmdDt8cmlnaHQ7KSkpfHIoPzpia2Fyb3c7fGMoPzpvcm47fHJvcDspKXxzKD86Yyg/OnI7fHk7KXxvbDt8dHJvazspfHQoPzpkb3Q7fHJpKD86O3xmOykpfHUoPzphcnI7fGhhcjspfHdhbmdsZTt8eig/OmN5O3xpZ3JhcnI7KSl8ZSg/OkQoPzpEb3Q7fG90Oyl8YSg/OmN1dGU7P3xzdGVyOyl8Yyg/OmFyb247fGlyKD86O3xjOz8pfG9sb247fHk7KXxkb3Q7fGU7fGYoPzpEb3Q7fHI7KXxnKD86O3xyYXZlOz98cyg/Ojt8ZG90OykpfGwoPzo7fGludGVyczt8bDt8cyg/Ojt8ZG90OykpfG0oPzphY3I7fHB0eSg/Ojt8c2V0O3x2Oyl8c3AoPzoxKD86Mzt8NDspfDspKXxuKD86Zzt8c3A7KXxvKD86Z29uO3xwZjspfHAoPzphcig/Ojt8c2w7KXxsdXM7fHNpKD86O3xsb247fHY7KSl8cSg/OmMoPzppcmM7fG9sb247KXxzKD86aW07fGxhbnQoPzpndHI7fGxlc3M7KSl8dSg/OmFsczt8ZXN0O3xpdig/Ojt8REQ7KSl8dnBhcnNsOyl8cig/OkRvdDt8YXJyOyl8cyg/OmNyO3xkb3Q7fGltOyl8dCg/OmE7fGg7Pyl8dSg/Om1sOz98cm87KXx4KD86Y2w7fGlzdDt8cCg/OmVjdGF0aW9uO3xvbmVudGlhbGU7KSkpfGYoPzphbGxpbmdkb3RzZXE7fGN5O3xlbWFsZTt8Zig/OmlsaWc7fGwoPzppZzt8bGlnOyl8cjspfGlsaWc7fGpsaWc7fGwoPzphdDt8bGlnO3x0bnM7KXxub2Y7fG8oPzpwZjt8cig/OmFsbDt8ayg/Ojt8djspKSl8cGFydGludDt8cig/OmEoPzpjKD86MSg/OjI7P3wzO3w0Oz98NTt8Njt8ODspfDIoPzozO3w1Oyl8Myg/OjQ7P3w1O3w4Oyl8NDU7fDUoPzo2O3w4Oyl8Nzg7KXxzbDspfG93bjspfHNjcjspfGcoPzpFKD86O3xsOyl8YSg/OmN1dGU7fG1tYSg/Ojt8ZDspfHA7KXxicmV2ZTt8Yyg/OmlyYzt8eTspfGRvdDt8ZSg/Ojt8bDt8cSg/Ojt8cTt8c2xhbnQ7KXxzKD86O3xjYzt8ZG90KD86O3xvKD86O3xsOykpfGwoPzo7fGVzOykpKXxmcjt8Zyg/Ojt8ZzspfGltZWw7fGpjeTt8bCg/Ojt8RTt8YTt8ajspfG4oPzpFO3xhcCg/Ojt8cHJveDspfGUoPzo7fHEoPzo7fHE7KSl8c2ltOyl8b3BmO3xyYXZlO3xzKD86Y3I7fGltKD86O3xlO3xsOykpfHQoPzo7fGMoPzpjO3xpcjspfGRvdDt8bFBhcjt8cXVlc3Q7fHIoPzphKD86cHByb3g7fHJyOyl8ZG90O3xlcSg/Omxlc3M7fHFsZXNzOyl8bGVzczt8c2ltOyl8KXx2KD86ZXJ0bmVxcTt8bkU7KSl8aCg/OkFycjt8YSg/Omlyc3A7fGxmO3xtaWx0O3xyKD86ZGN5O3xyKD86O3xjaXI7fHc7KSkpfGJhcjt8Y2lyYzt8ZSg/OmFydHMoPzo7fHVpdDspfGxsaXA7fHJjb247KXxmcjt8a3MoPzplYXJvdzt8d2Fyb3c7KXxvKD86YXJyO3xtdGh0O3xvayg/OmxlZnRhcnJvdzt8cmlnaHRhcnJvdzspfHBmO3xyYmFyOyl8cyg/OmNyO3xsYXNoO3x0cm9rOyl8eSg/OmJ1bGw7fHBoZW47KSl8aSg/OmFjdXRlOz98Yyg/Ojt8aXJjOz98eTspfGUoPzpjeTt8eGNsOz8pfGYoPzpmO3xyOyl8Z3JhdmU7P3xpKD86O3xpKD86aW50O3xudDspfG5maW47fG90YTspfGpsaWc7fG0oPzphKD86Y3I7fGcoPzplO3xsaW5lO3xwYXJ0Oyl8dGg7KXxvZjt8cGVkOyl8big/Ojt8Y2FyZTt8ZmluKD86O3x0aWU7KXxvZG90O3x0KD86O3xjYWw7fGUoPzpnZXJzO3xyY2FsOyl8bGFyaGs7fHByb2Q7KSl8byg/OmN5O3xnb247fHBmO3x0YTspfHByb2Q7fHF1ZXN0Oz98cyg/OmNyO3xpbig/Ojt8RTt8ZG90O3xzKD86O3x2Oyl8djspKXx0KD86O3xpbGRlOyl8dSg/OmtjeTt8bWw7PykpfGooPzpjKD86aXJjO3x5Oyl8ZnI7fG1hdGg7fG9wZjt8cyg/OmNyO3xlcmN5Oyl8dWtjeTspfGsoPzphcHBhKD86O3x2Oyl8Yyg/OmVkaWw7fHk7KXxmcjt8Z3JlZW47fGhjeTt8amN5O3xvcGY7fHNjcjspfGwoPzpBKD86YXJyO3xycjt8dGFpbDspfEJhcnI7fEUoPzo7fGc7KXxIYXI7fGEoPzpjdXRlO3xlbXB0eXY7fGdyYW47fG1iZGE7fG5nKD86O3xkO3xsZTspfHA7fHF1bzs/fHJyKD86O3xiKD86O3xmczspfGZzO3xoazt8bHA7fHBsO3xzaW07fHRsOyl8dCg/Ojt8YWlsO3xlKD86O3xzOykpKXxiKD86YXJyO3xicms7fHIoPzphYyg/OmU7fGs7KXxrKD86ZTt8c2woPzpkO3x1OykpKSl8Yyg/OmFyb247fGUoPzpkaWw7fGlsOyl8dWI7fHk7KXxkKD86Y2E7fHF1byg/Ojt8cjspfHIoPzpkaGFyO3x1c2hhcjspfHNoOyl8ZSg/Ojt8ZnQoPzphcnJvdyg/Ojt8dGFpbDspfGhhcnBvb24oPzpkb3duO3x1cDspfGxlZnRhcnJvd3M7fHJpZ2h0KD86YXJyb3coPzo7fHM7KXxoYXJwb29uczt8c3F1aWdhcnJvdzspfHRocmVldGltZXM7KXxnO3xxKD86O3xxO3xzbGFudDspfHMoPzo7fGNjO3xkb3QoPzo7fG8oPzo7fHI7KSl8Zyg/Ojt8ZXM7KXxzKD86YXBwcm94O3xkb3Q7fGVxKD86Z3RyO3xxZ3RyOyl8Z3RyO3xzaW07KSkpfGYoPzppc2h0O3xsb29yO3xyOyl8Zyg/Ojt8RTspfGgoPzphcig/OmQ7fHUoPzo7fGw7KSl8YmxrOyl8amN5O3xsKD86O3xhcnI7fGNvcm5lcjt8aGFyZDt8dHJpOyl8bSg/Omlkb3Q7fG91c3QoPzo7fGFjaGU7KSl8big/OkU7fGFwKD86O3xwcm94Oyl8ZSg/Ojt8cSg/Ojt8cTspKXxzaW07KXxvKD86YSg/Om5nO3xycjspfGJyazt8bmcoPzpsZWZ0KD86YXJyb3c7fHJpZ2h0YXJyb3c7KXxtYXBzdG87fHJpZ2h0YXJyb3c7KXxvcGFycm93KD86bGVmdDt8cmlnaHQ7KXxwKD86YXI7fGY7fGx1czspfHRpbWVzO3x3KD86YXN0O3xiYXI7KXx6KD86O3xlbmdlO3xmOykpfHBhcig/Ojt8bHQ7KXxyKD86YXJyO3xjb3JuZXI7fGhhcig/Ojt8ZDspfG07fHRyaTspfHMoPzphcXVvO3xjcjt8aDt8aW0oPzo7fGU7fGc7KXxxKD86Yjt8dW8oPzo7fHI7KSl8dHJvazspfHQoPzo7fGMoPzpjO3xpcjspfGRvdDt8aHJlZTt8aW1lczt8bGFycjt8cXVlc3Q7fHIoPzpQYXI7fGkoPzo7fGU7fGY7KSl8KXx1cig/OmRzaGFyO3x1aGFyOyl8dig/OmVydG5lcXE7fG5FOykpfG0oPzpERG90O3xhKD86Y3I7P3xsKD86ZTt8dCg/Ojt8ZXNlOykpfHAoPzo7fHN0byg/Ojt8ZG93bjt8bGVmdDt8dXA7KSl8cmtlcjspfGMoPzpvbW1hO3x5Oyl8ZGFzaDt8ZWFzdXJlZGFuZ2xlO3xmcjt8aG87fGkoPzpjcm87P3xkKD86O3xhc3Q7fGNpcjt8ZG90Oz8pfG51cyg/Ojt8Yjt8ZCg/Ojt8dTspKSl8bCg/OmNwO3xkcjspfG5wbHVzO3xvKD86ZGVsczt8cGY7KXxwO3xzKD86Y3I7fHRwb3M7KXx1KD86O3xsdGltYXA7fG1hcDspKXxuKD86Ryg/Omc7fHQoPzo7fHY7KSl8TCg/OmVmdCg/OmFycm93O3xyaWdodGFycm93Oyl8bDt8dCg/Ojt8djspKXxSaWdodGFycm93O3xWKD86RGFzaDt8ZGFzaDspfGEoPzpibGE7fGN1dGU7fG5nO3xwKD86O3xFO3xpZDt8b3M7fHByb3g7KXx0dXIoPzo7fGFsKD86O3xzOykpKXxiKD86c3A7P3x1bXAoPzo7fGU7KSl8Yyg/OmEoPzpwO3xyb247KXxlZGlsO3xvbmcoPzo7fGRvdDspfHVwO3x5Oyl8ZGFzaDt8ZSg/Ojt8QXJyO3xhcig/OmhrO3xyKD86O3xvdzspKXxkb3Q7fHF1aXY7fHMoPzplYXI7fGltOyl8eGlzdCg/Ojt8czspKXxmcjt8Zyg/OkU7fGUoPzo7fHEoPzo7fHE7fHNsYW50Oyl8czspfHNpbTt8dCg/Ojt8cjspKXxoKD86QXJyO3xhcnI7fHBhcjspfGkoPzo7fHMoPzo7fGQ7KXx2Oyl8amN5O3xsKD86QXJyO3xFO3xhcnI7fGRyO3xlKD86O3xmdCg/OmFycm93O3xyaWdodGFycm93Oyl8cSg/Ojt8cTt8c2xhbnQ7KXxzKD86O3xzOykpfHNpbTt8dCg/Ojt8cmkoPzo7fGU7KSkpfG1pZDt8byg/OnBmO3x0KD86O3xpbig/Ojt8RTt8ZG90O3x2KD86YTt8Yjt8YzspKXxuaSg/Ojt8dig/OmE7fGI7fGM7KSl8KSl8cCg/OmFyKD86O3xhbGxlbDt8c2w7fHQ7KXxvbGludDt8cig/Ojt8Y3VlO3xlKD86O3xjKD86O3xlcTspKSkpfHIoPzpBcnI7fGFycig/Ojt8Yzt8dzspfGlnaHRhcnJvdzt8dHJpKD86O3xlOykpfHMoPzpjKD86O3xjdWU7fGU7fHI7KXxob3J0KD86bWlkO3xwYXJhbGxlbDspfGltKD86O3xlKD86O3xxOykpfG1pZDt8cGFyO3xxc3UoPzpiZTt8cGU7KXx1KD86Yig/Ojt8RTt8ZTt8c2V0KD86O3xlcSg/Ojt8cTspKSl8Y2MoPzo7fGVxOyl8cCg/Ojt8RTt8ZTt8c2V0KD86O3xlcSg/Ojt8cTspKSkpKXx0KD86Z2w7fGlsZGU7P3xsZzt8cmlhbmdsZSg/OmxlZnQoPzo7fGVxOyl8cmlnaHQoPzo7fGVxOykpKXx1KD86O3xtKD86O3xlcm87fHNwOykpfHYoPzpEYXNoO3xIYXJyO3xhcDt8ZGFzaDt8Zyg/OmU7fHQ7KXxpbmZpbjt8bCg/OkFycjt8ZTt8dCg/Ojt8cmllOykpfHIoPzpBcnI7fHRyaWU7KXxzaW07KXx3KD86QXJyO3xhcig/OmhrO3xyKD86O3xvdzspKXxuZWFyOykpfG8oPzpTO3xhKD86Y3V0ZTs/fHN0Oyl8Yyg/OmlyKD86O3xjOz8pfHk7KXxkKD86YXNoO3xibGFjO3xpdjt8b3Q7fHNvbGQ7KXxlbGlnO3xmKD86Y2lyO3xyOyl8Zyg/Om9uO3xyYXZlOz98dDspfGgoPzpiYXI7fG07KXxpbnQ7fGwoPzphcnI7fGMoPzppcjt8cm9zczspfGluZTt8dDspfG0oPzphY3I7fGVnYTt8aSg/OmNyb247fGQ7fG51czspKXxvcGY7fHAoPzphcjt8ZXJwO3xsdXM7KXxyKD86O3xhcnI7fGQoPzo7fGVyKD86O3xvZjspfGY7P3xtOz8pfGlnb2Y7fG9yO3xzbG9wZTt8djspfHMoPzpjcjt8bGFzaDs/fG9sOyl8dGkoPzpsZGU7P3xtZXMoPzo7fGFzOykpfHVtbDs/fHZiYXI7KXxwKD86YXIoPzo7fGEoPzo7fGxsZWw7fCl8cyg/OmltO3xsOyl8dDspfGN5O3xlcig/OmNudDt8aW9kO3xtaWw7fHA7fHRlbms7KXxmcjt8aCg/OmkoPzo7fHY7KXxtbWF0O3xvbmU7KXxpKD86O3x0Y2hmb3JrO3x2Oyl8bCg/OmFuKD86Y2soPzo7fGg7KXxrdjspfHVzKD86O3xhY2lyO3xiO3xjaXI7fGQoPzpvO3x1Oyl8ZTt8bW47P3xzaW07fHR3bzspKXxtO3xvKD86aW50aW50O3xwZjt8dW5kOz8pfHIoPzo7fEU7fGFwO3xjdWU7fGUoPzo7fGMoPzo7fGFwcHJveDt8Y3VybHllcTt8ZXE7fG4oPzphcHByb3g7fGVxcTt8c2ltOyl8c2ltOykpfGltZSg/Ojt8czspfG4oPzpFO3xhcDt8c2ltOyl8byg/OmQ7fGYoPzphbGFyO3xsaW5lO3xzdXJmOyl8cCg/Ojt8dG87KSl8c2ltO3x1cmVsOyl8cyg/OmNyO3xpOyl8dW5jc3A7KXxxKD86ZnI7fGludDt8b3BmO3xwcmltZTt8c2NyO3x1KD86YXQoPzplcm5pb25zO3xpbnQ7KXxlc3QoPzo7fGVxOyl8b3Q7PykpfHIoPzpBKD86YXJyO3xycjt8dGFpbDspfEJhcnI7fEhhcjt8YSg/OmMoPzplO3x1dGU7KXxkaWM7fGVtcHR5djt8bmcoPzo7fGQ7fGU7fGxlOyl8cXVvOz98cnIoPzo7fGFwO3xiKD86O3xmczspfGM7fGZzO3xoazt8bHA7fHBsO3xzaW07fHRsO3x3Oyl8dCg/OmFpbDt8aW8oPzo7fG5hbHM7KSkpfGIoPzphcnI7fGJyazt8cig/OmFjKD86ZTt8azspfGsoPzplO3xzbCg/OmQ7fHU7KSkpKXxjKD86YXJvbjt8ZSg/OmRpbDt8aWw7KXx1Yjt8eTspfGQoPzpjYTt8bGRoYXI7fHF1byg/Ojt8cjspfHNoOyl8ZSg/OmFsKD86O3xpbmU7fHBhcnQ7fHM7KXxjdDt8Zzs/KXxmKD86aXNodDt8bG9vcjt8cjspfGgoPzphcig/OmQ7fHUoPzo7fGw7KSl8byg/Ojt8djspKXxpKD86Z2h0KD86YXJyb3coPzo7fHRhaWw7KXxoYXJwb29uKD86ZG93bjt8dXA7KXxsZWZ0KD86YXJyb3dzO3xoYXJwb29uczspfHJpZ2h0YXJyb3dzO3xzcXVpZ2Fycm93O3x0aHJlZXRpbWVzOyl8bmc7fHNpbmdkb3RzZXE7KXxsKD86YXJyO3xoYXI7fG07KXxtb3VzdCg/Ojt8YWNoZTspfG5taWQ7fG8oPzphKD86bmc7fHJyOyl8YnJrO3xwKD86YXI7fGY7fGx1czspfHRpbWVzOyl8cCg/OmFyKD86O3xndDspfHBvbGludDspfHJhcnI7fHMoPzphcXVvO3xjcjt8aDt8cSg/OmI7fHVvKD86O3xyOykpKXx0KD86aHJlZTt8aW1lczt8cmkoPzo7fGU7fGY7fGx0cmk7KSl8dWx1aGFyO3x4Oyl8cyg/OmFjdXRlO3xicXVvO3xjKD86O3xFO3xhKD86cDt8cm9uOyl8Y3VlO3xlKD86O3xkaWw7KXxpcmM7fG4oPzpFO3xhcDt8c2ltOyl8cG9saW50O3xzaW07fHk7KXxkb3QoPzo7fGI7fGU7KXxlKD86QXJyO3xhcig/OmhrO3xyKD86O3xvdzspKXxjdDs/fG1pO3xzd2FyO3x0bSg/OmludXM7fG47KXx4dDspfGZyKD86O3xvd247KXxoKD86YXJwO3xjKD86aGN5O3x5Oyl8b3J0KD86bWlkO3xwYXJhbGxlbDspfHk7Pyl8aSg/OmdtYSg/Ojt8Zjt8djspfG0oPzo7fGRvdDt8ZSg/Ojt8cTspfGcoPzo7fEU7KXxsKD86O3xFOyl8bmU7fHBsdXM7fHJhcnI7KSl8bGFycjt8bSg/OmEoPzpsbHNldG1pbnVzO3xzaHA7KXxlcGFyc2w7fGkoPzpkO3xsZTspfHQoPzo7fGUoPzo7fHM7KSkpfG8oPzpmdGN5O3xsKD86O3xiKD86O3xhcjspKXxwZjspfHBhKD86ZGVzKD86O3x1aXQ7KXxyOyl8cSg/OmMoPzphcCg/Ojt8czspfHVwKD86O3xzOykpfHN1KD86Yig/Ojt8ZTt8c2V0KD86O3xlcTspKXxwKD86O3xlO3xzZXQoPzo7fGVxOykpKXx1KD86O3xhcig/OmU7fGY7KXxmOykpfHJhcnI7fHMoPzpjcjt8ZXRtbjt8bWlsZTt8dGFyZjspfHQoPzphcig/Ojt8ZjspfHIoPzphaWdodCg/OmVwc2lsb247fHBoaTspfG5zOykpfHUoPzpiKD86O3xFO3xkb3Q7fGUoPzo7fGRvdDspfG11bHQ7fG4oPzpFO3xlOyl8cGx1czt8cmFycjt8cyg/OmV0KD86O3xlcSg/Ojt8cTspfG5lcSg/Ojt8cTspKXxpbTt8dSg/OmI7fHA7KSkpfGNjKD86O3xhcHByb3g7fGN1cmx5ZXE7fGVxO3xuKD86YXBwcm94O3xlcXE7fHNpbTspfHNpbTspfG07fG5nO3xwKD86MTs/fDI7P3wzOz98O3xFO3xkKD86b3Q7fHN1YjspfGUoPzo7fGRvdDspfGhzKD86b2w7fHViOyl8bGFycjt8bXVsdDt8big/OkU7fGU7KXxwbHVzO3xzKD86ZXQoPzo7fGVxKD86O3xxOyl8bmVxKD86O3xxOykpfGltO3x1KD86Yjt8cDspKSkpfHcoPzpBcnI7fGFyKD86aGs7fHIoPzo7fG93OykpfG53YXI7KXx6bGlnOz8pfHQoPzphKD86cmdldDt8dTspfGJyazt8Yyg/OmFyb247fGVkaWw7fHk7KXxkb3Q7fGVscmVjO3xmcjt8aCg/OmUoPzpyZSg/OjQ7fGZvcmU7KXx0YSg/Ojt8c3ltO3x2OykpfGkoPzpjayg/OmFwcHJveDt8c2ltOyl8bnNwOyl8ayg/OmFwO3xzaW07KXxvcm47Pyl8aSg/OmxkZTt8bWVzKD86O3xiKD86O3xhcjspfGQ7fCl8bnQ7KXxvKD86ZWE7fHAoPzo7fGJvdDt8Y2lyO3xmKD86O3xvcms7KSl8c2E7KXxwcmltZTt8cig/OmFkZTt8aSg/OmFuZ2xlKD86O3xkb3duO3xsZWZ0KD86O3xlcTspfHE7fHJpZ2h0KD86O3xlcTspKXxkb3Q7fGU7fG1pbnVzO3xwbHVzO3xzYjt8dGltZTspfHBleml1bTspfHMoPzpjKD86cjt8eTspfGhjeTt8dHJvazspfHcoPzppeHQ7fG9oZWFkKD86bGVmdGFycm93O3xyaWdodGFycm93OykpKXx1KD86QXJyO3xIYXI7fGEoPzpjdXRlOz98cnI7KXxicig/OmN5O3xldmU7KXxjKD86aXJjOz98eTspfGQoPzphcnI7fGJsYWM7fGhhcjspfGYoPzppc2h0O3xyOyl8Z3JhdmU7P3xoKD86YXIoPzpsO3xyOyl8YmxrOyl8bCg/OmMoPzpvcm4oPzo7fGVyOyl8cm9wOyl8dHJpOyl8bSg/OmFjcjt8bDs/KXxvKD86Z29uO3xwZjspfHAoPzphcnJvdzt8ZG93bmFycm93O3xoYXJwb29uKD86bGVmdDt8cmlnaHQ7KXxsdXM7fHNpKD86O3xoO3xsb247KXx1cGFycm93czspfHIoPzpjKD86b3JuKD86O3xlcjspfHJvcDspfGluZzt8dHJpOyl8c2NyO3x0KD86ZG90O3xpbGRlO3xyaSg/Ojt8ZjspKXx1KD86YXJyO3xtbDs/KXx3YW5nbGU7KXx2KD86QXJyO3xCYXIoPzo7fHY7KXxEYXNoO3xhKD86bmdydDt8cig/OmVwc2lsb247fGthcHBhO3xub3RoaW5nO3xwKD86aGk7fGk7fHJvcHRvOyl8cig/Ojt8aG87KXxzKD86aWdtYTt8dSg/OmJzZXRuZXEoPzo7fHE7KXxwc2V0bmVxKD86O3xxOykpKXx0KD86aGV0YTt8cmlhbmdsZSg/OmxlZnQ7fHJpZ2h0OykpKSl8Y3k7fGRhc2g7fGUoPzplKD86O3xiYXI7fGVxOyl8bGxpcDt8cig/OmJhcjt8dDspKXxmcjt8bHRyaTt8bnN1KD86Yjt8cDspfG9wZjt8cHJvcDt8cnRyaTt8cyg/OmNyO3x1KD86Ym4oPzpFO3xlOyl8cG4oPzpFO3xlOykpKXx6aWd6YWc7KXx3KD86Y2lyYzt8ZSg/OmQoPzpiYXI7fGdlKD86O3xxOykpfGllcnA7KXxmcjt8b3BmO3xwO3xyKD86O3xlYXRoOyl8c2NyOyl8eCg/OmMoPzphcDt8aXJjO3x1cDspfGR0cmk7fGZyO3xoKD86QXJyO3xhcnI7KXxpO3xsKD86QXJyO3xhcnI7KXxtYXA7fG5pczt8byg/OmRvdDt8cCg/OmY7fGx1czspfHRpbWU7KXxyKD86QXJyO3xhcnI7KXxzKD86Y3I7fHFjdXA7KXx1KD86cGx1czt8dHJpOyl8dmVlO3x3ZWRnZTspfHkoPzphYyg/OnV0ZTs/fHk7KXxjKD86aXJjO3x5Oyl8ZW47P3xmcjt8aWN5O3xvcGY7fHNjcjt8dSg/OmN5O3xtbDs/KSl8eig/OmFjdXRlO3xjKD86YXJvbjt8eTspfGRvdDt8ZSg/OmV0cmY7fHRhOyl8ZnI7fGhjeTt8aWdyYXJyO3xvcGY7fHNjcjt8dyg/Omo7fG5qOykpKXxbXFxzXFxTXS9nO1xyXG5cclxudmFyIE5BTUVEQ0hBUlJFRl9NQVhMRU4gPSAzMjtcclxuXHJcbi8vIFJlZ3VsYXIgZXhwcmVzc2lvbiBjb25zdGFudHMgdXNlZCBieSB0aGUgdG9rZW5pemVyIGFuZCBwYXJzZXJcclxuXHJcbi8vIE5vdGUgdGhhdCBcXHIgaXMgaW5jbHVkZWQgaW4gYWxsIG9mIHRoZXNlIHJlZ2V4cHMgYmVjYXVzZSBpdCB3aWxsIG5lZWRcclxuLy8gdG8gYmUgY29udmVydGVkIHRvIExGIGJ5IHRoZSBzY2FuQ2hhcnMoKSBmdW5jdGlvbi5cclxudmFyIERCTFFVT1RFQVRUUlZBTCA9IC9bXlxcclwiJlxcdTAwMDBdKy9nO1xyXG52YXIgU0lOR0xFUVVPVEVBVFRSVkFMID0gL1teXFxyJyZcXHUwMDAwXSsvZztcclxudmFyIFVOUVVPVEVEQVRUUlZBTCA9IC9bXlxcclxcdFxcblxcZiAmPlxcdTAwMDBdKy9nO1xyXG52YXIgVEFHTkFNRSA9IC9bXlxcclxcdFxcblxcZiBcXC8+QS1aXFx1MDAwMF0rL2c7XHJcbnZhciBBVFRSTkFNRSA9IC9bXlxcclxcdFxcblxcZiBcXC89PkEtWlxcdTAwMDBdKy9nO1xyXG5cclxudmFyIENEQVRBVEVYVCA9IC9bXlxcXVxcclxcdTAwMDBcXHVmZmZmXSovZztcclxudmFyIERBVEFURVhUID0gL1teJjxcXHJcXHUwMDAwXFx1ZmZmZl0qL2c7XHJcbnZhciBSQVdURVhUID0gL1tePFxcclxcdTAwMDBcXHVmZmZmXSovZztcclxudmFyIFBMQUlOVEVYVCA9IC9bXlxcclxcdTAwMDBcXHVmZmZmXSovZztcclxuLy8gU2luY2Ugd2UgZG9uJ3QgaGF2ZSB0aGUgJ3N0aWNreSB0YWcnLCBhZGQgJ3wuJyB0byB0aGUgZW5kIG9mIFNJTVBMRVRBR1xyXG4vLyBhbmQgU0lNUExFQVRUUiBzbyB0aGF0IHdlIGFyZSBndWFyYW50ZWVkIHRvIGFsd2F5cyBtYXRjaC4gIFRoaXMgcHJldmVudHNcclxuLy8gdXMgZnJvbSBzY2FubmluZyBwYXN0IHRoZSBsYXN0SW5kZXggc2V0LiAoTm90ZSB0aGF0IHRoZSBkZXNpcmVkIG1hdGNoZXNcclxuLy8gYXJlIGFsd2F5cyBncmVhdGVyIHRoYW4gMSBjaGFyIGxvbmcsIHNvIGxvbmdlc3QtbWF0Y2ggd2lsbCBlbnN1cmUgdGhhdCAuXHJcbi8vIGlzIG5vdCBtYXRjaGVkIHVubGVzcyB0aGUgZGVzaXJlZCBtYXRjaCBmYWlscy4pXHJcbnZhciBTSU1QTEVUQUcgPSAvKD86KFxcLyk/KFthLXpdKyk+KXxbXFxzXFxTXS9nO1xyXG52YXIgU0lNUExFQVRUUiA9IC8oPzooWy1hLXpdKylbIFxcdFxcblxcZl0qPVsgXFx0XFxuXFxmXSooJ1teJyZcXHJcXHUwMDAwXSonfFwiW15cIiZcXHJcXHUwMDAwXSpcInxbXlxcdFxcblxcclxcZiBcIiYnXFx1MDAwMD5dW14mPiBcXHRcXG5cXHJcXGZcXHUwMDAwXSpbIFxcdFxcblxcZl0pKXxbXFxzXFxTXS9nO1xyXG5cclxudmFyIE5PTldTID0gL1teXFx4MDlcXHgwQVxceDBDXFx4MERcXHgyMF0vO1xyXG52YXIgQUxMTk9OV1MgPSAvW15cXHgwOVxceDBBXFx4MENcXHgwRFxceDIwXS9nOyAvLyBsaWtlIGFib3ZlLCB3aXRoIGcgZmxhZ1xyXG52YXIgTk9OV1NOT05OVUwgPSAvW15cXHgwMFxceDA5XFx4MEFcXHgwQ1xceDBEXFx4MjBdLzsgLy8gZG9uJ3QgYWxsb3cgTlVMIGVpdGhlclxyXG52YXIgTEVBRElOR1dTID0gL15bXFx4MDlcXHgwQVxceDBDXFx4MERcXHgyMF0rLztcclxudmFyIE5VTENIQVJTID0gL1xceDAwL2c7XHJcblxyXG4vKioqXHJcbiAqIFRoZXNlIGFyZSB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IGRvbid0IHVzZSBhbnkgb2YgdGhlIHBhcnNlcidzXHJcbiAqIGludGVybmFsIHN0YXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gYnVmMnN0cihidWYpIHtcclxuICB2YXIgQ0hVTktTSVpFPTE2Mzg0O1xyXG4gIGlmIChidWYubGVuZ3RoIDwgQ0hVTktTSVpFKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGJ1Zik7XHJcbiAgfVxyXG4gIC8vIHNwZWNpYWwgY2FzZSBmb3IgbGFyZ2Ugc3RyaW5ncywgdG8gYXZvaWQgYnVzdGluZyB0aGUgc3RhY2suXHJcbiAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSBDSFVOS1NJWkUpIHtcclxuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgYnVmLnNsaWNlKGksIGkrQ0hVTktTSVpFKSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cjJidWYocykge1xyXG4gIHZhciByZXN1bHQgPSBbXTtcclxuICBmb3IgKHZhciBpPTA7IGk8cy5sZW5ndGg7IGkrKykge1xyXG4gICAgcmVzdWx0W2ldID0gcy5jaGFyQ29kZUF0KGkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgZWxlbWVudCBpcyBhIG1lbWJlciBvZiB0aGUgc2V0LlxyXG4vLyBUaGUgc2V0IGlzIGFuIG9iamVjdCB0aGF0IG1hcHMgbmFtZXNwYWNlcyB0byBvYmplY3RzLiBUaGUgb2JqZWN0c1xyXG4vLyB0aGVuIG1hcCBsb2NhbCB0YWduYW1lcyB0byB0aGUgdmFsdWUgdHJ1ZSBpZiB0aGF0IHRhZyBpcyBwYXJ0IG9mIHRoZSBzZXRcclxuZnVuY3Rpb24gaXNBKGVsdCwgc2V0KSB7XHJcbiAgaWYgKHR5cGVvZiBzZXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAvLyBjb252ZW5pZW5jZSBjYXNlIGZvciB0ZXN0aW5nIGEgcGFydGljdWxhciBIVE1MIGVsZW1lbnRcclxuICAgIHJldHVybiBlbHQubmFtZXNwYWNlVVJJID09PSBOQU1FU1BBQ0UuSFRNTCAmJlxyXG4gICAgICBlbHQubG9jYWxOYW1lID09PSBzZXQ7XHJcbiAgfVxyXG4gIHZhciB0YWduYW1lcyA9IHNldFtlbHQubmFtZXNwYWNlVVJJXTtcclxuICByZXR1cm4gdGFnbmFtZXMgJiYgdGFnbmFtZXNbZWx0LmxvY2FsTmFtZV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTWF0aG1sVGV4dEludGVncmF0aW9uUG9pbnQobikge1xyXG4gIHJldHVybiBpc0EobiwgbWF0aG1sVGV4dEludGVncmF0aW9uUG9pbnRTZXQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0hUTUxJbnRlZ3JhdGlvblBvaW50KG4pIHtcclxuICBpZiAoaXNBKG4sIGh0bWxJbnRlZ3JhdGlvblBvaW50U2V0KSkgcmV0dXJuIHRydWU7XHJcbiAgaWYgKG4ubmFtZXNwYWNlVVJJID09PSBOQU1FU1BBQ0UuTUFUSE1MICYmXHJcbiAgICBuLmxvY2FsTmFtZSA9PT0gXCJhbm5vdGF0aW9uLXhtbFwiKSB7XHJcbiAgICB2YXIgZW5jb2RpbmcgPSBuLmdldEF0dHJpYnV0ZShcImVuY29kaW5nXCIpO1xyXG4gICAgaWYgKGVuY29kaW5nKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBpZiAoZW5jb2RpbmcgPT09IFwidGV4dC9odG1sXCIgfHxcclxuICAgICAgZW5jb2RpbmcgPT09IFwiYXBwbGljYXRpb24veGh0bWwreG1sXCIpXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkanVzdFNWR1RhZ05hbWUobmFtZSkge1xyXG4gIGlmIChuYW1lIGluIHN2Z1RhZ05hbWVBZGp1c3RtZW50cylcclxuICAgIHJldHVybiBzdmdUYWdOYW1lQWRqdXN0bWVudHNbbmFtZV07XHJcbiAgZWxzZVxyXG4gICAgcmV0dXJuIG5hbWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkanVzdFNWR0F0dHJpYnV0ZXMoYXR0cnMpIHtcclxuICBmb3IodmFyIGkgPSAwLCBuID0gYXR0cnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICBpZiAoYXR0cnNbaV1bMF0gaW4gc3ZnQXR0ckFkanVzdG1lbnRzKSB7XHJcbiAgICAgIGF0dHJzW2ldWzBdID0gc3ZnQXR0ckFkanVzdG1lbnRzW2F0dHJzW2ldWzBdXTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkanVzdE1hdGhNTEF0dHJpYnV0ZXMoYXR0cnMpIHtcclxuICBmb3IodmFyIGkgPSAwLCBuID0gYXR0cnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICBpZiAoYXR0cnNbaV1bMF0gPT09IFwiZGVmaW5pdGlvbnVybFwiKSB7XHJcbiAgICAgIGF0dHJzW2ldWzBdID0gXCJkZWZpbml0aW9uVVJMXCI7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYWRqdXN0Rm9yZWlnbkF0dHJpYnV0ZXMoYXR0cnMpIHtcclxuICBmb3IodmFyIGkgPSAwLCBuID0gYXR0cnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICBpZiAoYXR0cnNbaV1bMF0gaW4gZm9yZWlnbkF0dHJpYnV0ZXMpIHtcclxuICAgICAgLy8gQXR0cmlidXRlcyB3aXRoIG5hbWVzcGFjZXMgZ2V0IGEgM3JkIGVsZW1lbnQ6XHJcbiAgICAgIC8vIFtRbmFtZSwgdmFsdWUsIG5hbWVzcGFjZV1cclxuICAgICAgYXR0cnNbaV0ucHVzaChmb3JlaWduQXR0cmlidXRlc1thdHRyc1tpXVswXV0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gRm9yIGVhY2ggYXR0cmlidXRlIGluIGF0dHJzLCBpZiBlbHQgZG9lc24ndCBoYXZlIGFuIGF0dHJpYnV0ZVxyXG4vLyBieSB0aGF0IG5hbWUsIGFkZCB0aGUgYXR0cmlidXRlIHRvIGVsdFxyXG4vLyBYWFg6IEknbSBpZ25vcmluZyBuYW1lc3BhY2VzIGZvciBub3dcclxuZnVuY3Rpb24gdHJhbnNmZXJBdHRyaWJ1dGVzKGF0dHJzLCBlbHQpIHtcclxuICBmb3IodmFyIGkgPSAwLCBuID0gYXR0cnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICB2YXIgbmFtZSA9IGF0dHJzW2ldWzBdLCB2YWx1ZSA9IGF0dHJzW2ldWzFdO1xyXG4gICAgaWYgKGVsdC5oYXNBdHRyaWJ1dGUobmFtZSkpIGNvbnRpbnVlO1xyXG4gICAgZWx0Ll9zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqKlxyXG4gKiBUaGUgRWxlbWVudFN0YWNrIGNsYXNzXHJcbiAqL1xyXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjayA9IGZ1bmN0aW9uIEVsZW1lbnRTdGFjaygpIHtcclxuICB0aGlzLmVsZW1lbnRzID0gW107XHJcbiAgdGhpcy50b3AgPSBudWxsOyAvLyBzdGFjay50b3AgaXMgdGhlIFwiY3VycmVudCBub2RlXCIgaW4gdGhlIHNwZWNcclxufTtcclxuXHJcbi8qXHJcbi8vIFRoaXMgaXMgZm9yIGRlYnVnZ2luZyBvbmx5XHJcbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGUpIHtcclxuICByZXR1cm4gXCJTVEFDSzogXCIgK1xyXG4gIHRoaXMuZWxlbWVudHMubWFwKGZ1bmN0aW9uKGUpIHtyZXR1cm4gZS5sb2NhbE5hbWU7fSkuam9pbihcIi1cIik7XHJcbn1cclxuKi9cclxuXHJcbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZSkge1xyXG4gIHRoaXMuZWxlbWVudHMucHVzaChlKTtcclxuICB0aGlzLnRvcCA9IGU7XHJcbn07XHJcblxyXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oZSkge1xyXG4gIHRoaXMuZWxlbWVudHMucG9wKCk7XHJcbiAgdGhpcy50b3AgPSB0aGlzLmVsZW1lbnRzW3RoaXMuZWxlbWVudHMubGVuZ3RoLTFdO1xyXG59O1xyXG5cclxuLy8gUG9wIGVsZW1lbnRzIG9mZiB0aGUgc3RhY2sgdXAgdG8gYW5kIGluY2x1ZGluZyB0aGUgZmlyc3RcclxuLy8gZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQgKEhUTUwpIHRhZ25hbWVcclxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLnBvcFRhZyA9IGZ1bmN0aW9uKHRhZykge1xyXG4gIGZvcih2YXIgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLTE7IGkgPiAwOyBpLS0pIHtcclxuICAgIHZhciBlID0gdGhpcy5lbGVtZW50c1tpXTtcclxuICAgIGlmIChpc0EoZSwgdGFnKSkgYnJlYWs7XHJcbiAgfVxyXG4gIHRoaXMuZWxlbWVudHMubGVuZ3RoID0gaTtcclxuICB0aGlzLnRvcCA9IHRoaXMuZWxlbWVudHNbaS0xXTtcclxufTtcclxuXHJcbi8vIFBvcCBlbGVtZW50cyBvZmYgdGhlIHN0YWNrIHVwIHRvIGFuZCBpbmNsdWRpbmcgdGhlIGZpcnN0XHJcbi8vIGVsZW1lbnQgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgc3BlY2lmaWVkIHR5cGVcclxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLnBvcEVsZW1lbnRUeXBlID0gZnVuY3Rpb24odHlwZSkge1xyXG4gIGZvcih2YXIgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLTE7IGkgPiAwOyBpLS0pIHtcclxuICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldIGluc3RhbmNlb2YgdHlwZSkgYnJlYWs7XHJcbiAgfVxyXG4gIHRoaXMuZWxlbWVudHMubGVuZ3RoID0gaTtcclxuICB0aGlzLnRvcCA9IHRoaXMuZWxlbWVudHNbaS0xXTtcclxufTtcclxuXHJcbi8vIFBvcCBlbGVtZW50cyBvZmYgdGhlIHN0YWNrIHVwIHRvIGFuZCBpbmNsdWRpbmcgdGhlIGVsZW1lbnQgZS5cclxuLy8gTm90ZSB0aGF0IHRoaXMgaXMgdmVyeSBkaWZmZXJlbnQgZnJvbSByZW1vdmVFbGVtZW50KClcclxuLy8gVGhpcyByZXF1aXJlcyB0aGF0IGUgaXMgb24gdGhlIHN0YWNrLlxyXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUucG9wRWxlbWVudCA9IGZ1bmN0aW9uKGUpIHtcclxuICBmb3IodmFyIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aC0xOyBpID4gMDsgaS0tKSB7XHJcbiAgICBpZiAodGhpcy5lbGVtZW50c1tpXSA9PT0gZSkgYnJlYWs7XHJcbiAgfVxyXG4gIHRoaXMuZWxlbWVudHMubGVuZ3RoID0gaTtcclxuICB0aGlzLnRvcCA9IHRoaXMuZWxlbWVudHNbaS0xXTtcclxufTtcclxuXHJcbi8vIFJlbW92ZSBhIHNwZWNpZmljIGVsZW1lbnQgZnJvbSB0aGUgc3RhY2suXHJcbi8vIERvIG5vdGhpbmcgaWYgdGhlIGVsZW1lbnQgaXMgbm90IG9uIHRoZSBzdGFja1xyXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uKGUpIHtcclxuICBpZiAodGhpcy50b3AgPT09IGUpIHRoaXMucG9wKCk7XHJcbiAgZWxzZSB7XHJcbiAgICB2YXIgaWR4ID0gdGhpcy5lbGVtZW50cy5sYXN0SW5kZXhPZihlKTtcclxuICAgIGlmIChpZHggIT09IC0xKVxyXG4gICAgICB0aGlzLmVsZW1lbnRzLnNwbGljZShpZHgsIDEpO1xyXG4gIH1cclxufTtcclxuXHJcbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5jbGVhclRvQ29udGV4dCA9IGZ1bmN0aW9uKHNldCkge1xyXG4gIC8vIE5vdGUgdGhhdCB3ZSBkb24ndCBsb29wIHRvIDAuIE5ldmVyIHBvcCB0aGUgPGh0bWw+IGVsdCBvZmYuXHJcbiAgZm9yKHZhciBpID0gdGhpcy5lbGVtZW50cy5sZW5ndGgtMTsgaSA+IDA7IGktLSkge1xyXG4gICAgaWYgKGlzQSh0aGlzLmVsZW1lbnRzW2ldLCBzZXQpKSBicmVhaztcclxuICB9XHJcbiAgdGhpcy5lbGVtZW50cy5sZW5ndGggPSBpKzE7XHJcbiAgdGhpcy50b3AgPSB0aGlzLmVsZW1lbnRzW2ldO1xyXG59O1xyXG5cclxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24odGFnKSB7XHJcbiAgcmV0dXJuIHRoaXMuaW5TcGVjaWZpY1Njb3BlKHRhZywgT2JqZWN0LmNyZWF0ZShudWxsKSk7XHJcbn07XHJcblxyXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUuaW5TcGVjaWZpY1Njb3BlID0gZnVuY3Rpb24odGFnLCBzZXQpIHtcclxuICBmb3IodmFyIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xyXG4gICAgdmFyIGVsdCA9IHRoaXMuZWxlbWVudHNbaV07XHJcbiAgICBpZiAoaXNBKGVsdCwgdGFnKSkgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAoaXNBKGVsdCwgc2V0KSkgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vLyBMaWtlIHRoZSBhYm92ZSwgYnV0IGZvciBhIHNwZWNpZmljIGVsZW1lbnQsIG5vdCBhIHRhZ25hbWVcclxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmVsZW1lbnRJblNwZWNpZmljU2NvcGUgPSBmdW5jdGlvbih0YXJnZXQsIHNldCkge1xyXG4gIGZvcih2YXIgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICB2YXIgZWx0ID0gdGhpcy5lbGVtZW50c1tpXTtcclxuICAgIGlmIChlbHQgPT09IHRhcmdldCkgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAoaXNBKGVsdCwgc2V0KSkgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vLyBMaWtlIHRoZSBhYm92ZSwgYnV0IGZvciBhbiBlbGVtZW50IGludGVyZmFjZSwgbm90IGEgdGFnbmFtZVxyXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUuZWxlbWVudFR5cGVJblNwZWNpZmljU2NvcGUgPSBmdW5jdGlvbih0YXJnZXQsIHNldCkge1xyXG4gIGZvcih2YXIgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICB2YXIgZWx0ID0gdGhpcy5lbGVtZW50c1tpXTtcclxuICAgIGlmIChlbHQgaW5zdGFuY2VvZiB0YXJnZXQpIHJldHVybiB0cnVlO1xyXG4gICAgaWYgKGlzQShlbHQsIHNldCkpIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmluU2NvcGUgPSBmdW5jdGlvbih0YWcpIHtcclxuICByZXR1cm4gdGhpcy5pblNwZWNpZmljU2NvcGUodGFnLCBpblNjb3BlU2V0KTtcclxufTtcclxuXHJcbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5lbGVtZW50SW5TY29wZSA9IGZ1bmN0aW9uKGUpIHtcclxuICByZXR1cm4gdGhpcy5lbGVtZW50SW5TcGVjaWZpY1Njb3BlKGUsIGluU2NvcGVTZXQpO1xyXG59O1xyXG5cclxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmVsZW1lbnRUeXBlSW5TY29wZSA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICByZXR1cm4gdGhpcy5lbGVtZW50VHlwZUluU3BlY2lmaWNTY29wZSh0eXBlLCBpblNjb3BlU2V0KTtcclxufTtcclxuXHJcbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5pbkJ1dHRvblNjb3BlID0gZnVuY3Rpb24odGFnKSB7XHJcbiAgcmV0dXJuIHRoaXMuaW5TcGVjaWZpY1Njb3BlKHRhZywgaW5CdXR0b25TY29wZVNldCk7XHJcbn07XHJcblxyXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUuaW5MaXN0SXRlbVNjb3BlID0gZnVuY3Rpb24odGFnKSB7XHJcbiAgcmV0dXJuIHRoaXMuaW5TcGVjaWZpY1Njb3BlKHRhZywgaW5MaXN0SXRlbVNjb3BlU2V0KTtcclxufTtcclxuXHJcbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5pblRhYmxlU2NvcGUgPSBmdW5jdGlvbih0YWcpIHtcclxuICByZXR1cm4gdGhpcy5pblNwZWNpZmljU2NvcGUodGFnLCBpblRhYmxlU2NvcGVTZXQpO1xyXG59O1xyXG5cclxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmluU2VsZWN0U2NvcGUgPSBmdW5jdGlvbih0YWcpIHtcclxuICAvLyBDYW4ndCBpbXBsZW1lbnQgdGhpcyBvbmUgd2l0aCBpblNwZWNpZmljU2NvcGUsIHNpbmNlIGl0IGludm9sdmVzXHJcbiAgLy8gYSBzZXQgZGVmaW5lZCBieSBpbnZlcnRpbmcgYW5vdGhlciBzZXQuIFNvIGltcGxlbWVudCBtYW51YWxseS5cclxuICBmb3IodmFyIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xyXG4gICAgdmFyIGVsdCA9IHRoaXMuZWxlbWVudHNbaV07XHJcbiAgICBpZiAoZWx0Lm5hbWVzcGFjZVVSSSAhPT0gTkFNRVNQQUNFLkhUTUwpIHJldHVybiBmYWxzZTtcclxuICAgIHZhciBsb2NhbG5hbWUgPSBlbHQubG9jYWxOYW1lO1xyXG4gICAgaWYgKGxvY2FsbmFtZSA9PT0gdGFnKSByZXR1cm4gdHJ1ZTtcclxuICAgIGlmIChsb2NhbG5hbWUgIT09IFwib3B0Z3JvdXBcIiAmJiBsb2NhbG5hbWUgIT09IFwib3B0aW9uXCIpXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3MgPSBmdW5jdGlvbihidXRub3QsIHRob3JvdWdoKSB7XHJcbiAgdmFyIGVuZFRhZ1NldCA9IHRob3JvdWdoID8gdGhvcm91Z2hJbXBsaWVkRW5kVGFnc1NldCA6IGltcGxpZWRFbmRUYWdzU2V0O1xyXG4gIGZvcih2YXIgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHNbaV07XHJcbiAgICBpZiAoYnV0bm90ICYmIGlzQShlLCBidXRub3QpKSBicmVhaztcclxuICAgIGlmICghaXNBKHRoaXMuZWxlbWVudHNbaV0sIGVuZFRhZ1NldCkpIGJyZWFrO1xyXG4gIH1cclxuXHJcbiAgdGhpcy5lbGVtZW50cy5sZW5ndGggPSBpKzE7XHJcbiAgdGhpcy50b3AgPSB0aGlzLmVsZW1lbnRzW2ldO1xyXG59O1xyXG5cclxuLyoqKlxyXG4gKiBUaGUgQWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzIGNsYXNzXHJcbiAqL1xyXG5IVE1MUGFyc2VyLkFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cyA9IGZ1bmN0aW9uIEFGRSgpIHtcclxuICB0aGlzLmxpc3QgPSBbXTsgLy8gZWxlbWVudHNcclxuICB0aGlzLmF0dHJzID0gW107IC8vIGF0dHJpYnV0ZSB0b2tlbnMgZm9yIGNsb25pbmdcclxufTtcclxuXHJcbkhUTUxQYXJzZXIuQWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLnByb3RvdHlwZS5NQVJLRVIgPSB7IGxvY2FsTmFtZTogXCJ8XCIgfTtcclxuXHJcbi8qXHJcbi8vIEZvciBkZWJ1Z2dpbmdcclxuSFRNTFBhcnNlci5BY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIFwiQUZFOiBcIiArXHJcbiAgdGhpcy5saXN0Lm1hcChmdW5jdGlvbihlKSB7IHJldHVybiBlLmxvY2FsTmFtZTsgfSkuam9pbihcIi1cIik7XHJcbn1cclxuKi9cclxuXHJcbkhUTUxQYXJzZXIuQWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLnByb3RvdHlwZS5pbnNlcnRNYXJrZXIgPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLmxpc3QucHVzaCh0aGlzLk1BUktFUik7XHJcbiAgdGhpcy5hdHRycy5wdXNoKHRoaXMuTUFSS0VSKTtcclxufTtcclxuXHJcbkhUTUxQYXJzZXIuQWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZWx0LCBhdHRycykge1xyXG4gIC8vIFNjYW4gYmFja3dhcmRzOiBpZiB0aGVyZSBhcmUgYWxyZWFkeSAzIGNvcGllcyBvZiB0aGlzIGVsZW1lbnRcclxuICAvLyBiZWZvcmUgd2UgZW5jb3VudGVyIGEgbWFya2VyLCB0aGVuIGRyb3AgdGhlIGxhc3Qgb25lXHJcbiAgdmFyIGNvdW50ID0gMDtcclxuICBmb3IodmFyIGkgPSB0aGlzLmxpc3QubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICBpZiAodGhpcy5saXN0W2ldID09PSB0aGlzLk1BUktFUikgYnJlYWs7XHJcbiAgICAvLyBlcXVhbCgpIGlzIGRlZmluZWQgYmVsb3dcclxuICAgIGlmIChlcXVhbChlbHQsIHRoaXMubGlzdFtpXSwgdGhpcy5hdHRyc1tpXSkpIHtcclxuICAgICAgY291bnQrKztcclxuICAgICAgaWYgKGNvdW50ID09PSAzKSB7XHJcbiAgICAgICAgdGhpcy5saXN0LnNwbGljZShpLCAxKTtcclxuICAgICAgICB0aGlzLmF0dHJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8vIE5vdyBwdXNoIHRoZSBlbGVtZW50IG9udG8gdGhlIGxpc3RcclxuICB0aGlzLmxpc3QucHVzaChlbHQpO1xyXG5cclxuICAvLyBDb3B5IHRoZSBhdHRyaWJ1dGVzIGFuZCBwdXNoIHRob3NlIG9uLCB0b29cclxuICB2YXIgYXR0cmNvcHkgPSBbXTtcclxuICBmb3IodmFyIGlpID0gMDsgaWkgPCBhdHRycy5sZW5ndGg7IGlpKyspIHtcclxuICAgIGF0dHJjb3B5W2lpXSA9IGF0dHJzW2lpXTtcclxuICB9XHJcblxyXG4gIHRoaXMuYXR0cnMucHVzaChhdHRyY29weSk7XHJcblxyXG4gIC8vIFRoaXMgZnVuY3Rpb24gZGVmaW5lcyBlcXVhbGl0eSBvZiB0d28gZWxlbWVudHMgZm9yIHRoZSBwdXJwb3Nlc1xyXG4gIC8vIG9mIHRoZSBBRkUgbGlzdC4gIE5vdGUgdGhhdCBpdCBjb21wYXJlcyB0aGUgbmV3IGVsZW1lbnRzXHJcbiAgLy8gYXR0cmlidXRlcyB0byB0aGUgc2F2ZWQgYXJyYXkgb2YgYXR0cmlidXRlcyBhc3NvY2lhdGVkIHdpdGhcclxuICAvLyB0aGUgb2xkIGVsZW1lbnQgYmVjYXVzZSBhIHNjcmlwdCBjb3VsZCBoYXZlIGNoYW5nZWQgdGhlXHJcbiAgLy8gb2xkIGVsZW1lbnQncyBzZXQgb2YgYXR0cmlidXRlc1xyXG4gIGZ1bmN0aW9uIGVxdWFsKG5ld2VsdCwgb2xkZWx0LCBvbGRhdHRycykge1xyXG4gICAgaWYgKG5ld2VsdC5sb2NhbE5hbWUgIT09IG9sZGVsdC5sb2NhbE5hbWUpIHJldHVybiBmYWxzZTtcclxuICAgIGlmIChuZXdlbHQuX251bWF0dHJzICE9PSBvbGRhdHRycy5sZW5ndGgpIHJldHVybiBmYWxzZTtcclxuICAgIGZvcih2YXIgaSA9IDAsIG4gPSBvbGRhdHRycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgdmFyIG9sZG5hbWUgPSBvbGRhdHRyc1tpXVswXTtcclxuICAgICAgdmFyIG9sZHZhbCA9IG9sZGF0dHJzW2ldWzFdO1xyXG4gICAgICBpZiAoIW5ld2VsdC5oYXNBdHRyaWJ1dGUob2xkbmFtZSkpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKG5ld2VsdC5nZXRBdHRyaWJ1dGUob2xkbmFtZSkgIT09IG9sZHZhbCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG59O1xyXG5cclxuSFRNTFBhcnNlci5BY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMucHJvdG90eXBlLmNsZWFyVG9NYXJrZXIgPSBmdW5jdGlvbigpIHtcclxuICBmb3IodmFyIGkgPSB0aGlzLmxpc3QubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICBpZiAodGhpcy5saXN0W2ldID09PSB0aGlzLk1BUktFUikgYnJlYWs7XHJcbiAgfVxyXG4gIGlmIChpIDwgMCkgaSA9IDA7XHJcbiAgdGhpcy5saXN0Lmxlbmd0aCA9IGk7XHJcbiAgdGhpcy5hdHRycy5sZW5ndGggPSBpO1xyXG59O1xyXG5cclxuLy8gRmluZCBhbmQgcmV0dXJuIHRoZSBsYXN0IGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIHRhZyBiZXR3ZWVuIHRoZVxyXG4vLyBlbmQgb2YgdGhlIGxpc3QgYW5kIHRoZSBsYXN0IG1hcmtlciBvbiB0aGUgbGlzdC5cclxuLy8gVXNlZCB3aGVuIHBhcnNpbmcgPGE+IGluX2JvZHlfbW9kZSgpXHJcbkhUTUxQYXJzZXIuQWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLnByb3RvdHlwZS5maW5kRWxlbWVudEJ5VGFnID0gZnVuY3Rpb24odGFnKSB7XHJcbiAgZm9yKHZhciBpID0gdGhpcy5saXN0Lmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xyXG4gICAgdmFyIGVsdCA9IHRoaXMubGlzdFtpXTtcclxuICAgIGlmIChlbHQgPT09IHRoaXMuTUFSS0VSKSBicmVhaztcclxuICAgIGlmIChlbHQubG9jYWxOYW1lID09PSB0YWcpIHJldHVybiBlbHQ7XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuSFRNTFBhcnNlci5BY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbihlKSB7XHJcbiAgcmV0dXJuIHRoaXMubGlzdC5sYXN0SW5kZXhPZihlKTtcclxufTtcclxuXHJcbi8vIEZpbmQgdGhlIGVsZW1lbnQgZSBpbiB0aGUgbGlzdCBhbmQgcmVtb3ZlIGl0XHJcbi8vIFVzZWQgd2hlbiBwYXJzaW5nIDxhPiBpbl9ib2R5KClcclxuSFRNTFBhcnNlci5BY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGUpIHtcclxuICB2YXIgaWR4ID0gdGhpcy5saXN0Lmxhc3RJbmRleE9mKGUpO1xyXG4gIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICB0aGlzLmxpc3Quc3BsaWNlKGlkeCwgMSk7XHJcbiAgICB0aGlzLmF0dHJzLnNwbGljZShpZHgsIDEpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEZpbmQgZWxlbWVudCBhIGluIHRoZSBsaXN0IGFuZCByZXBsYWNlIGl0IHdpdGggZWxlbWVudCBiXHJcbi8vIFhYWDogRG8gSSBuZWVkIHRvIGhhbmRsZSBhdHRyaWJ1dGVzIGhlcmU/XHJcbkhUTUxQYXJzZXIuQWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oYSwgYiwgYXR0cnMpIHtcclxuICB2YXIgaWR4ID0gdGhpcy5saXN0Lmxhc3RJbmRleE9mKGEpO1xyXG4gIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICB0aGlzLmxpc3RbaWR4XSA9IGI7XHJcbiAgICB0aGlzLmF0dHJzW2lkeF0gPSBhdHRycztcclxuICB9XHJcbn07XHJcblxyXG4vLyBGaW5kIGEgaW4gdGhlIGxpc3QgYW5kIGluc2VydCBiIGFmdGVyIGl0XHJcbi8vIFRoaXMgaXMgb25seSB1c2VkIGZvciBpbnNlcnQgYSBib29rbWFyayBvYmplY3QsIHNvIHRoZVxyXG4vLyBhdHRycyBhcnJheSBkb2Vzbid0IHJlYWxseSBtYXR0ZXJcclxuSFRNTFBhcnNlci5BY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24oYSxiKSB7XHJcbiAgdmFyIGlkeCA9IHRoaXMubGlzdC5sYXN0SW5kZXhPZihhKTtcclxuICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgdGhpcy5saXN0LnNwbGljZShpZHgsIDAsIGIpO1xyXG4gICAgdGhpcy5hdHRycy5zcGxpY2UoaWR4LCAwLCBiKTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG4vKioqXHJcbiAqIFRoaXMgaXMgdGhlIHBhcnNlciBmYWN0b3J5IGZ1bmN0aW9uLiBJdCBpcyB0aGUgcmV0dXJuIHZhbHVlIG9mXHJcbiAqIHRoZSBvdXRlciBjbG9zdXJlIHRoYXQgaXQgaXMgZGVmaW5lZCB3aXRoaW4uICBNb3N0IG9mIHRoZSBwYXJzZXJcclxuICogaW1wbGVtZW50YXRpb24gZGV0YWlscyBhcmUgaW5zaWRlIHRoaXMgZnVuY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBIVE1MUGFyc2VyKGFkZHJlc3MsIGZyYWdtZW50Q29udGV4dCwgb3B0aW9ucykge1xyXG4gIC8qKipcclxuICAgKiBUaGVzZSBhcmUgdGhlIHBhcnNlcidzIHN0YXRlIHZhcmlhYmxlc1xyXG4gICAqL1xyXG4gIC8vIFNjYW5uZXIgc3RhdGVcclxuICB2YXIgY2hhcnMgPSBudWxsO1xyXG4gIHZhciBudW1jaGFycyA9IDA7IC8vIExlbmd0aCBvZiBjaGFyc1xyXG4gIHZhciBuZXh0Y2hhciA9IDA7IC8vIEluZGV4IG9mIG5leHQgY2hhclxyXG4gIHZhciBpbnB1dF9jb21wbGV0ZSA9IGZhbHNlOyAvLyBCZWNvbWVzIHRydWUgd2hlbiBlbmQoKSBjYWxsZWQuXHJcbiAgdmFyIHNjYW5uZXJfc2tpcF9uZXdsaW5lID0gZmFsc2U7IC8vIElmIHByZXZpb3VzIGNoYXIgd2FzIENSXHJcbiAgdmFyIHJlZW50cmFudF9pbnZvY2F0aW9ucyA9IDA7XHJcbiAgdmFyIHNhdmVkX3NjYW5uZXJfc3RhdGUgPSBbXTtcclxuICB2YXIgbGVmdG92ZXJzID0gXCJcIjtcclxuICB2YXIgZmlyc3RfYmF0Y2ggPSB0cnVlO1xyXG4gIHZhciBwYXVzZWQgPSAwOyAvLyBCZWNvbWVzIG5vbi16ZXJvIHdoaWxlIGxvYWRpbmcgc2NyaXB0c1xyXG5cclxuXHJcbiAgLy8gVG9rZW5pemVyIHN0YXRlXHJcbiAgdmFyIHRva2VuaXplciA9IGRhdGFfc3RhdGU7IC8vIEN1cnJlbnQgdG9rZW5pemVyIHN0YXRlXHJcbiAgdmFyIHJldHVybl9zdGF0ZTtcclxuICB2YXIgY2hhcmFjdGVyX3JlZmVyZW5jZV9jb2RlO1xyXG4gIHZhciB0YWduYW1lYnVmID0gXCJcIjtcclxuICB2YXIgbGFzdHRhZ25hbWUgPSBcIlwiOyAvLyBob2xkcyB0aGUgdGFyZ2V0IGVuZCB0YWcgZm9yIHRleHQgc3RhdGVzXHJcbiAgdmFyIHRlbXBidWYgPSBbXTtcclxuICB2YXIgYXR0cm5hbWVidWYgPSBcIlwiO1xyXG4gIHZhciBhdHRydmFsdWVidWYgPSBcIlwiO1xyXG4gIHZhciBjb21tZW50YnVmID0gW107XHJcbiAgdmFyIGRvY3R5cGVuYW1lYnVmID0gW107XHJcbiAgdmFyIGRvY3R5cGVwdWJsaWNidWYgPSBbXTtcclxuICB2YXIgZG9jdHlwZXN5c3RlbWJ1ZiA9IFtdO1xyXG4gIHZhciBhdHRyaWJ1dGVzID0gW107XHJcbiAgdmFyIGlzX2VuZF90YWcgPSBmYWxzZTtcclxuXHJcbiAgLy8gVHJlZSBidWlsZGVyIHN0YXRlXHJcbiAgdmFyIHBhcnNlciA9IGluaXRpYWxfbW9kZTsgLy8gQ3VycmVudCBpbnNlcnRpb24gbW9kZVxyXG4gIHZhciBvcmlnaW5hbEluc2VydGlvbk1vZGUgPSBudWxsOyAvLyBBIHNhdmVkIGluc2VydGlvbiBtb2RlXHJcbiAgdmFyIHRlbXBsYXRlSW5zZXJ0aW9uTW9kZXMgPSBbXTsgLy8gU3RhY2sgb2YgdGVtcGxhdGUgaW5zZXJ0aW9uIG1vZGVzLlxyXG4gIHZhciBzdGFjayA9IG5ldyBIVE1MUGFyc2VyLkVsZW1lbnRTdGFjaygpOyAvLyBTdGFjayBvZiBvcGVuIGVsZW1lbnRzXHJcbiAgdmFyIGFmZSA9IG5ldyBIVE1MUGFyc2VyLkFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cygpOyAvLyBtaXMtbmVzdGVkIHRhZ3NcclxuICB2YXIgZnJhZ21lbnQgPSAoZnJhZ21lbnRDb250ZXh0IT09dW5kZWZpbmVkKTsgLy8gRm9yIGlubmVySFRNTCwgZXRjLlxyXG4gIHZhciBoZWFkX2VsZW1lbnRfcG9pbnRlciA9IG51bGw7XHJcbiAgdmFyIGZvcm1fZWxlbWVudF9wb2ludGVyID0gbnVsbDtcclxuICB2YXIgc2NyaXB0aW5nX2VuYWJsZWQgPSB0cnVlO1xyXG4gIGlmIChmcmFnbWVudENvbnRleHQpIHtcclxuXHRzY3JpcHRpbmdfZW5hYmxlZCA9IGZyYWdtZW50Q29udGV4dC5vd25lckRvY3VtZW50Ll9zY3JpcHRpbmdfZW5hYmxlZDtcclxuICB9XHJcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zY3JpcHRpbmdfZW5hYmxlZCA9PT0gZmFsc2UpXHJcbiAgICBzY3JpcHRpbmdfZW5hYmxlZCA9IGZhbHNlO1xyXG4gIHZhciBmcmFtZXNldF9vayA9IHRydWU7XHJcbiAgdmFyIGZvcmNlX3F1aXJrcyA9IGZhbHNlO1xyXG4gIHZhciBwZW5kaW5nX3RhYmxlX3RleHQ7XHJcbiAgdmFyIHRleHRfaW50ZWdyYXRpb25fbW9kZTsgLy8gWFhYIGEgc3BlYyBidWcgd29ya2Fyb3VuZD9cclxuXHJcbiAgLy8gQSBzaW5nbGUgcnVuIG9mIGNoYXJhY3RlcnMsIGJ1ZmZlcmVkIHVwIHRvIGJlIHNlbnQgdG9cclxuICAvLyB0aGUgcGFyc2VyIGFzIGEgc2luZ2xlIHN0cmluZy5cclxuICB2YXIgdGV4dHJ1biA9IFtdO1xyXG4gIHZhciB0ZXh0SW5jbHVkZXNOVUwgPSBmYWxzZTtcclxuICB2YXIgaWdub3JlX2xpbmVmZWVkID0gZmFsc2U7XHJcblxyXG4gIC8qKipcclxuICAgKiBUaGlzIGlzIHRoZSBwYXJzZXIgb2JqZWN0IHRoYXQgd2lsbCBiZSB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoaXNcclxuICAgKiBmYWN0b3J5IGZ1bmN0aW9uLCB3aGljaCBpcyBzb21lIDUwMDAgbGluZXMgYmVsb3cuXHJcbiAgICogTm90ZSB0aGF0IHRoZSB2YXJpYWJsZSBcInBhcnNlclwiIGlzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZVxyXG4gICAqIHBhcnNlcidzIHN0YXRlIG1hY2hpbmUuICBUaGlzIHZhcmlhYmxlIFwiaHRtbHBhcnNlclwiIGlzIHRoZVxyXG4gICAqIHJldHVybiB2YWx1ZSBhbmQgZGVmaW5lcyB0aGUgcHVibGljIEFQSSBvZiB0aGUgcGFyc2VyXHJcbiAgICovXHJcbiAgdmFyIGh0bWxwYXJzZXIgPSB7XHJcbiAgICBkb2N1bWVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBkb2M7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgZnJvbSBIVE1MU2NyaXB0RWxlbWVudCB0byBwYXVzZSB0aGVcclxuICAgIC8vIHBhcnNlciB3aGlsZSBhIHNjcmlwdCBpcyBiZWluZyBsb2FkZWQgZnJvbSB0aGUgbmV0d29ya1xyXG4gICAgcGF1c2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAvLyBwcmludChcInBhdXNpbmcgcGFyc2VyXCIpO1xyXG4gICAgICBwYXVzZWQrKztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2FsbGVkIHdoZW4gYSBzY3JpcHQgZmluaXNoZXMgbG9hZGluZ1xyXG4gICAgcmVzdW1lOiBmdW5jdGlvbigpIHtcclxuICAgICAgLy8gcHJpbnQoXCJyZXN1bWluZyBwYXJzZXJcIik7XHJcbiAgICAgIHBhdXNlZC0tO1xyXG4gICAgICAvLyBYWFg6IGFkZGVkIHRoaXMgdG8gZm9yY2UgYSByZXN1bXB0aW9uLlxyXG4gICAgICAvLyBJcyB0aGlzIHRoZSByaWdodCB0aGluZyB0byBkbz9cclxuICAgICAgdGhpcy5wYXJzZShcIlwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gUGFyc2UgdGhlIEhUTUwgdGV4dCBzLlxyXG4gICAgLy8gVGhlIHNlY29uZCBhcmd1bWVudCBzaG91bGQgYmUgdHJ1ZSBpZiB0aGVyZSBpcyBubyBtb3JlXHJcbiAgICAvLyB0ZXh0IHRvIGJlIHBhcnNlZCwgYW5kIHNob3VsZCBiZSBmYWxzZSBvciBvbWl0dGVkIG90aGVyd2lzZS5cclxuICAgIC8vIFRoZSBzZWNvbmQgYXJndW1lbnQgbXVzdCBub3QgYmUgc2V0IGZvciByZWN1cnNpdmUgaW52b2NhdGlvbnNcclxuICAgIC8vIGZyb20gZG9jdW1lbnQud3JpdGUoKVxyXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHMsIGVuZCkge1xyXG5cclxuICAgICAgLy8gSWYgd2UncmUgcGF1c2VkLCByZW1lbWJlciB0aGUgdGV4dCB0byBwYXJzZSwgYnV0XHJcbiAgICAgIC8vIGRvbid0IHBhcnNlIGl0IG5vdy5cclxuICAgICAgaWYgKHBhdXNlZCA+IDApIHtcclxuICAgICAgICBsZWZ0b3ZlcnMgKz0gcztcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICBpZiAocmVlbnRyYW50X2ludm9jYXRpb25zID09PSAwKSB7XHJcbiAgICAgICAgLy8gQSBub3JtYWwsIHRvcC1sZXZlbCBpbnZvY2F0aW9uXHJcbiAgICAgICAgaWYgKGxlZnRvdmVycykge1xyXG4gICAgICAgICAgcyA9IGxlZnRvdmVycyArIHM7XHJcbiAgICAgICAgICBsZWZ0b3ZlcnMgPSBcIlwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIGEgc3BlY2lhbCBtYXJrZXIgY2hhcmFjdGVyIHRvIHRoZSBlbmQgb2ZcclxuICAgICAgICAvLyB0aGUgYnVmZmVyLiAgSWYgdGhlIHNjYW5uZXIgaXMgYXQgdGhlIGVuZCBvZlxyXG4gICAgICAgIC8vIHRoZSBidWZmZXIgYW5kIGlucHV0X2NvbXBsZXRlIGlzIHNldCwgdGhlbiB0aGlzXHJcbiAgICAgICAgLy8gY2hhcmFjdGVyIHdpbGwgdHJhbnNmb3JtIGludG8gYW4gRU9GIHRva2VuLlxyXG4gICAgICAgIC8vIEhhdmluZyBhbiBhY3R1YWwgY2hhcmFjdGVyIHRoYXQgcmVwcmVzZW50cyBFT0ZcclxuICAgICAgICAvLyBpbiB0aGUgY2hhcmFjdGVyIGJ1ZmZlciBtYWtlcyBsb29rYWhlYWQgcmVnZXhwXHJcbiAgICAgICAgLy8gbWF0Y2hpbmcgd29yayBtb3JlIGVhc2lseSwgYW5kIHRoaXMgaXNcclxuICAgICAgICAvLyBpbXBvcnRhbnQgZm9yIGNoYXJhY3RlciByZWZlcmVuY2VzLlxyXG4gICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgIHMgKz0gXCJcXHVGRkZGXCI7XHJcbiAgICAgICAgICBpbnB1dF9jb21wbGV0ZSA9IHRydWU7IC8vIE1ha2VzIHNjYW5DaGFycygpIHNlbmQgRU9GXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaGFycyA9IHM7XHJcbiAgICAgICAgbnVtY2hhcnMgPSBzLmxlbmd0aDtcclxuICAgICAgICBuZXh0Y2hhciA9IDA7XHJcblxyXG4gICAgICAgIGlmIChmaXJzdF9iYXRjaCkge1xyXG4gICAgICAgICAgLy8gV2Ugc2tpcCBhIGxlYWRpbmcgQnl0ZSBPcmRlciBNYXJrIChcXHVGRUZGKVxyXG4gICAgICAgICAgLy8gb24gZmlyc3QgYmF0Y2ggb2YgdGV4dCB3ZSdyZSBnaXZlblxyXG4gICAgICAgICAgZmlyc3RfYmF0Y2ggPSBmYWxzZTtcclxuICAgICAgICAgIGlmIChjaGFycy5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIG5leHRjaGFyID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlZW50cmFudF9pbnZvY2F0aW9ucysrO1xyXG4gICAgICAgIHNjYW5DaGFycygpO1xyXG4gICAgICAgIGxlZnRvdmVycyA9IGNoYXJzLnN1YnN0cmluZyhuZXh0Y2hhciwgbnVtY2hhcnMpO1xyXG4gICAgICAgIHJlZW50cmFudF9pbnZvY2F0aW9ucy0tO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIHJlLWVudHJhbnQgY2FzZSwgd2hpY2ggd2UgaGF2ZSB0b1xyXG4gICAgICAgIC8vIGhhbmRsZSBhIGxpdHRsZSBkaWZmZXJlbnRseS5cclxuICAgICAgICByZWVudHJhbnRfaW52b2NhdGlvbnMrKztcclxuXHJcbiAgICAgICAgLy8gU2F2ZSBjdXJyZW50IHNjYW5uZXIgc3RhdGVcclxuICAgICAgICBzYXZlZF9zY2FubmVyX3N0YXRlLnB1c2goY2hhcnMsIG51bWNoYXJzLCBuZXh0Y2hhcik7XHJcblxyXG4gICAgICAgIC8vIFNldCBuZXcgc2Nhbm5lciBzdGF0ZVxyXG4gICAgICAgIGNoYXJzID0gcztcclxuICAgICAgICBudW1jaGFycyA9IHMubGVuZ3RoO1xyXG4gICAgICAgIG5leHRjaGFyID0gMDtcclxuXHJcbiAgICAgICAgLy8gTm93IHNjYW4gYXMgbWFueSBvZiB0aGVzZSBuZXcgY2hhcnMgYXMgd2UgY2FuXHJcbiAgICAgICAgc2NhbkNoYXJzKCk7XHJcblxyXG4gICAgICAgIGxlZnRvdmVycyA9IGNoYXJzLnN1YnN0cmluZyhuZXh0Y2hhciwgbnVtY2hhcnMpO1xyXG5cclxuICAgICAgICAvLyByZXN0b3JlIG9sZCBzY2FubmVyIHN0YXRlXHJcbiAgICAgICAgbmV4dGNoYXIgPSBzYXZlZF9zY2FubmVyX3N0YXRlLnBvcCgpO1xyXG4gICAgICAgIG51bWNoYXJzID0gc2F2ZWRfc2Nhbm5lcl9zdGF0ZS5wb3AoKTtcclxuICAgICAgICBjaGFycyA9IHNhdmVkX3NjYW5uZXJfc3RhdGUucG9wKCk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZXJlIHdlcmUgbGVmdG92ZXIgY2hhcnMgZnJvbSB0aGlzIGludm9jYXRpb25cclxuICAgICAgICAvLyBpbnNlcnQgdGhlbSBpbnRvIHRoZSBwZW5kaW5nIGludm9jYXRpb24ncyBidWZmZXJcclxuICAgICAgICAvLyBhbmQgdHJpbSBhbHJlYWR5IHByb2Nlc3NlZCBjaGFycyBhdCB0aGUgc2FtZSB0aW1lXHJcbiAgICAgICAgaWYgKGxlZnRvdmVycykge1xyXG4gICAgICAgICAgY2hhcnMgPSBsZWZ0b3ZlcnMgKyBjaGFycy5zdWJzdHJpbmcobmV4dGNoYXIpO1xyXG4gICAgICAgICAgbnVtY2hhcnMgPSBjaGFycy5sZW5ndGg7XHJcbiAgICAgICAgICBuZXh0Y2hhciA9IDA7XHJcbiAgICAgICAgICBsZWZ0b3ZlcnMgPSBcIlwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVjcmVtZW50IHRoZSBjb3VudGVyXHJcbiAgICAgICAgcmVlbnRyYW50X2ludm9jYXRpb25zLS07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuXHJcbiAgLy8gVGhpcyBpcyB0aGUgZG9jdW1lbnQgd2UnbGwgYmUgYnVpbGRpbmcgdXBcclxuICB2YXIgZG9jID0gbmV3IERvY3VtZW50KHRydWUsIGFkZHJlc3MpO1xyXG5cclxuICAvLyBUaGUgZG9jdW1lbnQgbmVlZHMgdG8ga25vdyBhYm91dCB0aGUgcGFyc2VyLCBmb3IgZG9jdW1lbnQud3JpdGUoKS5cclxuICAvLyBUaGlzIF9wYXJzZXIgcHJvcGVydHkgd2lsbCBiZSBkZWxldGVkIHdoZW4gd2UncmUgZG9uZSBwYXJzaW5nLlxyXG4gIGRvYy5fcGFyc2VyID0gaHRtbHBhcnNlcjtcclxuXHJcbiAgLy8gWFhYIEkgdGhpbmsgdGhhdCBhbnkgZG9jdW1lbnQgd2UgdXNlIHRoaXMgcGFyc2VyIG9uIHNob3VsZCBzdXBwb3J0XHJcbiAgLy8gc2NyaXB0cy4gQnV0IEkgbWF5IG5lZWQgdG8gY29uZmlndXJlIHRoYXQgdGhyb3VnaCBhIHBhcnNlciBwYXJhbWV0ZXJcclxuICAvLyBPbmx5IGRvY3VtZW50cyB3aXRoIHdpbmRvd3MgKFwiYnJvd3NpbmcgY29udGV4dHNcIiB0byBiZSBwcmVjaXNlKVxyXG4gIC8vIGFsbG93IHNjcmlwdGluZy5cclxuICBkb2MuX3NjcmlwdGluZ19lbmFibGVkID0gc2NyaXB0aW5nX2VuYWJsZWQ7XHJcblxyXG5cclxuICAvKioqXHJcbiAgICogVGhlIGFjdHVhbCBjb2RlIG9mIHRoZSBIVE1MUGFyc2VyKCkgZmFjdG9yeSBmdW5jdGlvbiBiZWdpbnMgaGVyZS5cclxuICAgKi9cclxuXHJcbiAgaWYgKGZyYWdtZW50Q29udGV4dCkgeyAvLyBmb3IgaW5uZXJIVE1MIHBhcnNpbmdcclxuICAgIGlmIChmcmFnbWVudENvbnRleHQub3duZXJEb2N1bWVudC5fcXVpcmtzKVxyXG4gICAgICBkb2MuX3F1aXJrcyA9IHRydWU7XHJcbiAgICBpZiAoZnJhZ21lbnRDb250ZXh0Lm93bmVyRG9jdW1lbnQuX2xpbWl0ZWRRdWlya3MpXHJcbiAgICAgIGRvYy5fbGltaXRlZFF1aXJrcyA9IHRydWU7XHJcblxyXG4gICAgLy8gU2V0IHRoZSBpbml0aWFsIHRva2VuaXplciBzdGF0ZVxyXG4gICAgaWYgKGZyYWdtZW50Q29udGV4dC5uYW1lc3BhY2VVUkkgPT09IE5BTUVTUEFDRS5IVE1MKSB7XHJcbiAgICAgIHN3aXRjaChmcmFnbWVudENvbnRleHQubG9jYWxOYW1lKSB7XHJcbiAgICAgIGNhc2UgXCJ0aXRsZVwiOlxyXG4gICAgICBjYXNlIFwidGV4dGFyZWFcIjpcclxuICAgICAgICB0b2tlbml6ZXIgPSByY2RhdGFfc3RhdGU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJzdHlsZVwiOlxyXG4gICAgICBjYXNlIFwieG1wXCI6XHJcbiAgICAgIGNhc2UgXCJpZnJhbWVcIjpcclxuICAgICAgY2FzZSBcIm5vZW1iZWRcIjpcclxuICAgICAgY2FzZSBcIm5vZnJhbWVzXCI6XHJcbiAgICAgIGNhc2UgXCJzY3JpcHRcIjpcclxuICAgICAgY2FzZSBcInBsYWludGV4dFwiOlxyXG4gICAgICAgIHRva2VuaXplciA9IHBsYWludGV4dF9zdGF0ZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcIm5vc2NyaXB0XCI6XHJcbiAgICAgICAgaWYgKHNjcmlwdGluZ19lbmFibGVkKVxyXG4gICAgICAgICAgdG9rZW5pemVyID0gcGxhaW50ZXh0X3N0YXRlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJvb3QgPSBkb2MuY3JlYXRlRWxlbWVudChcImh0bWxcIik7XHJcbiAgICBkb2MuX2FwcGVuZENoaWxkKHJvb3QpO1xyXG4gICAgc3RhY2sucHVzaChyb290KTtcclxuICAgIGlmIChmcmFnbWVudENvbnRleHQgaW5zdGFuY2VvZiBpbXBsLkhUTUxUZW1wbGF0ZUVsZW1lbnQpIHtcclxuICAgICAgdGVtcGxhdGVJbnNlcnRpb25Nb2Rlcy5wdXNoKGluX3RlbXBsYXRlX21vZGUpO1xyXG4gICAgfVxyXG4gICAgcmVzZXRJbnNlcnRpb25Nb2RlKCk7XHJcblxyXG4gICAgZm9yKHZhciBlID0gZnJhZ21lbnRDb250ZXh0OyBlICE9PSBudWxsOyBlID0gZS5wYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgaW1wbC5IVE1MRm9ybUVsZW1lbnQpIHtcclxuICAgICAgICBmb3JtX2VsZW1lbnRfcG9pbnRlciA9IGU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKipcclxuICAgKiBTY2FubmVyIGZ1bmN0aW9uc1xyXG4gICAqL1xyXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgY2hhcmFjdGVycyBpbiBjaGFycywgYW5kIHBhc3MgdGhlbSBvbmUgYXQgYSB0aW1lXHJcbiAgLy8gdG8gdGhlIHRva2VuaXplciBGU00uIFJldHVybiB3aGVuIG5vIG1vcmUgY2hhcmFjdGVycyBjYW4gYmUgcHJvY2Vzc2VkXHJcbiAgLy8gKFRoaXMgbWF5IGxlYXZlIDEgb3IgbW9yZSBjaGFyYWN0ZXJzIGluIHRoZSBidWZmZXI6IGxpa2UgYSBDUlxyXG4gIC8vIHdhaXRpbmcgdG8gc2VlIGlmIHRoZSBuZXh0IGNoYXIgaXMgTEYsIG9yIGZvciBzdGF0ZXMgdGhhdCByZXF1aXJlXHJcbiAgLy8gbG9va2FoZWFkLi4uKVxyXG4gIGZ1bmN0aW9uIHNjYW5DaGFycygpIHtcclxuICAgIHZhciBjb2RlcG9pbnQsIHMsIHBhdHRlcm4sIGVvZjtcclxuXHJcbiAgICB3aGlsZShuZXh0Y2hhciA8IG51bWNoYXJzKSB7XHJcblxyXG4gICAgICAvLyBJZiB3ZSBqdXN0IHRva2VuaXplZCBhIDwvc2NyaXB0PiB0YWcsIHRoZW4gdGhlIHBhdXNlZCBmbGFnXHJcbiAgICAgIC8vIG1heSBoYXZlIGJlZW4gc2V0IHRvIHRlbGwgdXMgdG8gc3RvcCB0b2tlbml6aW5nIHdoaWxlXHJcbiAgICAgIC8vIHRoZSBzY3JpcHQgaXMgbG9hZGluZ1xyXG4gICAgICBpZiAocGF1c2VkID4gMCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIHN3aXRjaCh0eXBlb2YgdG9rZW5pemVyLmxvb2thaGVhZCkge1xyXG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxyXG4gICAgICAgIGNvZGVwb2ludCA9IGNoYXJzLmNoYXJDb2RlQXQobmV4dGNoYXIrKyk7XHJcbiAgICAgICAgaWYgKHNjYW5uZXJfc2tpcF9uZXdsaW5lKSB7XHJcbiAgICAgICAgICBzY2FubmVyX3NraXBfbmV3bGluZSA9IGZhbHNlO1xyXG4gICAgICAgICAgaWYgKGNvZGVwb2ludCA9PT0gMHgwMDBBKSB7XHJcbiAgICAgICAgICAgIG5leHRjaGFyKys7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2goY29kZXBvaW50KSB7XHJcbiAgICAgICAgY2FzZSAweDAwMEQ6XHJcbiAgICAgICAgICAvLyBDUiBhbHdheXMgdHVybnMgaW50byBMRiwgYnV0IGlmIHRoZSBuZXh0IGNoYXJhY3RlclxyXG4gICAgICAgICAgLy8gaXMgTEYsIHRoZW4gdGhhdCBzZWNvbmQgTEYgaXMgc2tpcHBlZC5cclxuICAgICAgICAgIGlmIChuZXh0Y2hhciA8IG51bWNoYXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFycy5jaGFyQ29kZUF0KG5leHRjaGFyKSA9PT0gMHgwMDBBKVxyXG4gICAgICAgICAgICAgIG5leHRjaGFyKys7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qga25vdyB0aGUgbmV4dCBjaGFyIHJpZ2h0IG5vdywgc28gd2VcclxuICAgICAgICAgICAgLy8gY2FuJ3QgY2hlY2sgaWYgaXQgaXMgYSBMRi4gIFNvIHNldCBhIGZsYWdcclxuICAgICAgICAgICAgc2Nhbm5lcl9za2lwX25ld2xpbmUgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEluIGVpdGhlciBjYXNlLCBlbWl0IGEgTEZcclxuICAgICAgICAgIHRva2VuaXplcigweDAwMEEpO1xyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMHhGRkZGOlxyXG4gICAgICAgICAgaWYgKGlucHV0X2NvbXBsZXRlICYmIG5leHRjaGFyID09PSBudW1jaGFycykge1xyXG4gICAgICAgICAgICB0b2tlbml6ZXIoRU9GKTsgLy8gY29kZXBvaW50IHdpbGwgYmUgMHhGRkZGIGhlcmVcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRva2VuaXplcihjb2RlcG9pbnQpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICBjb2RlcG9pbnQgPSBjaGFycy5jaGFyQ29kZUF0KG5leHRjaGFyKTtcclxuXHJcbiAgICAgICAgLy8gVGhlIG9ubHkgdG9rZW5pemVyIHN0YXRlcyB0aGF0IHJlcXVpcmUgZml4ZWQgbG9va2FoZWFkXHJcbiAgICAgICAgLy8gb25seSBjb25zdW1lIGFscGhhbnVtIGNoYXJhY3RlcnMsIHNvIHdlIGRvbid0IGhhdmVcclxuICAgICAgICAvLyB0byB3b3JyeSBhYm91dCBDUiBhbmQgTEYgaW4gdGhpcyBjYXNlXHJcblxyXG4gICAgICAgIC8vIHRva2VuaXplciB3YW50cyBuIGNoYXJzIG9mIGxvb2thaGVhZFxyXG4gICAgICAgIHZhciBuID0gdG9rZW5pemVyLmxvb2thaGVhZDtcclxuICAgICAgICB2YXIgbmVlZHNTdHJpbmcgPSB0cnVlO1xyXG4gICAgICAgIGlmIChuIDwgMCkge1xyXG4gICAgICAgICAgbmVlZHNTdHJpbmcgPSBmYWxzZTtcclxuICAgICAgICAgIG4gPSAtbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuIDwgbnVtY2hhcnMgLSBuZXh0Y2hhcikge1xyXG4gICAgICAgICAgLy8gSWYgd2UgY2FuIGxvb2sgYWhlYWQgdGhhdCBmYXJcclxuICAgICAgICAgIHMgPSBuZWVkc1N0cmluZyA/IGNoYXJzLnN1YnN0cmluZyhuZXh0Y2hhciwgbmV4dGNoYXIrbikgOiBudWxsO1xyXG4gICAgICAgICAgZW9mID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgeyAvLyBpZiB3ZSBkb24ndCBoYXZlIHRoYXQgbWFueSBjaGFyYWN0ZXJzXHJcbiAgICAgICAgICBpZiAoaW5wdXRfY29tcGxldGUpIHsgLy8gSWYgbm8gbW9yZSBhcmUgY29taW5nXHJcbiAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIHdoYXQgd2UgaGF2ZVxyXG4gICAgICAgICAgICBzID0gbmVlZHNTdHJpbmcgPyBjaGFycy5zdWJzdHJpbmcobmV4dGNoYXIsIG51bWNoYXJzKSA6IG51bGw7XHJcbiAgICAgICAgICAgIGVvZiA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChjb2RlcG9pbnQgPT09IDB4RkZGRiAmJiBuZXh0Y2hhciA9PT0gbnVtY2hhcnMtMSlcclxuICAgICAgICAgICAgICBjb2RlcG9pbnQgPSBFT0Y7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gUmV0dXJuIG5vdyBhbmQgd2FpdCBmb3IgbW9yZSBjaGFycyBsYXRlclxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRva2VuaXplcihjb2RlcG9pbnQsIHMsIGVvZik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgY29kZXBvaW50ID0gY2hhcnMuY2hhckNvZGVBdChuZXh0Y2hhcik7XHJcblxyXG4gICAgICAgIC8vIHRva2VuaXplciB3YW50cyBjaGFyYWN0ZXJzIHVwIHRvIGEgbWF0Y2hpbmcgc3RyaW5nXHJcbiAgICAgICAgcGF0dGVybiA9IHRva2VuaXplci5sb29rYWhlYWQ7XHJcbiAgICAgICAgdmFyIHBvcyA9IGNoYXJzLmluZGV4T2YocGF0dGVybiwgbmV4dGNoYXIpO1xyXG4gICAgICAgIGlmIChwb3MgIT09IC0xKSB7XHJcbiAgICAgICAgICBzID0gY2hhcnMuc3Vic3RyaW5nKG5leHRjaGFyLCBwb3MgKyBwYXR0ZXJuLmxlbmd0aCk7XHJcbiAgICAgICAgICBlb2YgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7ICAvLyBObyBtYXRjaFxyXG4gICAgICAgICAgLy8gSWYgbW9yZSBjaGFyYWN0ZXJzIGNvbWluZywgd2FpdCBmb3IgdGhlbVxyXG4gICAgICAgICAgaWYgKCFpbnB1dF9jb21wbGV0ZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UndmUgZ290IHRvIHJldHVybiB3aGF0IHdlJ3ZlIGdvdFxyXG4gICAgICAgICAgcyA9IGNoYXJzLnN1YnN0cmluZyhuZXh0Y2hhciwgbnVtY2hhcnMpO1xyXG4gICAgICAgICAgaWYgKGNvZGVwb2ludCA9PT0gMHhGRkZGICYmIG5leHRjaGFyID09PSBudW1jaGFycy0xKVxyXG4gICAgICAgICAgICBjb2RlcG9pbnQgPSBFT0Y7XHJcbiAgICAgICAgICBlb2YgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIHRva2VuaXplciBzdGF0ZXMgdGhhdCByZXF1aXJlIHRoaXMga2luZCBvZlxyXG4gICAgICAgIC8vIGxvb2thaGVhZCBoYXZlIHRvIGJlIGNhcmVmdWwgdG8gaGFuZGxlIENSIGNoYXJhY3RlcnNcclxuICAgICAgICAvLyBjb3JyZWN0bHlcclxuICAgICAgICB0b2tlbml6ZXIoY29kZXBvaW50LCBzLCBlb2YpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqKlxyXG4gICAqIFRva2VuaXplciB1dGlsaXR5IGZ1bmN0aW9uc1xyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGFkZEF0dHJpYnV0ZShuYW1lLHZhbHVlKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgaXNuJ3QgYWxyZWFkeSBhbiBhdHRyaWJ1dGUgd2l0aCB0aGlzIG5hbWVcclxuICAgIC8vIElmIHRoZXJlIGlzLCBpZ25vcmUgdGhpcyBvbmUuXHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoYXR0cmlidXRlc1tpXVswXSA9PT0gbmFtZSkgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGF0dHJpYnV0ZXMucHVzaChbbmFtZSwgdmFsdWVdKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBhdHRyaWJ1dGVzLnB1c2goW25hbWVdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFNob3J0Y3V0IGZvciBzaW1wbGUgYXR0cmlidXRlc1xyXG4gIGZ1bmN0aW9uIGhhbmRsZVNpbXBsZUF0dHJpYnV0ZSgpIHtcclxuICAgIFNJTVBMRUFUVFIubGFzdEluZGV4ID0gbmV4dGNoYXItMTtcclxuICAgIHZhciBtYXRjaGVkID0gU0lNUExFQVRUUi5leGVjKGNoYXJzKTtcclxuICAgIGlmICghbWF0Y2hlZCkgdGhyb3cgbmV3IEVycm9yKFwic2hvdWxkIG5ldmVyIGhhcHBlblwiKTtcclxuICAgIHZhciBuYW1lID0gbWF0Y2hlZFsxXTtcclxuICAgIGlmICghbmFtZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmFyIHZhbHVlID0gbWF0Y2hlZFsyXTtcclxuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGg7XHJcbiAgICBzd2l0Y2godmFsdWVbMF0pIHtcclxuICAgIGNhc2UgJ1wiJzpcclxuICAgIGNhc2UgXCInXCI6XHJcbiAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEsIGxlbi0xKTtcclxuICAgICAgbmV4dGNoYXIgKz0gKG1hdGNoZWRbMF0ubGVuZ3RoLTEpO1xyXG4gICAgICB0b2tlbml6ZXIgPSBhZnRlcl9hdHRyaWJ1dGVfdmFsdWVfcXVvdGVkX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRva2VuaXplciA9IGJlZm9yZV9hdHRyaWJ1dGVfbmFtZV9zdGF0ZTtcclxuICAgICAgbmV4dGNoYXIgKz0gKG1hdGNoZWRbMF0ubGVuZ3RoLTEpO1xyXG4gICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBsZW4tMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBpc24ndCBhbHJlYWR5IGFuIGF0dHJpYnV0ZSB3aXRoIHRoaXMgbmFtZVxyXG4gICAgLy8gSWYgdGhlcmUgaXMsIGlnbm9yZSB0aGlzIG9uZS5cclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChhdHRyaWJ1dGVzW2ldWzBdID09PSBuYW1lKSByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBhdHRyaWJ1dGVzLnB1c2goW25hbWUsIHZhbHVlXSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGJlZ2luVGFnTmFtZSgpIHtcclxuICAgIGlzX2VuZF90YWcgPSBmYWxzZTtcclxuICAgIHRhZ25hbWVidWYgPSBcIlwiO1xyXG4gICAgYXR0cmlidXRlcy5sZW5ndGggPSAwO1xyXG4gIH1cclxuICBmdW5jdGlvbiBiZWdpbkVuZFRhZ05hbWUoKSB7XHJcbiAgICBpc19lbmRfdGFnID0gdHJ1ZTtcclxuICAgIHRhZ25hbWVidWYgPSBcIlwiO1xyXG4gICAgYXR0cmlidXRlcy5sZW5ndGggPSAwO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYmVnaW5UZW1wQnVmKCkgeyB0ZW1wYnVmLmxlbmd0aCA9IDA7IH1cclxuICBmdW5jdGlvbiBiZWdpbkF0dHJOYW1lKCkgeyBhdHRybmFtZWJ1ZiA9IFwiXCI7IH1cclxuICBmdW5jdGlvbiBiZWdpbkF0dHJWYWx1ZSgpIHsgYXR0cnZhbHVlYnVmID0gXCJcIjsgfVxyXG4gIGZ1bmN0aW9uIGJlZ2luQ29tbWVudCgpIHsgY29tbWVudGJ1Zi5sZW5ndGggPSAwOyB9XHJcbiAgZnVuY3Rpb24gYmVnaW5Eb2N0eXBlKCkge1xyXG4gICAgZG9jdHlwZW5hbWVidWYubGVuZ3RoID0gMDtcclxuICAgIGRvY3R5cGVwdWJsaWNidWYgPSBudWxsO1xyXG4gICAgZG9jdHlwZXN5c3RlbWJ1ZiA9IG51bGw7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGJlZ2luRG9jdHlwZVB1YmxpY0lkKCkgeyBkb2N0eXBlcHVibGljYnVmID0gW107IH1cclxuICBmdW5jdGlvbiBiZWdpbkRvY3R5cGVTeXN0ZW1JZCgpIHsgZG9jdHlwZXN5c3RlbWJ1ZiA9IFtdOyB9XHJcbiAgZnVuY3Rpb24gZm9yY2VxdWlya3MoKSB7IGZvcmNlX3F1aXJrcyA9IHRydWU7IH1cclxuICBmdW5jdGlvbiBjZGF0YUFsbG93ZWQoKSB7XHJcbiAgICByZXR1cm4gc3RhY2sudG9wICYmXHJcbiAgICAgIHN0YWNrLnRvcC5uYW1lc3BhY2VVUkkgIT09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIGNvZGVwb2ludHMgaW4gdGhlIHNwZWNpZmllZCBidWZmZXIgbWF0Y2ggdGhlXHJcbiAgLy8gY2hhcmFjdGVycyBvZiBsYXN0dGFnbmFtZVxyXG4gIGZ1bmN0aW9uIGFwcHJvcHJpYXRlRW5kVGFnKGJ1Zikge1xyXG4gICAgcmV0dXJuIGxhc3R0YWduYW1lID09PSBidWY7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmbHVzaFRleHQoKSB7XHJcbiAgICBpZiAodGV4dHJ1bi5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHZhciBzID0gYnVmMnN0cih0ZXh0cnVuKTtcclxuICAgICAgdGV4dHJ1bi5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgaWYgKGlnbm9yZV9saW5lZmVlZCkge1xyXG4gICAgICAgIGlnbm9yZV9saW5lZmVlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChzWzBdID09PSBcIlxcblwiKSBzID0gcy5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgaWYgKHMubGVuZ3RoID09PSAwKSByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGluc2VydFRva2VuKFRFWFQsIHMpO1xyXG4gICAgICB0ZXh0SW5jbHVkZXNOVUwgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlnbm9yZV9saW5lZmVlZCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29uc3VtZSBjaGFycyBtYXRjaGVkIGJ5IHRoZSBwYXR0ZXJuIGFuZCByZXR1cm4gdGhlbSBhcyBhIHN0cmluZy4gU3RhcnRzXHJcbiAgLy8gbWF0Y2hpbmcgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24sIHNvIHVzZXJzIHNob3VsZCBkcm9wIHRoZSBjdXJyZW50IGNoYXJcclxuICAvLyBvdGhlcndpc2UuXHJcbiAgZnVuY3Rpb24gZ2V0TWF0Y2hpbmdDaGFycyhwYXR0ZXJuKSB7XHJcbiAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IG5leHRjaGFyIC0gMTtcclxuICAgIHZhciBtYXRjaCA9IHBhdHRlcm4uZXhlYyhjaGFycyk7XHJcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPT09IG5leHRjaGFyIC0gMSkge1xyXG4gICAgICBtYXRjaCA9IG1hdGNoWzBdO1xyXG4gICAgICBuZXh0Y2hhciArPSBtYXRjaC5sZW5ndGggLSAxO1xyXG4gICAgICAvKiBDYXJlZnVsISAgTWFrZSBzdXJlIHdlIGhhdmVuJ3QgbWF0Y2hlZCB0aGUgRU9GIGNoYXJhY3RlciEgKi9cclxuICAgICAgaWYgKGlucHV0X2NvbXBsZXRlICYmIG5leHRjaGFyID09PSBudW1jaGFycykge1xyXG4gICAgICAgIC8vIE9vcHMsIGJhY2t1cCBvbmUuXHJcbiAgICAgICAgbWF0Y2ggPSBtYXRjaC5zbGljZSgwLCAtMSk7XHJcbiAgICAgICAgbmV4dGNoYXItLTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaG91bGQgbmV2ZXIgaGFwcGVuXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gZW1pdCBhIHN0cmluZyBvZiBjaGFycyB0aGF0IG1hdGNoIGEgcmVnZXhwXHJcbiAgLy8gUmV0dXJucyBmYWxzZSBpZiBubyBjaGFycyBtYXRjaGVkLlxyXG4gIGZ1bmN0aW9uIGVtaXRDaGFyc1doaWxlKHBhdHRlcm4pIHtcclxuICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gbmV4dGNoYXItMTtcclxuICAgIHZhciBtYXRjaCA9IHBhdHRlcm4uZXhlYyhjaGFycylbMF07XHJcbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gZmFsc2U7XHJcbiAgICBlbWl0Q2hhclN0cmluZyhtYXRjaCk7XHJcbiAgICBuZXh0Y2hhciArPSBtYXRjaC5sZW5ndGggLSAxO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBUaGlzIGlzIHVzZWQgYnkgQ0RBVEEgc2VjdGlvbnNcclxuICBmdW5jdGlvbiBlbWl0Q2hhclN0cmluZyhzKSB7XHJcbiAgICBpZiAodGV4dHJ1bi5sZW5ndGggPiAwKSBmbHVzaFRleHQoKTtcclxuXHJcbiAgICBpZiAoaWdub3JlX2xpbmVmZWVkKSB7XHJcbiAgICAgIGlnbm9yZV9saW5lZmVlZCA9IGZhbHNlO1xyXG4gICAgICBpZiAoc1swXSA9PT0gXCJcXG5cIikgcyA9IHMuc3Vic3RyaW5nKDEpO1xyXG4gICAgICBpZiAocy5sZW5ndGggPT09IDApIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnRUb2tlbihURVhULCBzKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVtaXRUYWcoKSB7XHJcbiAgICBpZiAoaXNfZW5kX3RhZykgaW5zZXJ0VG9rZW4oRU5EVEFHLCB0YWduYW1lYnVmKTtcclxuICAgIGVsc2Uge1xyXG4gICAgICAvLyBSZW1lbWJlciB0aGUgbGFzdCBvcGVuIHRhZyB3ZSBlbWl0dGVkXHJcbiAgICAgIHZhciB0YWduYW1lID0gdGFnbmFtZWJ1ZjtcclxuICAgICAgdGFnbmFtZWJ1ZiA9IFwiXCI7XHJcbiAgICAgIGxhc3R0YWduYW1lID0gdGFnbmFtZTtcclxuICAgICAgaW5zZXJ0VG9rZW4oVEFHLCB0YWduYW1lLCBhdHRyaWJ1dGVzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBBIHNob3J0Y3V0OiBsb29rIGFoZWFkIGFuZCBpZiB0aGlzIGlzIGEgb3BlbiBvciBjbG9zZSB0YWdcclxuICAvLyBpbiBsb3dlcmNhc2Ugd2l0aCBubyBzcGFjZXMgYW5kIG5vIGF0dHJpYnV0ZXMsIGp1c3QgZW1pdCBpdCBub3cuXHJcbiAgZnVuY3Rpb24gZW1pdFNpbXBsZVRhZygpIHtcclxuICAgIFNJTVBMRVRBRy5sYXN0SW5kZXggPSBuZXh0Y2hhcjtcclxuICAgIHZhciBtYXRjaGVkID0gU0lNUExFVEFHLmV4ZWMoY2hhcnMpO1xyXG4gICAgaWYgKCFtYXRjaGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJzaG91bGQgbmV2ZXIgaGFwcGVuXCIpO1xyXG4gICAgdmFyIHRhZ25hbWUgPSBtYXRjaGVkWzJdO1xyXG4gICAgaWYgKCF0YWduYW1lKSByZXR1cm4gZmFsc2U7XHJcbiAgICB2YXIgZW5kdGFnID0gbWF0Y2hlZFsxXTtcclxuICAgIGlmIChlbmR0YWcpIHtcclxuICAgICAgbmV4dGNoYXIgKz0gKHRhZ25hbWUubGVuZ3RoKzIpO1xyXG4gICAgICBpbnNlcnRUb2tlbihFTkRUQUcsIHRhZ25hbWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIG5leHRjaGFyICs9ICh0YWduYW1lLmxlbmd0aCsxKTtcclxuICAgICAgbGFzdHRhZ25hbWUgPSB0YWduYW1lO1xyXG4gICAgICBpbnNlcnRUb2tlbihUQUcsIHRhZ25hbWUsIE5PQVRUUlMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlbWl0U2VsZkNsb3NpbmdUYWcoKSB7XHJcbiAgICBpZiAoaXNfZW5kX3RhZykgaW5zZXJ0VG9rZW4oRU5EVEFHLCB0YWduYW1lYnVmLCBudWxsLCB0cnVlKTtcclxuICAgIGVsc2Uge1xyXG4gICAgICBpbnNlcnRUb2tlbihUQUcsIHRhZ25hbWVidWYsIGF0dHJpYnV0ZXMsIHRydWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZW1pdERvY3R5cGUoKSB7XHJcbiAgICBpbnNlcnRUb2tlbihET0NUWVBFLFxyXG4gICAgICAgICAgYnVmMnN0cihkb2N0eXBlbmFtZWJ1ZiksXHJcbiAgICAgICAgICBkb2N0eXBlcHVibGljYnVmID8gYnVmMnN0cihkb2N0eXBlcHVibGljYnVmKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgIGRvY3R5cGVzeXN0ZW1idWYgPyBidWYyc3RyKGRvY3R5cGVzeXN0ZW1idWYpIDogdW5kZWZpbmVkKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVtaXRFT0YoKSB7XHJcbiAgICBmbHVzaFRleHQoKTtcclxuICAgIHBhcnNlcihFT0YpOyAvLyBFT0YgbmV2ZXIgZ29lcyB0byBpbnNlcnRGb3JlaWduQ29udGVudCgpXHJcbiAgICBkb2MubW9kY2xvY2sgPSAxOyAvLyBTdGFydCB0cmFja2luZyBtb2RpZmljYXRpb25zXHJcbiAgfVxyXG5cclxuICAvLyBJbnNlcnQgYSB0b2tlbiwgZWl0aGVyIHVzaW5nIHRoZSBjdXJyZW50IHBhcnNlciBpbnNlcnRpb24gbW9kZVxyXG4gIC8vIChmb3IgSFRNTCBzdHVmZikgb3IgdXNpbmcgdGhlIGluc2VydEZvcmVpZ25Ub2tlbigpIG1ldGhvZC5cclxuICB2YXIgaW5zZXJ0VG9rZW4gPSBodG1scGFyc2VyLmluc2VydFRva2VuID0gZnVuY3Rpb24gaW5zZXJ0VG9rZW4odCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcclxuICAgIGZsdXNoVGV4dCgpO1xyXG4gICAgdmFyIGN1cnJlbnQgPSBzdGFjay50b3A7XHJcblxyXG4gICAgaWYgKCFjdXJyZW50IHx8IGN1cnJlbnQubmFtZXNwYWNlVVJJID09PSBOQU1FU1BBQ0UuSFRNTCkge1xyXG4gICAgICAvLyBUaGlzIGlzIHRoZSBjb21tb24gY2FzZVxyXG4gICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIC8vIE90aGVyd2lzZSB3ZSBtYXkgbmVlZCB0byBpbnNlcnQgdGhpcyB0b2tlbiBhcyBmb3JlaWduIGNvbnRlbnRcclxuICAgICAgaWYgKHQgIT09IFRBRyAmJiB0ICE9PSBURVhUKSB7XHJcbiAgICAgICAgaW5zZXJ0Rm9yZWlnblRva2VuKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAvLyBCdXQgaW4gc29tZSBjYXNlcyB3ZSB0cmVhdCBpdCBhcyByZWd1bGFyIGNvbnRlbnRcclxuICAgICAgICBpZiAoKGlzTWF0aG1sVGV4dEludGVncmF0aW9uUG9pbnQoY3VycmVudCkgJiZcclxuICAgICAgICAgICAodCA9PT0gVEVYVCB8fFxyXG4gICAgICAgICAgICAodCA9PT0gVEFHICYmXHJcbiAgICAgICAgICAgICB2YWx1ZSAhPT0gXCJtZ2x5cGhcIiAmJiB2YWx1ZSAhPT0gXCJtYWxpZ25tYXJrXCIpKSkgfHxcclxuICAgICAgICAgICh0ID09PSBUQUcgJiZcclxuICAgICAgICAgICB2YWx1ZSA9PT0gXCJzdmdcIiAmJlxyXG4gICAgICAgICAgIGN1cnJlbnQubmFtZXNwYWNlVVJJID09PSBOQU1FU1BBQ0UuTUFUSE1MICYmXHJcbiAgICAgICAgICAgY3VycmVudC5sb2NhbE5hbWUgPT09IFwiYW5ub3RhdGlvbi14bWxcIikgfHxcclxuICAgICAgICAgIGlzSFRNTEludGVncmF0aW9uUG9pbnQoY3VycmVudCkpIHtcclxuXHJcbiAgICAgICAgICAvLyBYWFg6IHRoZSB0ZXh0X2ludGVncmF0aW9uX21vZGUgc3R1ZmYgaXMgYW5cclxuICAgICAgICAgIC8vIGF0dGVtcHRlZCBidWcgd29ya2Fyb3VuZCBvZiBtaW5lXHJcbiAgICAgICAgICB0ZXh0X2ludGVncmF0aW9uX21vZGUgPSB0cnVlO1xyXG4gICAgICAgICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgICAgIHRleHRfaW50ZWdyYXRpb25fbW9kZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPdGhlcndpc2UgaXQgaXMgZm9yZWlnbiBjb250ZW50XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBpbnNlcnRGb3JlaWduVG9rZW4odCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG5cclxuICAvKioqXHJcbiAgICogVHJlZSBidWlsZGluZyB1dGlsaXR5IGZ1bmN0aW9uc1xyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGluc2VydENvbW1lbnQoZGF0YSkge1xyXG4gICAgdmFyIHBhcmVudCA9IHN0YWNrLnRvcDtcclxuICAgIGlmIChmb3N0ZXJfcGFyZW50X21vZGUgJiYgaXNBKHBhcmVudCwgdGFibGVzZWN0aW9ucm93U2V0KSkge1xyXG4gICAgICBmb3N0ZXJQYXJlbnQoZnVuY3Rpb24oZG9jKSB7IHJldHVybiBkb2MuY3JlYXRlQ29tbWVudChkYXRhKTsgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBcIklmIHRoZSBhZGp1c3RlZCBpbnNlcnRpb24gbG9jYXRpb24gaXMgaW5zaWRlIGEgdGVtcGxhdGUgZWxlbWVudCxcclxuICAgICAgLy8gbGV0IGl0IGluc3RlYWQgYmUgaW5zaWRlIHRoZSB0ZW1wbGF0ZSBlbGVtZW50J3MgdGVtcGxhdGUgY29udGVudHNcIlxyXG4gICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgaW1wbC5IVE1MVGVtcGxhdGVFbGVtZW50KSB7XHJcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LmNvbnRlbnQ7XHJcbiAgICAgIH1cclxuICAgICAgcGFyZW50Ll9hcHBlbmRDaGlsZChwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KGRhdGEpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluc2VydFRleHQocykge1xyXG4gICAgdmFyIHBhcmVudCA9IHN0YWNrLnRvcDtcclxuICAgIGlmIChmb3N0ZXJfcGFyZW50X21vZGUgJiYgaXNBKHBhcmVudCwgdGFibGVzZWN0aW9ucm93U2V0KSkge1xyXG4gICAgICBmb3N0ZXJQYXJlbnQoZnVuY3Rpb24oZG9jKSB7IHJldHVybiBkb2MuY3JlYXRlVGV4dE5vZGUocyk7IH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gXCJJZiB0aGUgYWRqdXN0ZWQgaW5zZXJ0aW9uIGxvY2F0aW9uIGlzIGluc2lkZSBhIHRlbXBsYXRlIGVsZW1lbnQsXHJcbiAgICAgIC8vIGxldCBpdCBpbnN0ZWFkIGJlIGluc2lkZSB0aGUgdGVtcGxhdGUgZWxlbWVudCdzIHRlbXBsYXRlIGNvbnRlbnRzXCJcclxuICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIGltcGwuSFRNTFRlbXBsYXRlRWxlbWVudCkge1xyXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5jb250ZW50O1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFwiSWYgdGhlcmUgaXMgYSBUZXh0IG5vZGUgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBhZGp1c3RlZCBpbnNlcnRpb25cclxuICAgICAgLy8gbG9jYXRpb24sIHRoZW4gYXBwZW5kIGRhdGEgdG8gdGhhdCBUZXh0IG5vZGUncyBkYXRhLlwiXHJcbiAgICAgIHZhciBsYXN0Q2hpbGQgPSBwYXJlbnQubGFzdENoaWxkO1xyXG4gICAgICBpZiAobGFzdENoaWxkICYmIGxhc3RDaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcclxuICAgICAgICBsYXN0Q2hpbGQuYXBwZW5kRGF0YShzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYXJlbnQuX2FwcGVuZENoaWxkKHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHMpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlSFRNTEVsdChkb2MsIG5hbWUsIGF0dHJzKSB7XHJcbiAgICAvLyBDcmVhdGUgdGhlIGVsZW1lbnQgdGhpcyB3YXksIHJhdGhlciB0aGFuIHdpdGhcclxuICAgIC8vIGRvYy5jcmVhdGVFbGVtZW50IGJlY2F1c2UgY3JlYXRlRWxlbWVudCgpIGRvZXMgZXJyb3JcclxuICAgIC8vIGNoZWNraW5nIG9uIHRoZSBlbGVtZW50IG5hbWUgdGhhdCB3ZSBuZWVkIHRvIGF2b2lkIGhlcmUuXHJcbiAgICB2YXIgZWx0ID0gaHRtbC5jcmVhdGVFbGVtZW50KGRvYywgbmFtZSwgbnVsbCk7XHJcblxyXG4gICAgaWYgKGF0dHJzKSB7XHJcbiAgICAgIGZvcih2YXIgaSA9IDAsIG4gPSBhdHRycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAvLyBVc2UgdGhlIF8gdmVyc2lvbiB0byBhdm9pZCB0ZXN0aW5nIHRoZSB2YWxpZGl0eVxyXG4gICAgICAgIC8vIG9mIHRoZSBhdHRyaWJ1dGUgbmFtZVxyXG4gICAgICAgIGVsdC5fc2V0QXR0cmlidXRlKGF0dHJzW2ldWzBdLCBhdHRyc1tpXVsxXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFhYWFxyXG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgYSByZXNldHRhYmxlIGZvcm0gZWxlbWVudCxcclxuICAgIC8vIHJ1biBpdHMgcmVzZXQgYWxnb3JpdGhtIG5vd1xyXG4gICAgLy8gWFhYXHJcbiAgICAvLyBoYW5kbGUgY2FzZSB3aGVyZSBmb3JtLWVsZW1lbnQtcG9pbnRlciBpcyBub3QgbnVsbFxyXG4gICAgcmV0dXJuIGVsdDtcclxuICB9XHJcblxyXG4gIC8vIFRoZSBpbl90YWJsZSBpbnNlcnRpb24gbW9kZSB0dXJucyBvbiB0aGlzIGZsYWcsIGFuZCB0aGF0IG1ha2VzXHJcbiAgLy8gaW5zZXJ0SFRNTEVsZW1lbnQgdXNlIHRoZSBmb3N0ZXIgcGFyZW50aW5nIGFsZ29yaXRobSBmb3IgZWxlbWVudHNcclxuICAvLyB0YWdzIGluc2lkZSBhIHRhYmxlXHJcbiAgdmFyIGZvc3Rlcl9wYXJlbnRfbW9kZSA9IGZhbHNlO1xyXG5cclxuICBmdW5jdGlvbiBpbnNlcnRIVE1MRWxlbWVudChuYW1lLCBhdHRycykge1xyXG4gICAgdmFyIGVsdCA9IGluc2VydEVsZW1lbnQoZnVuY3Rpb24oZG9jKSB7XHJcbiAgICAgIHJldHVybiBjcmVhdGVIVE1MRWx0KGRvYywgbmFtZSwgYXR0cnMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gWFhYXHJcbiAgICAvLyBJZiB0aGlzIGlzIGEgZm9ybSBlbGVtZW50LCBzZXQgaXRzIGZvcm0gYXR0cmlidXRlIHByb3BlcnR5IGhlcmVcclxuICAgIGlmIChpc0EoZWx0LCBmb3JtYXNzb2NpYXRlZFNldCkpIHtcclxuICAgICAgZWx0Ll9mb3JtID0gZm9ybV9lbGVtZW50X3BvaW50ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsdDtcclxuICB9XHJcblxyXG4gIC8vIEluc2VydCB0aGUgZWxlbWVudCBpbnRvIHRoZSBvcGVuIGVsZW1lbnQgb3IgZm9zdGVyIHBhcmVudCBpdFxyXG4gIGZ1bmN0aW9uIGluc2VydEVsZW1lbnQoZWx0RnVuYykge1xyXG4gICAgdmFyIGVsdDtcclxuICAgIGlmIChmb3N0ZXJfcGFyZW50X21vZGUgJiYgaXNBKHN0YWNrLnRvcCwgdGFibGVzZWN0aW9ucm93U2V0KSkge1xyXG4gICAgICBlbHQgPSBmb3N0ZXJQYXJlbnQoZWx0RnVuYyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzdGFjay50b3AgaW5zdGFuY2VvZiBpbXBsLkhUTUxUZW1wbGF0ZUVsZW1lbnQpIHtcclxuICAgICAgLy8gXCJJZiB0aGUgYWRqdXN0ZWQgaW5zZXJ0aW9uIGxvY2F0aW9uIGlzIGluc2lkZSBhIHRlbXBsYXRlIGVsZW1lbnQsXHJcbiAgICAgIC8vIGxldCBpdCBpbnN0ZWFkIGJlIGluc2lkZSB0aGUgdGVtcGxhdGUgZWxlbWVudCdzIHRlbXBsYXRlIGNvbnRlbnRzXCJcclxuICAgICAgZWx0ID0gZWx0RnVuYyhzdGFjay50b3AuY29udGVudC5vd25lckRvY3VtZW50KTtcclxuICAgICAgc3RhY2sudG9wLmNvbnRlbnQuX2FwcGVuZENoaWxkKGVsdCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbHQgPSBlbHRGdW5jKHN0YWNrLnRvcC5vd25lckRvY3VtZW50KTtcclxuICAgICAgc3RhY2sudG9wLl9hcHBlbmRDaGlsZChlbHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YWNrLnB1c2goZWx0KTtcclxuICAgIHJldHVybiBlbHQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbnNlcnRGb3JlaWduRWxlbWVudChuYW1lLCBhdHRycywgbnMpIHtcclxuICAgIHJldHVybiBpbnNlcnRFbGVtZW50KGZ1bmN0aW9uKGRvYykge1xyXG4gICAgICB2YXIgZWx0ID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgbmFtZSk7XHJcbiAgICAgIGlmIChhdHRycykge1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDAsIG4gPSBhdHRycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgIHZhciBhdHRyID0gYXR0cnNbaV07XHJcbiAgICAgICAgICBpZiAoYXR0ci5sZW5ndGggPT09IDIpXHJcbiAgICAgICAgICAgIGVsdC5fc2V0QXR0cmlidXRlKGF0dHJbMF0sIGF0dHJbMV0pO1xyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsdC5fc2V0QXR0cmlidXRlTlMoYXR0clsyXSwgYXR0clswXSwgYXR0clsxXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBlbHQ7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGxhc3RFbGVtZW50T2ZUeXBlKHR5cGUpIHtcclxuICAgIGZvcih2YXIgaSA9IHN0YWNrLmVsZW1lbnRzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xyXG4gICAgICBpZiAoc3RhY2suZWxlbWVudHNbaV0gaW5zdGFuY2VvZiB0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZvc3RlclBhcmVudChlbHRGdW5jKSB7XHJcbiAgICB2YXIgcGFyZW50LCBiZWZvcmUsIGxhc3RUYWJsZSA9IC0xLCBsYXN0VGVtcGxhdGUgPSAtMSwgZWx0O1xyXG5cclxuICAgIGxhc3RUYWJsZSA9IGxhc3RFbGVtZW50T2ZUeXBlKGltcGwuSFRNTFRhYmxlRWxlbWVudCk7XHJcbiAgICBsYXN0VGVtcGxhdGUgPSBsYXN0RWxlbWVudE9mVHlwZShpbXBsLkhUTUxUZW1wbGF0ZUVsZW1lbnQpO1xyXG5cclxuICAgIGlmIChsYXN0VGVtcGxhdGUgPj0gMCAmJiAobGFzdFRhYmxlIDwgMCB8fCBsYXN0VGVtcGxhdGUgPiBsYXN0VGFibGUpKSB7XHJcbiAgICAgIHBhcmVudCA9IHN0YWNrLmVsZW1lbnRzW2xhc3RUZW1wbGF0ZV07XHJcbiAgICB9IGVsc2UgaWYgKGxhc3RUYWJsZSA+PSAwKSB7XHJcbiAgICAgIHBhcmVudCA9IHN0YWNrLmVsZW1lbnRzW2xhc3RUYWJsZV0ucGFyZW50Tm9kZTtcclxuICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgIGJlZm9yZSA9IHN0YWNrLmVsZW1lbnRzW2xhc3RUYWJsZV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGFyZW50ID0gc3RhY2suZWxlbWVudHNbbGFzdFRhYmxlIC0gMV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghcGFyZW50KSBwYXJlbnQgPSBzdGFjay5lbGVtZW50c1swXTsgLy8gdGhlIGBodG1sYCBlbGVtZW50LlxyXG5cclxuICAgIC8vIFwiSWYgdGhlIGFkanVzdGVkIGluc2VydGlvbiBsb2NhdGlvbiBpcyBpbnNpZGUgYSB0ZW1wbGF0ZSBlbGVtZW50LFxyXG4gICAgLy8gbGV0IGl0IGluc3RlYWQgYmUgaW5zaWRlIHRoZSB0ZW1wbGF0ZSBlbGVtZW50J3MgdGVtcGxhdGUgY29udGVudHNcIlxyXG4gICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIGltcGwuSFRNTFRlbXBsYXRlRWxlbWVudCkge1xyXG4gICAgICBwYXJlbnQgPSBwYXJlbnQuY29udGVudDtcclxuICAgIH1cclxuICAgIC8vIENyZWF0ZSBlbGVtZW50IGluIHRoZSBhcHByb3ByaWF0ZSBkb2N1bWVudC5cclxuICAgIGVsdCA9IGVsdEZ1bmMocGFyZW50Lm93bmVyRG9jdW1lbnQpO1xyXG5cclxuICAgIGlmIChlbHQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XHJcbiAgICAgIHZhciBwcmV2O1xyXG4gICAgICBpZiAoYmVmb3JlKSBwcmV2ID0gYmVmb3JlLnByZXZpb3VzU2libGluZztcclxuICAgICAgZWxzZSBwcmV2ID0gcGFyZW50Lmxhc3RDaGlsZDtcclxuICAgICAgaWYgKHByZXYgJiYgcHJldi5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcclxuICAgICAgICBwcmV2LmFwcGVuZERhdGEoZWx0LmRhdGEpO1xyXG4gICAgICAgIHJldHVybiBlbHQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChiZWZvcmUpXHJcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWx0LCBiZWZvcmUpO1xyXG4gICAgZWxzZVxyXG4gICAgICBwYXJlbnQuX2FwcGVuZENoaWxkKGVsdCk7XHJcbiAgICByZXR1cm4gZWx0O1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHJlc2V0SW5zZXJ0aW9uTW9kZSgpIHtcclxuICAgIHZhciBsYXN0ID0gZmFsc2U7XHJcbiAgICBmb3IodmFyIGkgPSBzdGFjay5lbGVtZW50cy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgdmFyIG5vZGUgPSBzdGFjay5lbGVtZW50c1tpXTtcclxuICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICBsYXN0ID0gdHJ1ZTtcclxuICAgICAgICBpZiAoZnJhZ21lbnQpIHtcclxuICAgICAgICAgIG5vZGUgPSBmcmFnbWVudENvbnRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTkFNRVNQQUNFLkhUTUwpIHtcclxuICAgICAgICB2YXIgdGFnID0gbm9kZS5sb2NhbE5hbWU7XHJcbiAgICAgICAgc3dpdGNoKHRhZykge1xyXG4gICAgICAgIGNhc2UgXCJzZWxlY3RcIjpcclxuICAgICAgICAgIGZvcih2YXIgaiA9IGk7IGogPiAwOyApIHtcclxuICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gc3RhY2suZWxlbWVudHNbLS1qXTtcclxuICAgICAgICAgICAgaWYgKGFuY2VzdG9yIGluc3RhbmNlb2YgaW1wbC5IVE1MVGVtcGxhdGVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5jZXN0b3IgaW5zdGFuY2VvZiBpbXBsLkhUTUxUYWJsZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICBwYXJzZXIgPSBpbl9zZWxlY3RfaW5fdGFibGVfbW9kZTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHBhcnNlciA9IGluX3NlbGVjdF9tb2RlO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNhc2UgXCJ0clwiOlxyXG4gICAgICAgICAgcGFyc2VyID0gaW5fcm93X21vZGU7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY2FzZSBcInRib2R5XCI6XHJcbiAgICAgICAgY2FzZSBcInRmb290XCI6XHJcbiAgICAgICAgY2FzZSBcInRoZWFkXCI6XHJcbiAgICAgICAgICBwYXJzZXIgPSBpbl90YWJsZV9ib2R5X21vZGU7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY2FzZSBcImNhcHRpb25cIjpcclxuICAgICAgICAgIHBhcnNlciA9IGluX2NhcHRpb25fbW9kZTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcclxuICAgICAgICAgIHBhcnNlciA9IGluX2NvbHVtbl9ncm91cF9tb2RlO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNhc2UgXCJ0YWJsZVwiOlxyXG4gICAgICAgICAgcGFyc2VyID0gaW5fdGFibGVfbW9kZTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjYXNlIFwidGVtcGxhdGVcIjpcclxuICAgICAgICAgIHBhcnNlciA9IHRlbXBsYXRlSW5zZXJ0aW9uTW9kZXNbdGVtcGxhdGVJbnNlcnRpb25Nb2Rlcy5sZW5ndGgtMV07XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY2FzZSBcImJvZHlcIjpcclxuICAgICAgICAgIHBhcnNlciA9IGluX2JvZHlfbW9kZTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjYXNlIFwiZnJhbWVzZXRcIjpcclxuICAgICAgICAgIHBhcnNlciA9IGluX2ZyYW1lc2V0X21vZGU7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY2FzZSBcImh0bWxcIjpcclxuICAgICAgICAgIGlmIChoZWFkX2VsZW1lbnRfcG9pbnRlciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwYXJzZXIgPSBiZWZvcmVfaGVhZF9tb2RlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGFyc2VyID0gYWZ0ZXJfaGVhZF9tb2RlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBpZiAoIWxhc3QpIHtcclxuICAgICAgICAgICAgaWYgKHRhZyA9PT0gXCJoZWFkXCIpIHtcclxuICAgICAgICAgICAgICBwYXJzZXIgPSBpbl9oZWFkX21vZGU7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0YWcgPT09IFwidGRcIiB8fCB0YWcgPT09IFwidGhcIikge1xyXG4gICAgICAgICAgICAgIHBhcnNlciA9IGluX2NlbGxfbW9kZTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGxhc3QpIHtcclxuICAgICAgICBwYXJzZXIgPSBpbl9ib2R5X21vZGU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gcGFyc2VSYXdUZXh0KG5hbWUsIGF0dHJzKSB7XHJcbiAgICBpbnNlcnRIVE1MRWxlbWVudChuYW1lLCBhdHRycyk7XHJcbiAgICB0b2tlbml6ZXIgPSByYXd0ZXh0X3N0YXRlO1xyXG4gICAgb3JpZ2luYWxJbnNlcnRpb25Nb2RlID0gcGFyc2VyO1xyXG4gICAgcGFyc2VyID0gdGV4dF9tb2RlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGFyc2VSQ0RBVEEobmFtZSwgYXR0cnMpIHtcclxuICAgIGluc2VydEhUTUxFbGVtZW50KG5hbWUsIGF0dHJzKTtcclxuICAgIHRva2VuaXplciA9IHJjZGF0YV9zdGF0ZTtcclxuICAgIG9yaWdpbmFsSW5zZXJ0aW9uTW9kZSA9IHBhcnNlcjtcclxuICAgIHBhcnNlciA9IHRleHRfbW9kZTtcclxuICB9XHJcblxyXG4gIC8vIE1ha2UgYSBjb3B5IG9mIGVsZW1lbnQgaSBvbiB0aGUgbGlzdCBvZiBhY3RpdmUgZm9ybWF0dGluZ1xyXG4gIC8vIGVsZW1lbnRzLCB1c2luZyBpdHMgb3JpZ2luYWwgYXR0cmlidXRlcywgbm90IGN1cnJlbnRcclxuICAvLyBhdHRyaWJ1dGVzICh3aGljaCBtYXkgaGF2ZSBiZWVuIG1vZGlmaWVkIGJ5IGEgc2NyaXB0KVxyXG4gIGZ1bmN0aW9uIGFmZWNsb25lKGRvYywgaSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZWx0OiBjcmVhdGVIVE1MRWx0KGRvYywgYWZlLmxpc3RbaV0ubG9jYWxOYW1lLCBhZmUuYXR0cnNbaV0pLFxyXG4gICAgICBhdHRyczogYWZlLmF0dHJzW2ldLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiBhZmVyZWNvbnN0cnVjdCgpIHtcclxuICAgIGlmIChhZmUubGlzdC5sZW5ndGggPT09IDApIHJldHVybjtcclxuICAgIHZhciBlbnRyeSA9IGFmZS5saXN0W2FmZS5saXN0Lmxlbmd0aC0xXTtcclxuICAgIC8vIElmIHRoZSBsYXN0IGlzIGEgbWFya2VyICwgZG8gbm90aGluZ1xyXG4gICAgaWYgKGVudHJ5ID09PSBhZmUuTUFSS0VSKSByZXR1cm47XHJcbiAgICAvLyBPciBpZiBpdCBpcyBhbiBvcGVuIGVsZW1lbnQsIGRvIG5vdGhpbmdcclxuICAgIGlmIChzdGFjay5lbGVtZW50cy5sYXN0SW5kZXhPZihlbnRyeSkgIT09IC0xKSByZXR1cm47XHJcblxyXG4gICAgLy8gTG9vcCBiYWNrd2FyZCB0aHJvdWdoIHRoZSBsaXN0IHVudGlsIHdlIGZpbmQgYSBtYXJrZXIgb3IgYW5cclxuICAgIC8vIG9wZW4gZWxlbWVudCwgYW5kIHRoZW4gbW92ZSBmb3J3YXJkIG9uZSBmcm9tIHRoZXJlLlxyXG4gICAgZm9yKHZhciBpID0gYWZlLmxpc3QubGVuZ3RoLTI7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGVudHJ5ID0gYWZlLmxpc3RbaV07XHJcbiAgICAgIGlmIChlbnRyeSA9PT0gYWZlLk1BUktFUikgYnJlYWs7XHJcbiAgICAgIGlmIChzdGFjay5lbGVtZW50cy5sYXN0SW5kZXhPZihlbnRyeSkgIT09IC0xKSBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3cgbG9vcCBmb3J3YXJkLCBzdGFydGluZyBmcm9tIHRoZSBlbGVtZW50IGFmdGVyIHRoZSBjdXJyZW50XHJcbiAgICAvLyBvbmUsIHJlY3JlYXRpbmcgZm9ybWF0dGluZyBlbGVtZW50cyBhbmQgcHVzaGluZyB0aGVtIGJhY2sgb250b1xyXG4gICAgLy8gdGhlIGxpc3Qgb2Ygb3BlbiBlbGVtZW50c1xyXG4gICAgZm9yKGkgPSBpKzE7IGkgPCBhZmUubGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgbmV3ZWx0ID0gaW5zZXJ0RWxlbWVudChmdW5jdGlvbihkb2MpIHsgcmV0dXJuIGFmZWNsb25lKGRvYywgaSkuZWx0OyB9KTtcclxuICAgICAgYWZlLmxpc3RbaV0gPSBuZXdlbHQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBVc2VkIGJ5IHRoZSBhZG9wdGlvbkFnZW5jeSgpIGZ1bmN0aW9uXHJcbiAgdmFyIEJPT0tNQVJLID0ge2xvY2FsTmFtZTpcIkJNXCJ9O1xyXG5cclxuICBmdW5jdGlvbiBhZG9wdGlvbkFnZW5jeSh0YWcpIHtcclxuICAgIC8vIElmIHRoZSBjdXJyZW50IG5vZGUgaXMgYW4gSFRNTCBlbGVtZW50IHdob3NlIHRhZyBuYW1lIGlzIHN1YmplY3QsXHJcbiAgICAvLyBhbmQgdGhlIGN1cnJlbnQgbm9kZSBpcyBub3QgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGZvcm1hdHRpbmdcclxuICAgIC8vIGVsZW1lbnRzLCB0aGVuIHBvcCB0aGUgY3VycmVudCBub2RlIG9mZiB0aGUgc3RhY2sgb2Ygb3BlblxyXG4gICAgLy8gZWxlbWVudHMgYW5kIGFib3J0IHRoZXNlIHN0ZXBzLlxyXG4gICAgaWYgKGlzQShzdGFjay50b3AsIHRhZykgJiYgYWZlLmluZGV4T2Yoc3RhY2sudG9wKSA9PT0gLTEpIHtcclxuICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgIHJldHVybiB0cnVlOyAvLyBubyBtb3JlIGhhbmRsaW5nIHJlcXVpcmVkXHJcbiAgICB9XHJcblxyXG4gICAgLy8gTGV0IG91dGVyIGxvb3AgY291bnRlciBiZSB6ZXJvLlxyXG4gICAgdmFyIG91dGVyID0gMDtcclxuXHJcbiAgICAvLyBPdXRlciBsb29wOiBJZiBvdXRlciBsb29wIGNvdW50ZXIgaXMgZ3JlYXRlciB0aGFuIG9yXHJcbiAgICAvLyBlcXVhbCB0byBlaWdodCwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy5cclxuICAgIHdoaWxlKG91dGVyIDwgOCkge1xyXG4gICAgICAvLyBJbmNyZW1lbnQgb3V0ZXIgbG9vcCBjb3VudGVyIGJ5IG9uZS5cclxuICAgICAgb3V0ZXIrKztcclxuXHJcbiAgICAgIC8vIExldCB0aGUgZm9ybWF0dGluZyBlbGVtZW50IGJlIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIGxpc3RcclxuICAgICAgLy8gb2YgYWN0aXZlIGZvcm1hdHRpbmcgZWxlbWVudHMgdGhhdDogaXMgYmV0d2VlbiB0aGUgZW5kIG9mXHJcbiAgICAgIC8vIHRoZSBsaXN0IGFuZCB0aGUgbGFzdCBzY29wZSBtYXJrZXIgaW4gdGhlIGxpc3QsIGlmIGFueSwgb3JcclxuICAgICAgLy8gdGhlIHN0YXJ0IG9mIHRoZSBsaXN0IG90aGVyd2lzZSwgYW5kIGhhcyB0aGUgc2FtZSB0YWcgbmFtZVxyXG4gICAgICAvLyBhcyB0aGUgdG9rZW4uXHJcbiAgICAgIHZhciBmbXRlbHQgPSBhZmUuZmluZEVsZW1lbnRCeVRhZyh0YWcpO1xyXG5cclxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gc3VjaCBub2RlLCB0aGVuIGFib3J0IHRoZXNlIHN0ZXBzIGFuZCBpbnN0ZWFkXHJcbiAgICAgIC8vIGFjdCBhcyBkZXNjcmliZWQgaW4gdGhlIFwiYW55IG90aGVyIGVuZCB0YWdcIiBlbnRyeSBiZWxvdy5cclxuICAgICAgaWYgKCFmbXRlbHQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGZhbHNlIG1lYW5zIGhhbmRsZSBieSB0aGUgZGVmYXVsdCBjYXNlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlcmUgaXMgc3VjaCBhIG5vZGUsIGJ1dCB0aGF0IG5vZGUgaXMgbm90IGluXHJcbiAgICAgIC8vIHRoZSBzdGFjayBvZiBvcGVuIGVsZW1lbnRzLCB0aGVuIHRoaXMgaXMgYSBwYXJzZSBlcnJvcjtcclxuICAgICAgLy8gcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIGxpc3QsIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy5cclxuICAgICAgdmFyIGluZGV4ID0gc3RhY2suZWxlbWVudHMubGFzdEluZGV4T2YoZm10ZWx0KTtcclxuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIGFmZS5yZW1vdmUoZm10ZWx0KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTsgICAvLyB0cnVlIG1lYW5zIG5vIG1vcmUgaGFuZGxpbmcgcmVxdWlyZWRcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGVyZSBpcyBzdWNoIGEgbm9kZSwgYW5kIHRoYXQgbm9kZSBpcyBhbHNvIGluXHJcbiAgICAgIC8vIHRoZSBzdGFjayBvZiBvcGVuIGVsZW1lbnRzLCBidXQgdGhlIGVsZW1lbnQgaXMgbm90IGluIHNjb3BlLFxyXG4gICAgICAvLyB0aGVuIHRoaXMgaXMgYSBwYXJzZSBlcnJvcjsgaWdub3JlIHRoZSB0b2tlbiwgYW5kIGFib3J0XHJcbiAgICAgIC8vIHRoZXNlIHN0ZXBzLlxyXG4gICAgICBpZiAoIXN0YWNrLmVsZW1lbnRJblNjb3BlKGZtdGVsdCkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTGV0IHRoZSBmdXJ0aGVzdCBibG9jayBiZSB0aGUgdG9wbW9zdCBub2RlIGluIHRoZSBzdGFjayBvZlxyXG4gICAgICAvLyBvcGVuIGVsZW1lbnRzIHRoYXQgaXMgbG93ZXIgaW4gdGhlIHN0YWNrIHRoYW4gdGhlIGZvcm1hdHRpbmdcclxuICAgICAgLy8gZWxlbWVudCwgYW5kIGlzIGFuIGVsZW1lbnQgaW4gdGhlIHNwZWNpYWwgY2F0ZWdvcnkuIFRoZXJlXHJcbiAgICAgIC8vIG1pZ2h0IG5vdCBiZSBvbmUuXHJcbiAgICAgIHZhciBmdXJ0aGVzdGJsb2NrID0gbnVsbCwgZnVydGhlc3RibG9ja2luZGV4O1xyXG4gICAgICBmb3IodmFyIGkgPSBpbmRleCsxOyBpIDwgc3RhY2suZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoaXNBKHN0YWNrLmVsZW1lbnRzW2ldLCBzcGVjaWFsU2V0KSkge1xyXG4gICAgICAgICAgZnVydGhlc3RibG9jayA9IHN0YWNrLmVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgZnVydGhlc3RibG9ja2luZGV4ID0gaTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZnVydGhlc3QgYmxvY2ssIHRoZW4gdGhlIFVBIG11c3Qgc2tpcCB0aGVcclxuICAgICAgLy8gc3Vic2VxdWVudCBzdGVwcyBhbmQgaW5zdGVhZCBqdXN0IHBvcCBhbGwgdGhlIG5vZGVzIGZyb20gdGhlXHJcbiAgICAgIC8vIGJvdHRvbSBvZiB0aGUgc3RhY2sgb2Ygb3BlbiBlbGVtZW50cywgZnJvbSB0aGUgY3VycmVudCBub2RlXHJcbiAgICAgIC8vIHVwIHRvIGFuZCBpbmNsdWRpbmcgdGhlIGZvcm1hdHRpbmcgZWxlbWVudCwgYW5kIHJlbW92ZSB0aGVcclxuICAgICAgLy8gZm9ybWF0dGluZyBlbGVtZW50IGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIGZvcm1hdHRpbmdcclxuICAgICAgLy8gZWxlbWVudHMuXHJcbiAgICAgIGlmICghZnVydGhlc3RibG9jaykge1xyXG4gICAgICAgIHN0YWNrLnBvcEVsZW1lbnQoZm10ZWx0KTtcclxuICAgICAgICBhZmUucmVtb3ZlKGZtdGVsdCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgLy8gTGV0IHRoZSBjb21tb24gYW5jZXN0b3IgYmUgdGhlIGVsZW1lbnQgaW1tZWRpYXRlbHkgYWJvdmVcclxuICAgICAgICAvLyB0aGUgZm9ybWF0dGluZyBlbGVtZW50IGluIHRoZSBzdGFjayBvZiBvcGVuIGVsZW1lbnRzLlxyXG4gICAgICAgIHZhciBhbmNlc3RvciA9IHN0YWNrLmVsZW1lbnRzW2luZGV4LTFdO1xyXG5cclxuICAgICAgICAvLyBMZXQgYSBib29rbWFyayBub3RlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZm9ybWF0dGluZ1xyXG4gICAgICAgIC8vIGVsZW1lbnQgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGZvcm1hdHRpbmcgZWxlbWVudHNcclxuICAgICAgICAvLyByZWxhdGl2ZSB0byB0aGUgZWxlbWVudHMgb24gZWl0aGVyIHNpZGUgb2YgaXQgaW4gdGhlXHJcbiAgICAgICAgLy8gbGlzdC5cclxuICAgICAgICBhZmUuaW5zZXJ0QWZ0ZXIoZm10ZWx0LCBCT09LTUFSSyk7XHJcblxyXG4gICAgICAgIC8vIExldCBub2RlIGFuZCBsYXN0IG5vZGUgYmUgdGhlIGZ1cnRoZXN0IGJsb2NrLlxyXG4gICAgICAgIHZhciBub2RlID0gZnVydGhlc3RibG9jaztcclxuICAgICAgICB2YXIgbGFzdG5vZGUgPSBmdXJ0aGVzdGJsb2NrO1xyXG4gICAgICAgIHZhciBub2RlaW5kZXggPSBmdXJ0aGVzdGJsb2NraW5kZXg7XHJcbiAgICAgICAgdmFyIG5vZGVhZmVpbmRleDtcclxuXHJcbiAgICAgICAgLy8gTGV0IGlubmVyIGxvb3AgY291bnRlciBiZSB6ZXJvLlxyXG4gICAgICAgIHZhciBpbm5lciA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW5jcmVtZW50IGlubmVyIGxvb3AgY291bnRlciBieSBvbmUuXHJcbiAgICAgICAgICBpbm5lcisrO1xyXG5cclxuICAgICAgICAgIC8vIExldCBub2RlIGJlIHRoZSBlbGVtZW50IGltbWVkaWF0ZWx5IGFib3ZlIG5vZGUgaW5cclxuICAgICAgICAgIC8vIHRoZSBzdGFjayBvZiBvcGVuIGVsZW1lbnRzLCBvciBpZiBub2RlIGlzIG5vIGxvbmdlclxyXG4gICAgICAgICAgLy8gaW4gdGhlIHN0YWNrIG9mIG9wZW4gZWxlbWVudHMgKGUuZy4gYmVjYXVzZSBpdCBnb3RcclxuICAgICAgICAgIC8vIHJlbW92ZWQgYnkgdGhpcyBhbGdvcml0aG0pLCB0aGUgZWxlbWVudCB0aGF0IHdhc1xyXG4gICAgICAgICAgLy8gaW1tZWRpYXRlbHkgYWJvdmUgbm9kZSBpbiB0aGUgc3RhY2sgb2Ygb3BlbiBlbGVtZW50c1xyXG4gICAgICAgICAgLy8gYmVmb3JlIG5vZGUgd2FzIHJlbW92ZWQuXHJcbiAgICAgICAgICBub2RlID0gc3RhY2suZWxlbWVudHNbLS1ub2RlaW5kZXhdO1xyXG5cclxuICAgICAgICAgIC8vIElmIG5vZGUgaXMgdGhlIGZvcm1hdHRpbmcgZWxlbWVudCwgdGhlbiBnb1xyXG4gICAgICAgICAgLy8gdG8gdGhlIG5leHQgc3RlcCBpbiB0aGUgb3ZlcmFsbCBhbGdvcml0aG0uXHJcbiAgICAgICAgICBpZiAobm9kZSA9PT0gZm10ZWx0KSBicmVhaztcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgaW5uZXIgbG9vcCBjb3VudGVyIGlzIGdyZWF0ZXIgdGhhbiB0aHJlZSBhbmQgbm9kZVxyXG4gICAgICAgICAgLy8gaXMgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGZvcm1hdHRpbmcgZWxlbWVudHMsIHRoZW4gcmVtb3ZlXHJcbiAgICAgICAgICAvLyBub2RlIGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIGZvcm1hdHRpbmcgZWxlbWVudHMuXHJcbiAgICAgICAgICBub2RlYWZlaW5kZXggPSBhZmUuaW5kZXhPZihub2RlKTtcclxuICAgICAgICAgIGlmIChpbm5lciA+IDMgJiYgbm9kZWFmZWluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICBhZmUucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICBub2RlYWZlaW5kZXggPSAtMTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBJZiBub2RlIGlzIG5vdCBpbiB0aGUgbGlzdCBvZiBhY3RpdmUgZm9ybWF0dGluZ1xyXG4gICAgICAgICAgLy8gZWxlbWVudHMsIHRoZW4gcmVtb3ZlIG5vZGUgZnJvbSB0aGUgc3RhY2sgb2Ygb3BlblxyXG4gICAgICAgICAgLy8gZWxlbWVudHMgYW5kIHRoZW4gZ28gYmFjayB0byB0aGUgc3RlcCBsYWJlbGVkIGlubmVyXHJcbiAgICAgICAgICAvLyBsb29wLlxyXG4gICAgICAgICAgaWYgKG5vZGVhZmVpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgc3RhY2sucmVtb3ZlRWxlbWVudChub2RlKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ3JlYXRlIGFuIGVsZW1lbnQgZm9yIHRoZSB0b2tlbiBmb3Igd2hpY2ggdGhlXHJcbiAgICAgICAgICAvLyBlbGVtZW50IG5vZGUgd2FzIGNyZWF0ZWQgd2l0aCBjb21tb24gYW5jZXN0b3IgYXNcclxuICAgICAgICAgIC8vIHRoZSBpbnRlbmRlZCBwYXJlbnQsIHJlcGxhY2UgdGhlIGVudHJ5IGZvciBub2RlXHJcbiAgICAgICAgICAvLyBpbiB0aGUgbGlzdCBvZiBhY3RpdmUgZm9ybWF0dGluZyBlbGVtZW50cyB3aXRoIGFuXHJcbiAgICAgICAgICAvLyBlbnRyeSBmb3IgdGhlIG5ldyBlbGVtZW50LCByZXBsYWNlIHRoZSBlbnRyeSBmb3JcclxuICAgICAgICAgIC8vIG5vZGUgaW4gdGhlIHN0YWNrIG9mIG9wZW4gZWxlbWVudHMgd2l0aCBhbiBlbnRyeSBmb3JcclxuICAgICAgICAgIC8vIHRoZSBuZXcgZWxlbWVudCwgYW5kIGxldCBub2RlIGJlIHRoZSBuZXcgZWxlbWVudC5cclxuICAgICAgICAgIHZhciBuZXdlbHQgPSBhZmVjbG9uZShhbmNlc3Rvci5vd25lckRvY3VtZW50LCBub2RlYWZlaW5kZXgpO1xyXG4gICAgICAgICAgYWZlLnJlcGxhY2Uobm9kZSwgbmV3ZWx0LmVsdCwgbmV3ZWx0LmF0dHJzKTtcclxuICAgICAgICAgIHN0YWNrLmVsZW1lbnRzW25vZGVpbmRleF0gPSBuZXdlbHQuZWx0O1xyXG4gICAgICAgICAgbm9kZSA9IG5ld2VsdC5lbHQ7XHJcblxyXG4gICAgICAgICAgLy8gSWYgbGFzdCBub2RlIGlzIHRoZSBmdXJ0aGVzdCBibG9jaywgdGhlbiBtb3ZlIHRoZVxyXG4gICAgICAgICAgLy8gYWZvcmVtZW50aW9uZWQgYm9va21hcmsgdG8gYmUgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlXHJcbiAgICAgICAgICAvLyBuZXcgbm9kZSBpbiB0aGUgbGlzdCBvZiBhY3RpdmUgZm9ybWF0dGluZyBlbGVtZW50cy5cclxuICAgICAgICAgIGlmIChsYXN0bm9kZSA9PT0gZnVydGhlc3RibG9jaykge1xyXG4gICAgICAgICAgICBhZmUucmVtb3ZlKEJPT0tNQVJLKTtcclxuICAgICAgICAgICAgYWZlLmluc2VydEFmdGVyKG5ld2VsdC5lbHQsIEJPT0tNQVJLKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBJbnNlcnQgbGFzdCBub2RlIGludG8gbm9kZSwgZmlyc3QgcmVtb3ZpbmcgaXQgZnJvbVxyXG4gICAgICAgICAgLy8gaXRzIHByZXZpb3VzIHBhcmVudCBub2RlIGlmIGFueS5cclxuICAgICAgICAgIG5vZGUuX2FwcGVuZENoaWxkKGxhc3Rub2RlKTtcclxuXHJcbiAgICAgICAgICAvLyBMZXQgbGFzdCBub2RlIGJlIG5vZGUuXHJcbiAgICAgICAgICBsYXN0bm9kZSA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB0aGUgY29tbW9uIGFuY2VzdG9yIG5vZGUgaXMgYSB0YWJsZSwgdGJvZHksIHRmb290LFxyXG4gICAgICAgIC8vIHRoZWFkLCBvciB0ciBlbGVtZW50LCB0aGVuLCBmb3N0ZXIgcGFyZW50IHdoYXRldmVyIGxhc3RcclxuICAgICAgICAvLyBub2RlIGVuZGVkIHVwIGJlaW5nIGluIHRoZSBwcmV2aW91cyBzdGVwLCBmaXJzdCByZW1vdmluZ1xyXG4gICAgICAgIC8vIGl0IGZyb20gaXRzIHByZXZpb3VzIHBhcmVudCBub2RlIGlmIGFueS5cclxuICAgICAgICBpZiAoZm9zdGVyX3BhcmVudF9tb2RlICYmIGlzQShhbmNlc3RvciwgdGFibGVzZWN0aW9ucm93U2V0KSkge1xyXG4gICAgICAgICAgZm9zdGVyUGFyZW50KGZ1bmN0aW9uKCkgeyByZXR1cm4gbGFzdG5vZGU7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPdGhlcndpc2UsIGFwcGVuZCB3aGF0ZXZlciBsYXN0IG5vZGUgZW5kZWQgdXAgYmVpbmcgaW5cclxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgc3RlcCB0byB0aGUgY29tbW9uIGFuY2VzdG9yIG5vZGUsIGZpcnN0XHJcbiAgICAgICAgLy8gcmVtb3ZpbmcgaXQgZnJvbSBpdHMgcHJldmlvdXMgcGFyZW50IG5vZGUgaWYgYW55LlxyXG4gICAgICAgIGVsc2UgaWYgKGFuY2VzdG9yIGluc3RhbmNlb2YgaW1wbC5IVE1MVGVtcGxhdGVFbGVtZW50KSB7XHJcbiAgICAgICAgICBhbmNlc3Rvci5jb250ZW50Ll9hcHBlbmRDaGlsZChsYXN0bm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFuY2VzdG9yLl9hcHBlbmRDaGlsZChsYXN0bm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYW4gZWxlbWVudCBmb3IgdGhlIHRva2VuIGZvciB3aGljaCB0aGVcclxuICAgICAgICAvLyBmb3JtYXR0aW5nIGVsZW1lbnQgd2FzIGNyZWF0ZWQsIHdpdGggZnVydGhlc3QgYmxvY2tcclxuICAgICAgICAvLyBhcyB0aGUgaW50ZW5kZWQgcGFyZW50LlxyXG4gICAgICAgIHZhciBuZXdlbHQyID0gYWZlY2xvbmUoZnVydGhlc3RibG9jay5vd25lckRvY3VtZW50LCBhZmUuaW5kZXhPZihmbXRlbHQpKTtcclxuXHJcbiAgICAgICAgLy8gVGFrZSBhbGwgb2YgdGhlIGNoaWxkIG5vZGVzIG9mIHRoZSBmdXJ0aGVzdCBibG9jayBhbmRcclxuICAgICAgICAvLyBhcHBlbmQgdGhlbSB0byB0aGUgZWxlbWVudCBjcmVhdGVkIGluIHRoZSBsYXN0IHN0ZXAuXHJcbiAgICAgICAgd2hpbGUoZnVydGhlc3RibG9jay5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICAgICAgICAgIG5ld2VsdDIuZWx0Ll9hcHBlbmRDaGlsZChmdXJ0aGVzdGJsb2NrLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIHRoYXQgbmV3IGVsZW1lbnQgdG8gdGhlIGZ1cnRoZXN0IGJsb2NrLlxyXG4gICAgICAgIGZ1cnRoZXN0YmxvY2suX2FwcGVuZENoaWxkKG5ld2VsdDIuZWx0KTtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBmb3JtYXR0aW5nIGVsZW1lbnQgZnJvbSB0aGUgbGlzdCBvZiBhY3RpdmVcclxuICAgICAgICAvLyBmb3JtYXR0aW5nIGVsZW1lbnRzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgZWxlbWVudCBpbnRvIHRoZVxyXG4gICAgICAgIC8vIGxpc3Qgb2YgYWN0aXZlIGZvcm1hdHRpbmcgZWxlbWVudHMgYXQgdGhlIHBvc2l0aW9uIG9mXHJcbiAgICAgICAgLy8gdGhlIGFmb3JlbWVudGlvbmVkIGJvb2ttYXJrLlxyXG4gICAgICAgIGFmZS5yZW1vdmUoZm10ZWx0KTtcclxuICAgICAgICBhZmUucmVwbGFjZShCT09LTUFSSywgbmV3ZWx0Mi5lbHQsIG5ld2VsdDIuYXR0cnMpO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIGZvcm1hdHRpbmcgZWxlbWVudCBmcm9tIHRoZSBzdGFjayBvZiBvcGVuXHJcbiAgICAgICAgLy8gZWxlbWVudHMsIGFuZCBpbnNlcnQgdGhlIG5ldyBlbGVtZW50IGludG8gdGhlIHN0YWNrIG9mXHJcbiAgICAgICAgLy8gb3BlbiBlbGVtZW50cyBpbW1lZGlhdGVseSBiZWxvdyB0aGUgcG9zaXRpb24gb2YgdGhlXHJcbiAgICAgICAgLy8gZnVydGhlc3QgYmxvY2sgaW4gdGhhdCBzdGFjay5cclxuICAgICAgICBzdGFjay5yZW1vdmVFbGVtZW50KGZtdGVsdCk7XHJcbiAgICAgICAgdmFyIHBvcyA9IHN0YWNrLmVsZW1lbnRzLmxhc3RJbmRleE9mKGZ1cnRoZXN0YmxvY2spO1xyXG4gICAgICAgIHN0YWNrLmVsZW1lbnRzLnNwbGljZShwb3MrMSwgMCwgbmV3ZWx0Mi5lbHQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBXZSBkbyB0aGlzIHdoZW4gd2UgZ2V0IC9zY3JpcHQgaW4gaW5fdGV4dF9tb2RlXHJcbiAgZnVuY3Rpb24gaGFuZGxlU2NyaXB0RW5kKCkge1xyXG4gICAgLy8gWFhYOlxyXG4gICAgLy8gVGhpcyBpcyBqdXN0IGEgc3R1YiBpbXBsZW1lbnRhdGlvbiByaWdodCBub3cgYW5kIGRvZXNuJ3QgcnVuIHNjcmlwdHMuXHJcbiAgICAvLyBHZXR0aW5nIHRoaXMgbWV0aG9kIHJpZ2h0IGludm9sdmVzIHRoZSBldmVudCBsb29wLCBVUkwgcmVzb2x1dGlvblxyXG4gICAgLy8gc2NyaXB0IGZldGNoaW5nIGV0Yy4gRm9yIG5vdyBJIGp1c3Qgd2FudCB0byBiZSBhYmxlIHRvIHBhcnNlXHJcbiAgICAvLyBkb2N1bWVudHMgYW5kIHRlc3QgdGhlIHBhcnNlci5cclxuXHJcbiAgICAvL3ZhciBzY3JpcHQgPSBzdGFjay50b3A7XHJcbiAgICBzdGFjay5wb3AoKTtcclxuICAgIHBhcnNlciA9IG9yaWdpbmFsSW5zZXJ0aW9uTW9kZTtcclxuICAgIC8vc2NyaXB0Ll9wcmVwYXJlKCk7XHJcbiAgICByZXR1cm47XHJcblxyXG4gICAgLy8gWFhYOiBoZXJlIGlzIHdoYXQgdGhpcyBtZXRob2QgaXMgc3VwcG9zZWQgdG8gZG9cclxuXHJcbiAgICAvLyBQcm92aWRlIGEgc3RhYmxlIHN0YXRlLlxyXG5cclxuICAgIC8vIExldCBzY3JpcHQgYmUgdGhlIGN1cnJlbnQgbm9kZSAod2hpY2ggd2lsbCBiZSBhIHNjcmlwdFxyXG4gICAgLy8gZWxlbWVudCkuXHJcblxyXG4gICAgLy8gUG9wIHRoZSBjdXJyZW50IG5vZGUgb2ZmIHRoZSBzdGFjayBvZiBvcGVuIGVsZW1lbnRzLlxyXG5cclxuICAgIC8vIFN3aXRjaCB0aGUgaW5zZXJ0aW9uIG1vZGUgdG8gdGhlIG9yaWdpbmFsIGluc2VydGlvbiBtb2RlLlxyXG5cclxuICAgIC8vIExldCB0aGUgb2xkIGluc2VydGlvbiBwb2ludCBoYXZlIHRoZSBzYW1lIHZhbHVlIGFzIHRoZSBjdXJyZW50XHJcbiAgICAvLyBpbnNlcnRpb24gcG9pbnQuIExldCB0aGUgaW5zZXJ0aW9uIHBvaW50IGJlIGp1c3QgYmVmb3JlIHRoZVxyXG4gICAgLy8gbmV4dCBpbnB1dCBjaGFyYWN0ZXIuXHJcblxyXG4gICAgLy8gSW5jcmVtZW50IHRoZSBwYXJzZXIncyBzY3JpcHQgbmVzdGluZyBsZXZlbCBieSBvbmUuXHJcblxyXG4gICAgLy8gUHJlcGFyZSB0aGUgc2NyaXB0LiBUaGlzIG1pZ2h0IGNhdXNlIHNvbWUgc2NyaXB0IHRvIGV4ZWN1dGUsXHJcbiAgICAvLyB3aGljaCBtaWdodCBjYXVzZSBuZXcgY2hhcmFjdGVycyB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZVxyXG4gICAgLy8gdG9rZW5pemVyLCBhbmQgbWlnaHQgY2F1c2UgdGhlIHRva2VuaXplciB0byBvdXRwdXQgbW9yZSB0b2tlbnMsXHJcbiAgICAvLyByZXN1bHRpbmcgaW4gYSByZWVudHJhbnQgaW52b2NhdGlvbiBvZiB0aGUgcGFyc2VyLlxyXG5cclxuICAgIC8vIERlY3JlbWVudCB0aGUgcGFyc2VyJ3Mgc2NyaXB0IG5lc3RpbmcgbGV2ZWwgYnkgb25lLiBJZiB0aGVcclxuICAgIC8vIHBhcnNlcidzIHNjcmlwdCBuZXN0aW5nIGxldmVsIGlzIHplcm8sIHRoZW4gc2V0IHRoZSBwYXJzZXJcclxuICAgIC8vIHBhdXNlIGZsYWcgdG8gZmFsc2UuXHJcblxyXG4gICAgLy8gTGV0IHRoZSBpbnNlcnRpb24gcG9pbnQgaGF2ZSB0aGUgdmFsdWUgb2YgdGhlIG9sZCBpbnNlcnRpb25cclxuICAgIC8vIHBvaW50LiAoSW4gb3RoZXIgd29yZHMsIHJlc3RvcmUgdGhlIGluc2VydGlvbiBwb2ludCB0byBpdHNcclxuICAgIC8vIHByZXZpb3VzIHZhbHVlLiBUaGlzIHZhbHVlIG1pZ2h0IGJlIHRoZSBcInVuZGVmaW5lZFwiIHZhbHVlLilcclxuXHJcbiAgICAvLyBBdCB0aGlzIHN0YWdlLCBpZiB0aGVyZSBpcyBhIHBlbmRpbmcgcGFyc2luZy1ibG9ja2luZyBzY3JpcHQsXHJcbiAgICAvLyB0aGVuOlxyXG5cclxuICAgIC8vIElmIHRoZSBzY3JpcHQgbmVzdGluZyBsZXZlbCBpcyBub3QgemVybzpcclxuXHJcbiAgICAvLyAgIFNldCB0aGUgcGFyc2VyIHBhdXNlIGZsYWcgdG8gdHJ1ZSwgYW5kIGFib3J0IHRoZSBwcm9jZXNzaW5nXHJcbiAgICAvLyAgIG9mIGFueSBuZXN0ZWQgaW52b2NhdGlvbnMgb2YgdGhlIHRva2VuaXplciwgeWllbGRpbmdcclxuICAgIC8vICAgY29udHJvbCBiYWNrIHRvIHRoZSBjYWxsZXIuIChUb2tlbml6YXRpb24gd2lsbCByZXN1bWUgd2hlblxyXG4gICAgLy8gICB0aGUgY2FsbGVyIHJldHVybnMgdG8gdGhlIFwib3V0ZXJcIiB0cmVlIGNvbnN0cnVjdGlvbiBzdGFnZS4pXHJcblxyXG4gICAgLy8gICBUaGUgdHJlZSBjb25zdHJ1Y3Rpb24gc3RhZ2Ugb2YgdGhpcyBwYXJ0aWN1bGFyIHBhcnNlciBpc1xyXG4gICAgLy8gICBiZWluZyBjYWxsZWQgcmVlbnRyYW50bHksIHNheSBmcm9tIGEgY2FsbCB0b1xyXG4gICAgLy8gICBkb2N1bWVudC53cml0ZSgpLlxyXG5cclxuICAgIC8vIE90aGVyd2lzZTpcclxuXHJcbiAgICAvLyAgICAgUnVuIHRoZXNlIHN0ZXBzOlxyXG5cclxuICAgIC8vICAgICAgIExldCB0aGUgc2NyaXB0IGJlIHRoZSBwZW5kaW5nIHBhcnNpbmctYmxvY2tpbmdcclxuICAgIC8vICAgICAgIHNjcmlwdC4gVGhlcmUgaXMgbm8gbG9uZ2VyIGEgcGVuZGluZ1xyXG4gICAgLy8gICAgICAgcGFyc2luZy1ibG9ja2luZyBzY3JpcHQuXHJcblxyXG4gICAgLy8gICAgICAgQmxvY2sgdGhlIHRva2VuaXplciBmb3IgdGhpcyBpbnN0YW5jZSBvZiB0aGUgSFRNTFxyXG4gICAgLy8gICAgICAgcGFyc2VyLCBzdWNoIHRoYXQgdGhlIGV2ZW50IGxvb3Agd2lsbCBub3QgcnVuIHRhc2tzXHJcbiAgICAvLyAgICAgICB0aGF0IGludm9rZSB0aGUgdG9rZW5pemVyLlxyXG5cclxuICAgIC8vICAgICAgIElmIHRoZSBwYXJzZXIncyBEb2N1bWVudCBoYXMgYSBzdHlsZSBzaGVldCB0aGF0IGlzXHJcbiAgICAvLyAgICAgICBibG9ja2luZyBzY3JpcHRzIG9yIHRoZSBzY3JpcHQncyBcInJlYWR5IHRvIGJlXHJcbiAgICAvLyAgICAgICBwYXJzZXItZXhlY3V0ZWRcIiBmbGFnIGlzIG5vdCBzZXQ6IHNwaW4gdGhlIGV2ZW50XHJcbiAgICAvLyAgICAgICBsb29wIHVudGlsIHRoZSBwYXJzZXIncyBEb2N1bWVudCBoYXMgbm8gc3R5bGUgc2hlZXRcclxuICAgIC8vICAgICAgIHRoYXQgaXMgYmxvY2tpbmcgc2NyaXB0cyBhbmQgdGhlIHNjcmlwdCdzIFwicmVhZHkgdG9cclxuICAgIC8vICAgICAgIGJlIHBhcnNlci1leGVjdXRlZFwiIGZsYWcgaXMgc2V0LlxyXG5cclxuICAgIC8vICAgICAgIFVuYmxvY2sgdGhlIHRva2VuaXplciBmb3IgdGhpcyBpbnN0YW5jZSBvZiB0aGUgSFRNTFxyXG4gICAgLy8gICAgICAgcGFyc2VyLCBzdWNoIHRoYXQgdGFza3MgdGhhdCBpbnZva2UgdGhlIHRva2VuaXplclxyXG4gICAgLy8gICAgICAgY2FuIGFnYWluIGJlIHJ1bi5cclxuXHJcbiAgICAvLyAgICAgICBMZXQgdGhlIGluc2VydGlvbiBwb2ludCBiZSBqdXN0IGJlZm9yZSB0aGUgbmV4dFxyXG4gICAgLy8gICAgICAgaW5wdXQgY2hhcmFjdGVyLlxyXG5cclxuICAgIC8vICAgICAgIEluY3JlbWVudCB0aGUgcGFyc2VyJ3Mgc2NyaXB0IG5lc3RpbmcgbGV2ZWwgYnkgb25lXHJcbiAgICAvLyAgICAgICAoaXQgc2hvdWxkIGJlIHplcm8gYmVmb3JlIHRoaXMgc3RlcCwgc28gdGhpcyBzZXRzXHJcbiAgICAvLyAgICAgICBpdCB0byBvbmUpLlxyXG5cclxuICAgIC8vICAgICAgIEV4ZWN1dGUgdGhlIHNjcmlwdC5cclxuXHJcbiAgICAvLyAgICAgICBEZWNyZW1lbnQgdGhlIHBhcnNlcidzIHNjcmlwdCBuZXN0aW5nIGxldmVsIGJ5XHJcbiAgICAvLyAgICAgICBvbmUuIElmIHRoZSBwYXJzZXIncyBzY3JpcHQgbmVzdGluZyBsZXZlbCBpcyB6ZXJvXHJcbiAgICAvLyAgICAgICAod2hpY2ggaXQgYWx3YXlzIHNob3VsZCBiZSBhdCB0aGlzIHBvaW50KSwgdGhlbiBzZXRcclxuICAgIC8vICAgICAgIHRoZSBwYXJzZXIgcGF1c2UgZmxhZyB0byBmYWxzZS5cclxuXHJcbiAgICAvLyAgICAgICBMZXQgdGhlIGluc2VydGlvbiBwb2ludCBiZSB1bmRlZmluZWQgYWdhaW4uXHJcblxyXG4gICAgLy8gICAgICAgSWYgdGhlcmUgaXMgb25jZSBhZ2FpbiBhIHBlbmRpbmcgcGFyc2luZy1ibG9ja2luZ1xyXG4gICAgLy8gICAgICAgc2NyaXB0LCB0aGVuIHJlcGVhdCB0aGVzZSBzdGVwcyBmcm9tIHN0ZXAgMS5cclxuXHJcblxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3RvcFBhcnNpbmcoKSB7XHJcbiAgICAvLyBYWFggVGhpcyBpcyBqdXN0IGEgdGVtcG9yYXJ5IGltcGxlbWVudGF0aW9uIHRvIGdldCB0aGUgcGFyc2VyIHdvcmtpbmcuXHJcbiAgICAvLyBBIGZ1bGwgaW1wbGVtZW50YXRpb24gaW52b2x2ZXMgc2NyaXB0cyBhbmQgZXZlbnRzIGFuZCB0aGUgZXZlbnQgbG9vcC5cclxuXHJcbiAgICAvLyBSZW1vdmUgdGhlIGxpbmsgZnJvbSBkb2N1bWVudCB0byBwYXJzZXIuXHJcbiAgICAvLyBUaGlzIGlzIGluc3RlYWQgb2YgXCJzZXQgdGhlIGluc2VydGlvbiBwb2ludCB0byB1bmRlZmluZWRcIi5cclxuICAgIC8vIEl0IG1lYW5zIHRoYXQgZG9jdW1lbnQud3JpdGUoKSBjYW4ndCB3cml0ZSBpbnRvIHRoZSBkb2MgYW55bW9yZS5cclxuICAgIGRlbGV0ZSBkb2MuX3BhcnNlcjtcclxuXHJcbiAgICBzdGFjay5lbGVtZW50cy5sZW5ndGggPSAwOyAvLyBwb3AgZXZlcnl0aGluZyBvZmZcclxuXHJcbiAgICAvLyBJZiB0aGVyZSBpcyBhIHdpbmRvdyBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBkb2N1bWVudFxyXG4gICAgLy8gdGhlbiB0cmlnZ2VyIGFuIGxvYWQgZXZlbnQgb24gaXRcclxuICAgIGlmIChkb2MuZGVmYXVsdFZpZXcpIHtcclxuICAgICAgZG9jLmRlZmF1bHRWaWV3LmRpc3BhdGNoRXZlbnQobmV3IGltcGwuRXZlbnQoXCJsb2FkXCIse30pKTtcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICAvKioqKlxyXG4gICAqIFRva2VuaXplciBzdGF0ZXNcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBmaWxlIHdhcyBwYXJ0aWFsbHkgbWVjaGFuaWNhbGx5IGdlbmVyYXRlZCBmcm9tXHJcbiAgICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdG9rZW5pemF0aW9uLmh0bWxcclxuICAgKlxyXG4gICAqIEFmdGVyIG1lY2hhbmljYWwgY29udmVyc2lvbiwgaXQgd2FzIGZ1cnRoZXIgY29udmVydGVkIGZyb21cclxuICAgKiBwcm9zZSB0byBKUyBieSBoYW5kLCBidXQgdGhlIGludGVudCBpcyB0aGF0IGl0IGlzIGEgdmVyeVxyXG4gICAqIGZhaXRoZnVsIHJlbmRlcmluZyBvZiB0aGUgSFRNTCB0b2tlbml6YXRpb24gc3BlYyBpblxyXG4gICAqIEphdmFTY3JpcHQuXHJcbiAgICpcclxuICAgKiBJdCBpcyBub3QgYSBnb2FsIG9mIHRoaXMgdG9rZW5pemVyIHRvIGRldGVjdCBvciByZXBvcnRcclxuICAgKiBwYXJzZSBlcnJvcnMuXHJcbiAgICpcclxuICAgKiBYWFggVGhlIHRva2VuaXplciBpcyBzdXBwb3NlZCB0byB3b3JrIHdpdGggc3RyYWlnaHQgVVRGMzJcclxuICAgKiBjb2RlcG9pbnRzLiBCdXQgSSBkb24ndCB0aGluayBpdCBoYXMgYW55IGRlcGVuZGVuY2llcyBvblxyXG4gICAqIGFueSBjaGFyYWN0ZXIgb3V0c2lkZSBvZiB0aGUgQk1QIHNvIEkgdGhpbmsgaXQgaXMgc2FmZSB0b1xyXG4gICAqIHBhc3MgaXQgVVRGMTYgY2hhcmFjdGVycy4gSSBkb24ndCB0aGluayBpdCB3aWxsIGV2ZXIgY2hhbmdlXHJcbiAgICogc3RhdGUgaW4gdGhlIG1pZGRsZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxyXG4gICAqL1xyXG5cclxuICAvKlxyXG4gICAqIEVhY2ggc3RhdGUgaXMgcmVwcmVzZW50ZWQgYnkgYSBmdW5jdGlvbi4gIEZvciBtb3N0IHN0YXRlcywgdGhlXHJcbiAgICogc2Nhbm5lciBzaW1wbHkgcGFzc2VzIHRoZSBuZXh0IGNoYXJhY3RlciAoYXMgYW4gaW50ZWdlclxyXG4gICAqIGNvZGVwb2ludCkgdG8gdGhlIGN1cnJlbnQgc3RhdGUgZnVuY3Rpb24gYW5kIGF1dG9tYXRpY2FsbHlcclxuICAgKiBjb25zdW1lcyB0aGUgY2hhcmFjdGVyLiAgSWYgdGhlIHN0YXRlIGZ1bmN0aW9uIGNhbid0IHByb2Nlc3NcclxuICAgKiB0aGUgY2hhcmFjdGVyIGl0IGNhbiBjYWxsIHB1c2hiYWNrKCkgdG8gcHVzaCBpdCBiYWNrIHRvIHRoZVxyXG4gICAqIHNjYW5uZXIuXHJcbiAgICpcclxuICAgKiBTb21lIHN0YXRlcyByZXF1aXJlIGxvb2thaGVhZCwgdGhvdWdoLiAgSWYgYSBzdGF0ZSBmdW5jdGlvbiBoYXNcclxuICAgKiBhIGxvb2thaGVhZCBwcm9wZXJ0eSwgdGhlbiBpdCBpcyBpbnZva2VkIGRpZmZlcmVudGx5LiAgSW4gdGhpc1xyXG4gICAqIGNhc2UsIHRoZSBzY2FubmVyIGludm9rZXMgdGhlIGZ1bmN0aW9uIHdpdGggMyBhcmd1bWVudHM6IDEpIHRoZVxyXG4gICAqIG5leHQgY29kZXBvaW50IDIpIGEgc3RyaW5nIG9mIGxvb2thaGVhZCB0ZXh0IDMpIGEgYm9vbGVhbiB0aGF0XHJcbiAgICogaXMgdHJ1ZSBpZiB0aGUgbG9va2FoZWFkIGdvZXMgYWxsIHRoZSB3YXkgdG8gdGhlIEVPRi4gKFhYWFxyXG4gICAqIGFjdHVhbGx5IG1heWJlIHRoaXMgdGhpcmQgaXMgbm90IG5lY2Vzc2FyeS4uLiB0aGUgbG9va2FoZWFkXHJcbiAgICogY291bGQganVzdCBpbmNsdWRlIFxcdUZGRkY/KVxyXG4gICAqXHJcbiAgICogSWYgdGhlIGxvb2thaGVhZCBwcm9wZXJ0eSBvZiBhIHN0YXRlIGZ1bmN0aW9uIGlzIGFuIGludGVnZXIsIGl0XHJcbiAgICogc3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyByZXF1aXJlZC4gSWYgaXQgaXMgYSBzdHJpbmcsXHJcbiAgICogdGhlbiB0aGUgc2Nhbm5lciB3aWxsIHNjYW4gZm9yIHRoYXQgc3RyaW5nIGFuZCByZXR1cm4gYWxsXHJcbiAgICogY2hhcmFjdGVycyB1cCB0byBhbmQgaW5jbHVkaW5nIHRoYXQgc2VxdWVuY2UsIG9yIHVwIHRvIEVPRi4gIElmXHJcbiAgICogdGhlIGxvb2thaGVhZCBwcm9wZXJ0eSBpcyBhIHJlZ2V4cCwgdGhlbiB0aGUgc2Nhbm5lciB3aWxsIG1hdGNoXHJcbiAgICogdGhlIHJlZ2V4cCBhdCB0aGUgY3VycmVudCBwb2ludCBhbmQgcmV0dXJuIHRoZSBtYXRjaGluZyBzdHJpbmcuXHJcbiAgICpcclxuICAgKiBTdGF0ZXMgdGhhdCByZXF1aXJlIGxvb2thaGVhZCBhcmUgcmVzcG9uc2libGUgZm9yIGV4cGxpY2l0bHlcclxuICAgKiBjb25zdW1pbmcgdGhlIGNoYXJhY3RlcnMgdGhleSBwcm9jZXNzLiBUaGV5IGRvIHRoaXMgYnlcclxuICAgKiBpbmNyZW1lbnRpbmcgbmV4dGNoYXIgYnkgdGhlIG51bWJlciBvZiBwcm9jZXNzZWQgY2hhcmFjdGVycy5cclxuICAgKi9cclxuICBmdW5jdGlvbiByZWNvbnN1bWUoYywgbmV3X3N0YXRlKSB7XHJcbiAgICB0b2tlbml6ZXIgPSBuZXdfc3RhdGU7XHJcbiAgICBuZXh0Y2hhci0tOyAvLyBwdXNoYmFja1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGF0YV9zdGF0ZShjKSB7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwMjY6IC8vIEFNUEVSU0FORFxyXG4gICAgICByZXR1cm5fc3RhdGUgPSBkYXRhX3N0YXRlO1xyXG4gICAgICB0b2tlbml6ZXIgPSBjaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDNDOiAvLyBMRVNTLVRIQU4gU0lHTlxyXG4gICAgICBpZiAoZW1pdFNpbXBsZVRhZygpKSAvLyBTaG9ydGN1dCBmb3IgPHA+LCA8ZGw+LCA8L2Rpdj4gZXRjLlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB0b2tlbml6ZXIgPSB0YWdfb3Blbl9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxyXG4gICAgICAvLyBVc3VhbGx5IG51bGwgY2hhcmFjdGVycyBlbWl0dGVkIGJ5IHRoZSB0b2tlbml6ZXIgd2lsbCBiZVxyXG4gICAgICAvLyBpZ25vcmVkIGJ5IHRoZSB0cmVlIGJ1aWxkZXIsIGJ1dCBzb21ldGltZXMgdGhleSdsbCBiZVxyXG4gICAgICAvLyBjb252ZXJ0ZWQgdG8gXFx1RkZGRC4gIEkgZG9uJ3Qgd2FudCB0byBoYXZlIHRoZSBzZWFyY2ggZXZlcnlcclxuICAgICAgLy8gc3RyaW5nIGVtaXR0ZWQgdG8gcmVwbGFjZSBOVUxzLCBzbyBJJ2xsIHNldCBhIGZsYWdcclxuICAgICAgLy8gaWYgSSd2ZSBlbWl0dGVkIGEgTlVMLlxyXG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XHJcbiAgICAgIHRleHRJbmNsdWRlc05VTCA9IHRydWU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAtMTogLy8gRU9GXHJcbiAgICAgIGVtaXRFT0YoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICAvLyBJbnN0ZWFkIG9mIGp1c3QgcHVzaGluZyBhIHNpbmdsZSBjaGFyYWN0ZXIgYW5kIHRoZW5cclxuICAgICAgLy8gY29taW5nIGJhY2sgdG8gdGhlIHZlcnkgc2FtZSBwbGFjZSwgbG9va2FoZWFkIGFuZFxyXG4gICAgICAvLyBlbWl0IGV2ZXJ5dGhpbmcgd2UgY2FuIGF0IG9uY2UuXHJcbiAgICAgIC8qanNoaW50IC1XMDMwICovXHJcbiAgICAgIGVtaXRDaGFyc1doaWxlKERBVEFURVhUKSB8fCB0ZXh0cnVuLnB1c2goYyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmNkYXRhX3N0YXRlKGMpIHtcclxuICAgIC8vIFNhdmUgdGhlIG9wZW4gdGFnIHNvIHdlIGNhbiBmaW5kIGEgbWF0Y2hpbmcgY2xvc2UgdGFnXHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwMjY6IC8vIEFNUEVSU0FORFxyXG4gICAgICByZXR1cm5fc3RhdGUgPSByY2RhdGFfc3RhdGU7XHJcbiAgICAgIHRva2VuaXplciA9IGNoYXJhY3Rlcl9yZWZlcmVuY2Vfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXHJcbiAgICAgIHRva2VuaXplciA9IHJjZGF0YV9sZXNzX3RoYW5fc2lnbl9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxyXG4gICAgICB0ZXh0cnVuLnB1c2goMHhGRkZEKTsgLy8gUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXHJcbiAgICAgIHRleHRJbmNsdWRlc05VTCA9IHRydWU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAtMTogLy8gRU9GXHJcbiAgICAgIGVtaXRFT0YoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmF3dGV4dF9zdGF0ZShjKSB7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXHJcbiAgICAgIHRva2VuaXplciA9IHJhd3RleHRfbGVzc190aGFuX3NpZ25fc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcclxuICAgICAgdGV4dHJ1bi5wdXNoKDB4RkZGRCk7IC8vIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBlbWl0RU9GKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgLypqc2hpbnQgLVcwMzAgKi9cclxuICAgICAgZW1pdENoYXJzV2hpbGUoUkFXVEVYVCkgfHwgdGV4dHJ1bi5wdXNoKGMpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNjcmlwdF9kYXRhX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAzQzogLy8gTEVTUy1USEFOIFNJR05cclxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfbGVzc190aGFuX3NpZ25fc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcclxuICAgICAgdGV4dHJ1bi5wdXNoKDB4RkZGRCk7IC8vIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBlbWl0RU9GKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgLypqc2hpbnQgLVcwMzAgKi9cclxuICAgICAgZW1pdENoYXJzV2hpbGUoUkFXVEVYVCkgfHwgdGV4dHJ1bi5wdXNoKGMpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBsYWludGV4dF9zdGF0ZShjKSB7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcclxuICAgICAgdGV4dHJ1bi5wdXNoKDB4RkZGRCk7IC8vIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBlbWl0RU9GKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgLypqc2hpbnQgLVcwMzAgKi9cclxuICAgICAgZW1pdENoYXJzV2hpbGUoUExBSU5URVhUKSB8fCB0ZXh0cnVuLnB1c2goYyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdGFnX29wZW5fc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDIxOiAvLyBFWENMQU1BVElPTiBNQVJLXHJcbiAgICAgIHRva2VuaXplciA9IG1hcmt1cF9kZWNsYXJhdGlvbl9vcGVuX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDJGOiAvLyBTT0xJRFVTXHJcbiAgICAgIHRva2VuaXplciA9IGVuZF90YWdfb3Blbl9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXHJcbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcclxuICAgIGNhc2UgMHgwMDQ3OmNhc2UgMHgwMDQ4OmNhc2UgMHgwMDQ5OmNhc2UgMHgwMDRBOmNhc2UgMHgwMDRCOlxyXG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XHJcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcclxuICAgIGNhc2UgMHgwMDU2OmNhc2UgMHgwMDU3OmNhc2UgMHgwMDU4OmNhc2UgMHgwMDU5OmNhc2UgMHgwMDVBOlxyXG4gICAgY2FzZSAweDAwNjE6ICAvLyBbYS16XVxyXG4gICAgY2FzZSAweDAwNjI6Y2FzZSAweDAwNjM6Y2FzZSAweDAwNjQ6Y2FzZSAweDAwNjU6Y2FzZSAweDAwNjY6XHJcbiAgICBjYXNlIDB4MDA2NzpjYXNlIDB4MDA2ODpjYXNlIDB4MDA2OTpjYXNlIDB4MDA2QTpjYXNlIDB4MDA2QjpcclxuICAgIGNhc2UgMHgwMDZDOmNhc2UgMHgwMDZEOmNhc2UgMHgwMDZFOmNhc2UgMHgwMDZGOmNhc2UgMHgwMDcwOlxyXG4gICAgY2FzZSAweDAwNzE6Y2FzZSAweDAwNzI6Y2FzZSAweDAwNzM6Y2FzZSAweDAwNzQ6Y2FzZSAweDAwNzU6XHJcbiAgICBjYXNlIDB4MDA3NjpjYXNlIDB4MDA3NzpjYXNlIDB4MDA3ODpjYXNlIDB4MDA3OTpjYXNlIDB4MDA3QTpcclxuICAgICAgYmVnaW5UYWdOYW1lKCk7XHJcbiAgICAgIHJlY29uc3VtZShjLCB0YWdfbmFtZV9zdGF0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwM0Y6IC8vIFFVRVNUSU9OIE1BUktcclxuICAgICAgcmVjb25zdW1lKGMsIGJvZ3VzX2NvbW1lbnRfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxyXG4gICAgICByZWNvbnN1bWUoYywgZGF0YV9zdGF0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZW5kX3RhZ19vcGVuX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXHJcbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcclxuICAgIGNhc2UgMHgwMDQ3OmNhc2UgMHgwMDQ4OmNhc2UgMHgwMDQ5OmNhc2UgMHgwMDRBOmNhc2UgMHgwMDRCOlxyXG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XHJcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcclxuICAgIGNhc2UgMHgwMDU2OmNhc2UgMHgwMDU3OmNhc2UgMHgwMDU4OmNhc2UgMHgwMDU5OmNhc2UgMHgwMDVBOlxyXG4gICAgY2FzZSAweDAwNjE6ICAvLyBbYS16XVxyXG4gICAgY2FzZSAweDAwNjI6Y2FzZSAweDAwNjM6Y2FzZSAweDAwNjQ6Y2FzZSAweDAwNjU6Y2FzZSAweDAwNjY6XHJcbiAgICBjYXNlIDB4MDA2NzpjYXNlIDB4MDA2ODpjYXNlIDB4MDA2OTpjYXNlIDB4MDA2QTpjYXNlIDB4MDA2QjpcclxuICAgIGNhc2UgMHgwMDZDOmNhc2UgMHgwMDZEOmNhc2UgMHgwMDZFOmNhc2UgMHgwMDZGOmNhc2UgMHgwMDcwOlxyXG4gICAgY2FzZSAweDAwNzE6Y2FzZSAweDAwNzI6Y2FzZSAweDAwNzM6Y2FzZSAweDAwNzQ6Y2FzZSAweDAwNzU6XHJcbiAgICBjYXNlIDB4MDA3NjpjYXNlIDB4MDA3NzpjYXNlIDB4MDA3ODpjYXNlIDB4MDA3OTpjYXNlIDB4MDA3QTpcclxuICAgICAgYmVnaW5FbmRUYWdOYW1lKCk7XHJcbiAgICAgIHJlY29uc3VtZShjLCB0YWdfbmFtZV9zdGF0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXHJcbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAtMTogLy8gRU9GXHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxyXG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDJGKTsgLy8gU09MSURVU1xyXG4gICAgICBlbWl0RU9GKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmVjb25zdW1lKGMsIGJvZ3VzX2NvbW1lbnRfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRhZ19uYW1lX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcclxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxyXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXHJcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcclxuICAgICAgdG9rZW5pemVyID0gYmVmb3JlX2F0dHJpYnV0ZV9uYW1lX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDJGOiAvLyBTT0xJRFVTXHJcbiAgICAgIHRva2VuaXplciA9IHNlbGZfY2xvc2luZ19zdGFydF90YWdfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXHJcbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XHJcbiAgICAgIGVtaXRUYWcoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXHJcbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcclxuICAgIGNhc2UgMHgwMDQ3OmNhc2UgMHgwMDQ4OmNhc2UgMHgwMDQ5OmNhc2UgMHgwMDRBOmNhc2UgMHgwMDRCOlxyXG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XHJcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcclxuICAgIGNhc2UgMHgwMDU2OmNhc2UgMHgwMDU3OmNhc2UgMHgwMDU4OmNhc2UgMHgwMDU5OmNhc2UgMHgwMDVBOlxyXG4gICAgICB0YWduYW1lYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyArIDB4MDAyMCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcclxuICAgICAgdGFnbmFtZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCAvKiBSRVBMQUNFTUVOVCBDSEFSQUNURVIgKi8pO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBlbWl0RU9GKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGFnbmFtZWJ1ZiArPSBnZXRNYXRjaGluZ0NoYXJzKFRBR05BTUUpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJjZGF0YV9sZXNzX3RoYW5fc2lnbl9zdGF0ZShjKSB7XHJcbiAgICAvKiBpZGVudGljYWwgdG8gdGhlIFJBV1RFWFQgbGVzcy10aGFuIHNpZ24gc3RhdGUsIGV4Y2VwdCBzL1JBV1RFWFQvUkNEQVRBL2cgKi9cclxuICAgIGlmIChjID09PSAweDAwMkYpIHsgIC8vIFNPTElEVVNcclxuICAgICAgYmVnaW5UZW1wQnVmKCk7XHJcbiAgICAgIHRva2VuaXplciA9IHJjZGF0YV9lbmRfdGFnX29wZW5fc3RhdGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXHJcbiAgICAgIHJlY29uc3VtZShjLCByY2RhdGFfc3RhdGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmNkYXRhX2VuZF90YWdfb3Blbl9zdGF0ZShjKSB7XHJcbiAgICAvKiBpZGVudGljYWwgdG8gdGhlIFJBV1RFWFQgKGFuZCBTY3JpcHQgZGF0YSkgZW5kIHRhZyBvcGVuIHN0YXRlLCBleGNlcHQgcy9SQVdURVhUL1JDREFUQS9nICovXHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwNDE6ICAvLyBbQS1aXVxyXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XHJcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcclxuICAgIGNhc2UgMHgwMDRDOmNhc2UgMHgwMDREOmNhc2UgMHgwMDRFOmNhc2UgMHgwMDRGOmNhc2UgMHgwMDUwOlxyXG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XHJcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcclxuICAgIGNhc2UgMHgwMDYxOiAgLy8gW2Etel1cclxuICAgIGNhc2UgMHgwMDYyOmNhc2UgMHgwMDYzOmNhc2UgMHgwMDY0OmNhc2UgMHgwMDY1OmNhc2UgMHgwMDY2OlxyXG4gICAgY2FzZSAweDAwNjc6Y2FzZSAweDAwNjg6Y2FzZSAweDAwNjk6Y2FzZSAweDAwNkE6Y2FzZSAweDAwNkI6XHJcbiAgICBjYXNlIDB4MDA2QzpjYXNlIDB4MDA2RDpjYXNlIDB4MDA2RTpjYXNlIDB4MDA2RjpjYXNlIDB4MDA3MDpcclxuICAgIGNhc2UgMHgwMDcxOmNhc2UgMHgwMDcyOmNhc2UgMHgwMDczOmNhc2UgMHgwMDc0OmNhc2UgMHgwMDc1OlxyXG4gICAgY2FzZSAweDAwNzY6Y2FzZSAweDAwNzc6Y2FzZSAweDAwNzg6Y2FzZSAweDAwNzk6Y2FzZSAweDAwN0E6XHJcbiAgICAgIGJlZ2luRW5kVGFnTmFtZSgpO1xyXG4gICAgICByZWNvbnN1bWUoYywgcmNkYXRhX2VuZF90YWdfbmFtZV9zdGF0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkYpOyAvLyBTT0xJRFVTXHJcbiAgICAgIHJlY29uc3VtZShjLCByY2RhdGFfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJjZGF0YV9lbmRfdGFnX25hbWVfc3RhdGUoYykge1xyXG4gICAgLyogaWRlbnRpY2FsIHRvIHRoZSBSQVdURVhUIChhbmQgU2NyaXB0IGRhdGEpIGVuZCB0YWcgbmFtZSBzdGF0ZSwgZXhjZXB0IHMvUkFXVEVYVC9SQ0RBVEEvZyAqL1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxyXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXHJcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcclxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxyXG4gICAgICBpZiAoYXBwcm9wcmlhdGVFbmRUYWcodGFnbmFtZWJ1ZikpIHtcclxuICAgICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfYXR0cmlidXRlX25hbWVfc3RhdGU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMkY6IC8vIFNPTElEVVNcclxuICAgICAgaWYgKGFwcHJvcHJpYXRlRW5kVGFnKHRhZ25hbWVidWYpKSB7XHJcbiAgICAgICAgdG9rZW5pemVyID0gc2VsZl9jbG9zaW5nX3N0YXJ0X3RhZ19zdGF0ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cclxuICAgICAgaWYgKGFwcHJvcHJpYXRlRW5kVGFnKHRhZ25hbWVidWYpKSB7XHJcbiAgICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcclxuICAgICAgICBlbWl0VGFnKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwNDE6ICAvLyBbQS1aXVxyXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XHJcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcclxuICAgIGNhc2UgMHgwMDRDOmNhc2UgMHgwMDREOmNhc2UgMHgwMDRFOmNhc2UgMHgwMDRGOmNhc2UgMHgwMDUwOlxyXG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XHJcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcclxuXHJcbiAgICAgIHRhZ25hbWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjICsgMHgwMDIwKTtcclxuICAgICAgdGVtcGJ1Zi5wdXNoKGMpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIDB4MDA2MTogIC8vIFthLXpdXHJcbiAgICBjYXNlIDB4MDA2MjpjYXNlIDB4MDA2MzpjYXNlIDB4MDA2NDpjYXNlIDB4MDA2NTpjYXNlIDB4MDA2NjpcclxuICAgIGNhc2UgMHgwMDY3OmNhc2UgMHgwMDY4OmNhc2UgMHgwMDY5OmNhc2UgMHgwMDZBOmNhc2UgMHgwMDZCOlxyXG4gICAgY2FzZSAweDAwNkM6Y2FzZSAweDAwNkQ6Y2FzZSAweDAwNkU6Y2FzZSAweDAwNkY6Y2FzZSAweDAwNzA6XHJcbiAgICBjYXNlIDB4MDA3MTpjYXNlIDB4MDA3MjpjYXNlIDB4MDA3MzpjYXNlIDB4MDA3NDpjYXNlIDB4MDA3NTpcclxuICAgIGNhc2UgMHgwMDc2OmNhc2UgMHgwMDc3OmNhc2UgMHgwMDc4OmNhc2UgMHgwMDc5OmNhc2UgMHgwMDdBOlxyXG5cclxuICAgICAgdGFnbmFtZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xyXG4gICAgICB0ZW1wYnVmLnB1c2goYyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHdlIGRvbid0IHJldHVybiBpbiBvbmUgb2YgdGhlIGNhc2VzIGFib3ZlLCB0aGVuIHRoaXMgd2FzIG5vdFxyXG4gICAgLy8gYW4gYXBwcm9wcmlhdGVseSBtYXRjaGluZyBjbG9zZSB0YWcsIHNvIGJhY2sgb3V0IGJ5IGVtaXR0aW5nIGFsbFxyXG4gICAgLy8gdGhlIGNoYXJhY3RlcnMgYXMgdGV4dFxyXG4gICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXHJcbiAgICB0ZXh0cnVuLnB1c2goMHgwMDJGKTsgLy8gU09MSURVU1xyXG4gICAgcHVzaEFsbCh0ZXh0cnVuLCB0ZW1wYnVmKTtcclxuICAgIHJlY29uc3VtZShjLCByY2RhdGFfc3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmF3dGV4dF9sZXNzX3RoYW5fc2lnbl9zdGF0ZShjKSB7XHJcbiAgICAvKiBpZGVudGljYWwgdG8gdGhlIFJDREFUQSBsZXNzLXRoYW4gc2lnbiBzdGF0ZSwgZXhjZXB0IHMvUkNEQVRBL1JBV1RFWFQvZ1xyXG4gICAgICovXHJcbiAgICBpZiAoYyA9PT0gMHgwMDJGKSB7IC8vIFNPTElEVVNcclxuICAgICAgYmVnaW5UZW1wQnVmKCk7XHJcbiAgICAgIHRva2VuaXplciA9IHJhd3RleHRfZW5kX3RhZ19vcGVuX3N0YXRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxyXG4gICAgICByZWNvbnN1bWUoYywgcmF3dGV4dF9zdGF0ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByYXd0ZXh0X2VuZF90YWdfb3Blbl9zdGF0ZShjKSB7XHJcbiAgICAvKiBpZGVudGljYWwgdG8gdGhlIFJDREFUQSAoYW5kIFNjcmlwdCBkYXRhKSBlbmQgdGFnIG9wZW4gc3RhdGUsIGV4Y2VwdCBzL1JDREFUQS9SQVdURVhUL2cgKi9cclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXHJcbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcclxuICAgIGNhc2UgMHgwMDQ3OmNhc2UgMHgwMDQ4OmNhc2UgMHgwMDQ5OmNhc2UgMHgwMDRBOmNhc2UgMHgwMDRCOlxyXG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XHJcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcclxuICAgIGNhc2UgMHgwMDU2OmNhc2UgMHgwMDU3OmNhc2UgMHgwMDU4OmNhc2UgMHgwMDU5OmNhc2UgMHgwMDVBOlxyXG4gICAgY2FzZSAweDAwNjE6ICAvLyBbYS16XVxyXG4gICAgY2FzZSAweDAwNjI6Y2FzZSAweDAwNjM6Y2FzZSAweDAwNjQ6Y2FzZSAweDAwNjU6Y2FzZSAweDAwNjY6XHJcbiAgICBjYXNlIDB4MDA2NzpjYXNlIDB4MDA2ODpjYXNlIDB4MDA2OTpjYXNlIDB4MDA2QTpjYXNlIDB4MDA2QjpcclxuICAgIGNhc2UgMHgwMDZDOmNhc2UgMHgwMDZEOmNhc2UgMHgwMDZFOmNhc2UgMHgwMDZGOmNhc2UgMHgwMDcwOlxyXG4gICAgY2FzZSAweDAwNzE6Y2FzZSAweDAwNzI6Y2FzZSAweDAwNzM6Y2FzZSAweDAwNzQ6Y2FzZSAweDAwNzU6XHJcbiAgICBjYXNlIDB4MDA3NjpjYXNlIDB4MDA3NzpjYXNlIDB4MDA3ODpjYXNlIDB4MDA3OTpjYXNlIDB4MDA3QTpcclxuICAgICAgYmVnaW5FbmRUYWdOYW1lKCk7XHJcbiAgICAgIHJlY29uc3VtZShjLCByYXd0ZXh0X2VuZF90YWdfbmFtZV9zdGF0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkYpOyAvLyBTT0xJRFVTXHJcbiAgICAgIHJlY29uc3VtZShjLCByYXd0ZXh0X3N0YXRlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByYXd0ZXh0X2VuZF90YWdfbmFtZV9zdGF0ZShjKSB7XHJcbiAgICAvKiBpZGVudGljYWwgdG8gdGhlIFJDREFUQSAoYW5kIFNjcmlwdCBkYXRhKSBlbmQgdGFnIG5hbWUgc3RhdGUsIGV4Y2VwdCBzL1JDREFUQS9SQVdURVhUL2cgKi9cclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcclxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxyXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXHJcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcclxuICAgICAgaWYgKGFwcHJvcHJpYXRlRW5kVGFnKHRhZ25hbWVidWYpKSB7XHJcbiAgICAgICAgdG9rZW5pemVyID0gYmVmb3JlX2F0dHJpYnV0ZV9uYW1lX3N0YXRlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDJGOiAvLyBTT0xJRFVTXHJcbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xyXG4gICAgICAgIHRva2VuaXplciA9IHNlbGZfY2xvc2luZ19zdGFydF90YWdfc3RhdGU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXHJcbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xyXG4gICAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XHJcbiAgICAgICAgZW1pdFRhZygpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cclxuICAgIGNhc2UgMHgwMDQyOmNhc2UgMHgwMDQzOmNhc2UgMHgwMDQ0OmNhc2UgMHgwMDQ1OmNhc2UgMHgwMDQ2OlxyXG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XHJcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcclxuICAgIGNhc2UgMHgwMDUxOmNhc2UgMHgwMDUyOmNhc2UgMHgwMDUzOmNhc2UgMHgwMDU0OmNhc2UgMHgwMDU1OlxyXG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XHJcbiAgICAgIHRhZ25hbWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjICsgMHgwMDIwKTtcclxuICAgICAgdGVtcGJ1Zi5wdXNoKGMpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIDB4MDA2MTogIC8vIFthLXpdXHJcbiAgICBjYXNlIDB4MDA2MjpjYXNlIDB4MDA2MzpjYXNlIDB4MDA2NDpjYXNlIDB4MDA2NTpjYXNlIDB4MDA2NjpcclxuICAgIGNhc2UgMHgwMDY3OmNhc2UgMHgwMDY4OmNhc2UgMHgwMDY5OmNhc2UgMHgwMDZBOmNhc2UgMHgwMDZCOlxyXG4gICAgY2FzZSAweDAwNkM6Y2FzZSAweDAwNkQ6Y2FzZSAweDAwNkU6Y2FzZSAweDAwNkY6Y2FzZSAweDAwNzA6XHJcbiAgICBjYXNlIDB4MDA3MTpjYXNlIDB4MDA3MjpjYXNlIDB4MDA3MzpjYXNlIDB4MDA3NDpjYXNlIDB4MDA3NTpcclxuICAgIGNhc2UgMHgwMDc2OmNhc2UgMHgwMDc3OmNhc2UgMHgwMDc4OmNhc2UgMHgwMDc5OmNhc2UgMHgwMDdBOlxyXG4gICAgICB0YWduYW1lYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XHJcbiAgICAgIHRlbXBidWYucHVzaChjKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgd2UgZG9uJ3QgcmV0dXJuIGluIG9uZSBvZiB0aGUgY2FzZXMgYWJvdmUsIHRoZW4gdGhpcyB3YXMgbm90XHJcbiAgICAvLyBhbiBhcHByb3ByaWF0ZWx5IG1hdGNoaW5nIGNsb3NlIHRhZywgc28gYmFjayBvdXQgYnkgZW1pdHRpbmcgYWxsXHJcbiAgICAvLyB0aGUgY2hhcmFjdGVycyBhcyB0ZXh0XHJcbiAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cclxuICAgIHRleHRydW4ucHVzaCgweDAwMkYpOyAvLyBTT0xJRFVTXHJcbiAgICBwdXNoQWxsKHRleHRydW4sdGVtcGJ1Zik7XHJcbiAgICByZWNvbnN1bWUoYywgcmF3dGV4dF9zdGF0ZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9sZXNzX3RoYW5fc2lnbl9zdGF0ZShjKSB7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwMkY6IC8vIFNPTElEVVNcclxuICAgICAgYmVnaW5UZW1wQnVmKCk7XHJcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VuZF90YWdfb3Blbl9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAyMTogLy8gRVhDTEFNQVRJT04gTUFSS1xyXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9lc2NhcGVfc3RhcnRfc3RhdGU7XHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxyXG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDIxKTsgLy8gRVhDTEFNQVRJT04gTUFSS1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxyXG4gICAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNjcmlwdF9kYXRhX2VuZF90YWdfb3Blbl9zdGF0ZShjKSB7XHJcbiAgICAvKiBpZGVudGljYWwgdG8gdGhlIFJDREFUQSAoYW5kIFJBV1RFWFQpIGVuZCB0YWcgb3BlbiBzdGF0ZSwgZXhjZXB0IHMvUkNEQVRBL1NjcmlwdCBkYXRhL2cgKi9cclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXHJcbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcclxuICAgIGNhc2UgMHgwMDQ3OmNhc2UgMHgwMDQ4OmNhc2UgMHgwMDQ5OmNhc2UgMHgwMDRBOmNhc2UgMHgwMDRCOlxyXG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XHJcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcclxuICAgIGNhc2UgMHgwMDU2OmNhc2UgMHgwMDU3OmNhc2UgMHgwMDU4OmNhc2UgMHgwMDU5OmNhc2UgMHgwMDVBOlxyXG4gICAgY2FzZSAweDAwNjE6ICAvLyBbYS16XVxyXG4gICAgY2FzZSAweDAwNjI6Y2FzZSAweDAwNjM6Y2FzZSAweDAwNjQ6Y2FzZSAweDAwNjU6Y2FzZSAweDAwNjY6XHJcbiAgICBjYXNlIDB4MDA2NzpjYXNlIDB4MDA2ODpjYXNlIDB4MDA2OTpjYXNlIDB4MDA2QTpjYXNlIDB4MDA2QjpcclxuICAgIGNhc2UgMHgwMDZDOmNhc2UgMHgwMDZEOmNhc2UgMHgwMDZFOmNhc2UgMHgwMDZGOmNhc2UgMHgwMDcwOlxyXG4gICAgY2FzZSAweDAwNzE6Y2FzZSAweDAwNzI6Y2FzZSAweDAwNzM6Y2FzZSAweDAwNzQ6Y2FzZSAweDAwNzU6XHJcbiAgICBjYXNlIDB4MDA3NjpjYXNlIDB4MDA3NzpjYXNlIDB4MDA3ODpjYXNlIDB4MDA3OTpjYXNlIDB4MDA3QTpcclxuICAgICAgYmVnaW5FbmRUYWdOYW1lKCk7XHJcbiAgICAgIHJlY29uc3VtZShjLCBzY3JpcHRfZGF0YV9lbmRfdGFnX25hbWVfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxyXG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDJGKTsgLy8gU09MSURVU1xyXG4gICAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNjcmlwdF9kYXRhX2VuZF90YWdfbmFtZV9zdGF0ZShjKSB7XHJcbiAgICAvKiBpZGVudGljYWwgdG8gdGhlIFJDREFUQSAoYW5kIFJBV1RFWFQpIGVuZCB0YWcgbmFtZSBzdGF0ZSwgZXhjZXB0IHMvUkNEQVRBL1NjcmlwdCBkYXRhL2cgKi9cclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcclxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxyXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXHJcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcclxuICAgICAgaWYgKGFwcHJvcHJpYXRlRW5kVGFnKHRhZ25hbWVidWYpKSB7XHJcbiAgICAgICAgdG9rZW5pemVyID0gYmVmb3JlX2F0dHJpYnV0ZV9uYW1lX3N0YXRlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDJGOiAvLyBTT0xJRFVTXHJcbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xyXG4gICAgICAgIHRva2VuaXplciA9IHNlbGZfY2xvc2luZ19zdGFydF90YWdfc3RhdGU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXHJcbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xyXG4gICAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XHJcbiAgICAgICAgZW1pdFRhZygpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cclxuICAgIGNhc2UgMHgwMDQyOmNhc2UgMHgwMDQzOmNhc2UgMHgwMDQ0OmNhc2UgMHgwMDQ1OmNhc2UgMHgwMDQ2OlxyXG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XHJcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcclxuICAgIGNhc2UgMHgwMDUxOmNhc2UgMHgwMDUyOmNhc2UgMHgwMDUzOmNhc2UgMHgwMDU0OmNhc2UgMHgwMDU1OlxyXG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XHJcblxyXG4gICAgICB0YWduYW1lYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyArIDB4MDAyMCk7XHJcbiAgICAgIHRlbXBidWYucHVzaChjKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSAweDAwNjE6ICAvLyBbYS16XVxyXG4gICAgY2FzZSAweDAwNjI6Y2FzZSAweDAwNjM6Y2FzZSAweDAwNjQ6Y2FzZSAweDAwNjU6Y2FzZSAweDAwNjY6XHJcbiAgICBjYXNlIDB4MDA2NzpjYXNlIDB4MDA2ODpjYXNlIDB4MDA2OTpjYXNlIDB4MDA2QTpjYXNlIDB4MDA2QjpcclxuICAgIGNhc2UgMHgwMDZDOmNhc2UgMHgwMDZEOmNhc2UgMHgwMDZFOmNhc2UgMHgwMDZGOmNhc2UgMHgwMDcwOlxyXG4gICAgY2FzZSAweDAwNzE6Y2FzZSAweDAwNzI6Y2FzZSAweDAwNzM6Y2FzZSAweDAwNzQ6Y2FzZSAweDAwNzU6XHJcbiAgICBjYXNlIDB4MDA3NjpjYXNlIDB4MDA3NzpjYXNlIDB4MDA3ODpjYXNlIDB4MDA3OTpjYXNlIDB4MDA3QTpcclxuXHJcbiAgICAgIHRhZ25hbWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcclxuICAgICAgdGVtcGJ1Zi5wdXNoKGMpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB3ZSBkb24ndCByZXR1cm4gaW4gb25lIG9mIHRoZSBjYXNlcyBhYm92ZSwgdGhlbiB0aGlzIHdhcyBub3RcclxuICAgIC8vIGFuIGFwcHJvcHJpYXRlbHkgbWF0Y2hpbmcgY2xvc2UgdGFnLCBzbyBiYWNrIG91dCBieSBlbWl0dGluZyBhbGxcclxuICAgIC8vIHRoZSBjaGFyYWN0ZXJzIGFzIHRleHRcclxuICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxyXG4gICAgdGV4dHJ1bi5wdXNoKDB4MDAyRik7IC8vIFNPTElEVVNcclxuICAgIHB1c2hBbGwodGV4dHJ1bix0ZW1wYnVmKTtcclxuICAgIHJlY29uc3VtZShjLCBzY3JpcHRfZGF0YV9zdGF0ZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9lc2NhcGVfc3RhcnRfc3RhdGUoYykge1xyXG4gICAgaWYgKGMgPT09IDB4MDAyRCkgeyAvLyBIWVBIRU4tTUlOVVNcclxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlX3N0YXJ0X2Rhc2hfc3RhdGU7XHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkQpOyAvLyBIWVBIRU4tTUlOVVNcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfc3RhdGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZXNjYXBlX3N0YXJ0X2Rhc2hfc3RhdGUoYykge1xyXG4gICAgaWYgKGMgPT09IDB4MDAyRCkgeyAvLyBIWVBIRU4tTUlOVVNcclxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlZF9kYXNoX2Rhc2hfc3RhdGU7XHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkQpOyAvLyBIWVBIRU4tTUlOVVNcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfc3RhdGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZXNjYXBlZF9zdGF0ZShjKSB7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xyXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9lc2NhcGVkX2Rhc2hfc3RhdGU7XHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkQpOyAvLyBIWVBIRU4tTUlOVVNcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAzQzogLy8gTEVTUy1USEFOIFNJR05cclxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlZF9sZXNzX3RoYW5fc2lnbl9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxyXG4gICAgICB0ZXh0cnVuLnB1c2goMHhGRkZEKTsgLy8gUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAtMTogLy8gRU9GXHJcbiAgICAgIGVtaXRFT0YoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZXNjYXBlZF9kYXNoX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAyRDogLy8gSFlQSEVOLU1JTlVTXHJcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfZGFzaF9kYXNoX3N0YXRlO1xyXG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDJEKTsgLy8gSFlQSEVOLU1JTlVTXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXHJcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfbGVzc190aGFuX3NpZ25fc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcclxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlZF9zdGF0ZTtcclxuICAgICAgdGV4dHJ1bi5wdXNoKDB4RkZGRCk7IC8vIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBlbWl0RU9GKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlZF9zdGF0ZTtcclxuICAgICAgdGV4dHJ1bi5wdXNoKGMpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNjcmlwdF9kYXRhX2VzY2FwZWRfZGFzaF9kYXNoX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAyRDogLy8gSFlQSEVOLU1JTlVTXHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkQpOyAvLyBIWVBIRU4tTUlOVVNcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAzQzogLy8gTEVTUy1USEFOIFNJR05cclxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlZF9sZXNzX3RoYW5fc2lnbl9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cclxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfc3RhdGU7XHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0UpOyAvLyBHUkVBVEVSLVRIQU4gU0lHTlxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXHJcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfc3RhdGU7XHJcbiAgICAgIHRleHRydW4ucHVzaCgweEZGRkQpOyAvLyBSRVBMQUNFTUVOVCBDSEFSQUNURVJcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgZW1pdEVPRigpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfc3RhdGU7XHJcbiAgICAgIHRleHRydW4ucHVzaChjKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9lc2NhcGVkX2xlc3NfdGhhbl9zaWduX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAyRjogLy8gU09MSURVU1xyXG4gICAgICBiZWdpblRlbXBCdWYoKTtcclxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlZF9lbmRfdGFnX29wZW5fc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwNDE6ICAvLyBbQS1aXVxyXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XHJcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcclxuICAgIGNhc2UgMHgwMDRDOmNhc2UgMHgwMDREOmNhc2UgMHgwMDRFOmNhc2UgMHgwMDRGOmNhc2UgMHgwMDUwOlxyXG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XHJcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcclxuICAgIGNhc2UgMHgwMDYxOiAgLy8gW2Etel1cclxuICAgIGNhc2UgMHgwMDYyOmNhc2UgMHgwMDYzOmNhc2UgMHgwMDY0OmNhc2UgMHgwMDY1OmNhc2UgMHgwMDY2OlxyXG4gICAgY2FzZSAweDAwNjc6Y2FzZSAweDAwNjg6Y2FzZSAweDAwNjk6Y2FzZSAweDAwNkE6Y2FzZSAweDAwNkI6XHJcbiAgICBjYXNlIDB4MDA2QzpjYXNlIDB4MDA2RDpjYXNlIDB4MDA2RTpjYXNlIDB4MDA2RjpjYXNlIDB4MDA3MDpcclxuICAgIGNhc2UgMHgwMDcxOmNhc2UgMHgwMDcyOmNhc2UgMHgwMDczOmNhc2UgMHgwMDc0OmNhc2UgMHgwMDc1OlxyXG4gICAgY2FzZSAweDAwNzY6Y2FzZSAweDAwNzc6Y2FzZSAweDAwNzg6Y2FzZSAweDAwNzk6Y2FzZSAweDAwN0E6XHJcbiAgICAgIGJlZ2luVGVtcEJ1ZigpO1xyXG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cclxuICAgICAgcmVjb25zdW1lKGMsIHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVfc3RhcnRfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxyXG4gICAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfZXNjYXBlZF9zdGF0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZXNjYXBlZF9lbmRfdGFnX29wZW5fc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cclxuICAgIGNhc2UgMHgwMDQyOmNhc2UgMHgwMDQzOmNhc2UgMHgwMDQ0OmNhc2UgMHgwMDQ1OmNhc2UgMHgwMDQ2OlxyXG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XHJcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcclxuICAgIGNhc2UgMHgwMDUxOmNhc2UgMHgwMDUyOmNhc2UgMHgwMDUzOmNhc2UgMHgwMDU0OmNhc2UgMHgwMDU1OlxyXG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XHJcbiAgICBjYXNlIDB4MDA2MTogIC8vIFthLXpdXHJcbiAgICBjYXNlIDB4MDA2MjpjYXNlIDB4MDA2MzpjYXNlIDB4MDA2NDpjYXNlIDB4MDA2NTpjYXNlIDB4MDA2NjpcclxuICAgIGNhc2UgMHgwMDY3OmNhc2UgMHgwMDY4OmNhc2UgMHgwMDY5OmNhc2UgMHgwMDZBOmNhc2UgMHgwMDZCOlxyXG4gICAgY2FzZSAweDAwNkM6Y2FzZSAweDAwNkQ6Y2FzZSAweDAwNkU6Y2FzZSAweDAwNkY6Y2FzZSAweDAwNzA6XHJcbiAgICBjYXNlIDB4MDA3MTpjYXNlIDB4MDA3MjpjYXNlIDB4MDA3MzpjYXNlIDB4MDA3NDpjYXNlIDB4MDA3NTpcclxuICAgIGNhc2UgMHgwMDc2OmNhc2UgMHgwMDc3OmNhc2UgMHgwMDc4OmNhc2UgMHgwMDc5OmNhc2UgMHgwMDdBOlxyXG4gICAgICBiZWdpbkVuZFRhZ05hbWUoKTtcclxuICAgICAgcmVjb25zdW1lKGMsIHNjcmlwdF9kYXRhX2VzY2FwZWRfZW5kX3RhZ19uYW1lX3N0YXRlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cclxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAyRik7IC8vIFNPTElEVVNcclxuICAgICAgcmVjb25zdW1lKGMsIHNjcmlwdF9kYXRhX2VzY2FwZWRfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNjcmlwdF9kYXRhX2VzY2FwZWRfZW5kX3RhZ19uYW1lX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcclxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxyXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXHJcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcclxuICAgICAgaWYgKGFwcHJvcHJpYXRlRW5kVGFnKHRhZ25hbWVidWYpKSB7XHJcbiAgICAgICAgdG9rZW5pemVyID0gYmVmb3JlX2F0dHJpYnV0ZV9uYW1lX3N0YXRlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDJGOiAvLyBTT0xJRFVTXHJcbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xyXG4gICAgICAgIHRva2VuaXplciA9IHNlbGZfY2xvc2luZ19zdGFydF90YWdfc3RhdGU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXHJcbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xyXG4gICAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XHJcbiAgICAgICAgZW1pdFRhZygpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cclxuICAgIGNhc2UgMHgwMDQyOmNhc2UgMHgwMDQzOmNhc2UgMHgwMDQ0OmNhc2UgMHgwMDQ1OmNhc2UgMHgwMDQ2OlxyXG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XHJcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcclxuICAgIGNhc2UgMHgwMDUxOmNhc2UgMHgwMDUyOmNhc2UgMHgwMDUzOmNhc2UgMHgwMDU0OmNhc2UgMHgwMDU1OlxyXG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XHJcbiAgICAgIHRhZ25hbWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjICsgMHgwMDIwKTtcclxuICAgICAgdGVtcGJ1Zi5wdXNoKGMpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIDB4MDA2MTogIC8vIFthLXpdXHJcbiAgICBjYXNlIDB4MDA2MjpjYXNlIDB4MDA2MzpjYXNlIDB4MDA2NDpjYXNlIDB4MDA2NTpjYXNlIDB4MDA2NjpcclxuICAgIGNhc2UgMHgwMDY3OmNhc2UgMHgwMDY4OmNhc2UgMHgwMDY5OmNhc2UgMHgwMDZBOmNhc2UgMHgwMDZCOlxyXG4gICAgY2FzZSAweDAwNkM6Y2FzZSAweDAwNkQ6Y2FzZSAweDAwNkU6Y2FzZSAweDAwNkY6Y2FzZSAweDAwNzA6XHJcbiAgICBjYXNlIDB4MDA3MTpjYXNlIDB4MDA3MjpjYXNlIDB4MDA3MzpjYXNlIDB4MDA3NDpjYXNlIDB4MDA3NTpcclxuICAgIGNhc2UgMHgwMDc2OmNhc2UgMHgwMDc3OmNhc2UgMHgwMDc4OmNhc2UgMHgwMDc5OmNhc2UgMHgwMDdBOlxyXG4gICAgICB0YWduYW1lYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XHJcbiAgICAgIHRlbXBidWYucHVzaChjKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2UgZ2V0IGhlcmUgaW4gdGhlIGRlZmF1bHQgY2FzZSwgYW5kIGlmIHRoZSBjbG9zaW5nIHRhZ25hbWVcclxuICAgIC8vIGlzIG5vdCBhbiBhcHByb3ByaWF0ZSB0YWduYW1lLlxyXG4gICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXHJcbiAgICB0ZXh0cnVuLnB1c2goMHgwMDJGKTsgLy8gU09MSURVU1xyXG4gICAgcHVzaEFsbCh0ZXh0cnVuLHRlbXBidWYpO1xyXG4gICAgcmVjb25zdW1lKGMsIHNjcmlwdF9kYXRhX2VzY2FwZWRfc3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZV9zdGFydF9zdGF0ZShjKSB7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXHJcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcclxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxyXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXHJcbiAgICBjYXNlIDB4MDAyRjogLy8gU09MSURVU1xyXG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXHJcbiAgICAgIGlmIChidWYyc3RyKHRlbXBidWYpID09PSBcInNjcmlwdFwiKSB7XHJcbiAgICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfc3RhdGU7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlZF9zdGF0ZTtcclxuICAgICAgfVxyXG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwNDE6ICAvLyBbQS1aXVxyXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XHJcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcclxuICAgIGNhc2UgMHgwMDRDOmNhc2UgMHgwMDREOmNhc2UgMHgwMDRFOmNhc2UgMHgwMDRGOmNhc2UgMHgwMDUwOlxyXG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XHJcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcclxuICAgICAgdGVtcGJ1Zi5wdXNoKGMgKyAweDAwMjApO1xyXG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwNjE6ICAvLyBbYS16XVxyXG4gICAgY2FzZSAweDAwNjI6Y2FzZSAweDAwNjM6Y2FzZSAweDAwNjQ6Y2FzZSAweDAwNjU6Y2FzZSAweDAwNjY6XHJcbiAgICBjYXNlIDB4MDA2NzpjYXNlIDB4MDA2ODpjYXNlIDB4MDA2OTpjYXNlIDB4MDA2QTpjYXNlIDB4MDA2QjpcclxuICAgIGNhc2UgMHgwMDZDOmNhc2UgMHgwMDZEOmNhc2UgMHgwMDZFOmNhc2UgMHgwMDZGOmNhc2UgMHgwMDcwOlxyXG4gICAgY2FzZSAweDAwNzE6Y2FzZSAweDAwNzI6Y2FzZSAweDAwNzM6Y2FzZSAweDAwNzQ6Y2FzZSAweDAwNzU6XHJcbiAgICBjYXNlIDB4MDA3NjpjYXNlIDB4MDA3NzpjYXNlIDB4MDA3ODpjYXNlIDB4MDA3OTpjYXNlIDB4MDA3QTpcclxuICAgICAgdGVtcGJ1Zi5wdXNoKGMpO1xyXG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmVjb25zdW1lKGMsIHNjcmlwdF9kYXRhX2VzY2FwZWRfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVkX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAyRDogLy8gSFlQSEVOLU1JTlVTXHJcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVkX2Rhc2hfc3RhdGU7XHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkQpOyAvLyBIWVBIRU4tTUlOVVNcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAzQzogLy8gTEVTUy1USEFOIFNJR05cclxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfbGVzc190aGFuX3NpZ25fc3RhdGU7XHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXHJcbiAgICAgIHRleHRydW4ucHVzaCgweEZGRkQpOyAvLyBSRVBMQUNFTUVOVCBDSEFSQUNURVJcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgZW1pdEVPRigpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRleHRydW4ucHVzaChjKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlZF9kYXNoX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAyRDogLy8gSFlQSEVOLU1JTlVTXHJcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVkX2Rhc2hfZGFzaF9zdGF0ZTtcclxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAyRCk7IC8vIEhZUEhFTi1NSU5VU1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDNDOiAvLyBMRVNTLVRIQU4gU0lHTlxyXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlZF9sZXNzX3RoYW5fc2lnbl9zdGF0ZTtcclxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcclxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfc3RhdGU7XHJcbiAgICAgIHRleHRydW4ucHVzaCgweEZGRkQpOyAvLyBSRVBMQUNFTUVOVCBDSEFSQUNURVJcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgZW1pdEVPRigpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVkX3N0YXRlO1xyXG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfZGFzaF9kYXNoX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAyRDogLy8gSFlQSEVOLU1JTlVTXHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkQpOyAvLyBIWVBIRU4tTUlOVVNcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAzQzogLy8gTEVTUy1USEFOIFNJR05cclxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfbGVzc190aGFuX3NpZ25fc3RhdGU7XHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxyXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9zdGF0ZTtcclxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAzRSk7IC8vIEdSRUFURVItVEhBTiBTSUdOXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcclxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfc3RhdGU7XHJcbiAgICAgIHRleHRydW4ucHVzaCgweEZGRkQpOyAvLyBSRVBMQUNFTUVOVCBDSEFSQUNURVJcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgZW1pdEVPRigpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVkX3N0YXRlO1xyXG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfbGVzc190aGFuX3NpZ25fc3RhdGUoYykge1xyXG4gICAgaWYgKGMgPT09IDB4MDAyRikgeyAvLyBTT0xJRFVTXHJcbiAgICAgIGJlZ2luVGVtcEJ1ZigpO1xyXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlX2VuZF9zdGF0ZTtcclxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAyRik7IC8vIFNPTElEVVNcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfc3RhdGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZV9lbmRfc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxyXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXHJcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcclxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxyXG4gICAgY2FzZSAweDAwMkY6IC8vIFNPTElEVVNcclxuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxyXG4gICAgICBpZiAoYnVmMnN0cih0ZW1wYnVmKSA9PT0gXCJzY3JpcHRcIikge1xyXG4gICAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfc3RhdGU7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfc3RhdGU7XHJcbiAgICAgIH1cclxuICAgICAgdGV4dHJ1bi5wdXNoKGMpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cclxuICAgIGNhc2UgMHgwMDQyOmNhc2UgMHgwMDQzOmNhc2UgMHgwMDQ0OmNhc2UgMHgwMDQ1OmNhc2UgMHgwMDQ2OlxyXG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XHJcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcclxuICAgIGNhc2UgMHgwMDUxOmNhc2UgMHgwMDUyOmNhc2UgMHgwMDUzOmNhc2UgMHgwMDU0OmNhc2UgMHgwMDU1OlxyXG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XHJcbiAgICAgIHRlbXBidWYucHVzaChjICsgMHgwMDIwKTtcclxuICAgICAgdGV4dHJ1bi5wdXNoKGMpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDYxOiAgLy8gW2Etel1cclxuICAgIGNhc2UgMHgwMDYyOmNhc2UgMHgwMDYzOmNhc2UgMHgwMDY0OmNhc2UgMHgwMDY1OmNhc2UgMHgwMDY2OlxyXG4gICAgY2FzZSAweDAwNjc6Y2FzZSAweDAwNjg6Y2FzZSAweDAwNjk6Y2FzZSAweDAwNkE6Y2FzZSAweDAwNkI6XHJcbiAgICBjYXNlIDB4MDA2QzpjYXNlIDB4MDA2RDpjYXNlIDB4MDA2RTpjYXNlIDB4MDA2RjpjYXNlIDB4MDA3MDpcclxuICAgIGNhc2UgMHgwMDcxOmNhc2UgMHgwMDcyOmNhc2UgMHgwMDczOmNhc2UgMHgwMDc0OmNhc2UgMHgwMDc1OlxyXG4gICAgY2FzZSAweDAwNzY6Y2FzZSAweDAwNzc6Y2FzZSAweDAwNzg6Y2FzZSAweDAwNzk6Y2FzZSAweDAwN0E6XHJcbiAgICAgIHRlbXBidWYucHVzaChjKTtcclxuICAgICAgdGV4dHJ1bi5wdXNoKGMpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJlY29uc3VtZShjLCBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlZF9zdGF0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYmVmb3JlX2F0dHJpYnV0ZV9uYW1lX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcclxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxyXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXHJcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcclxuICAgICAgLyogSWdub3JlIHRoZSBjaGFyYWN0ZXIuICovXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgLy8gRm9yIFNPTElEVVMsIEdSRUFURVItVEhBTiBTSUdOLCBhbmQgRU9GLCBzcGVjIHNheXMgXCJyZWNvbnN1bWUgaW5cclxuICAgIC8vIHRoZSBhZnRlciBhdHRyaWJ1dGUgbmFtZSBzdGF0ZVwiLCBidXQgaW4gb3VyIGltcGxlbWVudGF0aW9uIHRoYXRcclxuICAgIC8vIHN0YXRlIGFsd2F5cyBoYXMgYW4gYWN0aXZlIGF0dHJpYnV0ZSBpbiBhdHRybmFtZWJ1Zi4gIEp1c3QgY2xvbmVcclxuICAgIC8vIHRoZSBydWxlcyBoZXJlLCB3aXRob3V0IHRoZSBhZGRBdHRyaWJ1dGUgYnVzaW5lc3MuXHJcbiAgICBjYXNlIDB4MDAyRjogLy8gU09MSURVU1xyXG4gICAgICB0b2tlbml6ZXIgPSBzZWxmX2Nsb3Npbmdfc3RhcnRfdGFnX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxyXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xyXG4gICAgICBlbWl0VGFnKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAtMTogLy8gRU9GXHJcbiAgICAgIGVtaXRFT0YoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAzRDogLy8gRVFVQUxTIFNJR05cclxuICAgICAgYmVnaW5BdHRyTmFtZSgpO1xyXG4gICAgICBhdHRybmFtZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xyXG4gICAgICB0b2tlbml6ZXIgPSBhdHRyaWJ1dGVfbmFtZV9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBpZiAoaGFuZGxlU2ltcGxlQXR0cmlidXRlKCkpIGJyZWFrO1xyXG4gICAgICBiZWdpbkF0dHJOYW1lKCk7XHJcbiAgICAgIHJlY29uc3VtZShjLCBhdHRyaWJ1dGVfbmFtZV9zdGF0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gYmVnaW5BdHRyTmFtZSgpIG11c3QgaGF2ZSBiZWVuIGNhbGxlZCBiZWZvcmUgdGhpcyBwb2ludFxyXG4gIC8vIFRoZXJlIGlzIGFuIGFjdGl2ZSBhdHRyaWJ1dGUgaW4gYXR0cm5hbWVidWYgKGJ1dCBub3QgYXR0cnZhbHVlYnVmKVxyXG4gIGZ1bmN0aW9uIGF0dHJpYnV0ZV9uYW1lX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcclxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxyXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXHJcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcclxuICAgIGNhc2UgMHgwMDJGOiAvLyBTT0xJRFVTXHJcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICByZWNvbnN1bWUoYywgYWZ0ZXJfYXR0cmlidXRlX25hbWVfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDNEOiAvLyBFUVVBTFMgU0lHTlxyXG4gICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfYXR0cmlidXRlX3ZhbHVlX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cclxuICAgIGNhc2UgMHgwMDQyOmNhc2UgMHgwMDQzOmNhc2UgMHgwMDQ0OmNhc2UgMHgwMDQ1OmNhc2UgMHgwMDQ2OlxyXG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XHJcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcclxuICAgIGNhc2UgMHgwMDUxOmNhc2UgMHgwMDUyOmNhc2UgMHgwMDUzOmNhc2UgMHgwMDU0OmNhc2UgMHgwMDU1OlxyXG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XHJcbiAgICAgIGF0dHJuYW1lYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyArIDB4MDAyMCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcclxuICAgICAgYXR0cm5hbWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQgLyogUkVQTEFDRU1FTlQgQ0hBUkFDVEVSICovKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAyMjogLy8gUVVPVEFUSU9OIE1BUktcclxuICAgIGNhc2UgMHgwMDI3OiAvLyBBUE9TVFJPUEhFXHJcbiAgICBjYXNlIDB4MDAzQzogLy8gTEVTUy1USEFOIFNJR05cclxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgYXR0cm5hbWVidWYgKz0gZ2V0TWF0Y2hpbmdDaGFycyhBVFRSTkFNRSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVGhlcmUgaXMgYW4gYWN0aXZlIGF0dHJpYnV0ZSBpbiBhdHRybmFtZWJ1ZiwgYnV0IG5vdCB5ZXQgaW4gYXR0cnZhbHVlYnVmLlxyXG4gIGZ1bmN0aW9uIGFmdGVyX2F0dHJpYnV0ZV9uYW1lX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcclxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxyXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXHJcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcclxuICAgICAgLyogSWdub3JlIHRoZSBjaGFyYWN0ZXIuICovXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMkY6IC8vIFNPTElEVVNcclxuICAgICAgLy8gS2VlcCBpbiBzeW5jIHdpdGggYmVmb3JlX2F0dHJpYnV0ZV9uYW1lX3N0YXRlLlxyXG4gICAgICBhZGRBdHRyaWJ1dGUoYXR0cm5hbWVidWYpO1xyXG4gICAgICB0b2tlbml6ZXIgPSBzZWxmX2Nsb3Npbmdfc3RhcnRfdGFnX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDNEOiAvLyBFUVVBTFMgU0lHTlxyXG4gICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfYXR0cmlidXRlX3ZhbHVlX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxyXG4gICAgICAvLyBLZWVwIGluIHN5bmMgd2l0aCBiZWZvcmVfYXR0cmlidXRlX25hbWVfc3RhdGUuXHJcbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XHJcbiAgICAgIGFkZEF0dHJpYnV0ZShhdHRybmFtZWJ1Zik7XHJcbiAgICAgIGVtaXRUYWcoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgLy8gS2VlcCBpbiBzeW5jIHdpdGggYmVmb3JlX2F0dHJpYnV0ZV9uYW1lX3N0YXRlLlxyXG4gICAgICBhZGRBdHRyaWJ1dGUoYXR0cm5hbWVidWYpO1xyXG4gICAgICBlbWl0RU9GKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgYWRkQXR0cmlidXRlKGF0dHJuYW1lYnVmKTtcclxuICAgICAgYmVnaW5BdHRyTmFtZSgpO1xyXG4gICAgICByZWNvbnN1bWUoYywgYXR0cmlidXRlX25hbWVfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGJlZm9yZV9hdHRyaWJ1dGVfdmFsdWVfc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxyXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXHJcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcclxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxyXG4gICAgICAvKiBJZ25vcmUgdGhlIGNoYXJhY3Rlci4gKi9cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAyMjogLy8gUVVPVEFUSU9OIE1BUktcclxuICAgICAgYmVnaW5BdHRyVmFsdWUoKTtcclxuICAgICAgdG9rZW5pemVyID0gYXR0cmlidXRlX3ZhbHVlX2RvdWJsZV9xdW90ZWRfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMjc6IC8vIEFQT1NUUk9QSEVcclxuICAgICAgYmVnaW5BdHRyVmFsdWUoKTtcclxuICAgICAgdG9rZW5pemVyID0gYXR0cmlidXRlX3ZhbHVlX3NpbmdsZV9xdW90ZWRfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXHJcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGJlZ2luQXR0clZhbHVlKCk7XHJcbiAgICAgIHJlY29uc3VtZShjLCBhdHRyaWJ1dGVfdmFsdWVfdW5xdW90ZWRfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGF0dHJpYnV0ZV92YWx1ZV9kb3VibGVfcXVvdGVkX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAyMjogLy8gUVVPVEFUSU9OIE1BUktcclxuICAgICAgYWRkQXR0cmlidXRlKGF0dHJuYW1lYnVmLCBhdHRydmFsdWVidWYpO1xyXG4gICAgICB0b2tlbml6ZXIgPSBhZnRlcl9hdHRyaWJ1dGVfdmFsdWVfcXVvdGVkX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDI2OiAvLyBBTVBFUlNBTkRcclxuICAgICAgcmV0dXJuX3N0YXRlID0gYXR0cmlidXRlX3ZhbHVlX2RvdWJsZV9xdW90ZWRfc3RhdGU7XHJcbiAgICAgIHRva2VuaXplciA9IGNoYXJhY3Rlcl9yZWZlcmVuY2Vfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcclxuICAgICAgYXR0cnZhbHVlYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEIC8qIFJFUExBQ0VNRU5UIENIQVJBQ1RFUiAqLyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAtMTogLy8gRU9GXHJcbiAgICAgIGVtaXRFT0YoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAwQTogLy8gTEZcclxuICAgICAgLy8gdGhpcyBjb3VsZCBiZSBhIGNvbnZlcnRlZCBcXHIsIHNvIGRvbid0IHVzZSBnZXRNYXRjaGluZ0NoYXJzXHJcbiAgICAgIGF0dHJ2YWx1ZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGF0dHJ2YWx1ZWJ1ZiArPSBnZXRNYXRjaGluZ0NoYXJzKERCTFFVT1RFQVRUUlZBTCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYXR0cmlidXRlX3ZhbHVlX3NpbmdsZV9xdW90ZWRfc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDI3OiAvLyBBUE9TVFJPUEhFXHJcbiAgICAgIGFkZEF0dHJpYnV0ZShhdHRybmFtZWJ1ZiwgYXR0cnZhbHVlYnVmKTtcclxuICAgICAgdG9rZW5pemVyID0gYWZ0ZXJfYXR0cmlidXRlX3ZhbHVlX3F1b3RlZF9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAyNjogLy8gQU1QRVJTQU5EXHJcbiAgICAgIHJldHVybl9zdGF0ZSA9IGF0dHJpYnV0ZV92YWx1ZV9zaW5nbGVfcXVvdGVkX3N0YXRlO1xyXG4gICAgICB0b2tlbml6ZXIgPSBjaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXHJcbiAgICAgIGF0dHJ2YWx1ZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCAvKiBSRVBMQUNFTUVOVCBDSEFSQUNURVIgKi8pO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBlbWl0RU9GKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMEE6IC8vIExGXHJcbiAgICAgIC8vIHRoaXMgY291bGQgYmUgYSBjb252ZXJ0ZWQgXFxyLCBzbyBkb24ndCB1c2UgZ2V0TWF0Y2hpbmdDaGFyc1xyXG4gICAgICBhdHRydmFsdWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBhdHRydmFsdWVidWYgKz0gZ2V0TWF0Y2hpbmdDaGFycyhTSU5HTEVRVU9URUFUVFJWQUwpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGF0dHJpYnV0ZV92YWx1ZV91bnF1b3RlZF9zdGF0ZShjKSB7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXHJcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcclxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxyXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXHJcbiAgICAgIGFkZEF0dHJpYnV0ZShhdHRybmFtZWJ1ZiwgYXR0cnZhbHVlYnVmKTtcclxuICAgICAgdG9rZW5pemVyID0gYmVmb3JlX2F0dHJpYnV0ZV9uYW1lX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDI2OiAvLyBBTVBFUlNBTkRcclxuICAgICAgcmV0dXJuX3N0YXRlID0gYXR0cmlidXRlX3ZhbHVlX3VucXVvdGVkX3N0YXRlO1xyXG4gICAgICB0b2tlbml6ZXIgPSBjaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxyXG4gICAgICBhZGRBdHRyaWJ1dGUoYXR0cm5hbWVidWYsIGF0dHJ2YWx1ZWJ1Zik7XHJcbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XHJcbiAgICAgIGVtaXRUYWcoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxyXG4gICAgICBhdHRydmFsdWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQgLyogUkVQTEFDRU1FTlQgQ0hBUkFDVEVSICovKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgbmV4dGNoYXItLTsgLy8gcHVzaGJhY2tcclxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAyMjogLy8gUVVPVEFUSU9OIE1BUktcclxuICAgIGNhc2UgMHgwMDI3OiAvLyBBUE9TVFJPUEhFXHJcbiAgICBjYXNlIDB4MDAzQzogLy8gTEVTUy1USEFOIFNJR05cclxuICAgIGNhc2UgMHgwMDNEOiAvLyBFUVVBTFMgU0lHTlxyXG4gICAgY2FzZSAweDAwNjA6IC8vIEdSQVZFIEFDQ0VOVFxyXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBhdHRydmFsdWVidWYgKz0gZ2V0TWF0Y2hpbmdDaGFycyhVTlFVT1RFREFUVFJWQUwpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFmdGVyX2F0dHJpYnV0ZV92YWx1ZV9xdW90ZWRfc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxyXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXHJcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcclxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxyXG4gICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfYXR0cmlidXRlX25hbWVfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMkY6IC8vIFNPTElEVVNcclxuICAgICAgdG9rZW5pemVyID0gc2VsZl9jbG9zaW5nX3N0YXJ0X3RhZ19zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cclxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcclxuICAgICAgZW1pdFRhZygpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBlbWl0RU9GKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmVjb25zdW1lKGMsIGJlZm9yZV9hdHRyaWJ1dGVfbmFtZV9zdGF0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2VsZl9jbG9zaW5nX3N0YXJ0X3RhZ19zdGF0ZShjKSB7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXHJcbiAgICAgIC8vIFNldCB0aGUgPGk+c2VsZi1jbG9zaW5nIGZsYWc8L2k+IG9mIHRoZSBjdXJyZW50IHRhZyB0b2tlbi5cclxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcclxuICAgICAgZW1pdFNlbGZDbG9zaW5nVGFnKHRydWUpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBlbWl0RU9GKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmVjb25zdW1lKGMsIGJlZm9yZV9hdHRyaWJ1dGVfbmFtZV9zdGF0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYm9ndXNfY29tbWVudF9zdGF0ZShjLCBsb29rYWhlYWQsIGVvZikge1xyXG4gICAgdmFyIGxlbiA9IGxvb2thaGVhZC5sZW5ndGg7XHJcblxyXG4gICAgaWYgKGVvZikge1xyXG4gICAgICBuZXh0Y2hhciArPSBsZW4tMTsgLy8gZG9uJ3QgY29uc3VtZSB0aGUgZW9mXHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgbmV4dGNoYXIgKz0gbGVuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjb21tZW50ID0gbG9va2FoZWFkLnN1YnN0cmluZygwLCBsZW4tMSk7XHJcblxyXG4gICAgY29tbWVudCA9IGNvbW1lbnQucmVwbGFjZSgvXFx1MDAwMC9nLFwiXFx1RkZGRFwiKTtcclxuICAgIGNvbW1lbnQgPSBjb21tZW50LnJlcGxhY2UoL1xcdTAwMERcXHUwMDBBL2csXCJcXHUwMDBBXCIpO1xyXG4gICAgY29tbWVudCA9IGNvbW1lbnQucmVwbGFjZSgvXFx1MDAwRC9nLFwiXFx1MDAwQVwiKTtcclxuXHJcbiAgICBpbnNlcnRUb2tlbihDT01NRU5ULCBjb21tZW50KTtcclxuICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XHJcbiAgfVxyXG4gIGJvZ3VzX2NvbW1lbnRfc3RhdGUubG9va2FoZWFkID0gXCI+XCI7XHJcblxyXG4gIGZ1bmN0aW9uIG1hcmt1cF9kZWNsYXJhdGlvbl9vcGVuX3N0YXRlKGMsIGxvb2thaGVhZCwgZW9mKSB7XHJcbiAgICBpZiAobG9va2FoZWFkWzBdID09PSBcIi1cIiAmJiBsb29rYWhlYWRbMV0gPT09IFwiLVwiKSB7XHJcbiAgICAgIG5leHRjaGFyICs9IDI7XHJcbiAgICAgIGJlZ2luQ29tbWVudCgpO1xyXG4gICAgICB0b2tlbml6ZXIgPSBjb21tZW50X3N0YXJ0X3N0YXRlO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGxvb2thaGVhZC50b1VwcGVyQ2FzZSgpID09PSBcIkRPQ1RZUEVcIikge1xyXG4gICAgICBuZXh0Y2hhciArPSA3O1xyXG4gICAgICB0b2tlbml6ZXIgPSBkb2N0eXBlX3N0YXRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobG9va2FoZWFkID09PSBcIltDREFUQVtcIiAmJiBjZGF0YUFsbG93ZWQoKSkge1xyXG4gICAgICBuZXh0Y2hhciArPSA3O1xyXG4gICAgICB0b2tlbml6ZXIgPSBjZGF0YV9zZWN0aW9uX3N0YXRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHRva2VuaXplciA9IGJvZ3VzX2NvbW1lbnRfc3RhdGU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIG1hcmt1cF9kZWNsYXJhdGlvbl9vcGVuX3N0YXRlLmxvb2thaGVhZCA9IDc7XHJcblxyXG4gIGZ1bmN0aW9uIGNvbW1lbnRfc3RhcnRfc3RhdGUoYykge1xyXG4gICAgYmVnaW5Db21tZW50KCk7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xyXG4gICAgICB0b2tlbml6ZXIgPSBjb21tZW50X3N0YXJ0X2Rhc2hfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXHJcbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XHJcbiAgICAgIGluc2VydFRva2VuKENPTU1FTlQsIGJ1ZjJzdHIoY29tbWVudGJ1ZikpO1xyXG4gICAgICBicmVhazsgLyogc2VlIGNvbW1lbnQgaW4gY29tbWVudCBlbmQgc3RhdGUgKi9cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJlY29uc3VtZShjLCBjb21tZW50X3N0YXRlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb21tZW50X3N0YXJ0X2Rhc2hfc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDJEOiAvLyBIWVBIRU4tTUlOVVNcclxuICAgICAgdG9rZW5pemVyID0gY29tbWVudF9lbmRfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXHJcbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XHJcbiAgICAgIGluc2VydFRva2VuKENPTU1FTlQsIGJ1ZjJzdHIoY29tbWVudGJ1ZikpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBpbnNlcnRUb2tlbihDT01NRU5ULCBidWYyc3RyKGNvbW1lbnRidWYpKTtcclxuICAgICAgZW1pdEVPRigpO1xyXG4gICAgICBicmVhazsgLyogc2VlIGNvbW1lbnQgaW4gY29tbWVudCBlbmQgc3RhdGUgKi9cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGNvbW1lbnRidWYucHVzaCgweDAwMkQgLyogSFlQSEVOLU1JTlVTICovKTtcclxuICAgICAgcmVjb25zdW1lKGMsIGNvbW1lbnRfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbW1lbnRfc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDNDOiAvLyBMRVNTLVRIQU4gU0lHTlxyXG4gICAgICBjb21tZW50YnVmLnB1c2goYyk7XHJcbiAgICAgIHRva2VuaXplciA9IGNvbW1lbnRfbGVzc190aGFuX3NpZ25fc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xyXG4gICAgICB0b2tlbml6ZXIgPSBjb21tZW50X2VuZF9kYXNoX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXHJcbiAgICAgIGNvbW1lbnRidWYucHVzaCgweEZGRkQgLyogUkVQTEFDRU1FTlQgQ0hBUkFDVEVSICovKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgaW5zZXJ0VG9rZW4oQ09NTUVOVCwgYnVmMnN0cihjb21tZW50YnVmKSk7XHJcbiAgICAgIGVtaXRFT0YoKTtcclxuICAgICAgYnJlYWs7IC8qIHNlZSBjb21tZW50IGluIGNvbW1lbnQgZW5kIHN0YXRlICovXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBjb21tZW50YnVmLnB1c2goYyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29tbWVudF9sZXNzX3RoYW5fc2lnbl9zdGF0ZShjKSB7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwMjE6IC8vIEVYQ0xBTUFUSU9OIE1BUktcclxuICAgICAgY29tbWVudGJ1Zi5wdXNoKGMpO1xyXG4gICAgICB0b2tlbml6ZXIgPSBjb21tZW50X2xlc3NfdGhhbl9zaWduX2Jhbmdfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXHJcbiAgICAgIGNvbW1lbnRidWYucHVzaChjKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZWNvbnN1bWUoYywgY29tbWVudF9zdGF0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29tbWVudF9sZXNzX3RoYW5fc2lnbl9iYW5nX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAyRDogLy8gSFlQSEVOLU1JTlVTXHJcbiAgICAgIHRva2VuaXplciA9IGNvbW1lbnRfbGVzc190aGFuX3NpZ25fYmFuZ19kYXNoX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJlY29uc3VtZShjLCBjb21tZW50X3N0YXRlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb21tZW50X2xlc3NfdGhhbl9zaWduX2JhbmdfZGFzaF9zdGF0ZShjKSB7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xyXG4gICAgICB0b2tlbml6ZXIgPSBjb21tZW50X2xlc3NfdGhhbl9zaWduX2JhbmdfZGFzaF9kYXNoX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJlY29uc3VtZShjLCBjb21tZW50X2VuZF9kYXNoX3N0YXRlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb21tZW50X2xlc3NfdGhhbl9zaWduX2JhbmdfZGFzaF9kYXNoX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICByZWNvbnN1bWUoYywgY29tbWVudF9lbmRfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIC8vIHBhcnNlIGVycm9yXHJcbiAgICAgIHJlY29uc3VtZShjLCBjb21tZW50X2VuZF9zdGF0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29tbWVudF9lbmRfZGFzaF9zdGF0ZShjKSB7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xyXG4gICAgICB0b2tlbml6ZXIgPSBjb21tZW50X2VuZF9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgaW5zZXJ0VG9rZW4oQ09NTUVOVCwgYnVmMnN0cihjb21tZW50YnVmKSk7XHJcbiAgICAgIGVtaXRFT0YoKTtcclxuICAgICAgYnJlYWs7IC8qIHNlZSBjb21tZW50IGluIGNvbW1lbnQgZW5kIHN0YXRlICovXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBjb21tZW50YnVmLnB1c2goMHgwMDJEIC8qIEhZUEhFTi1NSU5VUyAqLyk7XHJcbiAgICAgIHJlY29uc3VtZShjLCBjb21tZW50X3N0YXRlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb21tZW50X2VuZF9zdGF0ZShjKSB7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXHJcbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XHJcbiAgICAgIGluc2VydFRva2VuKENPTU1FTlQsIGJ1ZjJzdHIoY29tbWVudGJ1ZikpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDIxOiAvLyBFWENMQU1BVElPTiBNQVJLXHJcbiAgICAgIHRva2VuaXplciA9IGNvbW1lbnRfZW5kX2Jhbmdfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xyXG4gICAgICBjb21tZW50YnVmLnB1c2goMHgwMDJEKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgaW5zZXJ0VG9rZW4oQ09NTUVOVCwgYnVmMnN0cihjb21tZW50YnVmKSk7XHJcbiAgICAgIGVtaXRFT0YoKTtcclxuICAgICAgYnJlYWs7IC8qIEZvciBzZWN1cml0eSByZWFzb25zOiBvdGhlcndpc2UsIGhvc3RpbGUgdXNlciBjb3VsZCBwdXQgYSBzY3JpcHQgaW4gYSBjb21tZW50IGUuZy4gaW4gYSBibG9nIGNvbW1lbnQgYW5kIHRoZW4gRE9TIHRoZSBzZXJ2ZXIgc28gdGhhdCB0aGUgZW5kIHRhZyBpc24ndCByZWFkLCBhbmQgdGhlbiB0aGUgY29tbWVudGVkIHNjcmlwdCB0YWcgd291bGQgYmUgdHJlYXRlZCBhcyBsaXZlIGNvZGUgKi9cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGNvbW1lbnRidWYucHVzaCgweDAwMkQpO1xyXG4gICAgICBjb21tZW50YnVmLnB1c2goMHgwMDJEKTtcclxuICAgICAgcmVjb25zdW1lKGMsIGNvbW1lbnRfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbW1lbnRfZW5kX2Jhbmdfc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDJEOiAvLyBIWVBIRU4tTUlOVVNcclxuICAgICAgY29tbWVudGJ1Zi5wdXNoKDB4MDAyRCk7XHJcbiAgICAgIGNvbW1lbnRidWYucHVzaCgweDAwMkQpO1xyXG4gICAgICBjb21tZW50YnVmLnB1c2goMHgwMDIxKTtcclxuICAgICAgdG9rZW5pemVyID0gY29tbWVudF9lbmRfZGFzaF9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cclxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcclxuICAgICAgaW5zZXJ0VG9rZW4oQ09NTUVOVCwgYnVmMnN0cihjb21tZW50YnVmKSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAtMTogLy8gRU9GXHJcbiAgICAgIGluc2VydFRva2VuKENPTU1FTlQsIGJ1ZjJzdHIoY29tbWVudGJ1ZikpO1xyXG4gICAgICBlbWl0RU9GKCk7XHJcbiAgICAgIGJyZWFrOyAvKiBzZWUgY29tbWVudCBpbiBjb21tZW50IGVuZCBzdGF0ZSAqL1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgY29tbWVudGJ1Zi5wdXNoKDB4MDAyRCk7XHJcbiAgICAgIGNvbW1lbnRidWYucHVzaCgweDAwMkQpO1xyXG4gICAgICBjb21tZW50YnVmLnB1c2goMHgwMDIxKTtcclxuICAgICAgcmVjb25zdW1lKGMsIGNvbW1lbnRfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRvY3R5cGVfc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxyXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXHJcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcclxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxyXG4gICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfZG9jdHlwZV9uYW1lX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBiZWdpbkRvY3R5cGUoKTtcclxuICAgICAgZm9yY2VxdWlya3MoKTtcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgZW1pdEVPRigpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJlY29uc3VtZShjLCBiZWZvcmVfZG9jdHlwZV9uYW1lX3N0YXRlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBiZWZvcmVfZG9jdHlwZV9uYW1lX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcclxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxyXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXHJcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcclxuICAgICAgLyogSWdub3JlIHRoZSBjaGFyYWN0ZXIuICovXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwNDE6ICAvLyBbQS1aXVxyXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XHJcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcclxuICAgIGNhc2UgMHgwMDRDOmNhc2UgMHgwMDREOmNhc2UgMHgwMDRFOmNhc2UgMHgwMDRGOmNhc2UgMHgwMDUwOlxyXG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XHJcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcclxuICAgICAgYmVnaW5Eb2N0eXBlKCk7XHJcbiAgICAgIGRvY3R5cGVuYW1lYnVmLnB1c2goYyArIDB4MDAyMCk7XHJcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfbmFtZV9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxyXG4gICAgICBiZWdpbkRvY3R5cGUoKTtcclxuICAgICAgZG9jdHlwZW5hbWVidWYucHVzaCgweEZGRkQpO1xyXG4gICAgICB0b2tlbml6ZXIgPSBkb2N0eXBlX25hbWVfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXHJcbiAgICAgIGJlZ2luRG9jdHlwZSgpO1xyXG4gICAgICBmb3JjZXF1aXJrcygpO1xyXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xyXG4gICAgICBlbWl0RG9jdHlwZSgpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBiZWdpbkRvY3R5cGUoKTtcclxuICAgICAgZm9yY2VxdWlya3MoKTtcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgZW1pdEVPRigpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGJlZ2luRG9jdHlwZSgpO1xyXG4gICAgICBkb2N0eXBlbmFtZWJ1Zi5wdXNoKGMpO1xyXG4gICAgICB0b2tlbml6ZXIgPSBkb2N0eXBlX25hbWVfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZG9jdHlwZV9uYW1lX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcclxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxyXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXHJcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcclxuICAgICAgdG9rZW5pemVyID0gYWZ0ZXJfZG9jdHlwZV9uYW1lX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxyXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xyXG4gICAgICBlbWl0RG9jdHlwZSgpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cclxuICAgIGNhc2UgMHgwMDQyOmNhc2UgMHgwMDQzOmNhc2UgMHgwMDQ0OmNhc2UgMHgwMDQ1OmNhc2UgMHgwMDQ2OlxyXG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XHJcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcclxuICAgIGNhc2UgMHgwMDUxOmNhc2UgMHgwMDUyOmNhc2UgMHgwMDUzOmNhc2UgMHgwMDU0OmNhc2UgMHgwMDU1OlxyXG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XHJcbiAgICAgIGRvY3R5cGVuYW1lYnVmLnB1c2goYyArIDB4MDAyMCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcclxuICAgICAgZG9jdHlwZW5hbWVidWYucHVzaCgweEZGRkQgLyogUkVQTEFDRU1FTlQgQ0hBUkFDVEVSICovKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgZm9yY2VxdWlya3MoKTtcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgZW1pdEVPRigpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGRvY3R5cGVuYW1lYnVmLnB1c2goYyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYWZ0ZXJfZG9jdHlwZV9uYW1lX3N0YXRlKGMsIGxvb2thaGVhZCwgZW9mKSB7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXHJcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcclxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxyXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXHJcbiAgICAgIC8qIElnbm9yZSB0aGUgY2hhcmFjdGVyLiAqL1xyXG4gICAgICBuZXh0Y2hhciArPSAxO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxyXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xyXG4gICAgICBuZXh0Y2hhciArPSAxO1xyXG4gICAgICBlbWl0RG9jdHlwZSgpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBmb3JjZXF1aXJrcygpO1xyXG4gICAgICBlbWl0RG9jdHlwZSgpO1xyXG4gICAgICBlbWl0RU9GKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgbG9va2FoZWFkID0gbG9va2FoZWFkLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgIGlmIChsb29rYWhlYWQgPT09IFwiUFVCTElDXCIpIHtcclxuICAgICAgICBuZXh0Y2hhciArPSA2O1xyXG4gICAgICAgIHRva2VuaXplciA9IGFmdGVyX2RvY3R5cGVfcHVibGljX2tleXdvcmRfc3RhdGU7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAobG9va2FoZWFkID09PSBcIlNZU1RFTVwiKSB7XHJcbiAgICAgICAgbmV4dGNoYXIgKz0gNjtcclxuICAgICAgICB0b2tlbml6ZXIgPSBhZnRlcl9kb2N0eXBlX3N5c3RlbV9rZXl3b3JkX3N0YXRlO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGZvcmNlcXVpcmtzKCk7XHJcbiAgICAgICAgdG9rZW5pemVyID0gYm9ndXNfZG9jdHlwZV9zdGF0ZTtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgYWZ0ZXJfZG9jdHlwZV9uYW1lX3N0YXRlLmxvb2thaGVhZCA9IDY7XHJcblxyXG4gIGZ1bmN0aW9uIGFmdGVyX2RvY3R5cGVfcHVibGljX2tleXdvcmRfc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxyXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXHJcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcclxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxyXG4gICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfZG9jdHlwZV9wdWJsaWNfaWRlbnRpZmllcl9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAyMjogLy8gUVVPVEFUSU9OIE1BUktcclxuICAgICAgYmVnaW5Eb2N0eXBlUHVibGljSWQoKTtcclxuICAgICAgdG9rZW5pemVyID0gZG9jdHlwZV9wdWJsaWNfaWRlbnRpZmllcl9kb3VibGVfcXVvdGVkX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDI3OiAvLyBBUE9TVFJPUEhFXHJcbiAgICAgIGJlZ2luRG9jdHlwZVB1YmxpY0lkKCk7XHJcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfcHVibGljX2lkZW50aWZpZXJfc2luZ2xlX3F1b3RlZF9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cclxuICAgICAgZm9yY2VxdWlya3MoKTtcclxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgZm9yY2VxdWlya3MoKTtcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgZW1pdEVPRigpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGZvcmNlcXVpcmtzKCk7XHJcbiAgICAgIHRva2VuaXplciA9IGJvZ3VzX2RvY3R5cGVfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYmVmb3JlX2RvY3R5cGVfcHVibGljX2lkZW50aWZpZXJfc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxyXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXHJcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcclxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxyXG4gICAgICAvKiBJZ25vcmUgdGhlIGNoYXJhY3Rlci4gKi9cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAyMjogLy8gUVVPVEFUSU9OIE1BUktcclxuICAgICAgYmVnaW5Eb2N0eXBlUHVibGljSWQoKTtcclxuICAgICAgdG9rZW5pemVyID0gZG9jdHlwZV9wdWJsaWNfaWRlbnRpZmllcl9kb3VibGVfcXVvdGVkX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDI3OiAvLyBBUE9TVFJPUEhFXHJcbiAgICAgIGJlZ2luRG9jdHlwZVB1YmxpY0lkKCk7XHJcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfcHVibGljX2lkZW50aWZpZXJfc2luZ2xlX3F1b3RlZF9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cclxuICAgICAgZm9yY2VxdWlya3MoKTtcclxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgZm9yY2VxdWlya3MoKTtcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgZW1pdEVPRigpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGZvcmNlcXVpcmtzKCk7XHJcbiAgICAgIHRva2VuaXplciA9IGJvZ3VzX2RvY3R5cGVfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZG9jdHlwZV9wdWJsaWNfaWRlbnRpZmllcl9kb3VibGVfcXVvdGVkX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAyMjogLy8gUVVPVEFUSU9OIE1BUktcclxuICAgICAgdG9rZW5pemVyID0gYWZ0ZXJfZG9jdHlwZV9wdWJsaWNfaWRlbnRpZmllcl9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxyXG4gICAgICBkb2N0eXBlcHVibGljYnVmLnB1c2goMHhGRkZEIC8qIFJFUExBQ0VNRU5UIENIQVJBQ1RFUiAqLyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXHJcbiAgICAgIGZvcmNlcXVpcmtzKCk7XHJcbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XHJcbiAgICAgIGVtaXREb2N0eXBlKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAtMTogLy8gRU9GXHJcbiAgICAgIGZvcmNlcXVpcmtzKCk7XHJcbiAgICAgIGVtaXREb2N0eXBlKCk7XHJcbiAgICAgIGVtaXRFT0YoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBkb2N0eXBlcHVibGljYnVmLnB1c2goYyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZG9jdHlwZV9wdWJsaWNfaWRlbnRpZmllcl9zaW5nbGVfcXVvdGVkX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAyNzogLy8gQVBPU1RST1BIRVxyXG4gICAgICB0b2tlbml6ZXIgPSBhZnRlcl9kb2N0eXBlX3B1YmxpY19pZGVudGlmaWVyX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXHJcbiAgICAgIGRvY3R5cGVwdWJsaWNidWYucHVzaCgweEZGRkQgLyogUkVQTEFDRU1FTlQgQ0hBUkFDVEVSICovKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cclxuICAgICAgZm9yY2VxdWlya3MoKTtcclxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgZm9yY2VxdWlya3MoKTtcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgZW1pdEVPRigpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGRvY3R5cGVwdWJsaWNidWYucHVzaChjKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZnRlcl9kb2N0eXBlX3B1YmxpY19pZGVudGlmaWVyX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcclxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxyXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXHJcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcclxuICAgICAgdG9rZW5pemVyID0gYmV0d2Vlbl9kb2N0eXBlX3B1YmxpY19hbmRfc3lzdGVtX2lkZW50aWZpZXJzX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxyXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xyXG4gICAgICBlbWl0RG9jdHlwZSgpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDIyOiAvLyBRVU9UQVRJT04gTUFSS1xyXG4gICAgICBiZWdpbkRvY3R5cGVTeXN0ZW1JZCgpO1xyXG4gICAgICB0b2tlbml6ZXIgPSBkb2N0eXBlX3N5c3RlbV9pZGVudGlmaWVyX2RvdWJsZV9xdW90ZWRfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMjc6IC8vIEFQT1NUUk9QSEVcclxuICAgICAgYmVnaW5Eb2N0eXBlU3lzdGVtSWQoKTtcclxuICAgICAgdG9rZW5pemVyID0gZG9jdHlwZV9zeXN0ZW1faWRlbnRpZmllcl9zaW5nbGVfcXVvdGVkX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBmb3JjZXF1aXJrcygpO1xyXG4gICAgICBlbWl0RG9jdHlwZSgpO1xyXG4gICAgICBlbWl0RU9GKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgZm9yY2VxdWlya3MoKTtcclxuICAgICAgdG9rZW5pemVyID0gYm9ndXNfZG9jdHlwZV9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBiZXR3ZWVuX2RvY3R5cGVfcHVibGljX2FuZF9zeXN0ZW1faWRlbnRpZmllcnNfc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxyXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXHJcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcclxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRSBJZ25vcmUgdGhlIGNoYXJhY3Rlci5cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cclxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAyMjogLy8gUVVPVEFUSU9OIE1BUktcclxuICAgICAgYmVnaW5Eb2N0eXBlU3lzdGVtSWQoKTtcclxuICAgICAgdG9rZW5pemVyID0gZG9jdHlwZV9zeXN0ZW1faWRlbnRpZmllcl9kb3VibGVfcXVvdGVkX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDI3OiAvLyBBUE9TVFJPUEhFXHJcbiAgICAgIGJlZ2luRG9jdHlwZVN5c3RlbUlkKCk7XHJcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfc3lzdGVtX2lkZW50aWZpZXJfc2luZ2xlX3F1b3RlZF9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgZm9yY2VxdWlya3MoKTtcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgZW1pdEVPRigpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGZvcmNlcXVpcmtzKCk7XHJcbiAgICAgIHRva2VuaXplciA9IGJvZ3VzX2RvY3R5cGVfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYWZ0ZXJfZG9jdHlwZV9zeXN0ZW1fa2V5d29yZF9zdGF0ZShjKSB7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXHJcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcclxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxyXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXHJcbiAgICAgIHRva2VuaXplciA9IGJlZm9yZV9kb2N0eXBlX3N5c3RlbV9pZGVudGlmaWVyX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDIyOiAvLyBRVU9UQVRJT04gTUFSS1xyXG4gICAgICBiZWdpbkRvY3R5cGVTeXN0ZW1JZCgpO1xyXG4gICAgICB0b2tlbml6ZXIgPSBkb2N0eXBlX3N5c3RlbV9pZGVudGlmaWVyX2RvdWJsZV9xdW90ZWRfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMjc6IC8vIEFQT1NUUk9QSEVcclxuICAgICAgYmVnaW5Eb2N0eXBlU3lzdGVtSWQoKTtcclxuICAgICAgdG9rZW5pemVyID0gZG9jdHlwZV9zeXN0ZW1faWRlbnRpZmllcl9zaW5nbGVfcXVvdGVkX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxyXG4gICAgICBmb3JjZXF1aXJrcygpO1xyXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xyXG4gICAgICBlbWl0RG9jdHlwZSgpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBmb3JjZXF1aXJrcygpO1xyXG4gICAgICBlbWl0RG9jdHlwZSgpO1xyXG4gICAgICBlbWl0RU9GKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgZm9yY2VxdWlya3MoKTtcclxuICAgICAgdG9rZW5pemVyID0gYm9ndXNfZG9jdHlwZV9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBiZWZvcmVfZG9jdHlwZV9zeXN0ZW1faWRlbnRpZmllcl9zdGF0ZShjKSB7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXHJcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcclxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxyXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFIElnbm9yZSB0aGUgY2hhcmFjdGVyLlxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDIyOiAvLyBRVU9UQVRJT04gTUFSS1xyXG4gICAgICBiZWdpbkRvY3R5cGVTeXN0ZW1JZCgpO1xyXG4gICAgICB0b2tlbml6ZXIgPSBkb2N0eXBlX3N5c3RlbV9pZGVudGlmaWVyX2RvdWJsZV9xdW90ZWRfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMjc6IC8vIEFQT1NUUk9QSEVcclxuICAgICAgYmVnaW5Eb2N0eXBlU3lzdGVtSWQoKTtcclxuICAgICAgdG9rZW5pemVyID0gZG9jdHlwZV9zeXN0ZW1faWRlbnRpZmllcl9zaW5nbGVfcXVvdGVkX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxyXG4gICAgICBmb3JjZXF1aXJrcygpO1xyXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xyXG4gICAgICBlbWl0RG9jdHlwZSgpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBmb3JjZXF1aXJrcygpO1xyXG4gICAgICBlbWl0RG9jdHlwZSgpO1xyXG4gICAgICBlbWl0RU9GKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgZm9yY2VxdWlya3MoKTtcclxuICAgICAgdG9rZW5pemVyID0gYm9ndXNfZG9jdHlwZV9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkb2N0eXBlX3N5c3RlbV9pZGVudGlmaWVyX2RvdWJsZV9xdW90ZWRfc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDIyOiAvLyBRVU9UQVRJT04gTUFSS1xyXG4gICAgICB0b2tlbml6ZXIgPSBhZnRlcl9kb2N0eXBlX3N5c3RlbV9pZGVudGlmaWVyX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXHJcbiAgICAgIGRvY3R5cGVzeXN0ZW1idWYucHVzaCgweEZGRkQgLyogUkVQTEFDRU1FTlQgQ0hBUkFDVEVSICovKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cclxuICAgICAgZm9yY2VxdWlya3MoKTtcclxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgZm9yY2VxdWlya3MoKTtcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgZW1pdEVPRigpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGRvY3R5cGVzeXN0ZW1idWYucHVzaChjKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkb2N0eXBlX3N5c3RlbV9pZGVudGlmaWVyX3NpbmdsZV9xdW90ZWRfc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDI3OiAvLyBBUE9TVFJPUEhFXHJcbiAgICAgIHRva2VuaXplciA9IGFmdGVyX2RvY3R5cGVfc3lzdGVtX2lkZW50aWZpZXJfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcclxuICAgICAgZG9jdHlwZXN5c3RlbWJ1Zi5wdXNoKDB4RkZGRCAvKiBSRVBMQUNFTUVOVCBDSEFSQUNURVIgKi8pO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxyXG4gICAgICBmb3JjZXF1aXJrcygpO1xyXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xyXG4gICAgICBlbWl0RG9jdHlwZSgpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBmb3JjZXF1aXJrcygpO1xyXG4gICAgICBlbWl0RG9jdHlwZSgpO1xyXG4gICAgICBlbWl0RU9GKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgZG9jdHlwZXN5c3RlbWJ1Zi5wdXNoKGMpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFmdGVyX2RvY3R5cGVfc3lzdGVtX2lkZW50aWZpZXJfc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxyXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXHJcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcclxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxyXG4gICAgICAvKiBJZ25vcmUgdGhlIGNoYXJhY3Rlci4gKi9cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cclxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgZm9yY2VxdWlya3MoKTtcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgZW1pdEVPRigpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRva2VuaXplciA9IGJvZ3VzX2RvY3R5cGVfc3RhdGU7XHJcbiAgICAgIC8qIFRoaXMgZG9lcyAqbm90KiBzZXQgdGhlIERPQ1RZUEUgdG9rZW4ncyBmb3JjZS1xdWlya3MgZmxhZy4gKi9cclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBib2d1c19kb2N0eXBlX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cclxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgZW1pdERvY3R5cGUoKTtcclxuICAgICAgZW1pdEVPRigpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIC8qIElnbm9yZSB0aGUgY2hhcmFjdGVyLiAqL1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNkYXRhX3NlY3Rpb25fc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDVEOiAvLyBSSUdIVCBTUVVBUkUgQlJBQ0tFVFxyXG4gICAgICB0b2tlbml6ZXIgPSBjZGF0YV9zZWN0aW9uX2JyYWNrZXRfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAtMTogLy8gRU9GXHJcbiAgICAgIGVtaXRFT0YoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxyXG4gICAgICB0ZXh0SW5jbHVkZXNOVUwgPSB0cnVlO1xyXG4gICAgICAvKiBmYWxsIHRocm91Z2ggKi9cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIC8vIEluc3RlYWQgb2YganVzdCBwdXNoaW5nIGEgc2luZ2xlIGNoYXJhY3RlciBhbmQgdGhlblxyXG4gICAgICAvLyBjb21pbmcgYmFjayB0byB0aGUgdmVyeSBzYW1lIHBsYWNlLCBsb29rYWhlYWQgYW5kXHJcbiAgICAgIC8vIGVtaXQgZXZlcnl0aGluZyB3ZSBjYW4gYXQgb25jZS5cclxuICAgICAgLypqc2hpbnQgLVcwMzAgKi9cclxuICAgICAgZW1pdENoYXJzV2hpbGUoQ0RBVEFURVhUKSB8fCB0ZXh0cnVuLnB1c2goYyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2RhdGFfc2VjdGlvbl9icmFja2V0X3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDA1RDogLy8gUklHSFQgU1FVQVJFIEJSQUNLRVRcclxuICAgICAgdG9rZW5pemVyID0gY2RhdGFfc2VjdGlvbl9lbmRfc3RhdGU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDA1RCk7XHJcbiAgICAgIHJlY29uc3VtZShjLCBjZGF0YV9zZWN0aW9uX3N0YXRlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjZGF0YV9zZWN0aW9uX2VuZF9zdGF0ZShjKSB7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwNUQ6IC8vIFJJR0hUIFNRVUFSRSBCUkFDS0VUXHJcbiAgICAgIHRleHRydW4ucHVzaCgweDAwNUQpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxyXG4gICAgICBmbHVzaFRleHQoKTtcclxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDVEKTtcclxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDA1RCk7XHJcbiAgICAgIHJlY29uc3VtZShjLCBjZGF0YV9zZWN0aW9uX3N0YXRlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlKGMpIHtcclxuICAgIGJlZ2luVGVtcEJ1ZigpO1xyXG4gICAgdGVtcGJ1Zi5wdXNoKDB4MDAyNik7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwMDk6IC8vIFRBQlxyXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRFxyXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRFxyXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXHJcbiAgICBjYXNlIDB4MDAzQzogLy8gTEVTUy1USEFOIFNJR05cclxuICAgIGNhc2UgMHgwMDI2OiAvLyBBTVBFUlNBTkRcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICByZWNvbnN1bWUoYywgY2hhcmFjdGVyX3JlZmVyZW5jZV9lbmRfc3RhdGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDIzOiAvLyBOVU1CRVIgU0lHTlxyXG4gICAgICB0ZW1wYnVmLnB1c2goYyk7XHJcbiAgICAgIHRva2VuaXplciA9IG51bWVyaWNfY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZWNvbnN1bWUoYywgbmFtZWRfY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGF0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbmFtZWRfY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGF0ZShjKSB7XHJcbiAgICBOQU1FRENIQVJSRUYubGFzdEluZGV4ID0gbmV4dGNoYXI7IC8vIHcvIGxvb2thaGVhZCBubyBjaGFyIGhhcyBiZWVuIGNvbnN1bWVkXHJcbiAgICB2YXIgbWF0Y2hlZCA9IE5BTUVEQ0hBUlJFRi5leGVjKGNoYXJzKTtcclxuICAgIGlmICghbWF0Y2hlZCkgdGhyb3cgbmV3IEVycm9yKFwic2hvdWxkIG5ldmVyIGhhcHBlblwiKTtcclxuICAgIHZhciBuYW1lID0gbWF0Y2hlZFsxXTtcclxuICAgIGlmICghbmFtZSkge1xyXG4gICAgICAvLyBJZiBubyBtYXRjaCBjYW4gYmUgbWFkZSwgc3dpdGNoIHRvIHRoZSBjaGFyYWN0ZXIgcmVmZXJlbmNlIGVuZCBzdGF0ZVxyXG4gICAgICB0b2tlbml6ZXIgPSBjaGFyYWN0ZXJfcmVmZXJlbmNlX2VuZF9zdGF0ZTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnN1bWUgdGhlIG1hdGNoZWQgY2hhcmFjdGVycyBhbmQgYXBwZW5kIHRoZW0gdG8gdGVtcG9yYXJ5IGJ1ZmZlclxyXG4gICAgbmV4dGNoYXIgKz0gbmFtZS5sZW5ndGg7XHJcbiAgICBwdXNoQWxsKHRlbXBidWYsIHN0cjJidWYobmFtZSkpO1xyXG5cclxuICAgIHN3aXRjaChyZXR1cm5fc3RhdGUpIHtcclxuICAgIGNhc2UgYXR0cmlidXRlX3ZhbHVlX2RvdWJsZV9xdW90ZWRfc3RhdGU6XHJcbiAgICBjYXNlIGF0dHJpYnV0ZV92YWx1ZV9zaW5nbGVfcXVvdGVkX3N0YXRlOlxyXG4gICAgY2FzZSBhdHRyaWJ1dGVfdmFsdWVfdW5xdW90ZWRfc3RhdGU6XHJcbiAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBjb25zdW1lZCBhcyBwYXJ0IG9mIGFuIGF0dHJpYnV0ZS4uLlxyXG4gICAgICBpZiAobmFtZVtuYW1lLmxlbmd0aC0xXSAhPT0gJzsnKSB7IC8vIC4uLmFuZCB0aGUgbGFzdCBjaGFyIGlzIG5vdCA7XHJcbiAgICAgICAgaWYgKC9bPUEtWmEtejAtOV0vLnRlc3QoY2hhcnNbbmV4dGNoYXJdKSkge1xyXG4gICAgICAgICAgdG9rZW5pemVyID0gY2hhcmFjdGVyX3JlZmVyZW5jZV9lbmRfc3RhdGU7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgYmVnaW5UZW1wQnVmKCk7XHJcbiAgICB2YXIgcnYgPSBuYW1lZENoYXJSZWZzW25hbWVdO1xyXG4gICAgaWYgKHR5cGVvZiBydiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgdGVtcGJ1Zi5wdXNoKHJ2KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHB1c2hBbGwodGVtcGJ1ZiwgcnYpO1xyXG4gICAgfVxyXG4gICAgdG9rZW5pemVyID0gY2hhcmFjdGVyX3JlZmVyZW5jZV9lbmRfc3RhdGU7XHJcbiAgfVxyXG4gIC8vIFdlIG1pZ2h0IG5lZWQgdG8gcGF1c2UgdG9rZW5pemF0aW9uIHVudGlsIHdlIGhhdmUgZW5vdWdoIGNoYXJhY3RlcnNcclxuICAvLyBpbiB0aGUgYnVmZmVyIGZvciBsb25nZXN0IHBvc3NpYmxlIGNoYXJhY3RlciByZWZlcmVuY2UuXHJcbiAgbmFtZWRfY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGF0ZS5sb29rYWhlYWQgPSAtTkFNRURDSEFSUkVGX01BWExFTjtcclxuXHJcbiAgZnVuY3Rpb24gbnVtZXJpY19jaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlKGMpIHtcclxuICAgIGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSA9IDA7XHJcbiAgICBzd2l0Y2goYykge1xyXG4gICAgY2FzZSAweDAwNzg6IC8vIHhcclxuICAgIGNhc2UgMHgwMDU4OiAvLyBYXHJcbiAgICAgIHRlbXBidWYucHVzaChjKTtcclxuICAgICAgdG9rZW5pemVyID0gaGV4YWRlY2ltYWxfY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGFydF9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZWNvbnN1bWUoYywgZGVjaW1hbF9jaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXJ0X3N0YXRlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBoZXhhZGVjaW1hbF9jaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXJ0X3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDAzMDogY2FzZSAweDAwMzE6IGNhc2UgMHgwMDMyOiBjYXNlIDB4MDAzMzogY2FzZSAweDAwMzQ6XHJcbiAgICBjYXNlIDB4MDAzNTogY2FzZSAweDAwMzY6IGNhc2UgMHgwMDM3OiBjYXNlIDB4MDAzODogY2FzZSAweDAwMzk6IC8vIFswLTldXHJcbiAgICBjYXNlIDB4MDA0MTogY2FzZSAweDAwNDI6IGNhc2UgMHgwMDQzOiBjYXNlIDB4MDA0NDogY2FzZSAweDAwNDU6XHJcbiAgICBjYXNlIDB4MDA0NjogLy8gW0EtRl1cclxuICAgIGNhc2UgMHgwMDYxOiBjYXNlIDB4MDA2MjogY2FzZSAweDAwNjM6IGNhc2UgMHgwMDY0OiBjYXNlIDB4MDA2NTpcclxuICAgIGNhc2UgMHgwMDY2OiAvLyBbYS1mXVxyXG4gICAgICByZWNvbnN1bWUoYywgaGV4YWRlY2ltYWxfY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGF0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmVjb25zdW1lKGMsIGNoYXJhY3Rlcl9yZWZlcmVuY2VfZW5kX3N0YXRlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkZWNpbWFsX2NoYXJhY3Rlcl9yZWZlcmVuY2Vfc3RhcnRfc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDMwOiBjYXNlIDB4MDAzMTogY2FzZSAweDAwMzI6IGNhc2UgMHgwMDMzOiBjYXNlIDB4MDAzNDpcclxuICAgIGNhc2UgMHgwMDM1OiBjYXNlIDB4MDAzNjogY2FzZSAweDAwMzc6IGNhc2UgMHgwMDM4OiBjYXNlIDB4MDAzOTogLy8gWzAtOV1cclxuICAgICAgcmVjb25zdW1lKGMsIGRlY2ltYWxfY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGF0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmVjb25zdW1lKGMsIGNoYXJhY3Rlcl9yZWZlcmVuY2VfZW5kX3N0YXRlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBoZXhhZGVjaW1hbF9jaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlKGMpIHtcclxuICAgIHN3aXRjaChjKSB7XHJcbiAgICBjYXNlIDB4MDA0MTogY2FzZSAweDAwNDI6IGNhc2UgMHgwMDQzOiBjYXNlIDB4MDA0NDogY2FzZSAweDAwNDU6XHJcbiAgICBjYXNlIDB4MDA0NjogLy8gW0EtRl1cclxuICAgICAgY2hhcmFjdGVyX3JlZmVyZW5jZV9jb2RlICo9IDE2O1xyXG4gICAgICBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgKz0gKGMgLSAweDAwMzcpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDYxOiBjYXNlIDB4MDA2MjogY2FzZSAweDAwNjM6IGNhc2UgMHgwMDY0OiBjYXNlIDB4MDA2NTpcclxuICAgIGNhc2UgMHgwMDY2OiAvLyBbYS1mXVxyXG4gICAgICBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgKj0gMTY7XHJcbiAgICAgIGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSArPSAoYyAtIDB4MDA1Nyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwMzA6IGNhc2UgMHgwMDMxOiBjYXNlIDB4MDAzMjogY2FzZSAweDAwMzM6IGNhc2UgMHgwMDM0OlxyXG4gICAgY2FzZSAweDAwMzU6IGNhc2UgMHgwMDM2OiBjYXNlIDB4MDAzNzogY2FzZSAweDAwMzg6IGNhc2UgMHgwMDM5OiAvLyBbMC05XVxyXG4gICAgICBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgKj0gMTY7XHJcbiAgICAgIGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSArPSAoYyAtIDB4MDAzMCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDAwM0I6IC8vIFNFTUlDT0xPTlxyXG4gICAgICB0b2tlbml6ZXIgPSBudW1lcmljX2NoYXJhY3Rlcl9yZWZlcmVuY2VfZW5kX3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJlY29uc3VtZShjLCBudW1lcmljX2NoYXJhY3Rlcl9yZWZlcmVuY2VfZW5kX3N0YXRlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkZWNpbWFsX2NoYXJhY3Rlcl9yZWZlcmVuY2Vfc3RhdGUoYykge1xyXG4gICAgc3dpdGNoKGMpIHtcclxuICAgIGNhc2UgMHgwMDMwOiBjYXNlIDB4MDAzMTogY2FzZSAweDAwMzI6IGNhc2UgMHgwMDMzOiBjYXNlIDB4MDAzNDpcclxuICAgIGNhc2UgMHgwMDM1OiBjYXNlIDB4MDAzNjogY2FzZSAweDAwMzc6IGNhc2UgMHgwMDM4OiBjYXNlIDB4MDAzOTogLy8gWzAtOV1cclxuICAgICAgY2hhcmFjdGVyX3JlZmVyZW5jZV9jb2RlICo9IDEwO1xyXG4gICAgICBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgKz0gKGMgLSAweDAwMzApO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMHgwMDNCOiAvLyBTRU1JQ09MT05cclxuICAgICAgdG9rZW5pemVyID0gbnVtZXJpY19jaGFyYWN0ZXJfcmVmZXJlbmNlX2VuZF9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZWNvbnN1bWUoYywgbnVtZXJpY19jaGFyYWN0ZXJfcmVmZXJlbmNlX2VuZF9zdGF0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbnVtZXJpY19jaGFyYWN0ZXJfcmVmZXJlbmNlX2VuZF9zdGF0ZShjKSB7XHJcbiAgICBpZiAoY2hhcmFjdGVyX3JlZmVyZW5jZV9jb2RlIGluIG51bWVyaWNDaGFyUmVmUmVwbGFjZW1lbnRzKSB7XHJcbiAgICAgIGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSA9IG51bWVyaWNDaGFyUmVmUmVwbGFjZW1lbnRzW2NoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZV07XHJcbiAgICB9IGVsc2UgaWYgKGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSA+IDB4MTBGRkZGIHx8IChjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgPj0gMHhEODAwICYmIGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSA8IDB4RTAwMCkpIHtcclxuICAgICAgY2hhcmFjdGVyX3JlZmVyZW5jZV9jb2RlID0gMHhGRkZEO1xyXG4gICAgfVxyXG5cclxuICAgIGJlZ2luVGVtcEJ1ZigpO1xyXG4gICAgaWYgKGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSA8PSAweEZGRkYpIHtcclxuICAgICAgdGVtcGJ1Zi5wdXNoKGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgPSBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgLSAweDEwMDAwO1xyXG4gICAgICAvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cclxuICAgICAgdGVtcGJ1Zi5wdXNoKDB4RDgwMCArIChjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgPj4gMTApKTtcclxuICAgICAgdGVtcGJ1Zi5wdXNoKDB4REMwMCArIChjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgJiAweDAzRkYpKTtcclxuICAgIH1cclxuICAgIHJlY29uc3VtZShjLCBjaGFyYWN0ZXJfcmVmZXJlbmNlX2VuZF9zdGF0ZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjaGFyYWN0ZXJfcmVmZXJlbmNlX2VuZF9zdGF0ZShjKSB7XHJcbiAgICBzd2l0Y2gocmV0dXJuX3N0YXRlKSB7XHJcbiAgICBjYXNlIGF0dHJpYnV0ZV92YWx1ZV9kb3VibGVfcXVvdGVkX3N0YXRlOlxyXG4gICAgY2FzZSBhdHRyaWJ1dGVfdmFsdWVfc2luZ2xlX3F1b3RlZF9zdGF0ZTpcclxuICAgIGNhc2UgYXR0cmlidXRlX3ZhbHVlX3VucXVvdGVkX3N0YXRlOlxyXG4gICAgICAvLyBhcHBlbmQgZWFjaCBjaGFyYWN0ZXIgdG8gdGhlIGN1cnJlbnQgYXR0cmlidXRlJ3MgdmFsdWVcclxuICAgICAgYXR0cnZhbHVlYnVmICs9IGJ1ZjJzdHIodGVtcGJ1Zik7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcHVzaEFsbCh0ZXh0cnVuLCB0ZW1wYnVmKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZWNvbnN1bWUoYywgcmV0dXJuX3N0YXRlKTtcclxuICB9XHJcblxyXG4gIC8qKipcclxuICAgKiBUaGUgdHJlZSBidWlsZGVyIGluc2VydGlvbiBtb2Rlc1xyXG4gICAqL1xyXG5cclxuICAvLyAxMS4yLjUuNC4xIFRoZSBcImluaXRpYWxcIiBpbnNlcnRpb24gbW9kZVxyXG4gIGZ1bmN0aW9uIGluaXRpYWxfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xyXG4gICAgc3dpdGNoKHQpIHtcclxuICAgIGNhc2UgMTogLy8gVEVYVFxyXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoTEVBRElOR1dTLCBcIlwiKTsgLy8gSWdub3JlIHNwYWNlc1xyXG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm47IC8vIEFyZSB3ZSBkb25lP1xyXG4gICAgICBicmVhazsgLy8gSGFuZGxlIGFueXRoaW5nIG5vbi1zcGFjZSB0ZXh0IGJlbG93XHJcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcclxuICAgICAgZG9jLl9hcHBlbmRDaGlsZChkb2MuY3JlYXRlQ29tbWVudCh2YWx1ZSkpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcclxuICAgICAgdmFyIG5hbWUgPSB2YWx1ZTtcclxuICAgICAgdmFyIHB1YmxpY2lkID0gYXJnMztcclxuICAgICAgdmFyIHN5c3RlbWlkID0gYXJnNDtcclxuICAgICAgLy8gVXNlIHRoZSBjb25zdHJ1Y3RvciBkaXJlY3RseSBpbnN0ZWFkIG9mXHJcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50VHlwZSBiZWNhdXNlIHRoZSBjcmVhdGVcclxuICAgICAgLy8gZnVuY3Rpb24gdGhyb3dzIGVycm9ycyBvbiBpbnZhbGlkIGNoYXJhY3RlcnMsIGFuZFxyXG4gICAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBwYXJzZXIgdG8gdGhyb3cgdGhlbS5cclxuICAgICAgZG9jLmFwcGVuZENoaWxkKG5ldyBEb2N1bWVudFR5cGUobmFtZSxwdWJsaWNpZCwgc3lzdGVtaWQpKTtcclxuXHJcbiAgICAgIC8vIE5vdGUgdGhhdCB0aGVyZSBpcyBubyBwdWJsaWMgQVBJIGZvciBzZXR0aW5nIHF1aXJrcyBtb2RlIFdlIGNhblxyXG4gICAgICAvLyBkbyB0aGlzIGhlcmUgYmVjYXVzZSB3ZSBoYXZlIGFjY2VzcyB0byBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzXHJcbiAgICAgIGlmIChmb3JjZV9xdWlya3MgfHxcclxuICAgICAgICBuYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiaHRtbFwiIHx8XHJcbiAgICAgICAgcXVpcmt5UHVibGljSWRzLnRlc3QocHVibGljaWQpIHx8XHJcbiAgICAgICAgKHN5c3RlbWlkICYmIHN5c3RlbWlkLnRvTG93ZXJDYXNlKCkgPT09IHF1aXJreVN5c3RlbUlkKSB8fFxyXG4gICAgICAgIChzeXN0ZW1pZCA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgIGNvbmRpdGlvbmFsbHlRdWlya3lQdWJsaWNJZHMudGVzdChwdWJsaWNpZCkpKVxyXG4gICAgICAgIGRvYy5fcXVpcmtzID0gdHJ1ZTtcclxuICAgICAgZWxzZSBpZiAobGltaXRlZFF1aXJreVB1YmxpY0lkcy50ZXN0KHB1YmxpY2lkKSB8fFxyXG4gICAgICAgICAgIChzeXN0ZW1pZCAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIGNvbmRpdGlvbmFsbHlRdWlya3lQdWJsaWNJZHMudGVzdChwdWJsaWNpZCkpKVxyXG4gICAgICAgIGRvYy5fbGltaXRlZFF1aXJrcyA9IHRydWU7XHJcbiAgICAgIHBhcnNlciA9IGJlZm9yZV9odG1sX21vZGU7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0YWdzIG9yIG5vbi13aGl0ZXNwYWNlIHRleHRcclxuICAgIGRvYy5fcXVpcmtzID0gdHJ1ZTtcclxuICAgIHBhcnNlciA9IGJlZm9yZV9odG1sX21vZGU7XHJcbiAgICBwYXJzZXIodCx2YWx1ZSxhcmczLGFyZzQpO1xyXG4gIH1cclxuXHJcbiAgLy8gMTEuMi41LjQuMiBUaGUgXCJiZWZvcmUgaHRtbFwiIGluc2VydGlvbiBtb2RlXHJcbiAgZnVuY3Rpb24gYmVmb3JlX2h0bWxfbW9kZSh0LHZhbHVlLGFyZzMsYXJnNCkge1xyXG4gICAgdmFyIGVsdDtcclxuICAgIHN3aXRjaCh0KSB7XHJcbiAgICBjYXNlIDE6IC8vIFRFWFRcclxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKExFQURJTkdXUywgXCJcIik7IC8vIElnbm9yZSBzcGFjZXNcclxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuOyAvLyBBcmUgd2UgZG9uZT9cclxuICAgICAgYnJlYWs7IC8vIEhhbmRsZSBhbnl0aGluZyBub24tc3BhY2UgdGV4dCBiZWxvd1xyXG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXHJcbiAgICAgIC8qIGlnbm9yZSB0aGUgdG9rZW4gKi9cclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXHJcbiAgICAgIGRvYy5fYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZUNvbW1lbnQodmFsdWUpKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSAyOiAvLyBUQUdcclxuICAgICAgaWYgKHZhbHVlID09PSBcImh0bWxcIikge1xyXG4gICAgICAgIGVsdCA9IGNyZWF0ZUhUTUxFbHQoZG9jLCB2YWx1ZSwgYXJnMyk7XHJcbiAgICAgICAgc3RhY2sucHVzaChlbHQpO1xyXG4gICAgICAgIGRvYy5hcHBlbmRDaGlsZChlbHQpO1xyXG4gICAgICAgIC8vIFhYWDogaGFuZGxlIGFwcGxpY2F0aW9uIGNhY2hlIGhlcmVcclxuICAgICAgICBwYXJzZXIgPSBiZWZvcmVfaGVhZF9tb2RlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMzogLy8gRU5EVEFHXHJcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xyXG4gICAgICBjYXNlIFwiaHRtbFwiOlxyXG4gICAgICBjYXNlIFwiaGVhZFwiOlxyXG4gICAgICBjYXNlIFwiYm9keVwiOlxyXG4gICAgICBjYXNlIFwiYnJcIjpcclxuICAgICAgICBicmVhazsgIC8vIGZhbGwgdGhyb3VnaCBvbiB0aGVzZVxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybjsgLy8gaWdub3JlIG1vc3QgZW5kIHRhZ3NcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFueXRoaW5nIHRoYXQgZGlkbid0IGdldCBoYW5kbGVkIGFib3ZlIGlzIGhhbmRsZWQgbGlrZSB0aGlzOlxyXG4gICAgZWx0ID0gY3JlYXRlSFRNTEVsdChkb2MsIFwiaHRtbFwiLCBudWxsKTtcclxuICAgIHN0YWNrLnB1c2goZWx0KTtcclxuICAgIGRvYy5hcHBlbmRDaGlsZChlbHQpO1xyXG4gICAgLy8gWFhYOiBoYW5kbGUgYXBwbGljYXRpb24gY2FjaGUgaGVyZVxyXG4gICAgcGFyc2VyID0gYmVmb3JlX2hlYWRfbW9kZTtcclxuICAgIHBhcnNlcih0LHZhbHVlLGFyZzMsYXJnNCk7XHJcbiAgfVxyXG5cclxuICAvLyAxMS4yLjUuNC4zIFRoZSBcImJlZm9yZSBoZWFkXCIgaW5zZXJ0aW9uIG1vZGVcclxuICBmdW5jdGlvbiBiZWZvcmVfaGVhZF9tb2RlKHQsdmFsdWUsYXJnMyxhcmc0KSB7XHJcbiAgICBzd2l0Y2godCkge1xyXG4gICAgY2FzZSAxOiAvLyBURVhUXHJcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShMRUFESU5HV1MsIFwiXCIpOyAgLy8gSWdub3JlIHNwYWNlc1xyXG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm47IC8vIEFyZSB3ZSBkb25lP1xyXG4gICAgICBicmVhazsgIC8vIEhhbmRsZSBhbnl0aGluZyBub24tc3BhY2UgdGV4dCBiZWxvd1xyXG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXHJcbiAgICAgIC8qIGlnbm9yZSB0aGUgdG9rZW4gKi9cclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXHJcbiAgICAgIGluc2VydENvbW1lbnQodmFsdWUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIDI6IC8vIFRBR1xyXG4gICAgICBzd2l0Y2godmFsdWUpIHtcclxuICAgICAgY2FzZSBcImh0bWxcIjpcclxuICAgICAgICBpbl9ib2R5X21vZGUodCx2YWx1ZSxhcmczLGFyZzQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcImhlYWRcIjpcclxuICAgICAgICB2YXIgZWx0ID0gaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xyXG4gICAgICAgIGhlYWRfZWxlbWVudF9wb2ludGVyID0gZWx0O1xyXG4gICAgICAgIHBhcnNlciA9IGluX2hlYWRfbW9kZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xyXG4gICAgICBzd2l0Y2godmFsdWUpIHtcclxuICAgICAgY2FzZSBcImh0bWxcIjpcclxuICAgICAgY2FzZSBcImhlYWRcIjpcclxuICAgICAgY2FzZSBcImJvZHlcIjpcclxuICAgICAgY2FzZSBcImJyXCI6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuOyAvLyBpZ25vcmUgbW9zdCBlbmQgdGFnc1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgbm90IGhhbmRsZWQgZXhwbGljaXRseSBhYm92ZVxyXG4gICAgYmVmb3JlX2hlYWRfbW9kZShUQUcsIFwiaGVhZFwiLCBudWxsKTsgLy8gY3JlYXRlIGEgaGVhZCB0YWdcclxuICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7IC8vIHRoZW4gdHJ5IGFnYWluIHdpdGggdGhpcyB0b2tlblxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5faGVhZF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XHJcbiAgICBzd2l0Y2godCkge1xyXG4gICAgY2FzZSAxOiAvLyBURVhUXHJcbiAgICAgIHZhciB3cyA9IHZhbHVlLm1hdGNoKExFQURJTkdXUyk7XHJcbiAgICAgIGlmICh3cykge1xyXG4gICAgICAgIGluc2VydFRleHQod3NbMF0pO1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKHdzWzBdLmxlbmd0aCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG4gICAgICBicmVhazsgLy8gSGFuZGxlIG5vbi13aGl0ZXNwYWNlIGJlbG93XHJcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcclxuICAgICAgaW5zZXJ0Q29tbWVudCh2YWx1ZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgNTogLy8gRE9DVFlQRVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIDI6IC8vIFRBR1xyXG4gICAgICBzd2l0Y2godmFsdWUpIHtcclxuICAgICAgY2FzZSBcImh0bWxcIjpcclxuICAgICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcIm1ldGFcIjpcclxuICAgICAgICAvLyBYWFg6XHJcbiAgICAgICAgLy8gTWF5IG5lZWQgdG8gY2hhbmdlIHRoZSBlbmNvZGluZyBiYXNlZCBvbiB0aGlzIHRhZ1xyXG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgY2FzZSBcImJhc2VcIjpcclxuICAgICAgY2FzZSBcImJhc2Vmb250XCI6XHJcbiAgICAgIGNhc2UgXCJiZ3NvdW5kXCI6XHJcbiAgICAgIGNhc2UgXCJsaW5rXCI6XHJcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xyXG4gICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcInRpdGxlXCI6XHJcbiAgICAgICAgcGFyc2VSQ0RBVEEodmFsdWUsIGFyZzMpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcIm5vc2NyaXB0XCI6XHJcbiAgICAgICAgaWYgKCFzY3JpcHRpbmdfZW5hYmxlZCkge1xyXG4gICAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xyXG4gICAgICAgICAgcGFyc2VyID0gaW5faGVhZF9ub3NjcmlwdF9tb2RlO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHNjcmlwdGluZyBpcyBlbmFibGVkLi4uXHJcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICBjYXNlIFwibm9mcmFtZXNcIjpcclxuICAgICAgY2FzZSBcInN0eWxlXCI6XHJcbiAgICAgICAgcGFyc2VSYXdUZXh0KHZhbHVlLGFyZzMpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcInNjcmlwdFwiOlxyXG4gICAgICAgIGluc2VydEVsZW1lbnQoZnVuY3Rpb24oZG9jKSB7XHJcbiAgICAgICAgICB2YXIgZWx0ID0gY3JlYXRlSFRNTEVsdChkb2MsIHZhbHVlLCBhcmczKTtcclxuICAgICAgICAgIGVsdC5fcGFyc2VyX2luc2VydGVkID0gdHJ1ZTtcclxuICAgICAgICAgIGVsdC5fZm9yY2VfYXN5bmMgPSBmYWxzZTtcclxuICAgICAgICAgIGlmIChmcmFnbWVudCkgZWx0Ll9hbHJlYWR5X3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgZmx1c2hUZXh0KCk7XHJcbiAgICAgICAgICByZXR1cm4gZWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX3N0YXRlO1xyXG4gICAgICAgIG9yaWdpbmFsSW5zZXJ0aW9uTW9kZSA9IHBhcnNlcjtcclxuICAgICAgICBwYXJzZXIgPSB0ZXh0X21vZGU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwidGVtcGxhdGVcIjpcclxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XHJcbiAgICAgICAgYWZlLmluc2VydE1hcmtlcigpO1xyXG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XHJcbiAgICAgICAgcGFyc2VyID0gaW5fdGVtcGxhdGVfbW9kZTtcclxuICAgICAgICB0ZW1wbGF0ZUluc2VydGlvbk1vZGVzLnB1c2gocGFyc2VyKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNhc2UgXCJoZWFkXCI6XHJcbiAgICAgICAgcmV0dXJuOyAvLyBpZ25vcmUgaXRcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMzogLy8gRU5EVEFHXHJcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xyXG4gICAgICBjYXNlIFwiaGVhZFwiOlxyXG4gICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHBhcnNlciA9IGFmdGVyX2hlYWRfbW9kZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNhc2UgXCJib2R5XCI6XHJcbiAgICAgIGNhc2UgXCJodG1sXCI6XHJcbiAgICAgIGNhc2UgXCJiclwiOlxyXG4gICAgICAgIGJyZWFrOyAvLyBoYW5kbGUgdGhlc2UgYXQgdGhlIGJvdHRvbSBvZiB0aGUgZnVuY3Rpb25cclxuICAgICAgY2FzZSBcInRlbXBsYXRlXCI6XHJcbiAgICAgICAgaWYgKCFzdGFjay5jb250YWlucyhcInRlbXBsYXRlXCIpKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YWNrLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3MobnVsbCwgXCJ0aG9yb3VnaFwiKTtcclxuICAgICAgICBzdGFjay5wb3BUYWcoXCJ0ZW1wbGF0ZVwiKTtcclxuICAgICAgICBhZmUuY2xlYXJUb01hcmtlcigpO1xyXG4gICAgICAgIHRlbXBsYXRlSW5zZXJ0aW9uTW9kZXMucG9wKCk7XHJcbiAgICAgICAgcmVzZXRJbnNlcnRpb25Nb2RlKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIC8vIGlnbm9yZSBhbnkgb3RoZXIgZW5kIHRhZ1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBub3QgaGFuZGxlZCBhYm92ZVxyXG4gICAgaW5faGVhZF9tb2RlKEVORFRBRywgXCJoZWFkXCIsIG51bGwpOyAgIC8vIHN5bnRoZXRpYyA8L2hlYWQ+XHJcbiAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpOyAgIC8vIFRoZW4gcmVkbyB0aGlzIG9uZVxyXG4gIH1cclxuXHJcbiAgLy8gMTMuMi41LjQuNSBUaGUgXCJpbiBoZWFkIG5vc2NyaXB0XCIgaW5zZXJ0aW9uIG1vZGVcclxuICBmdW5jdGlvbiBpbl9oZWFkX25vc2NyaXB0X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcclxuICAgIHN3aXRjaCh0KSB7XHJcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXHJcbiAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgMTogLy8gVEVYVFxyXG4gICAgICB2YXIgd3MgPSB2YWx1ZS5tYXRjaChMRUFESU5HV1MpO1xyXG4gICAgICBpZiAod3MpIHtcclxuICAgICAgICBpbl9oZWFkX21vZGUodCwgd3NbMF0pO1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKHdzWzBdLmxlbmd0aCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuOyAvLyBubyBtb3JlIHRleHRcclxuICAgICAgYnJlYWs7IC8vIEhhbmRsZSBub24td2hpdGVzcGFjZSBiZWxvd1xyXG4gICAgY2FzZSAyOiAvLyBUQUdcclxuICAgICAgc3dpdGNoKHZhbHVlKSB7XHJcbiAgICAgIGNhc2UgXCJodG1sXCI6XHJcbiAgICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNhc2UgXCJiYXNlZm9udFwiOlxyXG4gICAgICBjYXNlIFwiYmdzb3VuZFwiOlxyXG4gICAgICBjYXNlIFwibGlua1wiOlxyXG4gICAgICBjYXNlIFwibWV0YVwiOlxyXG4gICAgICBjYXNlIFwibm9mcmFtZXNcIjpcclxuICAgICAgY2FzZSBcInN0eWxlXCI6XHJcbiAgICAgICAgaW5faGVhZF9tb2RlKHQsIHZhbHVlLCBhcmczKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNhc2UgXCJoZWFkXCI6XHJcbiAgICAgIGNhc2UgXCJub3NjcmlwdFwiOlxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMzogLy8gRU5EVEFHXHJcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xyXG4gICAgICBjYXNlIFwibm9zY3JpcHRcIjpcclxuICAgICAgICBzdGFjay5wb3AoKTtcclxuICAgICAgICBwYXJzZXIgPSBpbl9oZWFkX21vZGU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwiYnJcIjpcclxuICAgICAgICBicmVhazsgIC8vIGdvZXMgdG8gdGhlIG91dGVyIGRlZmF1bHRcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm47IC8vIGlnbm9yZSBvdGhlciBlbmQgdGFnc1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIG5vdCBoYW5kbGVkIGFib3ZlXHJcbiAgICBpbl9oZWFkX25vc2NyaXB0X21vZGUoRU5EVEFHLCBcIm5vc2NyaXB0XCIsIG51bGwpO1xyXG4gICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFmdGVyX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xyXG4gICAgc3dpdGNoKHQpIHtcclxuICAgIGNhc2UgMTogLy8gVEVYVFxyXG4gICAgICB2YXIgd3MgPSB2YWx1ZS5tYXRjaChMRUFESU5HV1MpO1xyXG4gICAgICBpZiAod3MpIHtcclxuICAgICAgICBpbnNlcnRUZXh0KHdzWzBdKTtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZyh3c1swXS5sZW5ndGgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHJldHVybjtcclxuICAgICAgYnJlYWs7IC8vIEhhbmRsZSBub24td2hpdGVzcGFjZSBiZWxvd1xyXG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXHJcbiAgICAgIGluc2VydENvbW1lbnQodmFsdWUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSAyOiAvLyBUQUdcclxuICAgICAgc3dpdGNoKHZhbHVlKSB7XHJcbiAgICAgIGNhc2UgXCJodG1sXCI6XHJcbiAgICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNhc2UgXCJib2R5XCI6XHJcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xyXG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XHJcbiAgICAgICAgcGFyc2VyID0gaW5fYm9keV9tb2RlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcImZyYW1lc2V0XCI6XHJcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xyXG4gICAgICAgIHBhcnNlciA9IGluX2ZyYW1lc2V0X21vZGU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwiYmFzZVwiOlxyXG4gICAgICBjYXNlIFwiYmFzZWZvbnRcIjpcclxuICAgICAgY2FzZSBcImJnc291bmRcIjpcclxuICAgICAgY2FzZSBcImxpbmtcIjpcclxuICAgICAgY2FzZSBcIm1ldGFcIjpcclxuICAgICAgY2FzZSBcIm5vZnJhbWVzXCI6XHJcbiAgICAgIGNhc2UgXCJzY3JpcHRcIjpcclxuICAgICAgY2FzZSBcInN0eWxlXCI6XHJcbiAgICAgIGNhc2UgXCJ0ZW1wbGF0ZVwiOlxyXG4gICAgICBjYXNlIFwidGl0bGVcIjpcclxuICAgICAgICBzdGFjay5wdXNoKGhlYWRfZWxlbWVudF9wb2ludGVyKTtcclxuICAgICAgICBpbl9oZWFkX21vZGUoVEFHLCB2YWx1ZSwgYXJnMyk7XHJcbiAgICAgICAgc3RhY2sucmVtb3ZlRWxlbWVudChoZWFkX2VsZW1lbnRfcG9pbnRlcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwiaGVhZFwiOlxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMzogLy8gRU5EVEFHXHJcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xyXG4gICAgICBjYXNlIFwidGVtcGxhdGVcIjpcclxuICAgICAgICByZXR1cm4gaW5faGVhZF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgY2FzZSBcImJvZHlcIjpcclxuICAgICAgY2FzZSBcImh0bWxcIjpcclxuICAgICAgY2FzZSBcImJyXCI6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuOyAgLy8gaWdub3JlIGFueSBvdGhlciBlbmQgdGFnXHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgYWZ0ZXJfaGVhZF9tb2RlKFRBRywgXCJib2R5XCIsIG51bGwpO1xyXG4gICAgZnJhbWVzZXRfb2sgPSB0cnVlO1xyXG4gICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICB9XHJcblxyXG4gIC8vIDEzLjIuNS40LjcgVGhlIFwiaW4gYm9keVwiIGluc2VydGlvbiBtb2RlXHJcbiAgZnVuY3Rpb24gaW5fYm9keV9tb2RlKHQsdmFsdWUsYXJnMyxhcmc0KSB7XHJcbiAgICB2YXIgYm9keSwgaSwgbm9kZSwgZWx0O1xyXG4gICAgc3dpdGNoKHQpIHtcclxuICAgIGNhc2UgMTogLy8gVEVYVFxyXG4gICAgICBpZiAodGV4dEluY2x1ZGVzTlVMKSB7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKE5VTENIQVJTLCBcIlwiKTtcclxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgLy8gSWYgYW55IG5vbi1zcGFjZSBjaGFyYWN0ZXJzXHJcbiAgICAgIGlmIChmcmFtZXNldF9vayAmJiBOT05XUy50ZXN0KHZhbHVlKSlcclxuICAgICAgICBmcmFtZXNldF9vayA9IGZhbHNlO1xyXG4gICAgICBhZmVyZWNvbnN0cnVjdCgpO1xyXG4gICAgICBpbnNlcnRUZXh0KHZhbHVlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgNDogLy8gQ09NTUVOVFxyXG4gICAgICBpbnNlcnRDb21tZW50KHZhbHVlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSAtMTogLy8gRU9GXHJcbiAgICAgIGlmICh0ZW1wbGF0ZUluc2VydGlvbk1vZGVzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBpbl90ZW1wbGF0ZV9tb2RlKHQpO1xyXG4gICAgICB9XHJcbiAgICAgIHN0b3BQYXJzaW5nKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgMjogLy8gVEFHXHJcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xyXG4gICAgICBjYXNlIFwiaHRtbFwiOlxyXG4gICAgICAgIGlmIChzdGFjay5jb250YWlucyhcInRlbXBsYXRlXCIpKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYW5zZmVyQXR0cmlidXRlcyhhcmczLCBzdGFjay5lbGVtZW50c1swXSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwiYmFzZVwiOlxyXG4gICAgICBjYXNlIFwiYmFzZWZvbnRcIjpcclxuICAgICAgY2FzZSBcImJnc291bmRcIjpcclxuICAgICAgY2FzZSBcImxpbmtcIjpcclxuICAgICAgY2FzZSBcIm1ldGFcIjpcclxuICAgICAgY2FzZSBcIm5vZnJhbWVzXCI6XHJcbiAgICAgIGNhc2UgXCJzY3JpcHRcIjpcclxuICAgICAgY2FzZSBcInN0eWxlXCI6XHJcbiAgICAgIGNhc2UgXCJ0ZW1wbGF0ZVwiOlxyXG4gICAgICBjYXNlIFwidGl0bGVcIjpcclxuICAgICAgICBpbl9oZWFkX21vZGUoVEFHLCB2YWx1ZSwgYXJnMyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwiYm9keVwiOlxyXG4gICAgICAgIGJvZHkgPSBzdGFjay5lbGVtZW50c1sxXTtcclxuICAgICAgICBpZiAoIWJvZHkgfHwgIShib2R5IGluc3RhbmNlb2YgaW1wbC5IVE1MQm9keUVsZW1lbnQpIHx8XHJcbiAgICAgICAgICAgIHN0YWNrLmNvbnRhaW5zKFwidGVtcGxhdGVcIikpXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcclxuICAgICAgICB0cmFuc2ZlckF0dHJpYnV0ZXMoYXJnMywgYm9keSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwiZnJhbWVzZXRcIjpcclxuICAgICAgICBpZiAoIWZyYW1lc2V0X29rKSByZXR1cm47XHJcbiAgICAgICAgYm9keSA9IHN0YWNrLmVsZW1lbnRzWzFdO1xyXG4gICAgICAgIGlmICghYm9keSB8fCAhKGJvZHkgaW5zdGFuY2VvZiBpbXBsLkhUTUxCb2R5RWxlbWVudCkpXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKGJvZHkucGFyZW50Tm9kZSkgYm9keS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJvZHkpO1xyXG4gICAgICAgIHdoaWxlKCEoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MSHRtbEVsZW1lbnQpKVxyXG4gICAgICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xyXG4gICAgICAgIHBhcnNlciA9IGluX2ZyYW1lc2V0X21vZGU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcImFkZHJlc3NcIjpcclxuICAgICAgY2FzZSBcImFydGljbGVcIjpcclxuICAgICAgY2FzZSBcImFzaWRlXCI6XHJcbiAgICAgIGNhc2UgXCJibG9ja3F1b3RlXCI6XHJcbiAgICAgIGNhc2UgXCJjZW50ZXJcIjpcclxuICAgICAgY2FzZSBcImRldGFpbHNcIjpcclxuICAgICAgY2FzZSBcImRpYWxvZ1wiOlxyXG4gICAgICBjYXNlIFwiZGlyXCI6XHJcbiAgICAgIGNhc2UgXCJkaXZcIjpcclxuICAgICAgY2FzZSBcImRsXCI6XHJcbiAgICAgIGNhc2UgXCJmaWVsZHNldFwiOlxyXG4gICAgICBjYXNlIFwiZmlnY2FwdGlvblwiOlxyXG4gICAgICBjYXNlIFwiZmlndXJlXCI6XHJcbiAgICAgIGNhc2UgXCJmb290ZXJcIjpcclxuICAgICAgY2FzZSBcImhlYWRlclwiOlxyXG4gICAgICBjYXNlIFwiaGdyb3VwXCI6XHJcbiAgICAgIGNhc2UgXCJtYWluXCI6XHJcbiAgICAgIGNhc2UgXCJuYXZcIjpcclxuICAgICAgY2FzZSBcIm9sXCI6XHJcbiAgICAgIGNhc2UgXCJwXCI6XHJcbiAgICAgIGNhc2UgXCJzZWN0aW9uXCI6XHJcbiAgICAgIGNhc2UgXCJzdW1tYXJ5XCI6XHJcbiAgICAgIGNhc2UgXCJ1bFwiOlxyXG4gICAgICAgIGlmIChzdGFjay5pbkJ1dHRvblNjb3BlKFwicFwiKSkgaW5fYm9keV9tb2RlKEVORFRBRywgXCJwXCIpO1xyXG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBjYXNlIFwibWVudVwiOlxyXG4gICAgICAgIGlmIChzdGFjay5pbkJ1dHRvblNjb3BlKFwicFwiKSkgaW5fYm9keV9tb2RlKEVORFRBRywgXCJwXCIpO1xyXG4gICAgICAgIGlmIChpc0Eoc3RhY2sudG9wLCAnbWVudWl0ZW0nKSkge1xyXG4gICAgICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBjYXNlIFwiaDFcIjpcclxuICAgICAgY2FzZSBcImgyXCI6XHJcbiAgICAgIGNhc2UgXCJoM1wiOlxyXG4gICAgICBjYXNlIFwiaDRcIjpcclxuICAgICAgY2FzZSBcImg1XCI6XHJcbiAgICAgIGNhc2UgXCJoNlwiOlxyXG4gICAgICAgIGlmIChzdGFjay5pbkJ1dHRvblNjb3BlKFwicFwiKSkgaW5fYm9keV9tb2RlKEVORFRBRywgXCJwXCIpO1xyXG4gICAgICAgIGlmIChzdGFjay50b3AgaW5zdGFuY2VvZiBpbXBsLkhUTUxIZWFkaW5nRWxlbWVudClcclxuICAgICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBjYXNlIFwicHJlXCI6XHJcbiAgICAgIGNhc2UgXCJsaXN0aW5nXCI6XHJcbiAgICAgICAgaWYgKHN0YWNrLmluQnV0dG9uU2NvcGUoXCJwXCIpKSBpbl9ib2R5X21vZGUoRU5EVEFHLCBcInBcIik7XHJcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xyXG4gICAgICAgIGlnbm9yZV9saW5lZmVlZCA9IHRydWU7XHJcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBjYXNlIFwiZm9ybVwiOlxyXG4gICAgICAgIGlmIChmb3JtX2VsZW1lbnRfcG9pbnRlciAmJiAhc3RhY2suY29udGFpbnMoXCJ0ZW1wbGF0ZVwiKSkgcmV0dXJuO1xyXG4gICAgICAgIGlmIChzdGFjay5pbkJ1dHRvblNjb3BlKFwicFwiKSkgaW5fYm9keV9tb2RlKEVORFRBRywgXCJwXCIpO1xyXG4gICAgICAgIGVsdCA9IGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcclxuICAgICAgICBpZiAoIXN0YWNrLmNvbnRhaW5zKFwidGVtcGxhdGVcIikpXHJcbiAgICAgICAgICBmb3JtX2VsZW1lbnRfcG9pbnRlciA9IGVsdDtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBjYXNlIFwibGlcIjpcclxuICAgICAgICBmcmFtZXNldF9vayA9IGZhbHNlO1xyXG4gICAgICAgIGZvcihpID0gc3RhY2suZWxlbWVudHMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICBub2RlID0gc3RhY2suZWxlbWVudHNbaV07XHJcbiAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGltcGwuSFRNTExJRWxlbWVudCkge1xyXG4gICAgICAgICAgICBpbl9ib2R5X21vZGUoRU5EVEFHLCBcImxpXCIpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChpc0Eobm9kZSwgc3BlY2lhbFNldCkgJiYgIWlzQShub2RlLCBhZGRyZXNzZGl2cFNldCkpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhY2suaW5CdXR0b25TY29wZShcInBcIikpIGluX2JvZHlfbW9kZShFTkRUQUcsIFwicFwiKTtcclxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcImRkXCI6XHJcbiAgICAgIGNhc2UgXCJkdFwiOlxyXG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XHJcbiAgICAgICAgZm9yKGkgPSBzdGFjay5lbGVtZW50cy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgIG5vZGUgPSBzdGFjay5lbGVtZW50c1tpXTtcclxuICAgICAgICAgIGlmIChpc0Eobm9kZSwgZGRkdFNldCkpIHtcclxuICAgICAgICAgICAgaW5fYm9keV9tb2RlKEVORFRBRywgbm9kZS5sb2NhbE5hbWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChpc0Eobm9kZSwgc3BlY2lhbFNldCkgJiYgIWlzQShub2RlLCBhZGRyZXNzZGl2cFNldCkpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhY2suaW5CdXR0b25TY29wZShcInBcIikpIGluX2JvZHlfbW9kZShFTkRUQUcsIFwicFwiKTtcclxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcInBsYWludGV4dFwiOlxyXG4gICAgICAgIGlmIChzdGFjay5pbkJ1dHRvblNjb3BlKFwicFwiKSkgaW5fYm9keV9tb2RlKEVORFRBRywgXCJwXCIpO1xyXG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcclxuICAgICAgICB0b2tlbml6ZXIgPSBwbGFpbnRleHRfc3RhdGU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcImJ1dHRvblwiOlxyXG4gICAgICAgIGlmIChzdGFjay5pblNjb3BlKFwiYnV0dG9uXCIpKSB7XHJcbiAgICAgICAgICBpbl9ib2R5X21vZGUoRU5EVEFHLCBcImJ1dHRvblwiKTtcclxuICAgICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcclxuICAgICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcclxuICAgICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJhXCI6XHJcbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBhZmUuZmluZEVsZW1lbnRCeVRhZyhcImFcIik7XHJcbiAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcclxuICAgICAgICAgIGluX2JvZHlfbW9kZShFTkRUQUcsIHZhbHVlKTtcclxuICAgICAgICAgIGFmZS5yZW1vdmUoYWN0aXZlRWxlbWVudCk7XHJcbiAgICAgICAgICBzdGFjay5yZW1vdmVFbGVtZW50KGFjdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgIGNhc2UgXCJiXCI6XHJcbiAgICAgIGNhc2UgXCJiaWdcIjpcclxuICAgICAgY2FzZSBcImNvZGVcIjpcclxuICAgICAgY2FzZSBcImVtXCI6XHJcbiAgICAgIGNhc2UgXCJmb250XCI6XHJcbiAgICAgIGNhc2UgXCJpXCI6XHJcbiAgICAgIGNhc2UgXCJzXCI6XHJcbiAgICAgIGNhc2UgXCJzbWFsbFwiOlxyXG4gICAgICBjYXNlIFwic3RyaWtlXCI6XHJcbiAgICAgIGNhc2UgXCJzdHJvbmdcIjpcclxuICAgICAgY2FzZSBcInR0XCI6XHJcbiAgICAgIGNhc2UgXCJ1XCI6XHJcbiAgICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcclxuICAgICAgICBhZmUucHVzaChpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKSwgYXJnMyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcIm5vYnJcIjpcclxuICAgICAgICBhZmVyZWNvbnN0cnVjdCgpO1xyXG5cclxuICAgICAgICBpZiAoc3RhY2suaW5TY29wZSh2YWx1ZSkpIHtcclxuICAgICAgICAgIGluX2JvZHlfbW9kZShFTkRUQUcsIHZhbHVlKTtcclxuICAgICAgICAgIGFmZXJlY29uc3RydWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFmZS5wdXNoKGluc2VydEhUTUxFbGVtZW50KHZhbHVlLGFyZzMpLCBhcmczKTtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBjYXNlIFwiYXBwbGV0XCI6XHJcbiAgICAgIGNhc2UgXCJtYXJxdWVlXCI6XHJcbiAgICAgIGNhc2UgXCJvYmplY3RcIjpcclxuICAgICAgICBhZmVyZWNvbnN0cnVjdCgpO1xyXG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLGFyZzMpO1xyXG4gICAgICAgIGFmZS5pbnNlcnRNYXJrZXIoKTtcclxuICAgICAgICBmcmFtZXNldF9vayA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJ0YWJsZVwiOlxyXG4gICAgICAgIGlmICghZG9jLl9xdWlya3MgJiYgc3RhY2suaW5CdXR0b25TY29wZShcInBcIikpIHtcclxuICAgICAgICAgIGluX2JvZHlfbW9kZShFTkRUQUcsIFwicFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XHJcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcclxuICAgICAgICBwYXJzZXIgPSBpbl90YWJsZV9tb2RlO1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJhcmVhXCI6XHJcbiAgICAgIGNhc2UgXCJiclwiOlxyXG4gICAgICBjYXNlIFwiZW1iZWRcIjpcclxuICAgICAgY2FzZSBcImltZ1wiOlxyXG4gICAgICBjYXNlIFwia2V5Z2VuXCI6XHJcbiAgICAgIGNhc2UgXCJ3YnJcIjpcclxuICAgICAgICBhZmVyZWNvbnN0cnVjdCgpO1xyXG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLGFyZzMpO1xyXG4gICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcImlucHV0XCI6XHJcbiAgICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcclxuICAgICAgICBlbHQgPSBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKTtcclxuICAgICAgICBzdGFjay5wb3AoKTtcclxuICAgICAgICB2YXIgdHlwZSA9IGVsdC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xyXG4gICAgICAgIGlmICghdHlwZSB8fCB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IFwiaGlkZGVuXCIpXHJcbiAgICAgICAgICBmcmFtZXNldF9vayA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJwYXJhbVwiOlxyXG4gICAgICBjYXNlIFwic291cmNlXCI6XHJcbiAgICAgIGNhc2UgXCJ0cmFja1wiOlxyXG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLGFyZzMpO1xyXG4gICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJoclwiOlxyXG4gICAgICAgIGlmIChzdGFjay5pbkJ1dHRvblNjb3BlKFwicFwiKSkgaW5fYm9keV9tb2RlKEVORFRBRywgXCJwXCIpO1xyXG4gICAgICAgIGlmIChpc0Eoc3RhY2sudG9wLCAnbWVudWl0ZW0nKSkge1xyXG4gICAgICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLGFyZzMpO1xyXG4gICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcImltYWdlXCI6XHJcbiAgICAgICAgaW5fYm9keV9tb2RlKFRBRywgXCJpbWdcIiwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcInRleHRhcmVhXCI6XHJcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XHJcbiAgICAgICAgaWdub3JlX2xpbmVmZWVkID0gdHJ1ZTtcclxuICAgICAgICBmcmFtZXNldF9vayA9IGZhbHNlO1xyXG4gICAgICAgIHRva2VuaXplciA9IHJjZGF0YV9zdGF0ZTtcclxuICAgICAgICBvcmlnaW5hbEluc2VydGlvbk1vZGUgPSBwYXJzZXI7XHJcbiAgICAgICAgcGFyc2VyID0gdGV4dF9tb2RlO1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJ4bXBcIjpcclxuICAgICAgICBpZiAoc3RhY2suaW5CdXR0b25TY29wZShcInBcIikpIGluX2JvZHlfbW9kZShFTkRUQUcsIFwicFwiKTtcclxuICAgICAgICBhZmVyZWNvbnN0cnVjdCgpO1xyXG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XHJcbiAgICAgICAgcGFyc2VSYXdUZXh0KHZhbHVlLCBhcmczKTtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBjYXNlIFwiaWZyYW1lXCI6XHJcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcclxuICAgICAgICBwYXJzZVJhd1RleHQodmFsdWUsIGFyZzMpO1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJub2VtYmVkXCI6XHJcbiAgICAgICAgcGFyc2VSYXdUZXh0KHZhbHVlLGFyZzMpO1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJub3NjcmlwdFwiOlxyXG4gICAgICAgIGlmIChzY3JpcHRpbmdfZW5hYmxlZCkge1xyXG4gICAgICAgICAgcGFyc2VSYXdUZXh0KHZhbHVlLGFyZzMpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhazsgIC8vIFhYWCBPdGhlcndpc2UgdHJlYXQgaXQgYXMgYW55IG90aGVyIG9wZW4gdGFnP1xyXG5cclxuICAgICAgY2FzZSBcInNlbGVjdFwiOlxyXG4gICAgICAgIGFmZXJlY29uc3RydWN0KCk7XHJcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XHJcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcclxuICAgICAgICBpZiAocGFyc2VyID09PSBpbl90YWJsZV9tb2RlIHx8XHJcbiAgICAgICAgICBwYXJzZXIgPT09IGluX2NhcHRpb25fbW9kZSB8fFxyXG4gICAgICAgICAgcGFyc2VyID09PSBpbl90YWJsZV9ib2R5X21vZGUgfHxcclxuICAgICAgICAgIHBhcnNlciA9PT0gaW5fcm93X21vZGUgfHxcclxuICAgICAgICAgIHBhcnNlciA9PT0gaW5fY2VsbF9tb2RlKVxyXG4gICAgICAgICAgcGFyc2VyID0gaW5fc2VsZWN0X2luX3RhYmxlX21vZGU7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgcGFyc2VyID0gaW5fc2VsZWN0X21vZGU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcIm9wdGdyb3VwXCI6XHJcbiAgICAgIGNhc2UgXCJvcHRpb25cIjpcclxuICAgICAgICBpZiAoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MT3B0aW9uRWxlbWVudCkge1xyXG4gICAgICAgICAgaW5fYm9keV9tb2RlKEVORFRBRywgXCJvcHRpb25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFmZXJlY29uc3RydWN0KCk7XHJcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcIm1lbnVpdGVtXCI6XHJcbiAgICAgICAgaWYgKGlzQShzdGFjay50b3AsICdtZW51aXRlbScpKSB7XHJcbiAgICAgICAgICBzdGFjay5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcclxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcInJiXCI6XHJcbiAgICAgIGNhc2UgXCJydGNcIjpcclxuICAgICAgICBpZiAoc3RhY2suaW5TY29wZShcInJ1YnlcIikpIHtcclxuICAgICAgICAgIHN0YWNrLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3MoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcInJwXCI6XHJcbiAgICAgIGNhc2UgXCJydFwiOlxyXG4gICAgICAgIGlmIChzdGFjay5pblNjb3BlKFwicnVieVwiKSkge1xyXG4gICAgICAgICAgc3RhY2suZ2VuZXJhdGVJbXBsaWVkRW5kVGFncyhcInJ0Y1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcIm1hdGhcIjpcclxuICAgICAgICBhZmVyZWNvbnN0cnVjdCgpO1xyXG4gICAgICAgIGFkanVzdE1hdGhNTEF0dHJpYnV0ZXMoYXJnMyk7XHJcbiAgICAgICAgYWRqdXN0Rm9yZWlnbkF0dHJpYnV0ZXMoYXJnMyk7XHJcbiAgICAgICAgaW5zZXJ0Rm9yZWlnbkVsZW1lbnQodmFsdWUsIGFyZzMsIE5BTUVTUEFDRS5NQVRITUwpO1xyXG4gICAgICAgIGlmIChhcmc0KSAvLyBzZWxmLWNsb3NpbmcgZmxhZ1xyXG4gICAgICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcInN2Z1wiOlxyXG4gICAgICAgIGFmZXJlY29uc3RydWN0KCk7XHJcbiAgICAgICAgYWRqdXN0U1ZHQXR0cmlidXRlcyhhcmczKTtcclxuICAgICAgICBhZGp1c3RGb3JlaWduQXR0cmlidXRlcyhhcmczKTtcclxuICAgICAgICBpbnNlcnRGb3JlaWduRWxlbWVudCh2YWx1ZSwgYXJnMywgTkFNRVNQQUNFLlNWRyk7XHJcbiAgICAgICAgaWYgKGFyZzQpIC8vIHNlbGYtY2xvc2luZyBmbGFnXHJcbiAgICAgICAgICBzdGFjay5wb3AoKTtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBjYXNlIFwiY2FwdGlvblwiOlxyXG4gICAgICBjYXNlIFwiY29sXCI6XHJcbiAgICAgIGNhc2UgXCJjb2xncm91cFwiOlxyXG4gICAgICBjYXNlIFwiZnJhbWVcIjpcclxuICAgICAgY2FzZSBcImhlYWRcIjpcclxuICAgICAgY2FzZSBcInRib2R5XCI6XHJcbiAgICAgIGNhc2UgXCJ0ZFwiOlxyXG4gICAgICBjYXNlIFwidGZvb3RcIjpcclxuICAgICAgY2FzZSBcInRoXCI6XHJcbiAgICAgIGNhc2UgXCJ0aGVhZFwiOlxyXG4gICAgICBjYXNlIFwidHJcIjpcclxuICAgICAgICAvLyBJZ25vcmUgdGFibGUgdGFncyBpZiB3ZSdyZSBub3QgaW5fdGFibGUgbW9kZVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSGFuZGxlIGFueSBvdGhlciBzdGFydCB0YWcgaGVyZVxyXG4gICAgICAvLyAoYW5kIGFsc28gbm9zY3JpcHQgdGFncyB3aGVuIHNjcmlwdGluZyBpcyBkaXNhYmxlZClcclxuICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcclxuICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xyXG4gICAgICBzd2l0Y2godmFsdWUpIHtcclxuICAgICAgY2FzZSBcInRlbXBsYXRlXCI6XHJcbiAgICAgICAgaW5faGVhZF9tb2RlKEVORFRBRywgdmFsdWUsIGFyZzMpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcImJvZHlcIjpcclxuICAgICAgICBpZiAoIXN0YWNrLmluU2NvcGUoXCJib2R5XCIpKSByZXR1cm47XHJcbiAgICAgICAgcGFyc2VyID0gYWZ0ZXJfYm9keV9tb2RlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcImh0bWxcIjpcclxuICAgICAgICBpZiAoIXN0YWNrLmluU2NvcGUoXCJib2R5XCIpKSByZXR1cm47XHJcbiAgICAgICAgcGFyc2VyID0gYWZ0ZXJfYm9keV9tb2RlO1xyXG4gICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcImFkZHJlc3NcIjpcclxuICAgICAgY2FzZSBcImFydGljbGVcIjpcclxuICAgICAgY2FzZSBcImFzaWRlXCI6XHJcbiAgICAgIGNhc2UgXCJibG9ja3F1b3RlXCI6XHJcbiAgICAgIGNhc2UgXCJidXR0b25cIjpcclxuICAgICAgY2FzZSBcImNlbnRlclwiOlxyXG4gICAgICBjYXNlIFwiZGV0YWlsc1wiOlxyXG4gICAgICBjYXNlIFwiZGlhbG9nXCI6XHJcbiAgICAgIGNhc2UgXCJkaXJcIjpcclxuICAgICAgY2FzZSBcImRpdlwiOlxyXG4gICAgICBjYXNlIFwiZGxcIjpcclxuICAgICAgY2FzZSBcImZpZWxkc2V0XCI6XHJcbiAgICAgIGNhc2UgXCJmaWdjYXB0aW9uXCI6XHJcbiAgICAgIGNhc2UgXCJmaWd1cmVcIjpcclxuICAgICAgY2FzZSBcImZvb3RlclwiOlxyXG4gICAgICBjYXNlIFwiaGVhZGVyXCI6XHJcbiAgICAgIGNhc2UgXCJoZ3JvdXBcIjpcclxuICAgICAgY2FzZSBcImxpc3RpbmdcIjpcclxuICAgICAgY2FzZSBcIm1haW5cIjpcclxuICAgICAgY2FzZSBcIm1lbnVcIjpcclxuICAgICAgY2FzZSBcIm5hdlwiOlxyXG4gICAgICBjYXNlIFwib2xcIjpcclxuICAgICAgY2FzZSBcInByZVwiOlxyXG4gICAgICBjYXNlIFwic2VjdGlvblwiOlxyXG4gICAgICBjYXNlIFwic3VtbWFyeVwiOlxyXG4gICAgICBjYXNlIFwidWxcIjpcclxuICAgICAgICAvLyBJZ25vcmUgaWYgdGhlcmUgaXMgbm90IGEgbWF0Y2hpbmcgb3BlbiB0YWdcclxuICAgICAgICBpZiAoIXN0YWNrLmluU2NvcGUodmFsdWUpKSByZXR1cm47XHJcbiAgICAgICAgc3RhY2suZ2VuZXJhdGVJbXBsaWVkRW5kVGFncygpO1xyXG4gICAgICAgIHN0YWNrLnBvcFRhZyh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcImZvcm1cIjpcclxuICAgICAgICBpZiAoIXN0YWNrLmNvbnRhaW5zKFwidGVtcGxhdGVcIikpIHtcclxuICAgICAgICAgIHZhciBvcGVuZm9ybSA9IGZvcm1fZWxlbWVudF9wb2ludGVyO1xyXG4gICAgICAgICAgZm9ybV9lbGVtZW50X3BvaW50ZXIgPSBudWxsO1xyXG4gICAgICAgICAgaWYgKCFvcGVuZm9ybSB8fCAhc3RhY2suZWxlbWVudEluU2NvcGUob3BlbmZvcm0pKSByZXR1cm47XHJcbiAgICAgICAgICBzdGFjay5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKCk7XHJcbiAgICAgICAgICBzdGFjay5yZW1vdmVFbGVtZW50KG9wZW5mb3JtKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCFzdGFjay5pblNjb3BlKFwiZm9ybVwiKSkgcmV0dXJuO1xyXG4gICAgICAgICAgc3RhY2suZ2VuZXJhdGVJbXBsaWVkRW5kVGFncygpO1xyXG4gICAgICAgICAgc3RhY2sucG9wVGFnKFwiZm9ybVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcInBcIjpcclxuICAgICAgICBpZiAoIXN0YWNrLmluQnV0dG9uU2NvcGUodmFsdWUpKSB7XHJcbiAgICAgICAgICBpbl9ib2R5X21vZGUoVEFHLCB2YWx1ZSwgbnVsbCk7XHJcbiAgICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHN0YWNrLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3ModmFsdWUpO1xyXG4gICAgICAgICAgc3RhY2sucG9wVGFnKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcImxpXCI6XHJcbiAgICAgICAgaWYgKCFzdGFjay5pbkxpc3RJdGVtU2NvcGUodmFsdWUpKSByZXR1cm47XHJcbiAgICAgICAgc3RhY2suZ2VuZXJhdGVJbXBsaWVkRW5kVGFncyh2YWx1ZSk7XHJcbiAgICAgICAgc3RhY2sucG9wVGFnKHZhbHVlKTtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBjYXNlIFwiZGRcIjpcclxuICAgICAgY2FzZSBcImR0XCI6XHJcbiAgICAgICAgaWYgKCFzdGFjay5pblNjb3BlKHZhbHVlKSkgcmV0dXJuO1xyXG4gICAgICAgIHN0YWNrLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3ModmFsdWUpO1xyXG4gICAgICAgIHN0YWNrLnBvcFRhZyh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcImgxXCI6XHJcbiAgICAgIGNhc2UgXCJoMlwiOlxyXG4gICAgICBjYXNlIFwiaDNcIjpcclxuICAgICAgY2FzZSBcImg0XCI6XHJcbiAgICAgIGNhc2UgXCJoNVwiOlxyXG4gICAgICBjYXNlIFwiaDZcIjpcclxuICAgICAgICBpZiAoIXN0YWNrLmVsZW1lbnRUeXBlSW5TY29wZShpbXBsLkhUTUxIZWFkaW5nRWxlbWVudCkpIHJldHVybjtcclxuICAgICAgICBzdGFjay5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKCk7XHJcbiAgICAgICAgc3RhY2sucG9wRWxlbWVudFR5cGUoaW1wbC5IVE1MSGVhZGluZ0VsZW1lbnQpO1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJzYXJjYXNtXCI6XHJcbiAgICAgICAgLy8gVGFrZSBhIGRlZXAgYnJlYXRoLCBhbmQgdGhlbjpcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgXCJhXCI6XHJcbiAgICAgIGNhc2UgXCJiXCI6XHJcbiAgICAgIGNhc2UgXCJiaWdcIjpcclxuICAgICAgY2FzZSBcImNvZGVcIjpcclxuICAgICAgY2FzZSBcImVtXCI6XHJcbiAgICAgIGNhc2UgXCJmb250XCI6XHJcbiAgICAgIGNhc2UgXCJpXCI6XHJcbiAgICAgIGNhc2UgXCJub2JyXCI6XHJcbiAgICAgIGNhc2UgXCJzXCI6XHJcbiAgICAgIGNhc2UgXCJzbWFsbFwiOlxyXG4gICAgICBjYXNlIFwic3RyaWtlXCI6XHJcbiAgICAgIGNhc2UgXCJzdHJvbmdcIjpcclxuICAgICAgY2FzZSBcInR0XCI6XHJcbiAgICAgIGNhc2UgXCJ1XCI6XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGFkb3B0aW9uQWdlbmN5KHZhbHVlKTtcclxuICAgICAgICBpZiAocmVzdWx0KSByZXR1cm47ICAvLyBJZiB3ZSBkaWQgc29tZXRoaW5nIHdlJ3JlIGRvbmVcclxuICAgICAgICBicmVhazsgICAgICAgICAvLyBHbyB0byB0aGUgXCJhbnkgb3RoZXIgZW5kIHRhZ1wiIGNhc2VcclxuXHJcbiAgICAgIGNhc2UgXCJhcHBsZXRcIjpcclxuICAgICAgY2FzZSBcIm1hcnF1ZWVcIjpcclxuICAgICAgY2FzZSBcIm9iamVjdFwiOlxyXG4gICAgICAgIGlmICghc3RhY2suaW5TY29wZSh2YWx1ZSkpIHJldHVybjtcclxuICAgICAgICBzdGFjay5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKCk7XHJcbiAgICAgICAgc3RhY2sucG9wVGFnKHZhbHVlKTtcclxuICAgICAgICBhZmUuY2xlYXJUb01hcmtlcigpO1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJiclwiOlxyXG4gICAgICAgIGluX2JvZHlfbW9kZShUQUcsIHZhbHVlLCBudWxsKTsgIC8vIFR1cm4gPC9icj4gaW50byA8YnI+XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBbnkgb3RoZXIgZW5kIHRhZyBnb2VzIGhlcmVcclxuICAgICAgZm9yKGkgPSBzdGFjay5lbGVtZW50cy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBub2RlID0gc3RhY2suZWxlbWVudHNbaV07XHJcbiAgICAgICAgaWYgKGlzQShub2RlLCB2YWx1ZSkpIHtcclxuICAgICAgICAgIHN0YWNrLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3ModmFsdWUpO1xyXG4gICAgICAgICAgc3RhY2sucG9wRWxlbWVudChub2RlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0Eobm9kZSwgc3BlY2lhbFNldCkpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRleHRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xyXG4gICAgc3dpdGNoKHQpIHtcclxuICAgIGNhc2UgMTogLy8gVEVYVFxyXG4gICAgICBpbnNlcnRUZXh0KHZhbHVlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSAtMTogLy8gRU9GXHJcbiAgICAgIGlmIChzdGFjay50b3AgaW5zdGFuY2VvZiBpbXBsLkhUTUxTY3JpcHRFbGVtZW50KVxyXG4gICAgICAgIHN0YWNrLnRvcC5fYWxyZWFkeV9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgIHBhcnNlciA9IG9yaWdpbmFsSW5zZXJ0aW9uTW9kZTtcclxuICAgICAgcGFyc2VyKHQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xyXG4gICAgICBpZiAodmFsdWUgPT09IFwic2NyaXB0XCIpIHtcclxuICAgICAgICBoYW5kbGVTY3JpcHRFbmQoKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBzdGFjay5wb3AoKTtcclxuICAgICAgICBwYXJzZXIgPSBvcmlnaW5hbEluc2VydGlvbk1vZGU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIGdldCBhbnkgb3RoZXIgdG9rZW4gdHlwZXNcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5fdGFibGVfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xyXG4gICAgZnVuY3Rpb24gZ2V0VHlwZUF0dHIoYXR0cnMpIHtcclxuICAgICAgZm9yKHZhciBpID0gMCwgbiA9IGF0dHJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIGlmIChhdHRyc1tpXVswXSA9PT0gXCJ0eXBlXCIpXHJcbiAgICAgICAgICByZXR1cm4gYXR0cnNbaV1bMV0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBzd2l0Y2godCkge1xyXG4gICAgY2FzZSAxOiAvLyBURVhUXHJcbiAgICAgIC8vIFhYWCB0aGUgdGV4dF9pbnRlZ3JhdGlvbl9tb2RlIHN0dWZmIGlzXHJcbiAgICAgIC8vIGp1c3QgYSBoYWNrIEkgbWFkZSB1cFxyXG4gICAgICBpZiAodGV4dF9pbnRlZ3JhdGlvbl9tb2RlKSB7XHJcbiAgICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoaXNBKHN0YWNrLnRvcCwgdGFibGVzZWN0aW9ucm93U2V0KSkge1xyXG4gICAgICAgIHBlbmRpbmdfdGFibGVfdGV4dCA9IFtdO1xyXG4gICAgICAgIG9yaWdpbmFsSW5zZXJ0aW9uTW9kZSA9IHBhcnNlcjtcclxuICAgICAgICBwYXJzZXIgPSBpbl90YWJsZV90ZXh0X21vZGU7XHJcbiAgICAgICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcclxuICAgICAgaW5zZXJ0Q29tbWVudCh2YWx1ZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgNTogLy8gRE9DVFlQRVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIDI6IC8vIFRBR1xyXG4gICAgICBzd2l0Y2godmFsdWUpIHtcclxuICAgICAgY2FzZSBcImNhcHRpb25cIjpcclxuICAgICAgICBzdGFjay5jbGVhclRvQ29udGV4dCh0YWJsZUNvbnRleHRTZXQpO1xyXG4gICAgICAgIGFmZS5pbnNlcnRNYXJrZXIoKTtcclxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKTtcclxuICAgICAgICBwYXJzZXIgPSBpbl9jYXB0aW9uX21vZGU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcclxuICAgICAgICBzdGFjay5jbGVhclRvQ29udGV4dCh0YWJsZUNvbnRleHRTZXQpO1xyXG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLGFyZzMpO1xyXG4gICAgICAgIHBhcnNlciA9IGluX2NvbHVtbl9ncm91cF9tb2RlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcImNvbFwiOlxyXG4gICAgICAgIGluX3RhYmxlX21vZGUoVEFHLCBcImNvbGdyb3VwXCIsIG51bGwpO1xyXG4gICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwidGJvZHlcIjpcclxuICAgICAgY2FzZSBcInRmb290XCI6XHJcbiAgICAgIGNhc2UgXCJ0aGVhZFwiOlxyXG4gICAgICAgIHN0YWNrLmNsZWFyVG9Db250ZXh0KHRhYmxlQ29udGV4dFNldCk7XHJcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XHJcbiAgICAgICAgcGFyc2VyID0gaW5fdGFibGVfYm9keV9tb2RlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcInRkXCI6XHJcbiAgICAgIGNhc2UgXCJ0aFwiOlxyXG4gICAgICBjYXNlIFwidHJcIjpcclxuICAgICAgICBpbl90YWJsZV9tb2RlKFRBRywgXCJ0Ym9keVwiLCBudWxsKTtcclxuICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJ0YWJsZVwiOlxyXG4gICAgICAgIGlmICghc3RhY2suaW5UYWJsZVNjb3BlKHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgdGhlIHRva2VuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluX3RhYmxlX21vZGUoRU5EVEFHLCB2YWx1ZSk7XHJcbiAgICAgICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBjYXNlIFwic3R5bGVcIjpcclxuICAgICAgY2FzZSBcInNjcmlwdFwiOlxyXG4gICAgICBjYXNlIFwidGVtcGxhdGVcIjpcclxuICAgICAgICBpbl9oZWFkX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJpbnB1dFwiOlxyXG4gICAgICAgIHZhciB0eXBlID0gZ2V0VHlwZUF0dHIoYXJnMyk7XHJcbiAgICAgICAgaWYgKHR5cGUgIT09IFwiaGlkZGVuXCIpIGJyZWFrOyAgLy8gdG8gdGhlIGFueXRoaW5nIGVsc2UgY2FzZVxyXG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLGFyZzMpO1xyXG4gICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJmb3JtXCI6XHJcbiAgICAgICAgaWYgKGZvcm1fZWxlbWVudF9wb2ludGVyIHx8IHN0YWNrLmNvbnRhaW5zKFwidGVtcGxhdGVcIikpIHJldHVybjtcclxuICAgICAgICBmb3JtX2VsZW1lbnRfcG9pbnRlciA9IGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcclxuICAgICAgICBzdGFjay5wb3BFbGVtZW50KGZvcm1fZWxlbWVudF9wb2ludGVyKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xyXG4gICAgICBzd2l0Y2godmFsdWUpIHtcclxuICAgICAgY2FzZSBcInRhYmxlXCI6XHJcbiAgICAgICAgaWYgKCFzdGFjay5pblRhYmxlU2NvcGUodmFsdWUpKSByZXR1cm47XHJcbiAgICAgICAgc3RhY2sucG9wVGFnKHZhbHVlKTtcclxuICAgICAgICByZXNldEluc2VydGlvbk1vZGUoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNhc2UgXCJib2R5XCI6XHJcbiAgICAgIGNhc2UgXCJjYXB0aW9uXCI6XHJcbiAgICAgIGNhc2UgXCJjb2xcIjpcclxuICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XHJcbiAgICAgIGNhc2UgXCJodG1sXCI6XHJcbiAgICAgIGNhc2UgXCJ0Ym9keVwiOlxyXG4gICAgICBjYXNlIFwidGRcIjpcclxuICAgICAgY2FzZSBcInRmb290XCI6XHJcbiAgICAgIGNhc2UgXCJ0aFwiOlxyXG4gICAgICBjYXNlIFwidGhlYWRcIjpcclxuICAgICAgY2FzZSBcInRyXCI6XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwidGVtcGxhdGVcIjpcclxuICAgICAgICBpbl9oZWFkX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoaXMgaXMgdGhlIGFueXRoaW5nIGVsc2UgY2FzZVxyXG4gICAgZm9zdGVyX3BhcmVudF9tb2RlID0gdHJ1ZTtcclxuICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICBmb3N0ZXJfcGFyZW50X21vZGUgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluX3RhYmxlX3RleHRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xyXG4gICAgaWYgKHQgPT09IFRFWFQpIHtcclxuICAgICAgaWYgKHRleHRJbmNsdWRlc05VTCkge1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShOVUxDSEFSUywgXCJcIik7XHJcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHBlbmRpbmdfdGFibGVfdGV4dC5wdXNoKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICB2YXIgcyA9IHBlbmRpbmdfdGFibGVfdGV4dC5qb2luKFwiXCIpO1xyXG4gICAgICBwZW5kaW5nX3RhYmxlX3RleHQubGVuZ3RoID0gMDtcclxuICAgICAgaWYgKE5PTldTLnRlc3QocykpIHsgLy8gSWYgYW55IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnNcclxuICAgICAgICAvLyBUaGlzIG11c3QgYmUgdGhlIHNhbWUgY29kZSBhcyB0aGUgXCJhbnl0aGluZyBlbHNlXCJcclxuICAgICAgICAvLyBjYXNlIG9mIHRoZSBpbl90YWJsZSBtb2RlIGFib3ZlLlxyXG4gICAgICAgIGZvc3Rlcl9wYXJlbnRfbW9kZSA9IHRydWU7XHJcbiAgICAgICAgaW5fYm9keV9tb2RlKFRFWFQsIHMpO1xyXG4gICAgICAgIGZvc3Rlcl9wYXJlbnRfbW9kZSA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGluc2VydFRleHQocyk7XHJcbiAgICAgIH1cclxuICAgICAgcGFyc2VyID0gb3JpZ2luYWxJbnNlcnRpb25Nb2RlO1xyXG4gICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGluX2NhcHRpb25fbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xyXG4gICAgZnVuY3Rpb24gZW5kX2NhcHRpb24oKSB7XHJcbiAgICAgIGlmICghc3RhY2suaW5UYWJsZVNjb3BlKFwiY2FwdGlvblwiKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBzdGFjay5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKCk7XHJcbiAgICAgIHN0YWNrLnBvcFRhZyhcImNhcHRpb25cIik7XHJcbiAgICAgIGFmZS5jbGVhclRvTWFya2VyKCk7XHJcbiAgICAgIHBhcnNlciA9IGluX3RhYmxlX21vZGU7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHN3aXRjaCh0KSB7XHJcbiAgICBjYXNlIDI6IC8vIFRBR1xyXG4gICAgICBzd2l0Y2godmFsdWUpIHtcclxuICAgICAgY2FzZSBcImNhcHRpb25cIjpcclxuICAgICAgY2FzZSBcImNvbFwiOlxyXG4gICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcclxuICAgICAgY2FzZSBcInRib2R5XCI6XHJcbiAgICAgIGNhc2UgXCJ0ZFwiOlxyXG4gICAgICBjYXNlIFwidGZvb3RcIjpcclxuICAgICAgY2FzZSBcInRoXCI6XHJcbiAgICAgIGNhc2UgXCJ0aGVhZFwiOlxyXG4gICAgICBjYXNlIFwidHJcIjpcclxuICAgICAgICBpZiAoZW5kX2NhcHRpb24oKSkgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xyXG4gICAgICBzd2l0Y2godmFsdWUpIHtcclxuICAgICAgY2FzZSBcImNhcHRpb25cIjpcclxuICAgICAgICBlbmRfY2FwdGlvbigpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcInRhYmxlXCI6XHJcbiAgICAgICAgaWYgKGVuZF9jYXB0aW9uKCkpIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwiYm9keVwiOlxyXG4gICAgICBjYXNlIFwiY29sXCI6XHJcbiAgICAgIGNhc2UgXCJjb2xncm91cFwiOlxyXG4gICAgICBjYXNlIFwiaHRtbFwiOlxyXG4gICAgICBjYXNlIFwidGJvZHlcIjpcclxuICAgICAgY2FzZSBcInRkXCI6XHJcbiAgICAgIGNhc2UgXCJ0Zm9vdFwiOlxyXG4gICAgICBjYXNlIFwidGhcIjpcclxuICAgICAgY2FzZSBcInRoZWFkXCI6XHJcbiAgICAgIGNhc2UgXCJ0clwiOlxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGUgQW55dGhpbmcgRWxzZSBjYXNlXHJcbiAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5fY29sdW1uX2dyb3VwX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcclxuICAgIHN3aXRjaCh0KSB7XHJcbiAgICBjYXNlIDE6IC8vIFRFWFRcclxuICAgICAgdmFyIHdzID0gdmFsdWUubWF0Y2goTEVBRElOR1dTKTtcclxuICAgICAgaWYgKHdzKSB7XHJcbiAgICAgICAgaW5zZXJ0VGV4dCh3c1swXSk7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcod3NbMF0ubGVuZ3RoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm47XHJcbiAgICAgIGJyZWFrOyAvLyBIYW5kbGUgbm9uLXdoaXRlc3BhY2UgYmVsb3dcclxuXHJcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcclxuICAgICAgaW5zZXJ0Q29tbWVudCh2YWx1ZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgNTogLy8gRE9DVFlQRVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIDI6IC8vIFRBR1xyXG4gICAgICBzd2l0Y2godmFsdWUpIHtcclxuICAgICAgY2FzZSBcImh0bWxcIjpcclxuICAgICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcImNvbFwiOlxyXG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcclxuICAgICAgICBzdGFjay5wb3AoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNhc2UgXCJ0ZW1wbGF0ZVwiOlxyXG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcclxuICAgICAgc3dpdGNoKHZhbHVlKSB7XHJcbiAgICAgIGNhc2UgXCJjb2xncm91cFwiOlxyXG4gICAgICAgIGlmICghaXNBKHN0YWNrLnRvcCwgJ2NvbGdyb3VwJykpIHtcclxuICAgICAgICAgIHJldHVybjsgLy8gSWdub3JlIHRoZSB0b2tlbi5cclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgICAgcGFyc2VyID0gaW5fdGFibGVfbW9kZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNhc2UgXCJjb2xcIjpcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNhc2UgXCJ0ZW1wbGF0ZVwiOlxyXG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAtMTogLy8gRU9GXHJcbiAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBbnl0aGluZyBlbHNlXHJcbiAgICBpZiAoIWlzQShzdGFjay50b3AsICdjb2xncm91cCcpKSB7XHJcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIHRoZSB0b2tlbi5cclxuICAgIH1cclxuICAgIGluX2NvbHVtbl9ncm91cF9tb2RlKEVORFRBRywgXCJjb2xncm91cFwiKTtcclxuICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbl90YWJsZV9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcclxuICAgIGZ1bmN0aW9uIGVuZHNlY3QoKSB7XHJcbiAgICAgIGlmICghc3RhY2suaW5UYWJsZVNjb3BlKFwidGJvZHlcIikgJiZcclxuICAgICAgICAhc3RhY2suaW5UYWJsZVNjb3BlKFwidGhlYWRcIikgJiZcclxuICAgICAgICAhc3RhY2suaW5UYWJsZVNjb3BlKFwidGZvb3RcIikpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBzdGFjay5jbGVhclRvQ29udGV4dCh0YWJsZUJvZHlDb250ZXh0U2V0KTtcclxuICAgICAgaW5fdGFibGVfYm9keV9tb2RlKEVORFRBRywgc3RhY2sudG9wLmxvY2FsTmFtZSwgbnVsbCk7XHJcbiAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoKHQpIHtcclxuICAgIGNhc2UgMjogLy8gVEFHXHJcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xyXG4gICAgICBjYXNlIFwidHJcIjpcclxuICAgICAgICBzdGFjay5jbGVhclRvQ29udGV4dCh0YWJsZUJvZHlDb250ZXh0U2V0KTtcclxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XHJcbiAgICAgICAgcGFyc2VyID0gaW5fcm93X21vZGU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwidGhcIjpcclxuICAgICAgY2FzZSBcInRkXCI6XHJcbiAgICAgICAgaW5fdGFibGVfYm9keV9tb2RlKFRBRywgXCJ0clwiLCBudWxsKTtcclxuICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcImNhcHRpb25cIjpcclxuICAgICAgY2FzZSBcImNvbFwiOlxyXG4gICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcclxuICAgICAgY2FzZSBcInRib2R5XCI6XHJcbiAgICAgIGNhc2UgXCJ0Zm9vdFwiOlxyXG4gICAgICBjYXNlIFwidGhlYWRcIjpcclxuICAgICAgICBlbmRzZWN0KCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcclxuICAgICAgc3dpdGNoKHZhbHVlKSB7XHJcbiAgICAgIGNhc2UgXCJ0YWJsZVwiOlxyXG4gICAgICAgIGVuZHNlY3QoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNhc2UgXCJ0Ym9keVwiOlxyXG4gICAgICBjYXNlIFwidGZvb3RcIjpcclxuICAgICAgY2FzZSBcInRoZWFkXCI6XHJcbiAgICAgICAgaWYgKHN0YWNrLmluVGFibGVTY29wZSh2YWx1ZSkpIHtcclxuICAgICAgICAgIHN0YWNrLmNsZWFyVG9Db250ZXh0KHRhYmxlQm9keUNvbnRleHRTZXQpO1xyXG4gICAgICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICBwYXJzZXIgPSBpbl90YWJsZV9tb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNhc2UgXCJib2R5XCI6XHJcbiAgICAgIGNhc2UgXCJjYXB0aW9uXCI6XHJcbiAgICAgIGNhc2UgXCJjb2xcIjpcclxuICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XHJcbiAgICAgIGNhc2UgXCJodG1sXCI6XHJcbiAgICAgIGNhc2UgXCJ0ZFwiOlxyXG4gICAgICBjYXNlIFwidGhcIjpcclxuICAgICAgY2FzZSBcInRyXCI6XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFueXRoaW5nIGVsc2U6XHJcbiAgICBpbl90YWJsZV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluX3Jvd19tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XHJcbiAgICBmdW5jdGlvbiBlbmRyb3coKSB7XHJcbiAgICAgIGlmICghc3RhY2suaW5UYWJsZVNjb3BlKFwidHJcIikpIHJldHVybiBmYWxzZTtcclxuICAgICAgc3RhY2suY2xlYXJUb0NvbnRleHQodGFibGVSb3dDb250ZXh0U2V0KTtcclxuICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgIHBhcnNlciA9IGluX3RhYmxlX2JvZHlfbW9kZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoKHQpIHtcclxuICAgIGNhc2UgMjogLy8gVEFHXHJcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xyXG4gICAgICBjYXNlIFwidGhcIjpcclxuICAgICAgY2FzZSBcInRkXCI6XHJcbiAgICAgICAgc3RhY2suY2xlYXJUb0NvbnRleHQodGFibGVSb3dDb250ZXh0U2V0KTtcclxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XHJcbiAgICAgICAgcGFyc2VyID0gaW5fY2VsbF9tb2RlO1xyXG4gICAgICAgIGFmZS5pbnNlcnRNYXJrZXIoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNhc2UgXCJjYXB0aW9uXCI6XHJcbiAgICAgIGNhc2UgXCJjb2xcIjpcclxuICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XHJcbiAgICAgIGNhc2UgXCJ0Ym9keVwiOlxyXG4gICAgICBjYXNlIFwidGZvb3RcIjpcclxuICAgICAgY2FzZSBcInRoZWFkXCI6XHJcbiAgICAgIGNhc2UgXCJ0clwiOlxyXG4gICAgICAgIGlmIChlbmRyb3coKSkgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xyXG4gICAgICBzd2l0Y2godmFsdWUpIHtcclxuICAgICAgY2FzZSBcInRyXCI6XHJcbiAgICAgICAgZW5kcm93KCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwidGFibGVcIjpcclxuICAgICAgICBpZiAoZW5kcm93KCkpIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwidGJvZHlcIjpcclxuICAgICAgY2FzZSBcInRmb290XCI6XHJcbiAgICAgIGNhc2UgXCJ0aGVhZFwiOlxyXG4gICAgICAgIGlmIChzdGFjay5pblRhYmxlU2NvcGUodmFsdWUpKSB7XHJcbiAgICAgICAgICBpZiAoZW5kcm93KCkpIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcImJvZHlcIjpcclxuICAgICAgY2FzZSBcImNhcHRpb25cIjpcclxuICAgICAgY2FzZSBcImNvbFwiOlxyXG4gICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcclxuICAgICAgY2FzZSBcImh0bWxcIjpcclxuICAgICAgY2FzZSBcInRkXCI6XHJcbiAgICAgIGNhc2UgXCJ0aFwiOlxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICAvLyBhbnl0aGluZyBlbHNlXHJcbiAgICBpbl90YWJsZV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluX2NlbGxfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xyXG4gICAgc3dpdGNoKHQpIHtcclxuICAgIGNhc2UgMjogLy8gVEFHXHJcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xyXG4gICAgICBjYXNlIFwiY2FwdGlvblwiOlxyXG4gICAgICBjYXNlIFwiY29sXCI6XHJcbiAgICAgIGNhc2UgXCJjb2xncm91cFwiOlxyXG4gICAgICBjYXNlIFwidGJvZHlcIjpcclxuICAgICAgY2FzZSBcInRkXCI6XHJcbiAgICAgIGNhc2UgXCJ0Zm9vdFwiOlxyXG4gICAgICBjYXNlIFwidGhcIjpcclxuICAgICAgY2FzZSBcInRoZWFkXCI6XHJcbiAgICAgIGNhc2UgXCJ0clwiOlxyXG4gICAgICAgIGlmIChzdGFjay5pblRhYmxlU2NvcGUoXCJ0ZFwiKSkge1xyXG4gICAgICAgICAgaW5fY2VsbF9tb2RlKEVORFRBRywgXCJ0ZFwiKTtcclxuICAgICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0YWNrLmluVGFibGVTY29wZShcInRoXCIpKSB7XHJcbiAgICAgICAgICBpbl9jZWxsX21vZGUoRU5EVEFHLCBcInRoXCIpO1xyXG4gICAgICAgICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcclxuICAgICAgc3dpdGNoKHZhbHVlKSB7XHJcbiAgICAgIGNhc2UgXCJ0ZFwiOlxyXG4gICAgICBjYXNlIFwidGhcIjpcclxuICAgICAgICBpZiAoIXN0YWNrLmluVGFibGVTY29wZSh2YWx1ZSkpIHJldHVybjtcclxuICAgICAgICBzdGFjay5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKCk7XHJcbiAgICAgICAgc3RhY2sucG9wVGFnKHZhbHVlKTtcclxuICAgICAgICBhZmUuY2xlYXJUb01hcmtlcigpO1xyXG4gICAgICAgIHBhcnNlciA9IGluX3Jvd19tb2RlO1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJib2R5XCI6XHJcbiAgICAgIGNhc2UgXCJjYXB0aW9uXCI6XHJcbiAgICAgIGNhc2UgXCJjb2xcIjpcclxuICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XHJcbiAgICAgIGNhc2UgXCJodG1sXCI6XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgY2FzZSBcInRhYmxlXCI6XHJcbiAgICAgIGNhc2UgXCJ0Ym9keVwiOlxyXG4gICAgICBjYXNlIFwidGZvb3RcIjpcclxuICAgICAgY2FzZSBcInRoZWFkXCI6XHJcbiAgICAgIGNhc2UgXCJ0clwiOlxyXG4gICAgICAgIGlmICghc3RhY2suaW5UYWJsZVNjb3BlKHZhbHVlKSkgcmV0dXJuO1xyXG4gICAgICAgIGluX2NlbGxfbW9kZShFTkRUQUcsIHN0YWNrLmluVGFibGVTY29wZShcInRkXCIpID8gXCJ0ZFwiIDogXCJ0aFwiKTtcclxuICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICAvLyBhbnl0aGluZyBlbHNlXHJcbiAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5fc2VsZWN0X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcclxuICAgIHN3aXRjaCh0KSB7XHJcbiAgICBjYXNlIDE6IC8vIFRFWFRcclxuICAgICAgaWYgKHRleHRJbmNsdWRlc05VTCkge1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShOVUxDSEFSUywgXCJcIik7XHJcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGluc2VydFRleHQodmFsdWUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcclxuICAgICAgaW5zZXJ0Q29tbWVudCh2YWx1ZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgNTogLy8gRE9DVFlQRVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSAyOiAvLyBUQUdcclxuICAgICAgc3dpdGNoKHZhbHVlKSB7XHJcbiAgICAgIGNhc2UgXCJodG1sXCI6XHJcbiAgICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNhc2UgXCJvcHRpb25cIjpcclxuICAgICAgICBpZiAoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MT3B0aW9uRWxlbWVudClcclxuICAgICAgICAgIGluX3NlbGVjdF9tb2RlKEVORFRBRywgdmFsdWUpO1xyXG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNhc2UgXCJvcHRncm91cFwiOlxyXG4gICAgICAgIGlmIChzdGFjay50b3AgaW5zdGFuY2VvZiBpbXBsLkhUTUxPcHRpb25FbGVtZW50KVxyXG4gICAgICAgICAgaW5fc2VsZWN0X21vZGUoRU5EVEFHLCBcIm9wdGlvblwiKTtcclxuICAgICAgICBpZiAoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MT3B0R3JvdXBFbGVtZW50KVxyXG4gICAgICAgICAgaW5fc2VsZWN0X21vZGUoRU5EVEFHLCB2YWx1ZSk7XHJcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcInNlbGVjdFwiOlxyXG4gICAgICAgIGluX3NlbGVjdF9tb2RlKEVORFRBRywgdmFsdWUpOyAvLyB0cmVhdCBpdCBhcyBhIGNsb3NlIHRhZ1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJpbnB1dFwiOlxyXG4gICAgICBjYXNlIFwia2V5Z2VuXCI6XHJcbiAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxyXG4gICAgICAgIGlmICghc3RhY2suaW5TZWxlY3RTY29wZShcInNlbGVjdFwiKSkgcmV0dXJuO1xyXG4gICAgICAgIGluX3NlbGVjdF9tb2RlKEVORFRBRywgXCJzZWxlY3RcIik7XHJcbiAgICAgICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBjYXNlIFwic2NyaXB0XCI6XHJcbiAgICAgIGNhc2UgXCJ0ZW1wbGF0ZVwiOlxyXG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcclxuICAgICAgc3dpdGNoKHZhbHVlKSB7XHJcbiAgICAgIGNhc2UgXCJvcHRncm91cFwiOlxyXG4gICAgICAgIGlmIChzdGFjay50b3AgaW5zdGFuY2VvZiBpbXBsLkhUTUxPcHRpb25FbGVtZW50ICYmXHJcbiAgICAgICAgICBzdGFjay5lbGVtZW50c1tzdGFjay5lbGVtZW50cy5sZW5ndGgtMl0gaW5zdGFuY2VvZlxyXG4gICAgICAgICAgaW1wbC5IVE1MT3B0R3JvdXBFbGVtZW50KSB7XHJcbiAgICAgICAgICBpbl9zZWxlY3RfbW9kZShFTkRUQUcsIFwib3B0aW9uXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MT3B0R3JvdXBFbGVtZW50KVxyXG4gICAgICAgICAgc3RhY2sucG9wKCk7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJvcHRpb25cIjpcclxuICAgICAgICBpZiAoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MT3B0aW9uRWxlbWVudClcclxuICAgICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGNhc2UgXCJzZWxlY3RcIjpcclxuICAgICAgICBpZiAoIXN0YWNrLmluU2VsZWN0U2NvcGUodmFsdWUpKSByZXR1cm47XHJcbiAgICAgICAgc3RhY2sucG9wVGFnKHZhbHVlKTtcclxuICAgICAgICByZXNldEluc2VydGlvbk1vZGUoKTtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBjYXNlIFwidGVtcGxhdGVcIjpcclxuICAgICAgICBpbl9oZWFkX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYW55dGhpbmcgZWxzZToganVzdCBpZ25vcmUgdGhlIHRva2VuXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbl9zZWxlY3RfaW5fdGFibGVfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xyXG4gICAgc3dpdGNoKHZhbHVlKSB7XHJcbiAgICBjYXNlIFwiY2FwdGlvblwiOlxyXG4gICAgY2FzZSBcInRhYmxlXCI6XHJcbiAgICBjYXNlIFwidGJvZHlcIjpcclxuICAgIGNhc2UgXCJ0Zm9vdFwiOlxyXG4gICAgY2FzZSBcInRoZWFkXCI6XHJcbiAgICBjYXNlIFwidHJcIjpcclxuICAgIGNhc2UgXCJ0ZFwiOlxyXG4gICAgY2FzZSBcInRoXCI6XHJcbiAgICAgIHN3aXRjaCh0KSB7XHJcbiAgICAgIGNhc2UgMjogLy8gVEFHXHJcbiAgICAgICAgaW5fc2VsZWN0X2luX3RhYmxlX21vZGUoRU5EVEFHLCBcInNlbGVjdFwiKTtcclxuICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSAzOiAvLyBFTkRUQUdcclxuICAgICAgICBpZiAoc3RhY2suaW5UYWJsZVNjb3BlKHZhbHVlKSkge1xyXG4gICAgICAgICAgaW5fc2VsZWN0X2luX3RhYmxlX21vZGUoRU5EVEFHLCBcInNlbGVjdFwiKTtcclxuICAgICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFueXRoaW5nIGVsc2VcclxuICAgIGluX3NlbGVjdF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluX3RlbXBsYXRlX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcclxuICAgIGZ1bmN0aW9uIHN3aXRjaE1vZGVBbmRSZXByb2Nlc3MobW9kZSkge1xyXG4gICAgICBwYXJzZXIgPSBtb2RlO1xyXG4gICAgICB0ZW1wbGF0ZUluc2VydGlvbk1vZGVzW3RlbXBsYXRlSW5zZXJ0aW9uTW9kZXMubGVuZ3RoLTFdID0gcGFyc2VyO1xyXG4gICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoKHQpIHtcclxuICAgIGNhc2UgMTogLy8gVEVYVFxyXG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXHJcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcclxuICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSAtMTogLy8gRU9GXHJcbiAgICAgIGlmICghc3RhY2suY29udGFpbnMoXCJ0ZW1wbGF0ZVwiKSkge1xyXG4gICAgICAgIHN0b3BQYXJzaW5nKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RhY2sucG9wVGFnKFwidGVtcGxhdGVcIik7XHJcbiAgICAgICAgYWZlLmNsZWFyVG9NYXJrZXIoKTtcclxuICAgICAgICB0ZW1wbGF0ZUluc2VydGlvbk1vZGVzLnBvcCgpO1xyXG4gICAgICAgIHJlc2V0SW5zZXJ0aW9uTW9kZSgpO1xyXG4gICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSAyOiAvLyBUQUdcclxuICAgICAgc3dpdGNoKHZhbHVlKSB7XHJcbiAgICAgIGNhc2UgXCJiYXNlXCI6XHJcbiAgICAgIGNhc2UgXCJiYXNlZm9udFwiOlxyXG4gICAgICBjYXNlIFwiYmdzb3VuZFwiOlxyXG4gICAgICBjYXNlIFwibGlua1wiOlxyXG4gICAgICBjYXNlIFwibWV0YVwiOlxyXG4gICAgICBjYXNlIFwibm9mcmFtZXNcIjpcclxuICAgICAgY2FzZSBcInNjcmlwdFwiOlxyXG4gICAgICBjYXNlIFwic3R5bGVcIjpcclxuICAgICAgY2FzZSBcInRlbXBsYXRlXCI6XHJcbiAgICAgIGNhc2UgXCJ0aXRsZVwiOlxyXG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwiY2FwdGlvblwiOlxyXG4gICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcclxuICAgICAgY2FzZSBcInRib2R5XCI6XHJcbiAgICAgIGNhc2UgXCJ0Zm9vdFwiOlxyXG4gICAgICBjYXNlIFwidGhlYWRcIjpcclxuICAgICAgICBzd2l0Y2hNb2RlQW5kUmVwcm9jZXNzKGluX3RhYmxlX21vZGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcImNvbFwiOlxyXG4gICAgICAgIHN3aXRjaE1vZGVBbmRSZXByb2Nlc3MoaW5fY29sdW1uX2dyb3VwX21vZGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcInRyXCI6XHJcbiAgICAgICAgc3dpdGNoTW9kZUFuZFJlcHJvY2Vzcyhpbl90YWJsZV9ib2R5X21vZGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcInRkXCI6XHJcbiAgICAgIGNhc2UgXCJ0aFwiOlxyXG4gICAgICAgIHN3aXRjaE1vZGVBbmRSZXByb2Nlc3MoaW5fcm93X21vZGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2hNb2RlQW5kUmVwcm9jZXNzKGluX2JvZHlfbW9kZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgMzogLy8gRU5EVEFHXHJcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xyXG4gICAgICBjYXNlIFwidGVtcGxhdGVcIjpcclxuICAgICAgICBpbl9oZWFkX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFmdGVyX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xyXG4gICAgc3dpdGNoKHQpIHtcclxuICAgIGNhc2UgMTogLy8gVEVYVFxyXG4gICAgICAvLyBJZiBhbnkgbm9uLXNwYWNlIGNoYXJzLCBoYW5kbGUgYmVsb3dcclxuICAgICAgaWYgKE5PTldTLnRlc3QodmFsdWUpKSBicmVhaztcclxuICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXHJcbiAgICAgIC8vIEFwcGVuZCBpdCB0byB0aGUgPGh0bWw+IGVsZW1lbnRcclxuICAgICAgc3RhY2suZWxlbWVudHNbMF0uX2FwcGVuZENoaWxkKGRvYy5jcmVhdGVDb21tZW50KHZhbHVlKSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgNTogLy8gRE9DVFlQRVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgc3RvcFBhcnNpbmcoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSAyOiAvLyBUQUdcclxuICAgICAgaWYgKHZhbHVlID09PSBcImh0bWxcIikge1xyXG4gICAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrOyAvLyBmb3IgYW55IG90aGVyIHRhZ3NcclxuICAgIGNhc2UgMzogLy8gRU5EVEFHXHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gXCJodG1sXCIpIHtcclxuICAgICAgICBpZiAoZnJhZ21lbnQpIHJldHVybjtcclxuICAgICAgICBwYXJzZXIgPSBhZnRlcl9hZnRlcl9ib2R5X21vZGU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrOyAvLyBmb3IgYW55IG90aGVyIHRhZ3NcclxuICAgIH1cclxuXHJcbiAgICAvLyBhbnl0aGluZyBlbHNlXHJcbiAgICBwYXJzZXIgPSBpbl9ib2R5X21vZGU7XHJcbiAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5fZnJhbWVzZXRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xyXG4gICAgc3dpdGNoKHQpIHtcclxuICAgIGNhc2UgMTogLy8gVEVYVFxyXG4gICAgICAvLyBJZ25vcmUgYW55IG5vbi1zcGFjZSBjaGFyYWN0ZXJzXHJcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShBTExOT05XUywgXCJcIik7XHJcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSBpbnNlcnRUZXh0KHZhbHVlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXHJcbiAgICAgIGluc2VydENvbW1lbnQodmFsdWUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSAtMTogLy8gRU9GXHJcbiAgICAgIHN0b3BQYXJzaW5nKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgMjogLy8gVEFHXHJcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xyXG4gICAgICBjYXNlIFwiaHRtbFwiOlxyXG4gICAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwiZnJhbWVzZXRcIjpcclxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwiZnJhbWVcIjpcclxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XHJcbiAgICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwibm9mcmFtZXNcIjpcclxuICAgICAgICBpbl9oZWFkX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMzogLy8gRU5EVEFHXHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gXCJmcmFtZXNldFwiKSB7XHJcbiAgICAgICAgaWYgKGZyYWdtZW50ICYmIHN0YWNrLnRvcCBpbnN0YW5jZW9mIGltcGwuSFRNTEh0bWxFbGVtZW50KVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIGlmICghZnJhZ21lbnQgJiZcclxuICAgICAgICAgICEoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MRnJhbWVTZXRFbGVtZW50KSlcclxuICAgICAgICAgIHBhcnNlciA9IGFmdGVyX2ZyYW1lc2V0X21vZGU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlnbm9yZSBhbnl0aGluZyBlbHNlXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZnRlcl9mcmFtZXNldF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XHJcbiAgICBzd2l0Y2godCkge1xyXG4gICAgY2FzZSAxOiAvLyBURVhUXHJcbiAgICAgIC8vIElnbm9yZSBhbnkgbm9uLXNwYWNlIGNoYXJhY3RlcnNcclxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKEFMTE5PTldTLCBcIlwiKTtcclxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDApIGluc2VydFRleHQodmFsdWUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcclxuICAgICAgaW5zZXJ0Q29tbWVudCh2YWx1ZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgNTogLy8gRE9DVFlQRVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgc3RvcFBhcnNpbmcoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSAyOiAvLyBUQUdcclxuICAgICAgc3dpdGNoKHZhbHVlKSB7XHJcbiAgICAgIGNhc2UgXCJodG1sXCI6XHJcbiAgICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNhc2UgXCJub2ZyYW1lc1wiOlxyXG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcclxuICAgICAgaWYgKHZhbHVlID09PSBcImh0bWxcIikge1xyXG4gICAgICAgIHBhcnNlciA9IGFmdGVyX2FmdGVyX2ZyYW1lc2V0X21vZGU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlnbm9yZSBhbnl0aGluZyBlbHNlXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZnRlcl9hZnRlcl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcclxuICAgIHN3aXRjaCh0KSB7XHJcbiAgICBjYXNlIDE6IC8vIFRFWFRcclxuICAgICAgLy8gSWYgYW55IG5vbi1zcGFjZSBjaGFycywgaGFuZGxlIGJlbG93XHJcbiAgICAgIGlmIChOT05XUy50ZXN0KHZhbHVlKSkgYnJlYWs7XHJcbiAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgNDogLy8gQ09NTUVOVFxyXG4gICAgICBkb2MuX2FwcGVuZENoaWxkKGRvYy5jcmVhdGVDb21tZW50KHZhbHVlKSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgNTogLy8gRE9DVFlQRVxyXG4gICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgc3RvcFBhcnNpbmcoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSAyOiAvLyBUQUdcclxuICAgICAgaWYgKHZhbHVlID09PSBcImh0bWxcIikge1xyXG4gICAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFueXRoaW5nIGVsc2VcclxuICAgIHBhcnNlciA9IGluX2JvZHlfbW9kZTtcclxuICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZnRlcl9hZnRlcl9mcmFtZXNldF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XHJcbiAgICBzd2l0Y2godCkge1xyXG4gICAgY2FzZSAxOiAvLyBURVhUXHJcbiAgICAgIC8vIElnbm9yZSBhbnkgbm9uLXNwYWNlIGNoYXJhY3RlcnNcclxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKEFMTE5PTldTLCBcIlwiKTtcclxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDApXHJcbiAgICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXHJcbiAgICAgIGRvYy5fYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZUNvbW1lbnQodmFsdWUpKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXHJcbiAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgLTE6IC8vIEVPRlxyXG4gICAgICBzdG9wUGFyc2luZygpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIDI6IC8vIFRBR1xyXG4gICAgICBzd2l0Y2godmFsdWUpIHtcclxuICAgICAgY2FzZSBcImh0bWxcIjpcclxuICAgICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcIm5vZnJhbWVzXCI6XHJcbiAgICAgICAgaW5faGVhZF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWdub3JlIGFueXRoaW5nIGVsc2VcclxuICB9XHJcblxyXG5cclxuICAvLyAxMy4yLjUuNSBUaGUgcnVsZXMgZm9yIHBhcnNpbmcgdG9rZW5zIGluIGZvcmVpZ24gY29udGVudFxyXG4gIC8vXHJcbiAgLy8gVGhpcyBpcyBsaWtlIG9uZSBvZiB0aGUgaW5zZXJ0aW9uIG1vZGVzIGFib3ZlLCBidXQgaXNcclxuICAvLyBpbnZva2VkIHNvbWV3aGF0IGRpZmZlcmVudGx5IHdoZW4gdGhlIGN1cnJlbnQgdG9rZW4gaXMgbm90IEhUTUwuXHJcbiAgLy8gU2VlIHRoZSBpbnNlcnRUb2tlbigpIGZ1bmN0aW9uLlxyXG4gIGZ1bmN0aW9uIGluc2VydEZvcmVpZ25Ub2tlbih0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xyXG4gICAgLy8gQSA8Zm9udD4gdGFnIGlzIGFuIEhUTUwgZm9udCB0YWcgaWYgaXQgaGFzIGEgY29sb3IsIGZvbnQsIG9yIHNpemVcclxuICAgIC8vIGF0dHJpYnV0ZS4gIE90aGVyd2lzZSB3ZSBhc3N1bWUgaXQgaXMgZm9yZWlnbiBjb250ZW50XHJcbiAgICBmdW5jdGlvbiBpc0hUTUxGb250KGF0dHJzKSB7XHJcbiAgICAgIGZvcih2YXIgaSA9IDAsIG4gPSBhdHRycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBzd2l0Y2goYXR0cnNbaV1bMF0pIHtcclxuICAgICAgICBjYXNlIFwiY29sb3JcIjpcclxuICAgICAgICBjYXNlIFwiZmFjZVwiOlxyXG4gICAgICAgIGNhc2UgXCJzaXplXCI6XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjdXJyZW50O1xyXG5cclxuICAgIHN3aXRjaCh0KSB7XHJcbiAgICBjYXNlIDE6IC8vIFRFWFRcclxuICAgICAgLy8gSWYgYW55IG5vbi1zcGFjZSwgbm9uLW51bCBjaGFyYWN0ZXJzXHJcbiAgICAgIGlmIChmcmFtZXNldF9vayAmJiBOT05XU05PTk5VTC50ZXN0KHZhbHVlKSlcclxuICAgICAgICBmcmFtZXNldF9vayA9IGZhbHNlO1xyXG4gICAgICBpZiAodGV4dEluY2x1ZGVzTlVMKSB7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKE5VTENIQVJTLCBcIlxcdUZGRkRcIik7XHJcbiAgICAgIH1cclxuICAgICAgaW5zZXJ0VGV4dCh2YWx1ZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgNDogLy8gQ09NTUVOVFxyXG4gICAgICBpbnNlcnRDb21tZW50KHZhbHVlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXHJcbiAgICAgIC8vIGlnbm9yZSBpdFxyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlIDI6IC8vIFRBR1xyXG4gICAgICBzd2l0Y2godmFsdWUpIHtcclxuICAgICAgY2FzZSBcImZvbnRcIjpcclxuICAgICAgICBpZiAoIWlzSFRNTEZvbnQoYXJnMykpIGJyZWFrO1xyXG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgY2FzZSBcImJcIjpcclxuICAgICAgY2FzZSBcImJpZ1wiOlxyXG4gICAgICBjYXNlIFwiYmxvY2txdW90ZVwiOlxyXG4gICAgICBjYXNlIFwiYm9keVwiOlxyXG4gICAgICBjYXNlIFwiYnJcIjpcclxuICAgICAgY2FzZSBcImNlbnRlclwiOlxyXG4gICAgICBjYXNlIFwiY29kZVwiOlxyXG4gICAgICBjYXNlIFwiZGRcIjpcclxuICAgICAgY2FzZSBcImRpdlwiOlxyXG4gICAgICBjYXNlIFwiZGxcIjpcclxuICAgICAgY2FzZSBcImR0XCI6XHJcbiAgICAgIGNhc2UgXCJlbVwiOlxyXG4gICAgICBjYXNlIFwiZW1iZWRcIjpcclxuICAgICAgY2FzZSBcImgxXCI6XHJcbiAgICAgIGNhc2UgXCJoMlwiOlxyXG4gICAgICBjYXNlIFwiaDNcIjpcclxuICAgICAgY2FzZSBcImg0XCI6XHJcbiAgICAgIGNhc2UgXCJoNVwiOlxyXG4gICAgICBjYXNlIFwiaDZcIjpcclxuICAgICAgY2FzZSBcImhlYWRcIjpcclxuICAgICAgY2FzZSBcImhyXCI6XHJcbiAgICAgIGNhc2UgXCJpXCI6XHJcbiAgICAgIGNhc2UgXCJpbWdcIjpcclxuICAgICAgY2FzZSBcImxpXCI6XHJcbiAgICAgIGNhc2UgXCJsaXN0aW5nXCI6XHJcbiAgICAgIGNhc2UgXCJtZW51XCI6XHJcbiAgICAgIGNhc2UgXCJtZXRhXCI6XHJcbiAgICAgIGNhc2UgXCJub2JyXCI6XHJcbiAgICAgIGNhc2UgXCJvbFwiOlxyXG4gICAgICBjYXNlIFwicFwiOlxyXG4gICAgICBjYXNlIFwicHJlXCI6XHJcbiAgICAgIGNhc2UgXCJydWJ5XCI6XHJcbiAgICAgIGNhc2UgXCJzXCI6XHJcbiAgICAgIGNhc2UgXCJzbWFsbFwiOlxyXG4gICAgICBjYXNlIFwic3BhblwiOlxyXG4gICAgICBjYXNlIFwic3Ryb25nXCI6XHJcbiAgICAgIGNhc2UgXCJzdHJpa2VcIjpcclxuICAgICAgY2FzZSBcInN1YlwiOlxyXG4gICAgICBjYXNlIFwic3VwXCI6XHJcbiAgICAgIGNhc2UgXCJ0YWJsZVwiOlxyXG4gICAgICBjYXNlIFwidHRcIjpcclxuICAgICAgY2FzZSBcInVcIjpcclxuICAgICAgY2FzZSBcInVsXCI6XHJcbiAgICAgIGNhc2UgXCJ2YXJcIjpcclxuICAgICAgICBpZiAoZnJhZ21lbnQpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICBzdGFjay5wb3AoKTtcclxuICAgICAgICAgIGN1cnJlbnQgPSBzdGFjay50b3A7XHJcbiAgICAgICAgfSB3aGlsZShjdXJyZW50Lm5hbWVzcGFjZVVSSSAhPT0gTkFNRVNQQUNFLkhUTUwgJiZcclxuICAgICAgICAgICAgIWlzTWF0aG1sVGV4dEludGVncmF0aW9uUG9pbnQoY3VycmVudCkgJiZcclxuICAgICAgICAgICAgIWlzSFRNTEludGVncmF0aW9uUG9pbnQoY3VycmVudCkpO1xyXG5cclxuICAgICAgICBpbnNlcnRUb2tlbih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7ICAvLyByZXByb2Nlc3NcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFueSBvdGhlciBzdGFydCB0YWcgY2FzZSBnb2VzIGhlcmVcclxuICAgICAgY3VycmVudCA9IChzdGFjay5lbGVtZW50cy5sZW5ndGg9PT0xICYmIGZyYWdtZW50KSA/IGZyYWdtZW50Q29udGV4dCA6XHJcbiAgICAgICAgc3RhY2sudG9wO1xyXG4gICAgICBpZiAoY3VycmVudC5uYW1lc3BhY2VVUkkgPT09IE5BTUVTUEFDRS5NQVRITUwpIHtcclxuICAgICAgICBhZGp1c3RNYXRoTUxBdHRyaWJ1dGVzKGFyZzMpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKGN1cnJlbnQubmFtZXNwYWNlVVJJID09PSBOQU1FU1BBQ0UuU1ZHKSB7XHJcbiAgICAgICAgdmFsdWUgPSBhZGp1c3RTVkdUYWdOYW1lKHZhbHVlKTtcclxuICAgICAgICBhZGp1c3RTVkdBdHRyaWJ1dGVzKGFyZzMpO1xyXG4gICAgICB9XHJcbiAgICAgIGFkanVzdEZvcmVpZ25BdHRyaWJ1dGVzKGFyZzMpO1xyXG5cclxuICAgICAgaW5zZXJ0Rm9yZWlnbkVsZW1lbnQodmFsdWUsIGFyZzMsIGN1cnJlbnQubmFtZXNwYWNlVVJJKTtcclxuICAgICAgaWYgKGFyZzQpIHsgLy8gdGhlIHNlbGYtY2xvc2luZyBmbGFnXHJcbiAgICAgICAgaWYgKHZhbHVlID09PSAnc2NyaXB0JyAmJiBjdXJyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTkFNRVNQQUNFLlNWRykge1xyXG4gICAgICAgICAgLy8gWFhYIGRlYWwgd2l0aCBTVkcgc2NyaXB0cyBoZXJlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xyXG4gICAgICBjdXJyZW50ID0gc3RhY2sudG9wO1xyXG4gICAgICBpZiAodmFsdWUgPT09IFwic2NyaXB0XCIgJiZcclxuICAgICAgICBjdXJyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTkFNRVNQQUNFLlNWRyAmJlxyXG4gICAgICAgIGN1cnJlbnQubG9jYWxOYW1lID09PSBcInNjcmlwdFwiKSB7XHJcblxyXG4gICAgICAgIHN0YWNrLnBvcCgpO1xyXG5cclxuICAgICAgICAvLyBYWFhcclxuICAgICAgICAvLyBEZWFsIHdpdGggU1ZHIHNjcmlwdHMgaGVyZVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFRoZSBhbnkgb3RoZXIgZW5kIHRhZyBjYXNlXHJcbiAgICAgICAgdmFyIGkgPSBzdGFjay5lbGVtZW50cy5sZW5ndGgtMTtcclxuICAgICAgICB2YXIgbm9kZSA9IHN0YWNrLmVsZW1lbnRzW2ldO1xyXG4gICAgICAgIGZvcig7Oykge1xyXG4gICAgICAgICAgaWYgKG5vZGUubG9jYWxOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHN0YWNrLnBvcEVsZW1lbnQobm9kZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbm9kZSA9IHN0YWNrLmVsZW1lbnRzWy0taV07XHJcbiAgICAgICAgICAvLyBJZiBub24taHRtbCwga2VlcCBsb29waW5nXHJcbiAgICAgICAgICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgIT09IE5BTUVTUEFDRS5IVE1MKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIC8vIE90aGVyd2lzZSBwcm9jZXNzIHRoZSBlbmQgdGFnIGFzIGh0bWxcclxuICAgICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqKlxyXG4gICAqIEZpbmFsbHksIHRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgSFRNTFBhcnNlcigpIGZhY3RvcnkgZnVuY3Rpb24uXHJcbiAgICogSXQgcmV0dXJucyB0aGUgaHRtbHBhcnNlciBvYmplY3Qgd2l0aCB0aGUgYXBwZW5kKCkgYW5kIGVuZCgpIG1ldGhvZHMuXHJcbiAgICovXHJcblxyXG4gIC8vIFNuZWFrIGFub3RoZXIgbWV0aG9kIGludG8gdGhlIGh0bWxwYXJzZXIgb2JqZWN0IHRvIGFsbG93IHVzIHRvIHJ1blxyXG4gIC8vIHRva2VuaXplciB0ZXN0cy4gIFRoaXMgY2FuIGJlIGNvbW1lbnRlZCBvdXQgaW4gcHJvZHVjdGlvbiBjb2RlLlxyXG4gIC8vIFRoaXMgaXMgYSBob29rIGZvciB0ZXN0aW5nIHRoZSB0b2tlbml6ZXIuIEl0IGhhcyB0byBiZSBoZXJlXHJcbiAgLy8gYmVjYXVzZSB0aGUgdG9rZW5pemVyIGRldGFpbHMgYXJlIGFsbCBoaWRkZW4gYXdheSB3aXRoaW4gdGhlIGNsb3N1cmUuXHJcbiAgLy8gSXQgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiB0b2tlbnMgZ2VuZXJhdGVkIHdoaWxlIHBhcnNpbmcgdGhlXHJcbiAgLy8gaW5wdXQgc3RyaW5nLlxyXG4gIGh0bWxwYXJzZXIudGVzdFRva2VuaXplciA9IGZ1bmN0aW9uKGlucHV0LCBpbml0aWFsU3RhdGUsIGxhc3RTdGFydFRhZywgY2hhcmJ5Y2hhcikge1xyXG4gICAgdmFyIHRva2VucyA9IFtdO1xyXG5cclxuICAgIHN3aXRjaChpbml0aWFsU3RhdGUpIHtcclxuICAgIGNhc2UgXCJQQ0RBVEEgc3RhdGVcIjpcclxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwiUkNEQVRBIHN0YXRlXCI6XHJcbiAgICAgIHRva2VuaXplciA9IHJjZGF0YV9zdGF0ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwiUkFXVEVYVCBzdGF0ZVwiOlxyXG4gICAgICB0b2tlbml6ZXIgPSByYXd0ZXh0X3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgXCJQTEFJTlRFWFQgc3RhdGVcIjpcclxuICAgICAgdG9rZW5pemVyID0gcGxhaW50ZXh0X3N0YXRlO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICBpZiAobGFzdFN0YXJ0VGFnKSB7XHJcbiAgICAgIGxhc3R0YWduYW1lID0gbGFzdFN0YXJ0VGFnO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydFRva2VuID0gZnVuY3Rpb24odCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcclxuICAgICAgZmx1c2hUZXh0KCk7XHJcbiAgICAgIHN3aXRjaCh0KSB7XHJcbiAgICAgIGNhc2UgMTogLy8gVEVYVFxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGgtMV1bMF0gPT09IFwiQ2hhcmFjdGVyXCIpIHtcclxuICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoLTFdWzFdICs9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHRva2Vucy5wdXNoKFtcIkNoYXJhY3RlclwiLCB2YWx1ZV0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDQ6IC8vIENPTU1FTlRcclxuICAgICAgICB0b2tlbnMucHVzaChbXCJDb21tZW50XCIsIHZhbHVlXSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgNTogLy8gRE9DVFlQRVxyXG4gICAgICAgIHRva2Vucy5wdXNoKFtcIkRPQ1RZUEVcIiwgdmFsdWUsXHJcbiAgICAgICAgICAgICAgIGFyZzMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmczLFxyXG4gICAgICAgICAgICAgICBhcmc0ID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJnNCxcclxuICAgICAgICAgICAgICAgIWZvcmNlX3F1aXJrc10pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDI6IC8vIFRBR1xyXG4gICAgICAgIHZhciBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZzMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIC8vIFhYWDogZG9lcyBhdHRyaWJ1dGUgb3JkZXIgbWF0dGVyP1xyXG4gICAgICAgICAgdmFyIGEgPSBhcmczW2ldO1xyXG4gICAgICAgICAgaWYgKGEubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGF0dHJzW2FbMF1dID0gXCJcIjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhdHRyc1thWzBdXSA9IGFbMV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0b2tlbiA9IFtcIlN0YXJ0VGFnXCIsIHZhbHVlLCBhdHRyc107XHJcbiAgICAgICAgaWYgKGFyZzQpIHRva2VuLnB1c2godHJ1ZSk7XHJcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDM6IC8vIEVORFRBR1xyXG4gICAgICAgIHRva2Vucy5wdXNoKFtcIkVuZFRhZ1wiLCB2YWx1ZV0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIC0xOiAvLyBFT0ZcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoIWNoYXJieWNoYXIpIHtcclxuICAgICAgdGhpcy5wYXJzZShpbnB1dCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZShpbnB1dFtpXSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5wYXJzZShcIlwiLCB0cnVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0b2tlbnM7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIHRoZSBwYXJzZXIgb2JqZWN0IGZyb20gdGhlIEhUTUxQYXJzZXIoKSBmYWN0b3J5IGZ1bmN0aW9uXHJcbiAgcmV0dXJuIGh0bWxwYXJzZXI7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvSFRNTFBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gVVJMO1xyXG5cclxuZnVuY3Rpb24gVVJMKHVybCkge1xyXG4gIGlmICghdXJsKSByZXR1cm4gT2JqZWN0LmNyZWF0ZShVUkwucHJvdG90eXBlKTtcclxuICAvLyBDYW4ndCB1c2UgU3RyaW5nLnRyaW0oKSBzaW5jZSBpdCBkZWZpbmVzIHdoaXRlc3BhY2UgZGlmZmVyZW50bHkgdGhhbiBIVE1MXHJcbiAgdGhpcy51cmwgPSB1cmwucmVwbGFjZSgvXlsgXFx0XFxuXFxyXFxmXSt8WyBcXHRcXG5cXHJcXGZdKyQvZywgXCJcIik7XHJcblxyXG4gIC8vIFNlZSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I2FwcGVuZGl4LUJcclxuICAvLyBhbmQgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNwYXJzaW5nXHJcbiAgdmFyIG1hdGNoID0gVVJMLnBhdHRlcm4uZXhlYyh0aGlzLnVybCk7XHJcbiAgaWYgKG1hdGNoKSB7XHJcbiAgICBpZiAobWF0Y2hbMl0pIHRoaXMuc2NoZW1lID0gbWF0Y2hbMl07XHJcbiAgICBpZiAobWF0Y2hbNF0pIHtcclxuICAgICAgLy8gcGFyc2UgdXNlcm5hbWUvcGFzc3dvcmRcclxuICAgICAgdmFyIHVzZXJpbmZvID0gbWF0Y2hbNF0ubWF0Y2goVVJMLnVzZXJpbmZvUGF0dGVybik7XHJcbiAgICAgIGlmICh1c2VyaW5mbykge1xyXG4gICAgICAgIHRoaXMudXNlcm5hbWUgPSB1c2VyaW5mb1sxXTtcclxuICAgICAgICB0aGlzLnBhc3N3b3JkID0gdXNlcmluZm9bM107XHJcbiAgICAgICAgbWF0Y2hbNF0gPSBtYXRjaFs0XS5zdWJzdHJpbmcodXNlcmluZm9bMF0ubGVuZ3RoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobWF0Y2hbNF0ubWF0Y2goVVJMLnBvcnRQYXR0ZXJuKSkge1xyXG4gICAgICAgIHZhciBwb3MgPSBtYXRjaFs0XS5sYXN0SW5kZXhPZignOicpO1xyXG4gICAgICAgIHRoaXMuaG9zdCA9IG1hdGNoWzRdLnN1YnN0cmluZygwLCBwb3MpO1xyXG4gICAgICAgIHRoaXMucG9ydCA9IG1hdGNoWzRdLnN1YnN0cmluZyhwb3MrMSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5ob3N0ID0gbWF0Y2hbNF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChtYXRjaFs1XSkgdGhpcy5wYXRoID0gbWF0Y2hbNV07XHJcbiAgICBpZiAobWF0Y2hbNl0pIHRoaXMucXVlcnkgPSBtYXRjaFs3XTtcclxuICAgIGlmIChtYXRjaFs4XSkgdGhpcy5mcmFnbWVudCA9IG1hdGNoWzldO1xyXG4gIH1cclxufVxyXG5cclxuVVJMLnBhdHRlcm4gPSAvXigoW146XFwvPyNdKyk6KT8oXFwvXFwvKFteXFwvPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/JC87XHJcblVSTC51c2VyaW5mb1BhdHRlcm4gPSAvXihbXkA6XSopKDooW15AXSopKT9ALztcclxuVVJMLnBvcnRQYXR0ZXJuID0gLzpcXGQrJC87XHJcblVSTC5hdXRob3JpdHlQYXR0ZXJuID0gL15bXjpcXC8/I10rOlxcL1xcLy87XHJcblVSTC5oaWVyYXJjaHlQYXR0ZXJuID0gL15bXjpcXC8/I10rOlxcLy87XHJcblxyXG4vLyBSZXR1cm4gYSBwZXJjZW50RW5jb2RlZCB2ZXJzaW9uIG9mIHMuXHJcbi8vIFMgc2hvdWxkIGJlIGEgc2luZ2xlLWNoYXJhY3RlciBzdHJpbmdcclxuLy8gWFhYOiBuZWVkcyB0byBkbyB1dGYtOCBlbmNvZGluZz9cclxuVVJMLnBlcmNlbnRFbmNvZGUgPSBmdW5jdGlvbiBwZXJjZW50RW5jb2RlKHMpIHtcclxuICB2YXIgYyA9IHMuY2hhckNvZGVBdCgwKTtcclxuICBpZiAoYyA8IDI1NikgcmV0dXJuIFwiJVwiICsgYy50b1N0cmluZygxNik7XHJcbiAgZWxzZSB0aHJvdyBFcnJvcihcImNhbid0IHBlcmNlbnQtZW5jb2RlIGNvZGVwb2ludHMgPiAyNTUgeWV0XCIpO1xyXG59O1xyXG5cclxuVVJMLnByb3RvdHlwZSA9IHtcclxuICBjb25zdHJ1Y3RvcjogVVJMLFxyXG5cclxuICAvLyBYWFg6IG5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIHByZWNpc2UgZGVmaW5pdGlvbiBvZiBhYnNvbHV0ZVxyXG4gIGlzQWJzb2x1dGU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gISF0aGlzLnNjaGVtZTsgfSxcclxuICBpc0F1dGhvcml0eUJhc2VkOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBVUkwuYXV0aG9yaXR5UGF0dGVybi50ZXN0KHRoaXMudXJsKTtcclxuICB9LFxyXG4gIGlzSGllcmFyY2hpY2FsOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBVUkwuaGllcmFyY2h5UGF0dGVybi50ZXN0KHRoaXMudXJsKTtcclxuICB9LFxyXG5cclxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcyA9IFwiXCI7XHJcbiAgICBpZiAodGhpcy5zY2hlbWUgIT09IHVuZGVmaW5lZCkgcyArPSB0aGlzLnNjaGVtZSArIFwiOlwiO1xyXG4gICAgaWYgKHRoaXMuaXNBYnNvbHV0ZSgpKSB7XHJcbiAgICAgIHMgKz0gJy8vJztcclxuICAgICAgaWYgKHRoaXMudXNlcm5hbWUgfHwgdGhpcy5wYXNzd29yZCkge1xyXG4gICAgICAgIHMgKz0gdGhpcy51c2VybmFtZSB8fCAnJztcclxuICAgICAgICBpZiAodGhpcy5wYXNzd29yZCkge1xyXG4gICAgICAgICAgcyArPSAnOicgKyB0aGlzLnBhc3N3b3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzICs9ICdAJztcclxuICAgICAgfVxyXG4gICAgICBzICs9IHRoaXMuaG9zdDtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnBvcnQgIT09IHVuZGVmaW5lZCkgcyArPSBcIjpcIiArIHRoaXMucG9ydDtcclxuICAgIGlmICh0aGlzLnBhdGggIT09IHVuZGVmaW5lZCkgcyArPSB0aGlzLnBhdGg7XHJcbiAgICBpZiAodGhpcy5xdWVyeSAhPT0gdW5kZWZpbmVkKSBzICs9IFwiP1wiICsgdGhpcy5xdWVyeTtcclxuICAgIGlmICh0aGlzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHMgKz0gXCIjXCIgKyB0aGlzLmZyYWdtZW50O1xyXG4gICAgcmV0dXJuIHM7XHJcbiAgfSxcclxuXHJcbiAgLy8gU2VlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNS4yXHJcbiAgLy8gYW5kIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jY29uc3RydWN0b3JzXHJcbiAgcmVzb2x2ZTogZnVuY3Rpb24ocmVsYXRpdmUpIHtcclxuICAgIHZhciBiYXNlID0gdGhpczsgICAgICAgICAgIC8vIFRoZSBiYXNlIHVybCB3ZSdyZSByZXNvbHZpbmcgYWdhaW5zdFxyXG4gICAgdmFyIHIgPSBuZXcgVVJMKHJlbGF0aXZlKTsgLy8gVGhlIHJlbGF0aXZlIHJlZmVyZW5jZSB1cmwgdG8gcmVzb2x2ZVxyXG4gICAgdmFyIHQgPSBuZXcgVVJMKCk7ICAgICAgICAgLy8gVGhlIGFic29sdXRlIHRhcmdldCB1cmwgd2Ugd2lsbCByZXR1cm5cclxuXHJcbiAgICBpZiAoci5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0LnNjaGVtZSA9IHIuc2NoZW1lO1xyXG4gICAgICB0LnVzZXJuYW1lID0gci51c2VybmFtZTtcclxuICAgICAgdC5wYXNzd29yZCA9IHIucGFzc3dvcmQ7XHJcbiAgICAgIHQuaG9zdCA9IHIuaG9zdDtcclxuICAgICAgdC5wb3J0ID0gci5wb3J0O1xyXG4gICAgICB0LnBhdGggPSByZW1vdmVfZG90X3NlZ21lbnRzKHIucGF0aCk7XHJcbiAgICAgIHQucXVlcnkgPSByLnF1ZXJ5O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHQuc2NoZW1lID0gYmFzZS5zY2hlbWU7XHJcbiAgICAgIGlmIChyLmhvc3QgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHQudXNlcm5hbWUgPSByLnVzZXJuYW1lO1xyXG4gICAgICAgIHQucGFzc3dvcmQgPSByLnBhc3N3b3JkO1xyXG4gICAgICAgIHQuaG9zdCA9IHIuaG9zdDtcclxuICAgICAgICB0LnBvcnQgPSByLnBvcnQ7XHJcbiAgICAgICAgdC5wYXRoID0gcmVtb3ZlX2RvdF9zZWdtZW50cyhyLnBhdGgpO1xyXG4gICAgICAgIHQucXVlcnkgPSByLnF1ZXJ5O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHQudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xyXG4gICAgICAgIHQucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xyXG4gICAgICAgIHQuaG9zdCA9IGJhc2UuaG9zdDtcclxuICAgICAgICB0LnBvcnQgPSBiYXNlLnBvcnQ7XHJcbiAgICAgICAgaWYgKCFyLnBhdGgpIHsgLy8gdW5kZWZpbmVkIG9yIGVtcHR5XHJcbiAgICAgICAgICB0LnBhdGggPSBiYXNlLnBhdGg7XHJcbiAgICAgICAgICBpZiAoci5xdWVyeSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0LnF1ZXJ5ID0gci5xdWVyeTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdC5xdWVyeSA9IGJhc2UucXVlcnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgaWYgKHIucGF0aC5jaGFyQXQoMCkgPT09IFwiL1wiKSB7XHJcbiAgICAgICAgICAgIHQucGF0aCA9IHJlbW92ZV9kb3Rfc2VnbWVudHMoci5wYXRoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0LnBhdGggPSBtZXJnZShiYXNlLnBhdGgsIHIucGF0aCk7XHJcbiAgICAgICAgICAgIHQucGF0aCA9IHJlbW92ZV9kb3Rfc2VnbWVudHModC5wYXRoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHQucXVlcnkgPSByLnF1ZXJ5O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdC5mcmFnbWVudCA9IHIuZnJhZ21lbnQ7XHJcblxyXG4gICAgcmV0dXJuIHQudG9TdHJpbmcoKTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gbWVyZ2UoYmFzZXBhdGgsIHJlZnBhdGgpIHtcclxuICAgICAgaWYgKGJhc2UuaG9zdCAhPT0gdW5kZWZpbmVkICYmICFiYXNlLnBhdGgpXHJcbiAgICAgICAgcmV0dXJuIFwiL1wiICsgcmVmcGF0aDtcclxuXHJcbiAgICAgIHZhciBsYXN0c2xhc2ggPSBiYXNlcGF0aC5sYXN0SW5kZXhPZihcIi9cIik7XHJcbiAgICAgIGlmIChsYXN0c2xhc2ggPT09IC0xKVxyXG4gICAgICAgIHJldHVybiByZWZwYXRoO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGJhc2VwYXRoLnN1YnN0cmluZygwLCBsYXN0c2xhc2grMSkgKyByZWZwYXRoO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbW92ZV9kb3Rfc2VnbWVudHMocGF0aCkge1xyXG4gICAgICBpZiAoIXBhdGgpIHJldHVybiBwYXRoOyAvLyBGb3IgXCJcIiBvciB1bmRlZmluZWRcclxuXHJcbiAgICAgIHZhciBvdXRwdXQgPSBcIlwiO1xyXG4gICAgICB3aGlsZShwYXRoLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBpZiAocGF0aCA9PT0gXCIuXCIgfHwgcGF0aCA9PT0gXCIuLlwiKSB7XHJcbiAgICAgICAgICBwYXRoID0gXCJcIjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHR3b2NoYXJzID0gcGF0aC5zdWJzdHJpbmcoMCwyKTtcclxuICAgICAgICB2YXIgdGhyZWVjaGFycyA9IHBhdGguc3Vic3RyaW5nKDAsMyk7XHJcbiAgICAgICAgdmFyIGZvdXJjaGFycyA9IHBhdGguc3Vic3RyaW5nKDAsNCk7XHJcbiAgICAgICAgaWYgKHRocmVlY2hhcnMgPT09IFwiLi4vXCIpIHtcclxuICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHdvY2hhcnMgPT09IFwiLi9cIikge1xyXG4gICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aHJlZWNoYXJzID09PSBcIi8uL1wiKSB7XHJcbiAgICAgICAgICBwYXRoID0gXCIvXCIgKyBwYXRoLnN1YnN0cmluZygzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHdvY2hhcnMgPT09IFwiLy5cIiAmJiBwYXRoLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgcGF0aCA9IFwiL1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChmb3VyY2hhcnMgPT09IFwiLy4uL1wiIHx8XHJcbiAgICAgICAgICAgICAodGhyZWVjaGFycyA9PT0gXCIvLi5cIiAmJiBwYXRoLmxlbmd0aCA9PT0gMykpIHtcclxuICAgICAgICAgIHBhdGggPSBcIi9cIiArIHBhdGguc3Vic3RyaW5nKDQpO1xyXG5cclxuICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9cXC8/W15cXC9dKiQvLCBcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICB2YXIgc2VnbWVudCA9IHBhdGgubWF0Y2goLyhcXC8/KFteXFwvXSopKS8pWzBdO1xyXG4gICAgICAgICAgb3V0cHV0ICs9IHNlZ21lbnQ7XHJcbiAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoc2VnbWVudC5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH1cclxuICB9LFxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZG9taW5vL2xpYi9VUkwuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgRE9NSW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL0RPTUltcGxlbWVudGF0aW9uJyk7XHJcbnZhciBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vRXZlbnRUYXJnZXQnKTtcclxudmFyIExvY2F0aW9uID0gcmVxdWlyZSgnLi9Mb2NhdGlvbicpO1xyXG52YXIgc2xvcHB5ID0gcmVxdWlyZSgnLi9zbG9wcHknKTtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXaW5kb3c7XHJcblxyXG5mdW5jdGlvbiBXaW5kb3coZG9jdW1lbnQpIHtcclxuICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQgfHwgbmV3IERPTUltcGxlbWVudGF0aW9uKCkuY3JlYXRlSFRNTERvY3VtZW50KFwiXCIpO1xyXG4gIHRoaXMuZG9jdW1lbnQuX3NjcmlwdGluZ19lbmFibGVkID0gdHJ1ZTtcclxuICB0aGlzLmRvY3VtZW50LmRlZmF1bHRWaWV3ID0gdGhpcztcclxuICB0aGlzLmxvY2F0aW9uID0gbmV3IExvY2F0aW9uKHRoaXMsIHRoaXMuZG9jdW1lbnQuX2FkZHJlc3MgfHwgJ2Fib3V0OmJsYW5rJyk7XHJcbn1cclxuXHJcbldpbmRvdy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50VGFyZ2V0LnByb3RvdHlwZSwge1xyXG4gIF9ydW46IHsgdmFsdWU6IHNsb3BweS5XaW5kb3dfcnVuIH0sXHJcbiAgY29uc29sZTogeyB2YWx1ZTogY29uc29sZSB9LFxyXG4gIGhpc3Rvcnk6IHsgdmFsdWU6IHtcclxuICAgIGJhY2s6IHV0aWxzLm55aSxcclxuICAgIGZvcndhcmQ6IHV0aWxzLm55aSxcclxuICAgIGdvOiB1dGlscy5ueWlcclxuICB9fSxcclxuICBuYXZpZ2F0b3I6IHsgdmFsdWU6IHJlcXVpcmUoXCIuL05hdmlnYXRvcklEXCIpIH0sXHJcblxyXG4gIC8vIFNlbGYtcmVmZXJlbnRpYWwgcHJvcGVydGllc1xyXG4gIHdpbmRvdzogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfX0sXHJcbiAgc2VsZjogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfX0sXHJcbiAgZnJhbWVzOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9fSxcclxuXHJcbiAgLy8gU2VsZi1yZWZlcmVudGlhbCBwcm9wZXJ0aWVzIGZvciBhIHRvcC1sZXZlbCB3aW5kb3dcclxuICBwYXJlbnQ6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH19LFxyXG4gIHRvcDogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfX0sXHJcblxyXG4gIC8vIFdlIGRvbid0IHN1cHBvcnQgYW55IG90aGVyIHdpbmRvd3MgZm9yIG5vd1xyXG4gIGxlbmd0aDogeyB2YWx1ZTogMCB9LCAgICAgICAgICAgLy8gbm8gZnJhbWVzXHJcbiAgZnJhbWVFbGVtZW50OiB7IHZhbHVlOiBudWxsIH0sICAvLyBub3QgcGFydCBvZiBhIGZyYW1lXHJcbiAgb3BlbmVyOiB7IHZhbHVlOiBudWxsIH0sICAgICAgICAvLyBub3Qgb3BlbmVkIGJ5IGFub3RoZXIgd2luZG93XHJcblxyXG4gIC8vIFRoZSBvbmxvYWQgZXZlbnQgaGFuZGxlci5cclxuICAvLyBYWFg6IG5lZWQgdG8gc3VwcG9ydCBhIGJ1bmNoIG9mIG90aGVyIGV2ZW50IHR5cGVzLCB0b28sXHJcbiAgLy8gYW5kIGhhdmUgdGhlbSBpbnRlcm9wZXJhdGUgd2l0aCBkb2N1bWVudC5ib2R5LlxyXG5cclxuICBvbmxvYWQ6IHtcclxuICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9nZXRFdmVudEhhbmRsZXIoXCJsb2FkXCIpO1xyXG4gICAgfSxcclxuICAgIHNldDogZnVuY3Rpb24odikge1xyXG4gICAgICB0aGlzLl9zZXRFdmVudEhhbmRsZXIoXCJsb2FkXCIsIHYpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIFhYWCBUaGlzIGlzIGEgY29tcGxldGVseSBicm9rZW4gaW1wbGVtZW50YXRpb25cclxuICBnZXRDb21wdXRlZFN0eWxlOiB7IHZhbHVlOiBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsdCkge1xyXG4gICAgcmV0dXJuIGVsdC5zdHlsZTtcclxuICB9fVxyXG5cclxufSk7XHJcblxyXG51dGlscy5leHBvc2UocmVxdWlyZSgnLi9XaW5kb3dUaW1lcnMnKSwgV2luZG93KTtcclxudXRpbHMuZXhwb3NlKHJlcXVpcmUoJy4vaW1wbCcpLCBXaW5kb3cpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZG9taW5vL2xpYi9XaW5kb3cuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xyXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4vRWxlbWVudCcpO1xyXG52YXIgQ1NTU3R5bGVEZWNsYXJhdGlvbiA9IHJlcXVpcmUoJy4vQ1NTU3R5bGVEZWNsYXJhdGlvbicpO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbnZhciBVUkxVdGlscyA9IHJlcXVpcmUoJy4vVVJMVXRpbHMnKTtcclxudmFyIGRlZmluZUVsZW1lbnQgPSByZXF1aXJlKCcuL2RlZmluZUVsZW1lbnQnKTtcclxuXHJcbnZhciBodG1sRWxlbWVudHMgPSBleHBvcnRzLmVsZW1lbnRzID0ge307XHJcbnZhciBodG1sTmFtZVRvSW1wbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgdmFyIGltcGwgPSBodG1sTmFtZVRvSW1wbFtsb2NhbE5hbWVdIHx8IEhUTUxVbmtub3duRWxlbWVudDtcclxuICByZXR1cm4gbmV3IGltcGwoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBkZWZpbmUoc3BlYykge1xyXG4gIHJldHVybiBkZWZpbmVFbGVtZW50KHNwZWMsIEhUTUxFbGVtZW50LCBodG1sRWxlbWVudHMsIGh0bWxOYW1lVG9JbXBsKTtcclxufVxyXG5cclxuZnVuY3Rpb24gVVJMKGF0dHIpIHtcclxuICByZXR1cm4ge1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHYgPSB0aGlzLl9nZXRhdHRyKGF0dHIpO1xyXG4gICAgICBpZiAodiA9PT0gbnVsbCkgeyByZXR1cm4gJyc7IH1cclxuICAgICAgdmFyIHVybCA9IHRoaXMuZG9jLl9yZXNvbHZlKHYpO1xyXG4gICAgICByZXR1cm4gKHVybCA9PT0gbnVsbCkgPyB2IDogdXJsO1xyXG4gICAgfSxcclxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgdGhpcy5fc2V0YXR0cihhdHRyLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gQ09SUyhhdHRyKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciB2ID0gdGhpcy5fZ2V0YXR0cihhdHRyKTtcclxuICAgICAgaWYgKHYgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cclxuICAgICAgaWYgKHYudG9Mb3dlckNhc2UoKSA9PT0gJ3VzZS1jcmVkZW50aWFscycpIHsgcmV0dXJuICd1c2UtY3JlZGVudGlhbHMnOyB9XHJcbiAgICAgIHJldHVybiAnYW5vbnltb3VzJztcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIGlmICh2YWx1ZT09PW51bGwgfHwgdmFsdWU9PT11bmRlZmluZWQpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9zZXRhdHRyKGF0dHIsIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbnZhciBSRUZFUlJFUiA9IHtcclxuICB0eXBlOiBbXCJcIiwgXCJuby1yZWZlcnJlclwiLCBcIm5vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlXCIsIFwic2FtZS1vcmlnaW5cIiwgXCJvcmlnaW5cIiwgXCJzdHJpY3Qtb3JpZ2luXCIsIFwib3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCIsIFwic3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpblwiLCBcInVuc2FmZS11cmxcIl0sXHJcbiAgbWlzc2luZzogJycsXHJcbn07XHJcblxyXG5cclxuLy8gWFhYOiB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGFiSW5kZXggc2hvdWxkIGJlIDAgaWYgdGhlIGVsZW1lbnQgaXNcclxuLy8gZm9jdXNhYmxlIGFuZCAtMSBpZiBpdCBpcyBub3QuICBCdXQgdGhlIGZ1bGwgZGVmaW5pdGlvbiBvZiBmb2N1c2FibGVcclxuLy8gaXMgYWN0dWFsbHkgaGFyZCB0byBjb21wdXRlLCBzbyBmb3Igbm93LCBJJ2xsIGZvbGxvdyBGaXJlZm94IGFuZFxyXG4vLyBqdXN0IGJhc2UgdGhlIGRlZmF1bHQgdmFsdWUgb24gdGhlIHR5cGUgb2YgdGhlIGVsZW1lbnQuXHJcbnZhciBmb2N1c2FibGVFbGVtZW50cyA9IHtcclxuICBcIkFcIjp0cnVlLCBcIkxJTktcIjp0cnVlLCBcIkJVVFRPTlwiOnRydWUsIFwiSU5QVVRcIjp0cnVlLFxyXG4gIFwiU0VMRUNUXCI6dHJ1ZSwgXCJURVhUQVJFQVwiOnRydWUsIFwiQ09NTUFORFwiOnRydWVcclxufTtcclxuXHJcbnZhciBIVE1MRm9ybUVsZW1lbnQgPSBmdW5jdGlvbihkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB0aGlzLl9mb3JtID0gbnVsbDsgLy8gUHJldmVudCBsYXRlciBkZW9wdGltaXphdGlvblxyXG59O1xyXG5cclxudmFyIEhUTUxFbGVtZW50ID0gZXhwb3J0cy5IVE1MRWxlbWVudCA9IGRlZmluZSh7XHJcbiAgc3VwZXJjbGFzczogRWxlbWVudCxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHV0aWxzLk5BTUVTUEFDRS5IVE1MLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgcHJvcHM6IHtcclxuICAgIGlubmVySFRNTDoge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICB2YXIgcGFyc2VyID0gdGhpcy5vd25lckRvY3VtZW50LmltcGxlbWVudGF0aW9uLm1vekhUTUxQYXJzZXIoXHJcbiAgICAgICAgICB0aGlzLm93bmVyRG9jdW1lbnQuX2FkZHJlc3MsXHJcbiAgICAgICAgICB0aGlzKTtcclxuICAgICAgICBwYXJzZXIucGFyc2UodiwgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIHRtcGRvYyA9IHBhcnNlci5kb2N1bWVudCgpO1xyXG4gICAgICAgIHZhciByb290ID0gdG1wZG9jLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9ICh0aGlzIGluc3RhbmNlb2YgaHRtbE5hbWVUb0ltcGwudGVtcGxhdGUpID9cclxuICAgICAgICAgICAgdGhpcy5jb250ZW50IDogdGhpcztcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBjaGlsZHJlbiBvZiB0aGlzIG5vZGVcclxuICAgICAgICB3aGlsZSh0YXJnZXQuaGFzQ2hpbGROb2RlcygpKVxyXG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUNoaWxkKHRhcmdldC5maXJzdENoaWxkKTtcclxuXHJcbiAgICAgICAgLy8gTm93IGNvcHkgbmV3bHkgcGFyc2VkIGNoaWxkcmVuIGZyb20gdGhlIHJvb3QgdG8gdGhpcyBub2RlXHJcbiAgICAgICAgdGFyZ2V0LmRvYy5hZG9wdE5vZGUocm9vdCk7XHJcbiAgICAgICAgd2hpbGUocm9vdC5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICAgICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChyb290LmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHN0eWxlOiB7IGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICghdGhpcy5fc3R5bGUpXHJcbiAgICAgICAgdGhpcy5fc3R5bGUgPSBuZXcgQ1NTU3R5bGVEZWNsYXJhdGlvbih0aGlzKTtcclxuICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xyXG4gICAgfX0sXHJcblxyXG4gICAgY2xpY2s6IHsgdmFsdWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAodGhpcy5fY2xpY2tfaW5fcHJvZ3Jlc3MpIHJldHVybjtcclxuICAgICAgdGhpcy5fY2xpY2tfaW5fcHJvZ3Jlc3MgPSB0cnVlO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wcmVfY2xpY2tfYWN0aXZhdGlvbl9zdGVwcylcclxuICAgICAgICAgIHRoaXMuX3ByZV9jbGlja19hY3RpdmF0aW9uX3N0ZXBzKCk7XHJcblxyXG4gICAgICAgIHZhciBldmVudCA9IHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRcIik7XHJcbiAgICAgICAgZXZlbnQuaW5pdE1vdXNlRXZlbnQoXCJjbGlja1wiLCB0cnVlLCB0cnVlLFxyXG4gICAgICAgICAgdGhpcy5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LCAxLFxyXG4gICAgICAgICAgMCwgMCwgMCwgMCxcclxuICAgICAgICAgIC8vIFRoZXNlIDQgc2hvdWxkIGJlIGluaXRpYWxpemVkIHdpdGhcclxuICAgICAgICAgIC8vIHRoZSBhY3R1YWxseSBjdXJyZW50IGtleWJvYXJkIHN0YXRlXHJcbiAgICAgICAgICAvLyBzb21laG93Li4uXHJcbiAgICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSxcclxuICAgICAgICAgIDAsIG51bGxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBEaXNwYXRjaCB0aGlzIGFzIGFuIHVudHJ1c3RlZCBldmVudCBzaW5jZSBpdCBpcyBzeW50aGV0aWNcclxuICAgICAgICB2YXIgc3VjY2VzcyA9IHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcblxyXG4gICAgICAgIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5fcG9zdF9jbGlja19hY3RpdmF0aW9uX3N0ZXBzKVxyXG4gICAgICAgICAgICB0aGlzLl9wb3N0X2NsaWNrX2FjdGl2YXRpb25fc3RlcHMoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGlmICh0aGlzLl9jYW5jZWxsZWRfYWN0aXZhdGlvbl9zdGVwcylcclxuICAgICAgICAgICAgdGhpcy5fY2FuY2VsbGVkX2FjdGl2YXRpb25fc3RlcHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5fY2xpY2tfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfX1cclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIHRpdGxlOiBTdHJpbmcsXHJcbiAgICBsYW5nOiBTdHJpbmcsXHJcbiAgICBkaXI6IHt0eXBlOiBbXCJsdHJcIiwgXCJydGxcIiwgXCJhdXRvXCJdLCBtaXNzaW5nOiAnJ30sXHJcbiAgICBhY2Nlc3NLZXk6IFN0cmluZyxcclxuICAgIGhpZGRlbjogQm9vbGVhbixcclxuICAgIHRhYkluZGV4OiB7dHlwZTogXCJsb25nXCIsIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAodGhpcy50YWdOYW1lIGluIGZvY3VzYWJsZUVsZW1lbnRzIHx8XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWRpdGFibGUpXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9fVxyXG4gIH0sXHJcbiAgZXZlbnRzOiBbXHJcbiAgICBcImFib3J0XCIsIFwiY2FucGxheVwiLCBcImNhbnBsYXl0aHJvdWdoXCIsIFwiY2hhbmdlXCIsIFwiY2xpY2tcIiwgXCJjb250ZXh0bWVudVwiLFxyXG4gICAgXCJjdWVjaGFuZ2VcIiwgXCJkYmxjbGlja1wiLCBcImRyYWdcIiwgXCJkcmFnZW5kXCIsIFwiZHJhZ2VudGVyXCIsIFwiZHJhZ2xlYXZlXCIsXHJcbiAgICBcImRyYWdvdmVyXCIsIFwiZHJhZ3N0YXJ0XCIsIFwiZHJvcFwiLCBcImR1cmF0aW9uY2hhbmdlXCIsIFwiZW1wdGllZFwiLCBcImVuZGVkXCIsXHJcbiAgICBcImlucHV0XCIsIFwiaW52YWxpZFwiLCBcImtleWRvd25cIiwgXCJrZXlwcmVzc1wiLCBcImtleXVwXCIsIFwibG9hZGVkZGF0YVwiLFxyXG4gICAgXCJsb2FkZWRtZXRhZGF0YVwiLCBcImxvYWRzdGFydFwiLCBcIm1vdXNlZG93blwiLCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNlb3V0XCIsXHJcbiAgICBcIm1vdXNlb3ZlclwiLCBcIm1vdXNldXBcIiwgXCJtb3VzZXdoZWVsXCIsIFwicGF1c2VcIiwgXCJwbGF5XCIsIFwicGxheWluZ1wiLFxyXG4gICAgXCJwcm9ncmVzc1wiLCBcInJhdGVjaGFuZ2VcIiwgXCJyZWFkeXN0YXRlY2hhbmdlXCIsIFwicmVzZXRcIiwgXCJzZWVrZWRcIixcclxuICAgIFwic2Vla2luZ1wiLCBcInNlbGVjdFwiLCBcInNob3dcIiwgXCJzdGFsbGVkXCIsIFwic3VibWl0XCIsIFwic3VzcGVuZFwiLFxyXG4gICAgXCJ0aW1ldXBkYXRlXCIsIFwidm9sdW1lY2hhbmdlXCIsIFwid2FpdGluZ1wiLFxyXG5cclxuICAgIC8vIFRoZXNlIGxhc3QgNSBldmVudCB0eXBlcyB3aWxsIGJlIG92ZXJyaWRlbiBieSBIVE1MQm9keUVsZW1lbnRcclxuICAgIFwiYmx1clwiLCBcImVycm9yXCIsIFwiZm9jdXNcIiwgXCJsb2FkXCIsIFwic2Nyb2xsXCJcclxuICBdXHJcbn0pO1xyXG5cclxuXHJcbi8vIFhYWDogcmVmbGVjdCBjb250ZXh0bWVudSBhcyBjb250ZXh0TWVudSwgd2l0aCBlbGVtZW50IHR5cGVcclxuXHJcblxyXG4vLyBzdHlsZTogdGhlIHNwZWMgZG9lc24ndCBjYWxsIHRoaXMgYSByZWZsZWN0ZWQgYXR0cmlidXRlLlxyXG4vLyAgIG1heSB3YW50IHRvIGhhbmRsZSBpdCBtYW51YWxseS5cclxuXHJcbi8vIGNvbnRlbnRFZGl0YWJsZTogZW51bWVyYXRlZCwgbm90IGNsZWFyIGlmIGl0IGlzIGFjdHVhbGx5XHJcbi8vIHJlZmxlY3RlZCBvciByZXF1aXJlcyBjdXN0b20gZ2V0dGVyL3NldHRlci4gTm90IGxpc3RlZCBhc1xyXG4vLyBcImxpbWl0ZWQgdG8ga25vd24gdmFsdWVzXCIuICBSYWlzZXMgc3ludGF4X2VyciBvbiBiYWQgc2V0dGluZyxcclxuLy8gc28gSSB0aGluayB0aGlzIGlzIGN1c3RvbS5cclxuXHJcbi8vIGNvbnRleHRtZW51OiBjb250ZW50IGlzIGVsZW1lbnQgaWQsIGlkbCB0eXBlIGlzIGFuIGVsZW1lbnRcclxuLy8gZHJhZ2dhYmxlOiBib29sZWFuLCBidXQgbm90IGEgcmVmbGVjdGVkIGF0dHJpYnV0ZVxyXG4vLyBkcm9wem9uZTogcmVmbGVjdGVkIFNldHRhYmxlVG9rZW5MaXN0LCBleHBlcmltZW50YWwsIHNvIGRvbid0XHJcbi8vICAgaW1wbGVtZW50IGl0IHJpZ2h0IGF3YXkuXHJcblxyXG4vLyBkYXRhLSogYXR0cmlidXRlczogbmVlZCBzcGVjaWFsIGhhbmRsaW5nIGluIHNldEF0dHJpYnV0ZT9cclxuLy8gT3IgbWF5YmUgdGhhdCBpc24ndCBuZWNlc3NhcnkuIENhbiBJIGp1c3Qgc2NhbiB0aGUgYXR0cmlidXRlIGxpc3RcclxuLy8gd2hlbiBidWlsZGluZyB0aGUgZGF0YXNldD8gIExpdmVuZXNzIGFuZCBjYWNoaW5nIGlzc3Vlcz9cclxuXHJcbi8vIG1pY3JvZGF0YSBhdHRyaWJ1dGVzOiBtYW55IGFyZSBzaW1wbGUgcmVmbGVjdGVkIGF0dHJpYnV0ZXMsIGJ1dFxyXG4vLyBJJ20gbm90IGdvaW5nIHRvIGltcGxlbWVudCB0aGlzIG5vdy5cclxuXHJcblxyXG52YXIgSFRNTFVua25vd25FbGVtZW50ID0gZGVmaW5lKHtcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MVW5rbm93bkVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9XHJcbn0pO1xyXG5cclxuXHJcbnZhciBmb3JtQXNzb2NpYXRlZFByb3BzID0ge1xyXG4gIC8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9hc3NvY2lhdGlvbi1vZi1jb250cm9scy1hbmQtZm9ybXMuaHRtbCNmb3JtLW93bmVyXHJcbiAgZm9ybTogeyBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2Zvcm07XHJcbiAgfX1cclxufTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAnYScsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEFuY2hvckVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIHByb3BzOiB7XHJcbiAgICBfcG9zdF9jbGlja19hY3RpdmF0aW9uX3N0ZXBzOiB7IHZhbHVlOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgIGlmICh0aGlzLmhyZWYpIHtcclxuICAgICAgICAvLyBGb2xsb3cgdGhlIGxpbmtcclxuICAgICAgICAvLyBYWFg6IHRoaXMgaXMganVzdCBhIHF1aWNrIGhhY2tcclxuICAgICAgICAvLyBYWFg6IHRoZSBIVE1MIHNwZWMgcHJvYmFibHkgcmVxdWlyZXMgbW9yZSB0aGFuIHRoaXNcclxuICAgICAgICB0aGlzLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcubG9jYXRpb24gPSB0aGlzLmhyZWY7XHJcbiAgICAgIH1cclxuICAgIH19LFxyXG4gICAgYmx1cjogeyB2YWx1ZTogZnVuY3Rpb24oKSB7fX0sXHJcbiAgICBmb2N1czogeyB2YWx1ZTogZnVuY3Rpb24oKSB7fX1cclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIGhyZWY6IFVSTCxcclxuICAgIHBpbmc6IFN0cmluZyxcclxuICAgIGRvd25sb2FkOiBTdHJpbmcsXHJcbiAgICB0YXJnZXQ6IFN0cmluZyxcclxuICAgIHJlbDogU3RyaW5nLFxyXG4gICAgbWVkaWE6IFN0cmluZyxcclxuICAgIGhyZWZsYW5nOiBTdHJpbmcsXHJcbiAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICByZWZlcnJlclBvbGljeTogUkVGRVJSRVIsXHJcbiAgICAvLyBPYnNvbGV0ZVxyXG4gICAgY29vcmRzOiBTdHJpbmcsXHJcbiAgICBjaGFyc2V0OiBTdHJpbmcsXHJcbiAgICBuYW1lOiBTdHJpbmcsXHJcbiAgICByZXY6IFN0cmluZyxcclxuICAgIHNoYXBlOiBTdHJpbmcsXHJcbiAgfVxyXG59KTtcclxuVVJMVXRpbHMuX2luaGVyaXQoaHRtbE5hbWVUb0ltcGwuYS5wcm90b3R5cGUpO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdhcmVhJyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MQXJlYUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIGFsdDogU3RyaW5nLFxyXG4gICAgdGFyZ2V0OiBTdHJpbmcsXHJcbiAgICBkb3dubG9hZDogU3RyaW5nLFxyXG4gICAgcmVsOiBTdHJpbmcsXHJcbiAgICBtZWRpYTogU3RyaW5nLFxyXG4gICAgaHJlZjogVVJMLFxyXG4gICAgaHJlZmxhbmc6IFN0cmluZyxcclxuICAgIHR5cGU6IFN0cmluZyxcclxuICAgIHNoYXBlOiBTdHJpbmcsXHJcbiAgICBjb29yZHM6IFN0cmluZyxcclxuICAgIHBpbmc6IFN0cmluZyxcclxuICAgIC8vIFhYWDogYWxzbyByZWZsZWN0IHJlbExpc3RcclxuICAgIHJlZmVycmVyUG9saWN5OiBSRUZFUlJFUixcclxuICAgIC8vIE9ic29sZXRlXHJcbiAgICBub0hyZWY6IEJvb2xlYW4sXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAnYnInLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxCUkVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIC8vIE9ic29sZXRlXHJcbiAgICBjbGVhcjogU3RyaW5nXHJcbiAgfSxcclxufSk7XHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZzogJ2Jhc2UnLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxCYXNlRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgXCJ0YXJnZXRcIjogU3RyaW5nXHJcbiAgfVxyXG59KTtcclxuXHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZzogJ2JvZHknLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxCb2R5RWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgLy8gQ2VydGFpbiBldmVudCBoYW5kbGVyIGF0dHJpYnV0ZXMgb24gYSA8Ym9keT4gdGFnIGFjdHVhbGx5IHNldFxyXG4gIC8vIGhhbmRsZXJzIGZvciB0aGUgd2luZG93IHJhdGhlciB0aGFuIGp1c3QgdGhhdCBlbGVtZW50LiAgRGVmaW5lXHJcbiAgLy8gZ2V0dGVycyBhbmQgc2V0dGVycyBmb3IgdGhvc2UgaGVyZS4gIE5vdGUgdGhhdCBzb21lIG9mIHRoZXNlIG92ZXJyaWRlXHJcbiAgLy8gcHJvcGVydGllcyBvbiBIVE1MRWxlbWVudC5wcm90b3R5cGUuXHJcbiAgLy8gWFhYOiBJZiBJIGFkZCBzdXBwb3J0IGZvciA8ZnJhbWVzZXQ+LCB0aGVzZSBoYXZlIHRvIGdvIHRoZXJlLCB0b29cclxuICAvLyBYWFhcclxuICAvLyBXaGVuIHRoZSBXaW5kb3cgb2JqZWN0IGlzIGltcGxlbWVudGVkLCB0aGVzZSBhdHRyaWJ1dGUgd2lsbCBoYXZlXHJcbiAgLy8gdG8gd29yayB3aXRoIHRoZSBzYW1lLW5hbWVkIGF0dHJpYnV0ZXMgb24gdGhlIFdpbmRvdy5cclxuICBldmVudHM6IFtcclxuICAgIFwiYWZ0ZXJwcmludFwiLCBcImJlZm9yZXByaW50XCIsIFwiYmVmb3JldW5sb2FkXCIsIFwiYmx1clwiLCBcImVycm9yXCIsXHJcbiAgICBcImZvY3VzXCIsXCJoYXNoY2hhbmdlXCIsIFwibG9hZFwiLCBcIm1lc3NhZ2VcIiwgXCJvZmZsaW5lXCIsIFwib25saW5lXCIsXHJcbiAgICBcInBhZ2VoaWRlXCIsIFwicGFnZXNob3dcIixcInBvcHN0YXRlXCIsXCJyZXNpemVcIixcInNjcm9sbFwiLFwic3RvcmFnZVwiLFwidW5sb2FkXCIsXHJcbiAgXSxcclxuICBhdHRyaWJ1dGVzOiB7XHJcbiAgICAvLyBPYnNvbGV0ZVxyXG4gICAgdGV4dDogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcclxuICAgIGxpbms6IHsgdHlwZTogU3RyaW5nLCB0cmVhdE51bGxBc0VtcHR5U3RyaW5nOiB0cnVlIH0sXHJcbiAgICB2TGluazogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcclxuICAgIGFMaW5rOiB7IHR5cGU6IFN0cmluZywgdHJlYXROdWxsQXNFbXB0eVN0cmluZzogdHJ1ZSB9LFxyXG4gICAgYmdDb2xvcjogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcclxuICAgIGJhY2tncm91bmQ6IFN0cmluZyxcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdidXR0b24nLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxCdXR0b25FbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxGb3JtRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgcHJvcHM6IGZvcm1Bc3NvY2lhdGVkUHJvcHMsXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgbmFtZTogU3RyaW5nLFxyXG4gICAgdmFsdWU6IFN0cmluZyxcclxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxyXG4gICAgYXV0b2ZvY3VzOiBCb29sZWFuLFxyXG4gICAgdHlwZTogeyB0eXBlOltcInN1Ym1pdFwiLCBcInJlc2V0XCIsIFwiYnV0dG9uXCIsIFwibWVudVwiXSwgbWlzc2luZzogJ3N1Ym1pdCcgfSxcclxuICAgIGZvcm1UYXJnZXQ6IFN0cmluZyxcclxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBCb29sZWFuLFxyXG4gICAgZm9ybU1ldGhvZDogeyB0eXBlOiBbXCJnZXRcIiwgXCJwb3N0XCIsIFwiZGlhbG9nXCJdLCBpbnZhbGlkOiAnZ2V0JywgbWlzc2luZzogJycgfSxcclxuICAgIGZvcm1FbmN0eXBlOiB7IHR5cGU6IFtcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiwgXCJ0ZXh0L3BsYWluXCJdLCBpbnZhbGlkOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCBtaXNzaW5nOiAnJyB9LFxyXG4gIH1cclxufSk7XHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZzogJ2RsJyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MRExpc3RFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxuICBhdHRyaWJ1dGVzOiB7XHJcbiAgICAvLyBPYnNvbGV0ZVxyXG4gICAgY29tcGFjdDogQm9vbGVhbixcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdkYXRhJyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MRGF0YUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIHZhbHVlOiBTdHJpbmcsXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAnZGF0YWxpc3QnLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxEYXRhTGlzdEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdkZXRhaWxzJyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MRGV0YWlsc0VsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIFwib3BlblwiOiBCb29sZWFuXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAnZGl2JyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MRGl2RWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgLy8gT2Jzb2xldGVcclxuICAgIGFsaWduOiBTdHJpbmdcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdlbWJlZCcsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEVtYmVkRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgc3JjOiBVUkwsXHJcbiAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICB3aWR0aDogU3RyaW5nLFxyXG4gICAgaGVpZ2h0OiBTdHJpbmcsXHJcbiAgICAvLyBPYnNvbGV0ZVxyXG4gICAgYWxpZ246IFN0cmluZyxcclxuICAgIG5hbWU6IFN0cmluZyxcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdmaWVsZHNldCcsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEZpZWxkU2V0RWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRm9ybUVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIHByb3BzOiBmb3JtQXNzb2NpYXRlZFByb3BzLFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxyXG4gICAgbmFtZTogU3RyaW5nXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAnZm9ybScsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEZvcm1FbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxuICBhdHRyaWJ1dGVzOiB7XHJcbiAgICBhY3Rpb246IFN0cmluZyxcclxuICAgIGF1dG9jb21wbGV0ZToge3R5cGU6WydvbicsICdvZmYnXSwgbWlzc2luZzogJ29uJ30sXHJcbiAgICBuYW1lOiBTdHJpbmcsXHJcbiAgICBhY2NlcHRDaGFyc2V0OiB7bmFtZTogXCJhY2NlcHQtY2hhcnNldFwifSxcclxuICAgIHRhcmdldDogU3RyaW5nLFxyXG4gICAgbm9WYWxpZGF0ZTogQm9vbGVhbixcclxuICAgIG1ldGhvZDogeyB0eXBlOiBbXCJnZXRcIiwgXCJwb3N0XCIsIFwiZGlhbG9nXCJdLCBpbnZhbGlkOiAnZ2V0JywgbWlzc2luZzogJ2dldCcgfSxcclxuICAgIC8vIEJvdGggZW5jdHlwZSBhbmQgZW5jb2RpbmcgcmVmbGVjdCB0aGUgZW5jdHlwZSBjb250ZW50IGF0dHJpYnV0ZVxyXG4gICAgZW5jdHlwZTogeyB0eXBlOiBbXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIsIFwidGV4dC9wbGFpblwiXSwgaW52YWxpZDogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgbWlzc2luZzogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiB9LFxyXG4gICAgZW5jb2Rpbmc6IHtuYW1lOiAnZW5jdHlwZScsIHR5cGU6IFtcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiwgXCJ0ZXh0L3BsYWluXCJdLCBpbnZhbGlkOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCBtaXNzaW5nOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiIH0sXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAnaHInLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxIUkVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIC8vIE9ic29sZXRlXHJcbiAgICBhbGlnbjogU3RyaW5nLFxyXG4gICAgY29sb3I6IFN0cmluZyxcclxuICAgIG5vU2hhZGU6IEJvb2xlYW4sXHJcbiAgICBzaXplOiBTdHJpbmcsXHJcbiAgICB3aWR0aDogU3RyaW5nLFxyXG4gIH0sXHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdoZWFkJyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MSGVhZEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWdzOiBbJ2gxJywnaDInLCdoMycsJ2g0JywnaDUnLCdoNiddLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxIZWFkaW5nRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgLy8gT2Jzb2xldGVcclxuICAgIGFsaWduOiBTdHJpbmcsXHJcbiAgfSxcclxufSk7XHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZzogJ2h0bWwnLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxIdG1sRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgLy8gT2Jzb2xldGVcclxuICAgIHZlcnNpb246IFN0cmluZ1xyXG4gIH1cclxufSk7XHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZzogJ2lmcmFtZScsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTElGcmFtZUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICAgIHZhciBXaW5kb3cgPSByZXF1aXJlKCcuL1dpbmRvdycpOyAvLyBBdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXHJcbiAgICB0aGlzLl9jb250ZW50V2luZG93ID0gbmV3IFdpbmRvdygpO1xyXG4gIH0sXHJcbiAgcHJvcHM6IHtcclxuICAgIGNvbnRlbnRXaW5kb3c6IHsgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRXaW5kb3c7XHJcbiAgICB9IH0sXHJcbiAgICBjb250ZW50RG9jdW1lbnQ6IHsgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29udGVudFdpbmRvdy5kb2N1bWVudDtcclxuICAgIH0gfSxcclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIHNyYzogVVJMLFxyXG4gICAgc3JjZG9jOiBTdHJpbmcsXHJcbiAgICBuYW1lOiBTdHJpbmcsXHJcbiAgICB3aWR0aDogU3RyaW5nLFxyXG4gICAgaGVpZ2h0OiBTdHJpbmcsXHJcbiAgICAvLyBYWFg6IHNhbmRib3ggaXMgYSByZWZsZWN0ZWQgc2V0dGFibGUgdG9rZW4gbGlzdFxyXG4gICAgc2VhbWxlc3M6IEJvb2xlYW4sXHJcbiAgICBhbGxvd0Z1bGxzY3JlZW46IEJvb2xlYW4sXHJcbiAgICBhbGxvd1VzZXJNZWRpYTogQm9vbGVhbixcclxuICAgIGFsbG93UGF5bWVudFJlcXVlc3Q6IEJvb2xlYW4sXHJcbiAgICByZWZlcnJlclBvbGljeTogUkVGRVJSRVIsXHJcbiAgICAvLyBPYnNvbGV0ZVxyXG4gICAgYWxpZ246IFN0cmluZyxcclxuICAgIHNjcm9sbGluZzogU3RyaW5nLFxyXG4gICAgZnJhbWVCb3JkZXI6IFN0cmluZyxcclxuICAgIGxvbmdEZXNjOiBVUkwsXHJcbiAgICBtYXJnaW5IZWlnaHQ6IHsgdHlwZTogU3RyaW5nLCB0cmVhdE51bGxBc0VtcHR5U3RyaW5nOiB0cnVlIH0sXHJcbiAgICBtYXJnaW5XaWR0aDogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdpbWcnLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxJbWFnZUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIGFsdDogU3RyaW5nLFxyXG4gICAgc3JjOiBVUkwsXHJcbiAgICBzcmNzZXQ6IFN0cmluZyxcclxuICAgIGNyb3NzT3JpZ2luOiBDT1JTLFxyXG4gICAgdXNlTWFwOiBTdHJpbmcsXHJcbiAgICBpc01hcDogQm9vbGVhbixcclxuICAgIGhlaWdodDogeyB0eXBlOiBcInVuc2lnbmVkIGxvbmdcIiwgZGVmYXVsdDogMCB9LFxyXG4gICAgd2lkdGg6IHsgdHlwZTogXCJ1bnNpZ25lZCBsb25nXCIsIGRlZmF1bHQ6IDAgfSxcclxuICAgIHJlZmVycmVyUG9saWN5OiBSRUZFUlJFUixcclxuICAgIC8vIE9ic29sZXRlOlxyXG4gICAgbmFtZTogU3RyaW5nLFxyXG4gICAgbG93c3JjOiBVUkwsXHJcbiAgICBhbGlnbjogU3RyaW5nLFxyXG4gICAgaHNwYWNlOiB7IHR5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBkZWZhdWx0OiAwIH0sXHJcbiAgICB2c3BhY2U6IHsgdHlwZTogXCJ1bnNpZ25lZCBsb25nXCIsIGRlZmF1bHQ6IDAgfSxcclxuICAgIGxvbmdEZXNjOiBVUkwsXHJcbiAgICBib3JkZXI6IHsgdHlwZTogU3RyaW5nLCB0cmVhdE51bGxBc0VtcHR5U3RyaW5nOiB0cnVlIH0sXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAnaW5wdXQnLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxJbnB1dEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEZvcm1FbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxuICBwcm9wczoge1xyXG4gICAgZm9ybTogZm9ybUFzc29jaWF0ZWRQcm9wcy5mb3JtLFxyXG4gICAgX3Bvc3RfY2xpY2tfYWN0aXZhdGlvbl9zdGVwczogeyB2YWx1ZTogZnVuY3Rpb24oZSkge1xyXG4gICAgICBpZiAodGhpcy50eXBlID09PSAnY2hlY2tib3gnKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja2VkID0gIXRoaXMuY2hlY2tlZDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpbycpIHtcclxuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmZvcm0uZ2V0RWxlbWVudHNCeU5hbWUodGhpcy5uYW1lKTtcclxuICAgICAgICBmb3IgKHZhciBpPWdyb3VwLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgdmFyIGVsID0gZ3JvdXBbaV07XHJcbiAgICAgICAgICBlbC5jaGVja2VkID0gKGVsID09PSB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH19LFxyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgbmFtZTogU3RyaW5nLFxyXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXHJcbiAgICBhdXRvZm9jdXM6IEJvb2xlYW4sXHJcbiAgICBhY2NlcHQ6IFN0cmluZyxcclxuICAgIGFsdDogU3RyaW5nLFxyXG4gICAgbWF4OiBTdHJpbmcsXHJcbiAgICBtaW46IFN0cmluZyxcclxuICAgIHBhdHRlcm46IFN0cmluZyxcclxuICAgIHBsYWNlaG9sZGVyOiBTdHJpbmcsXHJcbiAgICBzdGVwOiBTdHJpbmcsXHJcbiAgICBkaXJOYW1lOiBTdHJpbmcsXHJcbiAgICBkZWZhdWx0VmFsdWU6IHtuYW1lOiAndmFsdWUnfSxcclxuICAgIG11bHRpcGxlOiBCb29sZWFuLFxyXG4gICAgcmVxdWlyZWQ6IEJvb2xlYW4sXHJcbiAgICByZWFkT25seTogQm9vbGVhbixcclxuICAgIGNoZWNrZWQ6IEJvb2xlYW4sXHJcbiAgICB2YWx1ZTogU3RyaW5nLFxyXG4gICAgc3JjOiBVUkwsXHJcbiAgICBkZWZhdWx0Q2hlY2tlZDoge25hbWU6ICdjaGVja2VkJywgdHlwZTogQm9vbGVhbn0sXHJcbiAgICBzaXplOiB7dHlwZTogJ3Vuc2lnbmVkIGxvbmcnLCBkZWZhdWx0OiAyMCwgbWluOiAxLCBzZXRtaW46IDF9LFxyXG4gICAgbWF4TGVuZ3RoOiB7dHlwZTogJ3Vuc2lnbmVkIGxvbmcnLCBtaW46IDAsIHNldG1pbjogMCwgZGVmYXVsdDogLTF9LFxyXG4gICAgYXV0b2NvbXBsZXRlOiBTdHJpbmcsIC8vIEl0J3MgY29tcGxpY2F0ZWRcclxuICAgIHR5cGU6IHsgdHlwZTpcclxuICAgICAgICAgICAgW1widGV4dFwiLCBcImhpZGRlblwiLCBcInNlYXJjaFwiLCBcInRlbFwiLCBcInVybFwiLCBcImVtYWlsXCIsIFwicGFzc3dvcmRcIixcclxuICAgICAgICAgICAgIFwiZGF0ZXRpbWVcIiwgXCJkYXRlXCIsIFwibW9udGhcIiwgXCJ3ZWVrXCIsIFwidGltZVwiLCBcImRhdGV0aW1lLWxvY2FsXCIsXHJcbiAgICAgICAgICAgICBcIm51bWJlclwiLCBcInJhbmdlXCIsIFwiY29sb3JcIiwgXCJjaGVja2JveFwiLCBcInJhZGlvXCIsIFwiZmlsZVwiLCBcInN1Ym1pdFwiLFxyXG4gICAgICAgICAgICAgXCJpbWFnZVwiLCBcInJlc2V0XCIsIFwiYnV0dG9uXCJdLFxyXG4gICAgICAgICAgICBtaXNzaW5nOiAndGV4dCcgfSxcclxuICAgIGZvcm1UYXJnZXQ6IFN0cmluZyxcclxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBCb29sZWFuLFxyXG4gICAgZm9ybU1ldGhvZDogeyB0eXBlOiBbXCJnZXRcIiwgXCJwb3N0XCJdLCBpbnZhbGlkOiAnZ2V0JywgbWlzc2luZzogJycgfSxcclxuICAgIGZvcm1FbmN0eXBlOiB7IHR5cGU6IFtcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiwgXCJ0ZXh0L3BsYWluXCJdLCBpbnZhbGlkOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCBtaXNzaW5nOiAnJyB9LFxyXG4gICAgaW5wdXRNb2RlOiB7IHR5cGU6IFsgXCJ2ZXJiYXRpbVwiLCBcImxhdGluXCIsIFwibGF0aW4tbmFtZVwiLCBcImxhdGluLXByb3NlXCIsIFwiZnVsbC13aWR0aC1sYXRpblwiLCBcImthbmFcIiwgXCJrYW5hLW5hbWVcIiwgXCJrYXRha2FuYVwiLCBcIm51bWVyaWNcIiwgXCJ0ZWxcIiwgXCJlbWFpbFwiLCBcInVybFwiIF0sIG1pc3Npbmc6ICcnIH0sXHJcbiAgICAvLyBPYnNvbGV0ZVxyXG4gICAgYWxpZ246IFN0cmluZyxcclxuICAgIHVzZU1hcDogU3RyaW5nLFxyXG4gIH1cclxufSk7XHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZzogJ2tleWdlbicsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEtleWdlbkVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEZvcm1FbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxuICBwcm9wczogZm9ybUFzc29jaWF0ZWRQcm9wcyxcclxuICBhdHRyaWJ1dGVzOiB7XHJcbiAgICBuYW1lOiBTdHJpbmcsXHJcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcclxuICAgIGF1dG9mb2N1czogQm9vbGVhbixcclxuICAgIGNoYWxsZW5nZTogU3RyaW5nLFxyXG4gICAga2V5dHlwZTogeyB0eXBlOltcInJzYVwiXSwgbWlzc2luZzogJycgfSxcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdsaScsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTExJRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgdmFsdWU6IHt0eXBlOiBcImxvbmdcIiwgZGVmYXVsdDogMH0sXHJcbiAgICAvLyBPYnNvbGV0ZVxyXG4gICAgdHlwZTogU3RyaW5nLFxyXG4gIH1cclxufSk7XHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZzogJ2xhYmVsJyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MTGFiZWxFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxGb3JtRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgcHJvcHM6IGZvcm1Bc3NvY2lhdGVkUHJvcHMsXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgaHRtbEZvcjoge25hbWU6ICdmb3InLCB0eXBlOiBTdHJpbmd9XHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAnbGVnZW5kJyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MTGVnZW5kRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgLy8gT2Jzb2xldGVcclxuICAgIGFsaWduOiBTdHJpbmdcclxuICB9LFxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAnbGluaycsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTExpbmtFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxuICBhdHRyaWJ1dGVzOiB7XHJcbiAgICAvLyBYWFggUmVmbGVjdCBET01TZXR0YWJsZVRva2VuTGlzdCBzaXplcyBhbHNvIERPTVRva2VuTGlzdCByZWxMaXN0XHJcbiAgICBocmVmOiBVUkwsXHJcbiAgICByZWw6IFN0cmluZyxcclxuICAgIG1lZGlhOiBTdHJpbmcsXHJcbiAgICBocmVmbGFuZzogU3RyaW5nLFxyXG4gICAgdHlwZTogU3RyaW5nLFxyXG4gICAgY3Jvc3NPcmlnaW46IENPUlMsXHJcbiAgICBub25jZTogU3RyaW5nLFxyXG4gICAgaW50ZWdyaXR5OiBTdHJpbmcsXHJcbiAgICByZWZlcnJlclBvbGljeTogUkVGRVJSRVIsXHJcbiAgICAvLyBPYnNvbGV0ZVxyXG4gICAgY2hhcnNldDogU3RyaW5nLFxyXG4gICAgcmV2OiBTdHJpbmcsXHJcbiAgICB0YXJnZXQ6IFN0cmluZyxcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdtYXAnLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxNYXBFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxuICBhdHRyaWJ1dGVzOiB7XHJcbiAgICBuYW1lOiBTdHJpbmdcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdtZW51JyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MTWVudUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIC8vIFhYWDogbm90IHF1aXRlIHJpZ2h0LCBkZWZhdWx0IHNob3VsZCBiZSBwb3B1cCBpZiBwYXJlbnQgZWxlbWVudCBpc1xyXG4gICAgLy8gcG9wdXAuXHJcbiAgICB0eXBlOiB7IHR5cGU6IFsgJ2NvbnRleHQnLCAncG9wdXAnLCAndG9vbGJhcicgXSwgbWlzc2luZzogJ3Rvb2xiYXInIH0sXHJcbiAgICBsYWJlbDogU3RyaW5nLFxyXG4gICAgLy8gT2Jzb2xldGVcclxuICAgIGNvbXBhY3Q6IEJvb2xlYW4sXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAnbWV0YScsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTE1ldGFFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxuICBhdHRyaWJ1dGVzOiB7XHJcbiAgICBuYW1lOiBTdHJpbmcsXHJcbiAgICBjb250ZW50OiBTdHJpbmcsXHJcbiAgICBodHRwRXF1aXY6IHtuYW1lOiAnaHR0cC1lcXVpdicsIHR5cGU6IFN0cmluZ30sXHJcbiAgICAvLyBPYnNvbGV0ZVxyXG4gICAgc2NoZW1lOiBTdHJpbmcsXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAnbWV0ZXInLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxNZXRlckVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEZvcm1FbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxuICBwcm9wczogZm9ybUFzc29jaWF0ZWRQcm9wc1xyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnczogWydpbnMnLCAnZGVsJ10sXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTE1vZEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIGNpdGU6IFVSTCxcclxuICAgIGRhdGVUaW1lOiBTdHJpbmdcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdvbCcsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTE9MaXN0RWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgcHJvcHM6IHtcclxuICAgIC8vIFV0aWxpdHkgZnVuY3Rpb24gKHNlZSB0aGUgc3RhcnQgYXR0cmlidXRlIGRlZmF1bHQgdmFsdWUpLiBSZXR1cm5zXHJcbiAgICAvLyB0aGUgbnVtYmVyIG9mIDxsaT4gY2hpbGRyZW4gb2YgdGhpcyBlbGVtZW50XHJcbiAgICBfbnVtaXRlbXM6IHsgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGl0ZW1zID0gMDtcclxuICAgICAgdGhpcy5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24obikge1xyXG4gICAgICAgIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBuLnRhZ05hbWUgPT09IFwiTElcIilcclxuICAgICAgICAgIGl0ZW1zKys7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gaXRlbXM7XHJcbiAgICB9fVxyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgdHlwZTogU3RyaW5nLFxyXG4gICAgcmV2ZXJzZWQ6IEJvb2xlYW4sXHJcbiAgICBzdGFydDoge1xyXG4gICAgICB0eXBlOiBcImxvbmdcIixcclxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSBvZiB0aGUgc3RhcnQgYXR0cmlidXRlIGlzIDEgdW5sZXNzIHRoZSBsaXN0IGlzXHJcbiAgICAgICAvLyByZXZlcnNlZC4gVGhlbiBpdCBpcyB0aGUgIyBvZiBsaSBjaGlsZHJlblxyXG4gICAgICAgaWYgKHRoaXMucmV2ZXJzZWQpXHJcbiAgICAgICAgIHJldHVybiB0aGlzLl9udW1pdGVtcztcclxuICAgICAgIGVsc2VcclxuICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyBPYnNvbGV0ZVxyXG4gICAgY29tcGFjdDogQm9vbGVhbixcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdvYmplY3QnLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxPYmplY3RFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxGb3JtRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgcHJvcHM6IGZvcm1Bc3NvY2lhdGVkUHJvcHMsXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgZGF0YTogVVJMLFxyXG4gICAgdHlwZTogU3RyaW5nLFxyXG4gICAgbmFtZTogU3RyaW5nLFxyXG4gICAgdXNlTWFwOiBTdHJpbmcsXHJcbiAgICB0eXBlTXVzdE1hdGNoOiBCb29sZWFuLFxyXG4gICAgd2lkdGg6IFN0cmluZyxcclxuICAgIGhlaWdodDogU3RyaW5nLFxyXG4gICAgLy8gT2Jzb2xldGVcclxuICAgIGFsaWduOiBTdHJpbmcsXHJcbiAgICBhcmNoaXZlOiBTdHJpbmcsXHJcbiAgICBjb2RlOiBTdHJpbmcsXHJcbiAgICBkZWNsYXJlOiBCb29sZWFuLFxyXG4gICAgaHNwYWNlOiB7IHR5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBkZWZhdWx0OiAwIH0sXHJcbiAgICBzdGFuZGJ5OiBTdHJpbmcsXHJcbiAgICB2c3BhY2U6IHsgdHlwZTogXCJ1bnNpZ25lZCBsb25nXCIsIGRlZmF1bHQ6IDAgfSxcclxuICAgIGNvZGVCYXNlOiBVUkwsXHJcbiAgICBjb2RlVHlwZTogU3RyaW5nLFxyXG4gICAgYm9yZGVyOiB7IHR5cGU6IFN0cmluZywgdHJlYXROdWxsQXNFbXB0eVN0cmluZzogdHJ1ZSB9LFxyXG4gIH1cclxufSk7XHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZzogJ29wdGdyb3VwJyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MT3B0R3JvdXBFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxuICBhdHRyaWJ1dGVzOiB7XHJcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcclxuICAgIGxhYmVsOiBTdHJpbmdcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdvcHRpb24nLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxPcHRpb25FbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxuICBwcm9wczoge1xyXG4gICAgZm9ybTogeyBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgcCA9IHRoaXMucGFyZW50Tm9kZTtcclxuICAgICAgd2hpbGUgKHAgJiYgcC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICBpZiAocC5sb2NhbE5hbWUgPT09ICdzZWxlY3QnKSByZXR1cm4gcC5mb3JtO1xyXG4gICAgICAgIHAgPSBwLnBhcmVudE5vZGU7XHJcbiAgICAgIH1cclxuICAgIH19XHJcbiAgfSxcclxuICBhdHRyaWJ1dGVzOiB7XHJcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcclxuICAgIGRlZmF1bHRTZWxlY3RlZDoge25hbWU6ICdzZWxlY3RlZCcsIHR5cGU6IEJvb2xlYW59LFxyXG4gICAgbGFiZWw6IFN0cmluZyxcclxuICAgIHZhbHVlOiBTdHJpbmcsXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAnb3V0cHV0JyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MT3V0cHV0RWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRm9ybUVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIHByb3BzOiBmb3JtQXNzb2NpYXRlZFByb3BzLFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIC8vIFhYWCBSZWZsZWN0IGZvci9odG1sRm9yIGFzIGEgc2V0dGFibGUgdG9rZW4gbGlzdFxyXG4gICAgbmFtZTogU3RyaW5nXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAncCcsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFBhcmFncmFwaEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIC8vIE9ic29sZXRlXHJcbiAgICBhbGlnbjogU3RyaW5nXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAncGFyYW0nLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxQYXJhbUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIG5hbWU6IFN0cmluZyxcclxuICAgIHZhbHVlOiBTdHJpbmcsXHJcbiAgICAvLyBPYnNvbGV0ZVxyXG4gICAgdHlwZTogU3RyaW5nLFxyXG4gICAgdmFsdWVUeXBlOiBTdHJpbmcsXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnczogWydwcmUnLC8qbGVnYWN5IGVsZW1lbnRzOiovJ2xpc3RpbmcnLCd4bXAnXSxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MUHJlRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgLy8gT2Jzb2xldGVcclxuICAgIHdpZHRoOiB7IHR5cGU6IFwibG9uZ1wiLCBkZWZhdWx0OiAwIH0sXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAncHJvZ3Jlc3MnLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxQcm9ncmVzc0VsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEZvcm1FbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxuICBwcm9wczogZm9ybUFzc29jaWF0ZWRQcm9wcyxcclxuICBhdHRyaWJ1dGVzOiB7XHJcbiAgICBtYXg6IHt0eXBlOiBOdW1iZXIsIGZsb2F0OiB0cnVlLCBkZWZhdWx0OiAxLjAsIG1pbjogMH1cclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWdzOiBbJ3EnLCAnYmxvY2txdW90ZSddLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxRdW90ZUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIGNpdGU6IFVSTFxyXG4gIH1cclxufSk7XHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZzogJ3NjcmlwdCcsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFNjcmlwdEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIHByb3BzOiB7XHJcbiAgICB0ZXh0OiB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHMgPSBcIlwiO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDAsIG4gPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkTm9kZXNbaV07XHJcbiAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKVxyXG4gICAgICAgICAgICBzICs9IGNoaWxkLl9kYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcztcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGRyZW4oKTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IFwiXCIpIHtcclxuICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBhdHRyaWJ1dGVzOiB7XHJcbiAgICBzcmM6IFVSTCxcclxuICAgIHR5cGU6IFN0cmluZyxcclxuICAgIGNoYXJzZXQ6IFN0cmluZyxcclxuICAgIGRlZmVyOiBCb29sZWFuLFxyXG4gICAgYXN5bmM6IEJvb2xlYW4sXHJcbiAgICBjcm9zc09yaWdpbjogQ09SUyxcclxuICAgIG5vbmNlOiBTdHJpbmcsXHJcbiAgICBpbnRlZ3JpdHk6IFN0cmluZyxcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdzZWxlY3QnLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxTZWxlY3RFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxGb3JtRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgcHJvcHM6IHtcclxuICAgIGZvcm06IGZvcm1Bc3NvY2lhdGVkUHJvcHMuZm9ybSxcclxuICAgIG9wdGlvbnM6IHsgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ29wdGlvbicpO1xyXG4gICAgfX1cclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIG5hbWU6IFN0cmluZyxcclxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxyXG4gICAgYXV0b2ZvY3VzOiBCb29sZWFuLFxyXG4gICAgbXVsdGlwbGU6IEJvb2xlYW4sXHJcbiAgICByZXF1aXJlZDogQm9vbGVhbixcclxuICAgIHNpemU6IHt0eXBlOiBcInVuc2lnbmVkIGxvbmdcIiwgZGVmYXVsdDogMH1cclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdzb3VyY2UnLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxTb3VyY2VFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxuICBhdHRyaWJ1dGVzOiB7XHJcbiAgICBzcmM6IFVSTCxcclxuICAgIHR5cGU6IFN0cmluZyxcclxuICAgIG1lZGlhOiBTdHJpbmdcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdzcGFuJyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MU3BhbkVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdzdHlsZScsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFN0eWxlRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgbWVkaWE6IFN0cmluZyxcclxuICAgIHR5cGU6IFN0cmluZyxcclxuICAgIHNjb3BlZDogQm9vbGVhblxyXG4gIH1cclxufSk7XHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZzogJ2NhcHRpb24nLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxUYWJsZUNhcHRpb25FbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxuICBhdHRyaWJ1dGVzOiB7XHJcbiAgICAvLyBPYnNvbGV0ZVxyXG4gICAgYWxpZ246IFN0cmluZyxcclxuICB9XHJcbn0pO1xyXG5cclxuXHJcbmRlZmluZSh7XHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFRhYmxlQ2VsbEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIGNvbFNwYW46IHt0eXBlOiBcInVuc2lnbmVkIGxvbmdcIiwgZGVmYXVsdDogMX0sXHJcbiAgICByb3dTcGFuOiB7dHlwZTogXCJ1bnNpZ25lZCBsb25nXCIsIGRlZmF1bHQ6IDF9LFxyXG4gICAgLy9YWFggQWxzbyByZWZsZWN0IHNldHRhYmxlIHRva2VuIGxpc3QgaGVhZGVyc1xyXG4gICAgc2NvcGU6IHsgdHlwZTogWydyb3cnLCdjb2wnLCdyb3dncm91cCcsJ2NvbGdyb3VwJ10sIG1pc3Npbmc6ICcnIH0sXHJcbiAgICBhYmJyOiBTdHJpbmcsXHJcbiAgICAvLyBPYnNvbGV0ZVxyXG4gICAgYWxpZ246IFN0cmluZyxcclxuICAgIGF4aXM6IFN0cmluZyxcclxuICAgIGhlaWdodDogU3RyaW5nLFxyXG4gICAgd2lkdGg6IFN0cmluZyxcclxuICAgIGNoOiB7IG5hbWU6ICdjaGFyJywgdHlwZTogU3RyaW5nIH0sXHJcbiAgICBjaE9mZjogeyBuYW1lOiAnY2hhcm9mZicsIHR5cGU6IFN0cmluZyB9LFxyXG4gICAgbm9XcmFwOiBCb29sZWFuLFxyXG4gICAgdkFsaWduOiBTdHJpbmcsXHJcbiAgICBiZ0NvbG9yOiB7IHR5cGU6IFN0cmluZywgdHJlYXROdWxsQXNFbXB0eVN0cmluZzogdHJ1ZSB9LFxyXG4gIH1cclxufSk7XHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZ3M6IFsnY29sJywgJ2NvbGdyb3VwJ10sXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFRhYmxlQ29sRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgc3Bhbjoge3R5cGU6ICdsaW1pdGVkIHVuc2lnbmVkIGxvbmcgd2l0aCBmYWxsYmFjaycsIGRlZmF1bHQ6IDEsIG1pbjogMX0sXHJcbiAgICAvLyBPYnNvbGV0ZVxyXG4gICAgYWxpZ246IFN0cmluZyxcclxuICAgIGNoOiB7IG5hbWU6ICdjaGFyJywgdHlwZTogU3RyaW5nIH0sXHJcbiAgICBjaE9mZjogeyBuYW1lOiAnY2hhcm9mZicsIHR5cGU6IFN0cmluZyB9LFxyXG4gICAgdkFsaWduOiBTdHJpbmcsXHJcbiAgICB3aWR0aDogU3RyaW5nLFxyXG4gIH1cclxufSk7XHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZzogJ3RhYmxlJyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MVGFibGVFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxuICBwcm9wczoge1xyXG4gICAgcm93czogeyBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndHInKTtcclxuICAgIH19XHJcbiAgfSxcclxuICBhdHRyaWJ1dGVzOiB7XHJcbiAgICAvLyBPYnNvbGV0ZVxyXG4gICAgYWxpZ246IFN0cmluZyxcclxuICAgIGJvcmRlcjogU3RyaW5nLFxyXG4gICAgZnJhbWU6IFN0cmluZyxcclxuICAgIHJ1bGVzOiBTdHJpbmcsXHJcbiAgICBzdW1tYXJ5OiBTdHJpbmcsXHJcbiAgICB3aWR0aDogU3RyaW5nLFxyXG4gICAgYmdDb2xvcjogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcclxuICAgIGNlbGxQYWRkaW5nOiB7IHR5cGU6IFN0cmluZywgdHJlYXROdWxsQXNFbXB0eVN0cmluZzogdHJ1ZSB9LFxyXG4gICAgY2VsbFNwYWNpbmc6IHsgdHlwZTogU3RyaW5nLCB0cmVhdE51bGxBc0VtcHR5U3RyaW5nOiB0cnVlIH0sXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAndGVtcGxhdGUnLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxUZW1wbGF0ZUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICAgIHRoaXMuX2NvbnRlbnRGcmFnbWVudCA9IGRvYy5fdGVtcGxhdGVEb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gIH0sXHJcbiAgcHJvcHM6IHtcclxuICAgIGNvbnRlbnQ6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2NvbnRlbnRGcmFnbWVudDsgfSB9LFxyXG4gICAgc2VyaWFsaXplOiB7IHZhbHVlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY29udGVudC5zZXJpYWxpemUoKTsgfSB9XHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAndHInLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxUYWJsZVJvd0VsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIHByb3BzOiB7XHJcbiAgICBjZWxsczogeyBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCd0ZCx0aCcpO1xyXG4gICAgfX1cclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIC8vIE9ic29sZXRlXHJcbiAgICBhbGlnbjogU3RyaW5nLFxyXG4gICAgY2g6IHsgbmFtZTogJ2NoYXInLCB0eXBlOiBTdHJpbmcgfSxcclxuICAgIGNoT2ZmOiB7IG5hbWU6ICdjaGFyb2ZmJywgdHlwZTogU3RyaW5nIH0sXHJcbiAgICB2QWxpZ246IFN0cmluZyxcclxuICAgIGJnQ29sb3I6IHsgdHlwZTogU3RyaW5nLCB0cmVhdE51bGxBc0VtcHR5U3RyaW5nOiB0cnVlIH0sXHJcbiAgfSxcclxufSk7XHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZ3M6IFsndGhlYWQnLCAndGZvb3QnLCAndGJvZHknXSxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MVGFibGVTZWN0aW9uRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgcHJvcHM6IHtcclxuICAgIHJvd3M6IHsgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RyJyk7XHJcbiAgICB9fVxyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgLy8gT2Jzb2xldGVcclxuICAgIGFsaWduOiBTdHJpbmcsXHJcbiAgICBjaDogeyBuYW1lOiAnY2hhcicsIHR5cGU6IFN0cmluZyB9LFxyXG4gICAgY2hPZmY6IHsgbmFtZTogJ2NoYXJvZmYnLCB0eXBlOiBTdHJpbmcgfSxcclxuICAgIHZBbGlnbjogU3RyaW5nLFxyXG4gIH1cclxufSk7XHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZzogJ3RleHRhcmVhJyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MVGV4dEFyZWFFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxGb3JtRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgcHJvcHM6IGZvcm1Bc3NvY2lhdGVkUHJvcHMsXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgYXV0b2NvbXBsZXRlOiBTdHJpbmcsIC8vIEl0J3MgY29tcGxpY2F0ZWRcclxuICAgIG5hbWU6IFN0cmluZyxcclxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxyXG4gICAgYXV0b2ZvY3VzOiBCb29sZWFuLFxyXG4gICAgcGxhY2Vob2xkZXI6IFN0cmluZyxcclxuICAgIHdyYXA6IFN0cmluZyxcclxuICAgIGRpck5hbWU6IFN0cmluZyxcclxuICAgIHJlcXVpcmVkOiBCb29sZWFuLFxyXG4gICAgcmVhZE9ubHk6IEJvb2xlYW4sXHJcbiAgICByb3dzOiB7dHlwZTogJ2xpbWl0ZWQgdW5zaWduZWQgbG9uZyB3aXRoIGZhbGxiYWNrJywgZGVmYXVsdDogMiB9LFxyXG4gICAgY29sczoge3R5cGU6ICdsaW1pdGVkIHVuc2lnbmVkIGxvbmcgd2l0aCBmYWxsYmFjaycsIGRlZmF1bHQ6IDIwIH0sXHJcbiAgICBtYXhMZW5ndGg6IHt0eXBlOiAndW5zaWduZWQgbG9uZycsIG1pbjogMCwgc2V0bWluOiAwLCBkZWZhdWx0OiAtMX0sXHJcbiAgICBpbnB1dE1vZGU6IHsgdHlwZTogWyBcInZlcmJhdGltXCIsIFwibGF0aW5cIiwgXCJsYXRpbi1uYW1lXCIsIFwibGF0aW4tcHJvc2VcIiwgXCJmdWxsLXdpZHRoLWxhdGluXCIsIFwia2FuYVwiLCBcImthbmEtbmFtZVwiLCBcImthdGFrYW5hXCIsIFwibnVtZXJpY1wiLCBcInRlbFwiLCBcImVtYWlsXCIsIFwidXJsXCIgXSwgbWlzc2luZzogJycgfSxcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICd0aW1lJyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MVGltZUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIGRhdGVUaW1lOiBTdHJpbmcsXHJcbiAgICBwdWJEYXRlOiBCb29sZWFuXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAndGl0bGUnLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxUaXRsZUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIHByb3BzOiB7XHJcbiAgICB0ZXh0OiB7IGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRleHRDb250ZW50O1xyXG4gICAgfX1cclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICd1bCcsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFVMaXN0RWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgdHlwZTogU3RyaW5nLFxyXG4gICAgLy8gT2Jzb2xldGVcclxuICAgIGNvbXBhY3Q6IEJvb2xlYW4sXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTE1lZGlhRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgc3JjOiBVUkwsXHJcbiAgICBjcm9zc09yaWdpbjogQ09SUyxcclxuICAgIHByZWxvYWQ6IHsgdHlwZTpbXCJtZXRhZGF0YVwiLCBcIm5vbmVcIiwgXCJhdXRvXCIsIHt2YWx1ZTogXCJcIiwgYWxpYXM6IFwiYXV0b1wifV0sIG1pc3Npbmc6ICdhdXRvJyB9LFxyXG4gICAgbG9vcDogQm9vbGVhbixcclxuICAgIGF1dG9wbGF5OiBCb29sZWFuLFxyXG4gICAgbWVkaWFHcm91cDogU3RyaW5nLFxyXG4gICAgY29udHJvbHM6IEJvb2xlYW4sXHJcbiAgICBkZWZhdWx0TXV0ZWQ6IHtuYW1lOiBcIm11dGVkXCIsIHR5cGU6IEJvb2xlYW59XHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAnYXVkaW8nLFxyXG4gIHN1cGVyY2xhc3M6IGh0bWxFbGVtZW50cy5IVE1MTWVkaWFFbGVtZW50LFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxBdWRpb0VsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgaHRtbEVsZW1lbnRzLkhUTUxNZWRpYUVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICd2aWRlbycsXHJcbiAgc3VwZXJjbGFzczogaHRtbEVsZW1lbnRzLkhUTUxNZWRpYUVsZW1lbnQsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFZpZGVvRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBodG1sRWxlbWVudHMuSFRNTE1lZGlhRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgcG9zdGVyOiBVUkwsXHJcbiAgICB3aWR0aDoge3R5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBtaW46IDAsIGRlZmF1bHQ6IDAgfSxcclxuICAgIGhlaWdodDoge3R5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBtaW46IDAsIGRlZmF1bHQ6IDAgfVxyXG4gIH1cclxufSk7XHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZzogJ3RkJyxcclxuICBzdXBlcmNsYXNzOiBodG1sRWxlbWVudHMuSFRNTFRhYmxlQ2VsbEVsZW1lbnQsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIGh0bWxFbGVtZW50cy5IVE1MVGFibGVDZWxsRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH1cclxufSk7XHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZzogJ3RoJyxcclxuICBzdXBlcmNsYXNzOiBodG1sRWxlbWVudHMuSFRNTFRhYmxlQ2VsbEVsZW1lbnQsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFRhYmxlSGVhZGVyQ2VsbEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgaHRtbEVsZW1lbnRzLkhUTUxUYWJsZUNlbGxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxufSk7XHJcblxyXG5kZWZpbmUoe1xyXG4gIHRhZzogJ2ZyYW1lc2V0JyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MRnJhbWVTZXRFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAnZnJhbWUnLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxGcmFtZUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdjYW52YXMnLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxDYW52YXNFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxuICBwcm9wczoge1xyXG4gICAgZ2V0Q29udGV4dDogeyB2YWx1ZTogdXRpbHMubnlpIH0sXHJcbiAgICBwcm9iYWJseVN1cHBvcnRzQ29udGV4dDogeyB2YWx1ZTogdXRpbHMubnlpIH0sXHJcbiAgICBzZXRDb250ZXh0OiB7IHZhbHVlOiB1dGlscy5ueWkgfSxcclxuICAgIHRyYW5zZmVyQ29udHJvbFRvUHJveHk6IHsgdmFsdWU6IHV0aWxzLm55aSB9LFxyXG4gICAgdG9EYXRhVVJMOiB7IHZhbHVlOiB1dGlscy5ueWkgfSxcclxuICAgIHRvQmxvYjogeyB2YWx1ZTogdXRpbHMubnlpIH1cclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIHdpZHRoOiB7IHR5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBkZWZhdWx0OiAzMDB9LFxyXG4gICAgaGVpZ2h0OiB7IHR5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBkZWZhdWx0OiAxNTB9XHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAnZGlhbG9nJyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MRGlhbG9nRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgcHJvcHM6IHtcclxuICAgIHNob3c6IHsgdmFsdWU6IHV0aWxzLm55aSB9LFxyXG4gICAgc2hvd01vZGFsOiB7IHZhbHVlOiB1dGlscy5ueWkgfSxcclxuICAgIGNsb3NlOiB7IHZhbHVlOiB1dGlscy5ueWkgfVxyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgb3BlbjogQm9vbGVhbixcclxuICAgIHJldHVyblZhbHVlOiBTdHJpbmdcclxuICB9XHJcbn0pO1xyXG5cclxuZGVmaW5lKHtcclxuICB0YWc6ICdtZW51aXRlbScsXHJcbiAgY3RvcjogZnVuY3Rpb24gSFRNTE1lbnVJdGVtRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgcHJvcHM6IHtcclxuICAgIC8vIFRoZSBtZW51aXRlbSdzIGxhYmVsXHJcbiAgICBfbGFiZWw6IHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy5fZ2V0YXR0cignbGFiZWwnKTtcclxuICAgICAgICBpZiAodmFsICE9PSBudWxsICYmIHZhbCAhPT0gJycpIHsgcmV0dXJuIHZhbDsgfVxyXG4gICAgICAgIHZhbCA9IHRoaXMudGV4dENvbnRlbnQ7XHJcbiAgICAgICAgLy8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2VcclxuICAgICAgICByZXR1cm4gdmFsLnJlcGxhY2UoL1sgXFx0XFxuXFxmXFxyXSsvZywgJyAnKS50cmltKCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyBUaGUgbWVudWl0ZW0gbGFiZWwgSURMIGF0dHJpYnV0ZVxyXG4gICAgbGFiZWw6IHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy5fZ2V0YXR0cignbGFiZWwnKTtcclxuICAgICAgICBpZiAodmFsICE9PSBudWxsKSB7IHJldHVybiB2YWw7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fbGFiZWw7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xyXG4gICAgICAgIHRoaXMuX3NldGF0dHIoJ2xhYmVsJywgdik7XHJcbiAgICAgIH0sXHJcbiAgICB9XHJcbiAgfSxcclxuICBhdHRyaWJ1dGVzOiB7XHJcbiAgICB0eXBlOiB7IHR5cGU6IFtcImNvbW1hbmRcIixcImNoZWNrYm94XCIsXCJyYWRpb1wiXSwgbWlzc2luZzogJ2NvbW1hbmQnIH0sXHJcbiAgICBpY29uOiBVUkwsXHJcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcclxuICAgIGNoZWNrZWQ6IEJvb2xlYW4sXHJcbiAgICByYWRpb2dyb3VwOiBTdHJpbmcsXHJcbiAgICBkZWZhdWx0OiBCb29sZWFuXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAnc291cmNlJyxcclxuICBjdG9yOiBmdW5jdGlvbiBIVE1MU291cmNlRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xyXG4gIH0sXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgc3Jjc2V0OiBTdHJpbmcsXHJcbiAgICBzaXplczogU3RyaW5nLFxyXG4gICAgbWVkaWE6IFN0cmluZyxcclxuICAgIHNyYzogVVJMLFxyXG4gICAgdHlwZTogU3RyaW5nXHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnOiAndHJhY2snLFxyXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxUcmFja0VsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xyXG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxuICB9LFxyXG4gIGF0dHJpYnV0ZXM6IHtcclxuICAgIHNyYzogVVJMLFxyXG4gICAgc3JjbGFuZzogU3RyaW5nLFxyXG4gICAgbGFiZWw6IFN0cmluZyxcclxuICAgIGRlZmF1bHQ6IEJvb2xlYW4sXHJcbiAgICBraW5kOiB7IHR5cGU6IFtcInN1YnRpdGxlc1wiLCBcImNhcHRpb25zXCIsIFwiZGVzY3JpcHRpb25zXCIsIFwiY2hhcHRlcnNcIiwgXCJtZXRhZGF0YVwiXSwgbWlzc2luZzogJ3N1YnRpdGxlcycsIGludmFsaWQ6ICdtZXRhZGF0YScgfSxcclxuICB9LFxyXG4gIHByb3BzOiB7XHJcbiAgICBOT05FOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9IH0sXHJcbiAgICBMT0FESU5HOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9IH0sXHJcbiAgICBMT0FERUQ6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIDI7IH0gfSxcclxuICAgIEVSUk9SOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAzOyB9IH0sXHJcbiAgICByZWFkeVN0YXRlOiB7IGdldDogdXRpbHMubnlpIH0sXHJcbiAgICB0cmFjazogeyBnZXQ6IHV0aWxzLm55aSB9XHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnczogW1xyXG4gICAgXCJhYmJyXCIsIFwiYWRkcmVzc1wiLCBcImFydGljbGVcIiwgXCJhc2lkZVwiLCBcImJcIiwgXCJiZGlcIiwgXCJiZG9cIixcclxuICAgIFwiY2l0ZVwiLCBcImNvZGVcIiwgXCJkZFwiLCBcImRmblwiLCBcImR0XCIsIFwiZW1cIiwgXCJmaWdjYXB0aW9uXCIsIFwiZmlndXJlXCIsXHJcbiAgICBcImZvb3RlclwiLCBcImhlYWRlclwiLCBcImhncm91cFwiLCBcImlcIiwgXCJrYmRcIiwgXCJtYWluXCIsIFwibWFya1wiLCBcIm5hdlwiLCBcIm5vc2NyaXB0XCIsXHJcbiAgICBcInJiXCIsIFwicnBcIiwgXCJydFwiLCBcInJ0Y1wiLCBcInJ1YnlcIiwgXCJzXCIsIFwic2FtcFwiLCBcInNlY3Rpb25cIiwgXCJzbWFsbFwiLCBcInN0cm9uZ1wiLFxyXG4gICAgXCJzdWJcIiwgXCJzdW1tYXJ5XCIsIFwic3VwXCIsIFwidVwiLCBcInZhclwiLCBcIndiclwiLFxyXG4gICAgLy8gTGVnYWN5IGVsZW1lbnRzXHJcbiAgICBcImFjcm9ueW1cIiwgXCJiYXNlZm9udFwiLCBcImJpZ1wiLCBcImNlbnRlclwiLCBcIm5vYnJcIiwgXCJub2VtYmVkXCIsIFwibm9mcmFtZXNcIixcclxuICAgIFwicGxhaW50ZXh0XCIsIFwic3RyaWtlXCIsIFwidHRcIlxyXG4gIF1cclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kb21pbm8vbGliL2h0bWxlbHRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuLyoganNoaW50IGVxbnVsbDogdHJ1ZSAqL1xyXG4vKipcclxuICogWmVzdCAoaHR0cHM6Ly9naXRodWIuY29tL2NoamovemVzdClcclxuICogQSBjc3Mgc2VsZWN0b3IgZW5naW5lLlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcclxuICovXHJcblxyXG4vKipcclxuICogSGVscGVyc1xyXG4gKi9cclxuXHJcbnZhciB3aW5kb3cgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICBsb2NhdGlvbjogeyBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCd3aW5kb3cubG9jYXRpb24gaXMgbm90IHN1cHBvcnRlZC4nKTtcclxuICB9IH1cclxufSk7XHJcblxyXG52YXIgY29tcGFyZURvY3VtZW50UG9zaXRpb24gPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgIHJldHVybiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpO1xyXG59O1xyXG5cclxudmFyIG9yZGVyID0gZnVuY3Rpb24oYSwgYikge1xyXG4gIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xyXG4gIHJldHVybiBjb21wYXJlRG9jdW1lbnRQb3NpdGlvbihhLCBiKSAmIDIgPyAxIDogLTE7XHJcbn07XHJcblxyXG52YXIgbmV4dCA9IGZ1bmN0aW9uKGVsKSB7XHJcbiAgd2hpbGUgKChlbCA9IGVsLm5leHRTaWJsaW5nKVxyXG4gICAgICAgICAmJiBlbC5ub2RlVHlwZSAhPT0gMSk7XHJcbiAgcmV0dXJuIGVsO1xyXG59O1xyXG5cclxudmFyIHByZXYgPSBmdW5jdGlvbihlbCkge1xyXG4gIHdoaWxlICgoZWwgPSBlbC5wcmV2aW91c1NpYmxpbmcpXHJcbiAgICAgICAgICYmIGVsLm5vZGVUeXBlICE9PSAxKTtcclxuICByZXR1cm4gZWw7XHJcbn07XHJcblxyXG52YXIgY2hpbGQgPSBmdW5jdGlvbihlbCkge1xyXG4gIC8qanNoaW50IC1XMDg0ICovXHJcbiAgaWYgKGVsID0gZWwuZmlyc3RDaGlsZCkge1xyXG4gICAgd2hpbGUgKGVsLm5vZGVUeXBlICE9PSAxXHJcbiAgICAgICAgICAgJiYgKGVsID0gZWwubmV4dFNpYmxpbmcpKTtcclxuICB9XHJcbiAgcmV0dXJuIGVsO1xyXG59O1xyXG5cclxudmFyIGxhc3RDaGlsZCA9IGZ1bmN0aW9uKGVsKSB7XHJcbiAgLypqc2hpbnQgLVcwODQgKi9cclxuICBpZiAoZWwgPSBlbC5sYXN0Q2hpbGQpIHtcclxuICAgIHdoaWxlIChlbC5ub2RlVHlwZSAhPT0gMVxyXG4gICAgICAgICAgICYmIChlbCA9IGVsLnByZXZpb3VzU2libGluZykpO1xyXG4gIH1cclxuICByZXR1cm4gZWw7XHJcbn07XHJcblxyXG52YXIgdW5xdW90ZSA9IGZ1bmN0aW9uKHN0cikge1xyXG4gIGlmICghc3RyKSByZXR1cm4gc3RyO1xyXG4gIHZhciBjaCA9IHN0clswXTtcclxuICBpZiAoY2ggPT09ICdcIicgfHwgY2ggPT09ICdcXCcnKSB7XHJcbiAgICBpZiAoc3RyW3N0ci5sZW5ndGgtMV0gPT09IGNoKSB7XHJcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgxLCAtMSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBiYWQgc3RyaW5nLlxyXG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UocnVsZXMuc3RyX2VzY2FwZSwgZnVuY3Rpb24ocykge1xyXG4gICAgICB2YXIgbSA9IC9eXFxcXCg/OihbMC05QS1GYS1mXSspfChbXFxyXFxuXFxmXSspKS8uZXhlYyhzKTtcclxuICAgICAgaWYgKCFtKSB7IHJldHVybiBzLnNsaWNlKDEpOyB9XHJcbiAgICAgIGlmIChtWzJdKSB7IHJldHVybiAnJzsgLyogZXNjYXBlZCBuZXdsaW5lcyBhcmUgaWdub3JlZCBpbiBzdHJpbmdzLiAqLyB9XHJcbiAgICAgIHZhciBjcCA9IHBhcnNlSW50KG1bMV0sIDE2KTtcclxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50ID8gU3RyaW5nLmZyb21Db2RlUG9pbnQoY3ApIDpcclxuICAgICAgICAvLyBOb3QgYWxsIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb25zIGhhdmUgU3RyaW5nLmZyb21Db2RlUG9pbnQgeWV0LlxyXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIGlmIChydWxlcy5pZGVudC50ZXN0KHN0cikpIHtcclxuICAgIHJldHVybiBkZWNvZGVpZChzdHIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBOVU1CRVIsIFBFUkNFTlRBR0UsIERJTUVOU0lPTiwgZXRjXHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBkZWNvZGVpZCA9IGZ1bmN0aW9uKHN0cikge1xyXG4gIHJldHVybiBzdHIucmVwbGFjZShydWxlcy5lc2NhcGUsIGZ1bmN0aW9uKHMpIHtcclxuICAgIHZhciBtID0gL15cXFxcKFswLTlBLUZhLWZdKykvLmV4ZWMocyk7XHJcbiAgICBpZiAoIW0pIHsgcmV0dXJuIHNbMV07IH1cclxuICAgIHZhciBjcCA9IHBhcnNlSW50KG1bMV0sIDE2KTtcclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCA/IFN0cmluZy5mcm9tQ29kZVBvaW50KGNwKSA6XHJcbiAgICAgIC8vIE5vdCBhbGwgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbnMgaGF2ZSBTdHJpbmcuZnJvbUNvZGVQb2ludCB5ZXQuXHJcbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApO1xyXG4gIH0pO1xyXG59O1xyXG5cclxudmFyIGluZGV4T2YgPSAoZnVuY3Rpb24oKSB7XHJcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XHJcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XHJcbiAgfVxyXG4gIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZW0pIHtcclxuICAgIHZhciBpID0gdGhpcy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIGlmICh0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTtcclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxuICB9O1xyXG59KSgpO1xyXG5cclxudmFyIG1ha2VJbnNpZGUgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XHJcbiAgdmFyIHJlZ2V4ID0gcnVsZXMuaW5zaWRlLnNvdXJjZVxyXG4gICAgLnJlcGxhY2UoLzwvZywgc3RhcnQpXHJcbiAgICAucmVwbGFjZSgvPi9nLCBlbmQpO1xyXG5cclxuICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCk7XHJcbn07XHJcblxyXG52YXIgcmVwbGFjZSA9IGZ1bmN0aW9uKHJlZ2V4LCBuYW1lLCB2YWwpIHtcclxuICByZWdleCA9IHJlZ2V4LnNvdXJjZTtcclxuICByZWdleCA9IHJlZ2V4LnJlcGxhY2UobmFtZSwgdmFsLnNvdXJjZSB8fCB2YWwpO1xyXG4gIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4KTtcclxufTtcclxuXHJcbnZhciB0cnVuY2F0ZVVybCA9IGZ1bmN0aW9uKHVybCwgbnVtKSB7XHJcbiAgcmV0dXJuIHVybFxyXG4gICAgLnJlcGxhY2UoL14oPzpcXHcrOlxcL1xcL3xcXC8rKS8sICcnKVxyXG4gICAgLnJlcGxhY2UoLyg/OlxcLyt8XFwvKiMuKj8pJC8sICcnKVxyXG4gICAgLnNwbGl0KCcvJywgbnVtKVxyXG4gICAgLmpvaW4oJy8nKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIYW5kbGUgYG50aGAgU2VsZWN0b3JzXHJcbiAqL1xyXG5cclxudmFyIHBhcnNlTnRoID0gZnVuY3Rpb24ocGFyYW1fLCB0ZXN0KSB7XHJcbiAgdmFyIHBhcmFtID0gcGFyYW1fLnJlcGxhY2UoL1xccysvZywgJycpXHJcbiAgICAsIGNhcDtcclxuXHJcbiAgaWYgKHBhcmFtID09PSAnZXZlbicpIHtcclxuICAgIHBhcmFtID0gJzJuKzAnO1xyXG4gIH0gZWxzZSBpZiAocGFyYW0gPT09ICdvZGQnKSB7XHJcbiAgICBwYXJhbSA9ICcybisxJztcclxuICB9IGVsc2UgaWYgKHBhcmFtLmluZGV4T2YoJ24nKSA9PT0gLTEpIHtcclxuICAgIHBhcmFtID0gJzBuJyArIHBhcmFtO1xyXG4gIH1cclxuXHJcbiAgY2FwID0gL14oWystXSk/KFxcZCspP24oWystXSk/KFxcZCspPyQvLmV4ZWMocGFyYW0pO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZ3JvdXA6IGNhcFsxXSA9PT0gJy0nXHJcbiAgICAgID8gLShjYXBbMl0gfHwgMSlcclxuICAgICAgOiArKGNhcFsyXSB8fCAxKSxcclxuICAgIG9mZnNldDogY2FwWzRdXHJcbiAgICAgID8gKGNhcFszXSA9PT0gJy0nID8gLWNhcFs0XSA6ICtjYXBbNF0pXHJcbiAgICAgIDogMFxyXG4gIH07XHJcbn07XHJcblxyXG52YXIgbnRoID0gZnVuY3Rpb24ocGFyYW1fLCB0ZXN0LCBsYXN0KSB7XHJcbiAgdmFyIHBhcmFtID0gcGFyc2VOdGgocGFyYW1fKVxyXG4gICAgLCBncm91cCA9IHBhcmFtLmdyb3VwXHJcbiAgICAsIG9mZnNldCA9IHBhcmFtLm9mZnNldFxyXG4gICAgLCBmaW5kID0gIWxhc3QgPyBjaGlsZCA6IGxhc3RDaGlsZFxyXG4gICAgLCBhZHZhbmNlID0gIWxhc3QgPyBuZXh0IDogcHJldjtcclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XHJcbiAgICBpZiAoZWwucGFyZW50Tm9kZS5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuO1xyXG5cclxuICAgIHZhciByZWwgPSBmaW5kKGVsLnBhcmVudE5vZGUpXHJcbiAgICAgICwgcG9zID0gMDtcclxuXHJcbiAgICB3aGlsZSAocmVsKSB7XHJcbiAgICAgIGlmICh0ZXN0KHJlbCwgZWwpKSBwb3MrKztcclxuICAgICAgaWYgKHJlbCA9PT0gZWwpIHtcclxuICAgICAgICBwb3MgLT0gb2Zmc2V0O1xyXG4gICAgICAgIHJldHVybiBncm91cCAmJiBwb3NcclxuICAgICAgICAgID8gKHBvcyAlIGdyb3VwKSA9PT0gMCAmJiAocG9zIDwgMCA9PT0gZ3JvdXAgPCAwKVxyXG4gICAgICAgICAgOiAhcG9zO1xyXG4gICAgICB9XHJcbiAgICAgIHJlbCA9IGFkdmFuY2UocmVsKTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNpbXBsZSBTZWxlY3RvcnNcclxuICovXHJcblxyXG52YXIgc2VsZWN0b3JzID0ge1xyXG4gICcqJzogKGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKGZhbHNlLypmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgIGVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJycpKTtcclxuICAgICAgcmV0dXJuICEhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKVswXTtcclxuICAgIH0oKSovKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xyXG4gICAgICAgIGlmIChlbC5ub2RlVHlwZSA9PT0gMSkgcmV0dXJuIHRydWU7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICB9KSgpLFxyXG4gICd0eXBlJzogZnVuY3Rpb24odHlwZSkge1xyXG4gICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcclxuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xyXG4gICAgICByZXR1cm4gZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gdHlwZTtcclxuICAgIH07XHJcbiAgfSxcclxuICAnYXR0cic6IGZ1bmN0aW9uKGtleSwgb3AsIHZhbCwgaSkge1xyXG4gICAgb3AgPSBvcGVyYXRvcnNbb3BdO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgIHZhciBhdHRyO1xyXG4gICAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgIGNhc2UgJ2Zvcic6XHJcbiAgICAgICAgICBhdHRyID0gZWwuaHRtbEZvcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2NsYXNzJzpcclxuICAgICAgICAgIC8vIGNsYXNzTmFtZSBpcyAnJyB3aGVuIG5vbi1leGlzdGVudFxyXG4gICAgICAgICAgLy8gZ2V0QXR0cmlidXRlKCdjbGFzcycpIGlzIG51bGxcclxuICAgICAgICAgIGF0dHIgPSBlbC5jbGFzc05hbWU7XHJcbiAgICAgICAgICBpZiAoYXR0ciA9PT0gJycgJiYgZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpID09IG51bGwpIHtcclxuICAgICAgICAgICAgYXR0ciA9IG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdocmVmJzpcclxuICAgICAgICAgIGF0dHIgPSBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnLCAyKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3RpdGxlJzpcclxuICAgICAgICAgIC8vIGdldEF0dHJpYnV0ZSgndGl0bGUnKSBjYW4gYmUgJycgd2hlbiBub24tZXhpc3RlbnQgc29tZXRpbWVzP1xyXG4gICAgICAgICAgYXR0ciA9IGVsLmdldEF0dHJpYnV0ZSgndGl0bGUnKSB8fCBudWxsO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gY2FyZWZ1bCB3aXRoIGF0dHJpYnV0ZXMgd2l0aCBzcGVjaWFsIGdldHRlciBmdW5jdGlvbnNcclxuICAgICAgICBjYXNlICdpZCc6XHJcbiAgICAgICAgY2FzZSAnbGFuZyc6XHJcbiAgICAgICAgY2FzZSAnZGlyJzpcclxuICAgICAgICBjYXNlICdhY2Nlc3NLZXknOlxyXG4gICAgICAgIGNhc2UgJ2hpZGRlbic6XHJcbiAgICAgICAgY2FzZSAndGFiSW5kZXgnOlxyXG4gICAgICAgIGNhc2UgJ3N0eWxlJzpcclxuICAgICAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUpIHtcclxuICAgICAgICAgICAgYXR0ciA9IGVsLmdldEF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUgJiYgIWVsLmhhc0F0dHJpYnV0ZShrZXkpKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYXR0ciA9IGVsW2tleV0gIT0gbnVsbFxyXG4gICAgICAgICAgICA/IGVsW2tleV1cclxuICAgICAgICAgICAgOiBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpZiAoYXR0ciA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgIGF0dHIgPSBhdHRyICsgJyc7XHJcbiAgICAgIGlmIChpKSB7XHJcbiAgICAgICAgYXR0ciA9IGF0dHIudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB2YWwgPSB2YWwudG9Mb3dlckNhc2UoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3AoYXR0ciwgdmFsKTtcclxuICAgIH07XHJcbiAgfSxcclxuICAnOmZpcnN0LWNoaWxkJzogZnVuY3Rpb24oZWwpIHtcclxuICAgIHJldHVybiAhcHJldihlbCkgJiYgZWwucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMTtcclxuICB9LFxyXG4gICc6bGFzdC1jaGlsZCc6IGZ1bmN0aW9uKGVsKSB7XHJcbiAgICByZXR1cm4gIW5leHQoZWwpICYmIGVsLnBhcmVudE5vZGUubm9kZVR5cGUgPT09IDE7XHJcbiAgfSxcclxuICAnOm9ubHktY2hpbGQnOiBmdW5jdGlvbihlbCkge1xyXG4gICAgcmV0dXJuICFwcmV2KGVsKSAmJiAhbmV4dChlbClcclxuICAgICAgJiYgZWwucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMTtcclxuICB9LFxyXG4gICc6bnRoLWNoaWxkJzogZnVuY3Rpb24ocGFyYW0sIGxhc3QpIHtcclxuICAgIHJldHVybiBudGgocGFyYW0sIGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sIGxhc3QpO1xyXG4gIH0sXHJcbiAgJzpudGgtbGFzdC1jaGlsZCc6IGZ1bmN0aW9uKHBhcmFtKSB7XHJcbiAgICByZXR1cm4gc2VsZWN0b3JzWyc6bnRoLWNoaWxkJ10ocGFyYW0sIHRydWUpO1xyXG4gIH0sXHJcbiAgJzpyb290JzogZnVuY3Rpb24oZWwpIHtcclxuICAgIHJldHVybiBlbC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA9PT0gZWw7XHJcbiAgfSxcclxuICAnOmVtcHR5JzogZnVuY3Rpb24oZWwpIHtcclxuICAgIHJldHVybiAhZWwuZmlyc3RDaGlsZDtcclxuICB9LFxyXG4gICc6bm90JzogZnVuY3Rpb24oc2VsKSB7XHJcbiAgICB2YXIgdGVzdCA9IGNvbXBpbGVHcm91cChzZWwpO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgIHJldHVybiAhdGVzdChlbCk7XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgJzpmaXJzdC1vZi10eXBlJzogZnVuY3Rpb24oZWwpIHtcclxuICAgIGlmIChlbC5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSAxKSByZXR1cm47XHJcbiAgICB2YXIgdHlwZSA9IGVsLm5vZGVOYW1lO1xyXG4gICAgLypqc2hpbnQgLVcwODQgKi9cclxuICAgIHdoaWxlIChlbCA9IHByZXYoZWwpKSB7XHJcbiAgICAgIGlmIChlbC5ub2RlTmFtZSA9PT0gdHlwZSkgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSxcclxuICAnOmxhc3Qtb2YtdHlwZSc6IGZ1bmN0aW9uKGVsKSB7XHJcbiAgICBpZiAoZWwucGFyZW50Tm9kZS5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuO1xyXG4gICAgdmFyIHR5cGUgPSBlbC5ub2RlTmFtZTtcclxuICAgIC8qanNoaW50IC1XMDg0ICovXHJcbiAgICB3aGlsZSAoZWwgPSBuZXh0KGVsKSkge1xyXG4gICAgICBpZiAoZWwubm9kZU5hbWUgPT09IHR5cGUpIHJldHVybjtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0sXHJcbiAgJzpvbmx5LW9mLXR5cGUnOiBmdW5jdGlvbihlbCkge1xyXG4gICAgcmV0dXJuIHNlbGVjdG9yc1snOmZpcnN0LW9mLXR5cGUnXShlbClcclxuICAgICAgICAmJiBzZWxlY3RvcnNbJzpsYXN0LW9mLXR5cGUnXShlbCk7XHJcbiAgfSxcclxuICAnOm50aC1vZi10eXBlJzogZnVuY3Rpb24ocGFyYW0sIGxhc3QpIHtcclxuICAgIHJldHVybiBudGgocGFyYW0sIGZ1bmN0aW9uKHJlbCwgZWwpIHtcclxuICAgICAgcmV0dXJuIHJlbC5ub2RlTmFtZSA9PT0gZWwubm9kZU5hbWU7XHJcbiAgICB9LCBsYXN0KTtcclxuICB9LFxyXG4gICc6bnRoLWxhc3Qtb2YtdHlwZSc6IGZ1bmN0aW9uKHBhcmFtKSB7XHJcbiAgICByZXR1cm4gc2VsZWN0b3JzWyc6bnRoLW9mLXR5cGUnXShwYXJhbSwgdHJ1ZSk7XHJcbiAgfSxcclxuICAnOmNoZWNrZWQnOiBmdW5jdGlvbihlbCkge1xyXG4gICAgcmV0dXJuICEhKGVsLmNoZWNrZWQgfHwgZWwuc2VsZWN0ZWQpO1xyXG4gIH0sXHJcbiAgJzppbmRldGVybWluYXRlJzogZnVuY3Rpb24oZWwpIHtcclxuICAgIHJldHVybiAhc2VsZWN0b3JzWyc6Y2hlY2tlZCddKGVsKTtcclxuICB9LFxyXG4gICc6ZW5hYmxlZCc6IGZ1bmN0aW9uKGVsKSB7XHJcbiAgICByZXR1cm4gIWVsLmRpc2FibGVkICYmIGVsLnR5cGUgIT09ICdoaWRkZW4nO1xyXG4gIH0sXHJcbiAgJzpkaXNhYmxlZCc6IGZ1bmN0aW9uKGVsKSB7XHJcbiAgICByZXR1cm4gISFlbC5kaXNhYmxlZDtcclxuICB9LFxyXG4gICc6dGFyZ2V0JzogZnVuY3Rpb24oZWwpIHtcclxuICAgIHJldHVybiBlbC5pZCA9PT0gd2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpO1xyXG4gIH0sXHJcbiAgJzpmb2N1cyc6IGZ1bmN0aW9uKGVsKSB7XHJcbiAgICByZXR1cm4gZWwgPT09IGVsLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcclxuICB9LFxyXG4gICc6bWF0Y2hlcyc6IGZ1bmN0aW9uKHNlbCkge1xyXG4gICAgcmV0dXJuIGNvbXBpbGVHcm91cChzZWwpO1xyXG4gIH0sXHJcbiAgJzpudGgtbWF0Y2gnOiBmdW5jdGlvbihwYXJhbSwgbGFzdCkge1xyXG4gICAgdmFyIGFyZ3MgPSBwYXJhbS5zcGxpdCgvXFxzKixcXHMqLylcclxuICAgICAgLCBhcmcgPSBhcmdzLnNoaWZ0KClcclxuICAgICAgLCB0ZXN0ID0gY29tcGlsZUdyb3VwKGFyZ3Muam9pbignLCcpKTtcclxuXHJcbiAgICByZXR1cm4gbnRoKGFyZywgdGVzdCwgbGFzdCk7XHJcbiAgfSxcclxuICAnOm50aC1sYXN0LW1hdGNoJzogZnVuY3Rpb24ocGFyYW0pIHtcclxuICAgIHJldHVybiBzZWxlY3RvcnNbJzpudGgtbWF0Y2gnXShwYXJhbSwgdHJ1ZSk7XHJcbiAgfSxcclxuICAnOmxpbmtzLWhlcmUnOiBmdW5jdGlvbihlbCkge1xyXG4gICAgcmV0dXJuIGVsICsgJycgPT09IHdpbmRvdy5sb2NhdGlvbiArICcnO1xyXG4gIH0sXHJcbiAgJzpsYW5nJzogZnVuY3Rpb24ocGFyYW0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xyXG4gICAgICB3aGlsZSAoZWwpIHtcclxuICAgICAgICBpZiAoZWwubGFuZykgcmV0dXJuIGVsLmxhbmcuaW5kZXhPZihwYXJhbSkgPT09IDA7XHJcbiAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgJzpkaXInOiBmdW5jdGlvbihwYXJhbSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgIHdoaWxlIChlbCkge1xyXG4gICAgICAgIGlmIChlbC5kaXIpIHJldHVybiBlbC5kaXIgPT09IHBhcmFtO1xyXG4gICAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LFxyXG4gICc6c2NvcGUnOiBmdW5jdGlvbihlbCwgY29uKSB7XHJcbiAgICB2YXIgY29udGV4dCA9IGNvbiB8fCBlbC5vd25lckRvY3VtZW50O1xyXG4gICAgaWYgKGNvbnRleHQubm9kZVR5cGUgPT09IDkpIHtcclxuICAgICAgcmV0dXJuIGVsID09PSBjb250ZXh0LmRvY3VtZW50RWxlbWVudDtcclxuICAgIH1cclxuICAgIHJldHVybiBlbCA9PT0gY29udGV4dDtcclxuICB9LFxyXG4gICc6YW55LWxpbmsnOiBmdW5jdGlvbihlbCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBlbC5ocmVmID09PSAnc3RyaW5nJztcclxuICB9LFxyXG4gICc6bG9jYWwtbGluayc6IGZ1bmN0aW9uKGVsKSB7XHJcbiAgICBpZiAoZWwubm9kZU5hbWUpIHtcclxuICAgICAgcmV0dXJuIGVsLmhyZWYgJiYgZWwuaG9zdCA9PT0gd2luZG93LmxvY2F0aW9uLmhvc3Q7XHJcbiAgICB9XHJcbiAgICB2YXIgcGFyYW0gPSArZWwgKyAxO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgIGlmICghZWwuaHJlZikgcmV0dXJuO1xyXG5cclxuICAgICAgdmFyIHVybCA9IHdpbmRvdy5sb2NhdGlvbiArICcnXHJcbiAgICAgICAgLCBocmVmID0gZWwgKyAnJztcclxuXHJcbiAgICAgIHJldHVybiB0cnVuY2F0ZVVybCh1cmwsIHBhcmFtKSA9PT0gdHJ1bmNhdGVVcmwoaHJlZiwgcGFyYW0pO1xyXG4gICAgfTtcclxuICB9LFxyXG4gICc6ZGVmYXVsdCc6IGZ1bmN0aW9uKGVsKSB7XHJcbiAgICByZXR1cm4gISFlbC5kZWZhdWx0U2VsZWN0ZWQ7XHJcbiAgfSxcclxuICAnOnZhbGlkJzogZnVuY3Rpb24oZWwpIHtcclxuICAgIHJldHVybiBlbC53aWxsVmFsaWRhdGUgfHwgKGVsLnZhbGlkaXR5ICYmIGVsLnZhbGlkaXR5LnZhbGlkKTtcclxuICB9LFxyXG4gICc6aW52YWxpZCc6IGZ1bmN0aW9uKGVsKSB7XHJcbiAgICByZXR1cm4gIXNlbGVjdG9yc1snOnZhbGlkJ10oZWwpO1xyXG4gIH0sXHJcbiAgJzppbi1yYW5nZSc6IGZ1bmN0aW9uKGVsKSB7XHJcbiAgICByZXR1cm4gZWwudmFsdWUgPiBlbC5taW4gJiYgZWwudmFsdWUgPD0gZWwubWF4O1xyXG4gIH0sXHJcbiAgJzpvdXQtb2YtcmFuZ2UnOiBmdW5jdGlvbihlbCkge1xyXG4gICAgcmV0dXJuICFzZWxlY3RvcnNbJzppbi1yYW5nZSddKGVsKTtcclxuICB9LFxyXG4gICc6cmVxdWlyZWQnOiBmdW5jdGlvbihlbCkge1xyXG4gICAgcmV0dXJuICEhZWwucmVxdWlyZWQ7XHJcbiAgfSxcclxuICAnOm9wdGlvbmFsJzogZnVuY3Rpb24oZWwpIHtcclxuICAgIHJldHVybiAhZWwucmVxdWlyZWQ7XHJcbiAgfSxcclxuICAnOnJlYWQtb25seSc6IGZ1bmN0aW9uKGVsKSB7XHJcbiAgICBpZiAoZWwucmVhZE9ubHkpIHJldHVybiB0cnVlO1xyXG5cclxuICAgIHZhciBhdHRyID0gZWwuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKVxyXG4gICAgICAsIHByb3AgPSBlbC5jb250ZW50RWRpdGFibGVcclxuICAgICAgLCBuYW1lID0gZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICBuYW1lID0gbmFtZSAhPT0gJ2lucHV0JyAmJiBuYW1lICE9PSAndGV4dGFyZWEnO1xyXG5cclxuICAgIHJldHVybiAobmFtZSB8fCBlbC5kaXNhYmxlZCkgJiYgYXR0ciA9PSBudWxsICYmIHByb3AgIT09ICd0cnVlJztcclxuICB9LFxyXG4gICc6cmVhZC13cml0ZSc6IGZ1bmN0aW9uKGVsKSB7XHJcbiAgICByZXR1cm4gIXNlbGVjdG9yc1snOnJlYWQtb25seSddKGVsKTtcclxuICB9LFxyXG4gICc6aG92ZXInOiBmdW5jdGlvbigpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignOmhvdmVyIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgfSxcclxuICAnOmFjdGl2ZSc6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCc6YWN0aXZlIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgfSxcclxuICAnOmxpbmsnOiBmdW5jdGlvbigpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignOmxpbmsgaXMgbm90IHN1cHBvcnRlZC4nKTtcclxuICB9LFxyXG4gICc6dmlzaXRlZCc6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCc6dmlzaXRlZCBpcyBub3Qgc3VwcG9ydGVkLicpO1xyXG4gIH0sXHJcbiAgJzpjb2x1bW4nOiBmdW5jdGlvbigpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignOmNvbHVtbiBpcyBub3Qgc3VwcG9ydGVkLicpO1xyXG4gIH0sXHJcbiAgJzpudGgtY29sdW1uJzogZnVuY3Rpb24oKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJzpudGgtY29sdW1uIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgfSxcclxuICAnOm50aC1sYXN0LWNvbHVtbic6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCc6bnRoLWxhc3QtY29sdW1uIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgfSxcclxuICAnOmN1cnJlbnQnOiBmdW5jdGlvbigpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignOmN1cnJlbnQgaXMgbm90IHN1cHBvcnRlZC4nKTtcclxuICB9LFxyXG4gICc6cGFzdCc6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCc6cGFzdCBpcyBub3Qgc3VwcG9ydGVkLicpO1xyXG4gIH0sXHJcbiAgJzpmdXR1cmUnOiBmdW5jdGlvbigpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignOmZ1dHVyZSBpcyBub3Qgc3VwcG9ydGVkLicpO1xyXG4gIH0sXHJcbiAgLy8gTm9uLXN0YW5kYXJkLCBmb3IgY29tcGF0aWJpbGl0eSBwdXJwb3Nlcy5cclxuICAnOmNvbnRhaW5zJzogZnVuY3Rpb24ocGFyYW0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xyXG4gICAgICB2YXIgdGV4dCA9IGVsLmlubmVyVGV4dCB8fCBlbC50ZXh0Q29udGVudCB8fCBlbC52YWx1ZSB8fCAnJztcclxuICAgICAgcmV0dXJuIHRleHQuaW5kZXhPZihwYXJhbSkgIT09IC0xO1xyXG4gICAgfTtcclxuICB9LFxyXG4gICc6aGFzJzogZnVuY3Rpb24ocGFyYW0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xyXG4gICAgICByZXR1cm4gZmluZChwYXJhbSwgZWwpLmxlbmd0aCA+IDA7XHJcbiAgICB9O1xyXG4gIH1cclxuICAvLyBQb3RlbnRpYWxseSBhZGQgbW9yZSBwc2V1ZG8gc2VsZWN0b3JzIGZvclxyXG4gIC8vIGNvbXBhdGliaWxpdHkgd2l0aCBzaXp6bGUgYW5kIG1vc3Qgb3RoZXJcclxuICAvLyBzZWxlY3RvciBlbmdpbmVzICg/KS5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBdHRyaWJ1dGUgT3BlcmF0b3JzXHJcbiAqL1xyXG5cclxudmFyIG9wZXJhdG9ycyA9IHtcclxuICAnLSc6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSxcclxuICAnPSc6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xyXG4gICAgcmV0dXJuIGF0dHIgPT09IHZhbDtcclxuICB9LFxyXG4gICcqPSc6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xyXG4gICAgcmV0dXJuIGF0dHIuaW5kZXhPZih2YWwpICE9PSAtMTtcclxuICB9LFxyXG4gICd+PSc6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xyXG4gICAgdmFyIGkgPSBhdHRyLmluZGV4T2YodmFsKVxyXG4gICAgICAsIGZcclxuICAgICAgLCBsO1xyXG5cclxuICAgIGlmIChpID09PSAtMSkgcmV0dXJuO1xyXG4gICAgZiA9IGF0dHJbaSAtIDFdO1xyXG4gICAgbCA9IGF0dHJbaSArIHZhbC5sZW5ndGhdO1xyXG5cclxuICAgIHJldHVybiAoIWYgfHwgZiA9PT0gJyAnKSAmJiAoIWwgfHwgbCA9PT0gJyAnKTtcclxuICB9LFxyXG4gICd8PSc6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xyXG4gICAgdmFyIGkgPSBhdHRyLmluZGV4T2YodmFsKVxyXG4gICAgICAsIGw7XHJcblxyXG4gICAgaWYgKGkgIT09IDApIHJldHVybjtcclxuICAgIGwgPSBhdHRyW2kgKyB2YWwubGVuZ3RoXTtcclxuXHJcbiAgICByZXR1cm4gbCA9PT0gJy0nIHx8ICFsO1xyXG4gIH0sXHJcbiAgJ149JzogZnVuY3Rpb24oYXR0ciwgdmFsKSB7XHJcbiAgICByZXR1cm4gYXR0ci5pbmRleE9mKHZhbCkgPT09IDA7XHJcbiAgfSxcclxuICAnJD0nOiBmdW5jdGlvbihhdHRyLCB2YWwpIHtcclxuICAgIHJldHVybiBhdHRyLmluZGV4T2YodmFsKSArIHZhbC5sZW5ndGggPT09IGF0dHIubGVuZ3RoO1xyXG4gIH0sXHJcbiAgLy8gbm9uLXN0YW5kYXJkXHJcbiAgJyE9JzogZnVuY3Rpb24oYXR0ciwgdmFsKSB7XHJcbiAgICByZXR1cm4gYXR0ciAhPT0gdmFsO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21iaW5hdG9yIExvZ2ljXHJcbiAqL1xyXG5cclxudmFyIGNvbWJpbmF0b3JzID0ge1xyXG4gICcgJzogZnVuY3Rpb24odGVzdCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgIC8qanNoaW50IC1XMDg0ICovXHJcbiAgICAgIHdoaWxlIChlbCA9IGVsLnBhcmVudE5vZGUpIHtcclxuICAgICAgICBpZiAodGVzdChlbCkpIHJldHVybiBlbDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LFxyXG4gICc+JzogZnVuY3Rpb24odGVzdCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgIC8qanNoaW50IC1XMDg0ICovXHJcbiAgICAgIGlmIChlbCA9IGVsLnBhcmVudE5vZGUpIHtcclxuICAgICAgICByZXR1cm4gdGVzdChlbCkgJiYgZWw7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSxcclxuICAnKyc6IGZ1bmN0aW9uKHRlc3QpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xyXG4gICAgICAvKmpzaGludCAtVzA4NCAqL1xyXG4gICAgICBpZiAoZWwgPSBwcmV2KGVsKSkge1xyXG4gICAgICAgIHJldHVybiB0ZXN0KGVsKSAmJiBlbDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LFxyXG4gICd+JzogZnVuY3Rpb24odGVzdCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgIC8qanNoaW50IC1XMDg0ICovXHJcbiAgICAgIHdoaWxlIChlbCA9IHByZXYoZWwpKSB7XHJcbiAgICAgICAgaWYgKHRlc3QoZWwpKSByZXR1cm4gZWw7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSxcclxuICAnbm9vcCc6IGZ1bmN0aW9uKHRlc3QpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xyXG4gICAgICByZXR1cm4gdGVzdChlbCkgJiYgZWw7XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgJ3JlZic6IGZ1bmN0aW9uKHRlc3QsIG5hbWUpIHtcclxuICAgIHZhciBub2RlO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlZihlbCkge1xyXG4gICAgICB2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudFxyXG4gICAgICAgICwgbm9kZXMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKVxyXG4gICAgICAgICwgaSA9IG5vZGVzLmxlbmd0aDtcclxuXHJcbiAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgaWYgKHJlZi50ZXN0KGVsKSkge1xyXG4gICAgICAgICAgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5vZGUgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZi5jb21iaW5hdG9yID0gZnVuY3Rpb24oZWwpIHtcclxuICAgICAgaWYgKCFub2RlIHx8ICFub2RlLmdldEF0dHJpYnV0ZSkgcmV0dXJuO1xyXG5cclxuICAgICAgdmFyIGF0dHIgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKSB8fCAnJztcclxuICAgICAgaWYgKGF0dHJbMF0gPT09ICcjJykgYXR0ciA9IGF0dHIuc3Vic3RyaW5nKDEpO1xyXG5cclxuICAgICAgaWYgKGF0dHIgPT09IGVsLmlkICYmIHRlc3Qobm9kZSkpIHtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gcmVmO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHcmFtbWFyXHJcbiAqL1xyXG5cclxudmFyIHJ1bGVzID0ge1xyXG4gIGVzY2FwZTogL1xcXFwoPzpbXjAtOUEtRmEtZlxcclxcbl18WzAtOUEtRmEtZl17MSw2fVtcXHJcXG5cXHQgXT8pL2csXHJcbiAgc3RyX2VzY2FwZTogLyhlc2NhcGUpfFxcXFwoXFxufFxcclxcbj98XFxmKS9nLFxyXG4gIG5vbmFzY2lpOiAvW1xcdTAwQTAtXFx1RkZGRl0vLFxyXG4gIGNzc2lkOiAvKD86KD8hLT9bMC05XSkoPzplc2NhcGV8bm9uYXNjaWl8Wy1fYS16QS1aMC05XSkrKS8sXHJcbiAgcW5hbWU6IC9eICooY3NzaWR8XFwqKS8sXHJcbiAgc2ltcGxlOiAvXig/OihbLiNdY3NzaWQpfHBzZXVkb3xhdHRyKS8sXHJcbiAgcmVmOiAvXiAqXFwvKGNzc2lkKVxcLyAqLyxcclxuICBjb21iaW5hdG9yOiAvXig/OiArKFteIFxcdyouI1xcXFxdKSArfCggKSt8KFteIFxcdyouI1xcXFxdKSkoPyEgKiQpLyxcclxuICBhdHRyOiAvXlxcWyhjc3NpZCkoPzooW15cXHddPz0pKGluc2lkZSkpP1xcXS8sXHJcbiAgcHNldWRvOiAvXig6Y3NzaWQpKD86XFwoKGluc2lkZSlcXCkpPy8sXHJcbiAgaW5zaWRlOiAvKD86XCIoPzpcXFxcXCJ8W15cIl0pKlwifCcoPzpcXFxcJ3xbXiddKSonfDxbXlwiJz5dKj58XFxcXFtcIic+XXxbXlwiJz5dKSovLFxyXG4gIGlkZW50OiAvXihjc3NpZCkkL1xyXG59O1xyXG5cclxucnVsZXMuY3NzaWQgPSByZXBsYWNlKHJ1bGVzLmNzc2lkLCAnbm9uYXNjaWknLCBydWxlcy5ub25hc2NpaSk7XHJcbnJ1bGVzLmNzc2lkID0gcmVwbGFjZShydWxlcy5jc3NpZCwgJ2VzY2FwZScsIHJ1bGVzLmVzY2FwZSk7XHJcbnJ1bGVzLnFuYW1lID0gcmVwbGFjZShydWxlcy5xbmFtZSwgJ2Nzc2lkJywgcnVsZXMuY3NzaWQpO1xyXG5ydWxlcy5zaW1wbGUgPSByZXBsYWNlKHJ1bGVzLnNpbXBsZSwgJ2Nzc2lkJywgcnVsZXMuY3NzaWQpO1xyXG5ydWxlcy5yZWYgPSByZXBsYWNlKHJ1bGVzLnJlZiwgJ2Nzc2lkJywgcnVsZXMuY3NzaWQpO1xyXG5ydWxlcy5hdHRyID0gcmVwbGFjZShydWxlcy5hdHRyLCAnY3NzaWQnLCBydWxlcy5jc3NpZCk7XHJcbnJ1bGVzLnBzZXVkbyA9IHJlcGxhY2UocnVsZXMucHNldWRvLCAnY3NzaWQnLCBydWxlcy5jc3NpZCk7XHJcbnJ1bGVzLmluc2lkZSA9IHJlcGxhY2UocnVsZXMuaW5zaWRlLCAnW15cIlxcJz5dKicsIHJ1bGVzLmluc2lkZSk7XHJcbnJ1bGVzLmF0dHIgPSByZXBsYWNlKHJ1bGVzLmF0dHIsICdpbnNpZGUnLCBtYWtlSW5zaWRlKCdcXFxcWycsICdcXFxcXScpKTtcclxucnVsZXMucHNldWRvID0gcmVwbGFjZShydWxlcy5wc2V1ZG8sICdpbnNpZGUnLCBtYWtlSW5zaWRlKCdcXFxcKCcsICdcXFxcKScpKTtcclxucnVsZXMuc2ltcGxlID0gcmVwbGFjZShydWxlcy5zaW1wbGUsICdwc2V1ZG8nLCBydWxlcy5wc2V1ZG8pO1xyXG5ydWxlcy5zaW1wbGUgPSByZXBsYWNlKHJ1bGVzLnNpbXBsZSwgJ2F0dHInLCBydWxlcy5hdHRyKTtcclxucnVsZXMuaWRlbnQgPSByZXBsYWNlKHJ1bGVzLmlkZW50LCAnY3NzaWQnLCBydWxlcy5jc3NpZCk7XHJcbnJ1bGVzLnN0cl9lc2NhcGUgPSByZXBsYWNlKHJ1bGVzLnN0cl9lc2NhcGUsICdlc2NhcGUnLCBydWxlcy5lc2NhcGUpO1xyXG5cclxuLyoqXHJcbiAqIENvbXBpbGluZ1xyXG4gKi9cclxuXHJcbnZhciBjb21waWxlID0gZnVuY3Rpb24oc2VsXykge1xyXG4gIHZhciBzZWwgPSBzZWxfLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxyXG4gICAgLCB0ZXN0XHJcbiAgICAsIGZpbHRlciA9IFtdXHJcbiAgICAsIGJ1ZmYgPSBbXVxyXG4gICAgLCBzdWJqZWN0XHJcbiAgICAsIHFuYW1lXHJcbiAgICAsIGNhcFxyXG4gICAgLCBvcFxyXG4gICAgLCByZWY7XHJcblxyXG4gIC8qanNoaW50IC1XMDg0ICovXHJcbiAgd2hpbGUgKHNlbCkge1xyXG4gICAgaWYgKGNhcCA9IHJ1bGVzLnFuYW1lLmV4ZWMoc2VsKSkge1xyXG4gICAgICBzZWwgPSBzZWwuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xyXG4gICAgICBxbmFtZSA9IGNhcFsxXTtcclxuICAgICAgYnVmZi5wdXNoKHRvayhxbmFtZSwgdHJ1ZSkpO1xyXG4gICAgfSBlbHNlIGlmIChjYXAgPSBydWxlcy5zaW1wbGUuZXhlYyhzZWwpKSB7XHJcbiAgICAgIHNlbCA9IHNlbC5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XHJcbiAgICAgIHFuYW1lID0gJyonO1xyXG4gICAgICBidWZmLnB1c2godG9rKHFuYW1lLCB0cnVlKSk7XHJcbiAgICAgIGJ1ZmYucHVzaCh0b2soY2FwKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ludmFsaWQgc2VsZWN0b3IuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgd2hpbGUgKGNhcCA9IHJ1bGVzLnNpbXBsZS5leGVjKHNlbCkpIHtcclxuICAgICAgc2VsID0gc2VsLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcclxuICAgICAgYnVmZi5wdXNoKHRvayhjYXApKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2VsWzBdID09PSAnIScpIHtcclxuICAgICAgc2VsID0gc2VsLnN1YnN0cmluZygxKTtcclxuICAgICAgc3ViamVjdCA9IG1ha2VTdWJqZWN0KCk7XHJcbiAgICAgIHN1YmplY3QucW5hbWUgPSBxbmFtZTtcclxuICAgICAgYnVmZi5wdXNoKHN1YmplY3Quc2ltcGxlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FwID0gcnVsZXMucmVmLmV4ZWMoc2VsKSkge1xyXG4gICAgICBzZWwgPSBzZWwuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xyXG4gICAgICByZWYgPSBjb21iaW5hdG9ycy5yZWYobWFrZVNpbXBsZShidWZmKSwgZGVjb2RlaWQoY2FwWzFdKSk7XHJcbiAgICAgIGZpbHRlci5wdXNoKHJlZi5jb21iaW5hdG9yKTtcclxuICAgICAgYnVmZiA9IFtdO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FwID0gcnVsZXMuY29tYmluYXRvci5leGVjKHNlbCkpIHtcclxuICAgICAgc2VsID0gc2VsLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcclxuICAgICAgb3AgPSBjYXBbMV0gfHwgY2FwWzJdIHx8IGNhcFszXTtcclxuICAgICAgaWYgKG9wID09PSAnLCcpIHtcclxuICAgICAgICBmaWx0ZXIucHVzaChjb21iaW5hdG9ycy5ub29wKG1ha2VTaW1wbGUoYnVmZikpKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb3AgPSAnbm9vcCc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb21iaW5hdG9yc1tvcF0pIHsgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdCYWQgY29tYmluYXRvci4nKTsgfVxyXG4gICAgZmlsdGVyLnB1c2goY29tYmluYXRvcnNbb3BdKG1ha2VTaW1wbGUoYnVmZikpKTtcclxuICAgIGJ1ZmYgPSBbXTtcclxuICB9XHJcblxyXG4gIHRlc3QgPSBtYWtlVGVzdChmaWx0ZXIpO1xyXG4gIHRlc3QucW5hbWUgPSBxbmFtZTtcclxuICB0ZXN0LnNlbCA9IHNlbDtcclxuXHJcbiAgaWYgKHN1YmplY3QpIHtcclxuICAgIHN1YmplY3QubG5hbWUgPSB0ZXN0LnFuYW1lO1xyXG5cclxuICAgIHN1YmplY3QudGVzdCA9IHRlc3Q7XHJcbiAgICBzdWJqZWN0LnFuYW1lID0gc3ViamVjdC5xbmFtZTtcclxuICAgIHN1YmplY3Quc2VsID0gdGVzdC5zZWw7XHJcbiAgICB0ZXN0ID0gc3ViamVjdDtcclxuICB9XHJcblxyXG4gIGlmIChyZWYpIHtcclxuICAgIHJlZi50ZXN0ID0gdGVzdDtcclxuICAgIHJlZi5xbmFtZSA9IHRlc3QucW5hbWU7XHJcbiAgICByZWYuc2VsID0gdGVzdC5zZWw7XHJcbiAgICB0ZXN0ID0gcmVmO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRlc3Q7XHJcbn07XHJcblxyXG52YXIgdG9rID0gZnVuY3Rpb24oY2FwLCBxbmFtZSkge1xyXG4gIC8vIHFuYW1lXHJcbiAgaWYgKHFuYW1lKSB7XHJcbiAgICByZXR1cm4gY2FwID09PSAnKidcclxuICAgICAgPyBzZWxlY3RvcnNbJyonXVxyXG4gICAgICA6IHNlbGVjdG9ycy50eXBlKGRlY29kZWlkKGNhcCkpO1xyXG4gIH1cclxuXHJcbiAgLy8gY2xhc3MvaWRcclxuICBpZiAoY2FwWzFdKSB7XHJcbiAgICByZXR1cm4gY2FwWzFdWzBdID09PSAnLidcclxuXHQgIC8vIFhYWCB1bmVzY2FwZSBoZXJlPyAgb3IgaW4gYXR0cj9cclxuICAgICAgPyBzZWxlY3RvcnMuYXR0cignY2xhc3MnLCAnfj0nLCBkZWNvZGVpZChjYXBbMV0uc3Vic3RyaW5nKDEpKSlcclxuICAgICAgOiBzZWxlY3RvcnMuYXR0cignaWQnLCAnPScsIGRlY29kZWlkKGNhcFsxXS5zdWJzdHJpbmcoMSkpKTtcclxuICB9XHJcblxyXG4gIC8vIHBzZXVkby1uYW1lXHJcbiAgLy8gaW5zaWRlLXBzZXVkb1xyXG4gIGlmIChjYXBbMl0pIHtcclxuICAgIHJldHVybiBjYXBbM11cclxuICAgICAgPyBzZWxlY3RvcnNbZGVjb2RlaWQoY2FwWzJdKV0odW5xdW90ZShjYXBbM10pKVxyXG4gICAgICA6IHNlbGVjdG9yc1tkZWNvZGVpZChjYXBbMl0pXTtcclxuICB9XHJcblxyXG4gIC8vIGF0dHIgbmFtZVxyXG4gIC8vIGF0dHIgb3BcclxuICAvLyBhdHRyIHZhbHVlXHJcbiAgaWYgKGNhcFs0XSkge1xyXG4gICAgcmV0dXJuIHNlbGVjdG9ycy5hdHRyKGRlY29kZWlkKGNhcFs0XSksIGNhcFs1XSB8fCAnLScsIHVucXVvdGUoY2FwWzZdKSwgZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmtub3duIFNlbGVjdG9yLicpO1xyXG59O1xyXG5cclxudmFyIG1ha2VTaW1wbGUgPSBmdW5jdGlvbihmdW5jKSB7XHJcbiAgdmFyIGwgPSBmdW5jLmxlbmd0aFxyXG4gICAgLCBpO1xyXG5cclxuICAvLyBQb3RlbnRpYWxseSBtYWtlIHN1cmVcclxuICAvLyBgZWxgIGlzIHRydXRoeS5cclxuICBpZiAobCA8IDIpIHJldHVybiBmdW5jWzBdO1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcclxuICAgIGlmICghZWwpIHJldHVybjtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgaWYgKCFmdW5jW2ldKGVsKSkgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfTtcclxufTtcclxuXHJcbnZhciBtYWtlVGVzdCA9IGZ1bmN0aW9uKGZ1bmMpIHtcclxuICBpZiAoZnVuYy5sZW5ndGggPCAyKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcclxuICAgICAgcmV0dXJuICEhZnVuY1swXShlbCk7XHJcbiAgICB9O1xyXG4gIH1cclxuICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcclxuICAgIHZhciBpID0gZnVuYy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIGlmICghKGVsID0gZnVuY1tpXShlbCkpKSByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9O1xyXG59O1xyXG5cclxudmFyIG1ha2VTdWJqZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIHRhcmdldDtcclxuXHJcbiAgZnVuY3Rpb24gc3ViamVjdChlbCkge1xyXG4gICAgdmFyIG5vZGUgPSBlbC5vd25lckRvY3VtZW50XHJcbiAgICAgICwgc2NvcGUgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKHN1YmplY3QubG5hbWUpXHJcbiAgICAgICwgaSA9IHNjb3BlLmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIGlmIChzdWJqZWN0LnRlc3Qoc2NvcGVbaV0pICYmIHRhcmdldCA9PT0gZWwpIHtcclxuICAgICAgICB0YXJnZXQgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGFyZ2V0ID0gbnVsbDtcclxuICB9XHJcblxyXG4gIHN1YmplY3Quc2ltcGxlID0gZnVuY3Rpb24oZWwpIHtcclxuICAgIHRhcmdldCA9IGVsO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHN1YmplY3Q7XHJcbn07XHJcblxyXG52YXIgY29tcGlsZUdyb3VwID0gZnVuY3Rpb24oc2VsKSB7XHJcbiAgdmFyIHRlc3QgPSBjb21waWxlKHNlbClcclxuICAgICwgdGVzdHMgPSBbIHRlc3QgXTtcclxuXHJcbiAgd2hpbGUgKHRlc3Quc2VsKSB7XHJcbiAgICB0ZXN0ID0gY29tcGlsZSh0ZXN0LnNlbCk7XHJcbiAgICB0ZXN0cy5wdXNoKHRlc3QpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHRlc3RzLmxlbmd0aCA8IDIpIHJldHVybiB0ZXN0O1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcclxuICAgIHZhciBsID0gdGVzdHMubGVuZ3RoXHJcbiAgICAgICwgaSA9IDA7XHJcblxyXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgaWYgKHRlc3RzW2ldKGVsKSkgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZWxlY3Rpb25cclxuICovXHJcblxyXG52YXIgZmluZCA9IGZ1bmN0aW9uKHNlbCwgbm9kZSkge1xyXG4gIHZhciByZXN1bHRzID0gW11cclxuICAgICwgdGVzdCA9IGNvbXBpbGUoc2VsKVxyXG4gICAgLCBzY29wZSA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGVzdC5xbmFtZSlcclxuICAgICwgaSA9IDBcclxuICAgICwgZWw7XHJcblxyXG4gIC8qanNoaW50IC1XMDg0ICovXHJcbiAgd2hpbGUgKGVsID0gc2NvcGVbaSsrXSkge1xyXG4gICAgaWYgKHRlc3QoZWwpKSByZXN1bHRzLnB1c2goZWwpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHRlc3Quc2VsKSB7XHJcbiAgICB3aGlsZSAodGVzdC5zZWwpIHtcclxuICAgICAgdGVzdCA9IGNvbXBpbGUodGVzdC5zZWwpO1xyXG4gICAgICBzY29wZSA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGVzdC5xbmFtZSk7XHJcbiAgICAgIGkgPSAwO1xyXG4gICAgICAvKmpzaGludCAtVzA4NCAqL1xyXG4gICAgICB3aGlsZSAoZWwgPSBzY29wZVtpKytdKSB7XHJcbiAgICAgICAgaWYgKHRlc3QoZWwpICYmIGluZGV4T2YuY2FsbChyZXN1bHRzLCBlbCkgPT09IC0xKSB7XHJcbiAgICAgICAgICByZXN1bHRzLnB1c2goZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdWx0cy5zb3J0KG9yZGVyKTtcclxuICB9XHJcblxyXG4gIHJldHVybiByZXN1bHRzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV4cG9zZVxyXG4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZ1bmN0aW9uKHNlbCwgY29udGV4dCkge1xyXG4gIC8qIHdoZW4gY29udGV4dCBpc24ndCBhIERvY3VtZW50RnJhZ21lbnQgYW5kIHRoZSBzZWxlY3RvciBpcyBzaW1wbGU6ICovXHJcbiAgdmFyIGlkLCByO1xyXG4gIGlmIChjb250ZXh0Lm5vZGVUeXBlICE9PSAxMSAmJiBzZWwuaW5kZXhPZignICcpID09PSAtMSkge1xyXG4gICAgaWYgKHNlbFswXSA9PT0gJyMnICYmIGNvbnRleHQucm9vdGVkICYmIC9eI1tBLVpfXVstQS1aMC05X10qJC9pLnRlc3Qoc2VsKSkge1xyXG4gICAgICBpZiAoY29udGV4dC5kb2MuX2hhc011bHRpcGxlRWxlbWVudHNXaXRoSWQpIHtcclxuICAgICAgICBpZCA9IHNlbC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgaWYgKCFjb250ZXh0LmRvYy5faGFzTXVsdGlwbGVFbGVtZW50c1dpdGhJZChpZCkpIHtcclxuICAgICAgICAgIHIgPSBjb250ZXh0LmRvYy5nZXRFbGVtZW50QnlJZChpZCk7XHJcbiAgICAgICAgICByZXR1cm4gciA/IFtyXSA6IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNlbFswXSA9PT0gJy4nICYmIC9eXFwuXFx3KyQvLnRlc3Qoc2VsKSkge1xyXG4gICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHNlbC5zdWJzdHJpbmcoMSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKC9eXFx3KyQvLnRlc3Qoc2VsKSkge1xyXG4gICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZShzZWwpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKiBkbyB0aGluZ3MgdGhlIGhhcmQvc2xvdyB3YXkgKi9cclxuICByZXR1cm4gZmluZChzZWwsIGNvbnRleHQpO1xyXG59O1xyXG5cclxuZXhwb3J0cy5zZWxlY3RvcnMgPSBzZWxlY3RvcnM7XHJcbmV4cG9ydHMub3BlcmF0b3JzID0gb3BlcmF0b3JzO1xyXG5leHBvcnRzLmNvbWJpbmF0b3JzID0gY29tYmluYXRvcnM7XHJcblxyXG5leHBvcnRzLm1hdGNoZXMgPSBmdW5jdGlvbihlbCwgc2VsKSB7XHJcbiAgdmFyIHRlc3QgPSB7IHNlbDogc2VsIH07XHJcbiAgZG8ge1xyXG4gICAgdGVzdCA9IGNvbXBpbGUodGVzdC5zZWwpO1xyXG4gICAgaWYgKHRlc3QoZWwpKSB7IHJldHVybiB0cnVlOyB9XHJcbiAgfSB3aGlsZSAodGVzdC5zZWwpO1xyXG4gIHJldHVybiBmYWxzZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvc2VsZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuLy8gVGhpcyBncmFtbWFyIGlzIGZyb20gdGhlIFhNTCBhbmQgWE1MIE5hbWVzcGFjZSBzcGVjcy4gSXQgc3BlY2lmaWVzIHdoZXRoZXJcclxuLy8gYSBzdHJpbmcgKHN1Y2ggYXMgYW4gZWxlbWVudCBvciBhdHRyaWJ1dGUgbmFtZSkgaXMgYSB2YWxpZCBOYW1lIG9yIFFOYW1lLlxyXG4vL1xyXG4vLyBOYW1lICAgICAgICAgICA6Oj0gTmFtZVN0YXJ0Q2hhciAoTmFtZUNoYXIpKlxyXG4vLyBOYW1lU3RhcnRDaGFyICA6Oj0gXCI6XCIgfCBbQS1aXSB8IFwiX1wiIHwgW2Etel0gfFxyXG4vLyAgICAgICAgICAgICAgICAgICAgWyN4QzAtI3hENl0gfCBbI3hEOC0jeEY2XSB8IFsjeEY4LSN4MkZGXSB8XHJcbi8vICAgICAgICAgICAgICAgICAgICBbI3gzNzAtI3gzN0RdIHwgWyN4MzdGLSN4MUZGRl0gfFxyXG4vLyAgICAgICAgICAgICAgICAgICAgWyN4MjAwQy0jeDIwMERdIHwgWyN4MjA3MC0jeDIxOEZdIHxcclxuLy8gICAgICAgICAgICAgICAgICAgIFsjeDJDMDAtI3gyRkVGXSB8IFsjeDMwMDEtI3hEN0ZGXSB8XHJcbi8vICAgICAgICAgICAgICAgICAgICBbI3hGOTAwLSN4RkRDRl0gfCBbI3hGREYwLSN4RkZGRF0gfFxyXG4vLyAgICAgICAgICAgICAgICAgICAgWyN4MTAwMDAtI3hFRkZGRl1cclxuLy9cclxuLy8gTmFtZUNoYXIgICAgICAgOjo9IE5hbWVTdGFydENoYXIgfCBcIi1cIiB8IFwiLlwiIHwgWzAtOV0gfFxyXG4vLyAgICAgICAgICAgICAgICAgICAgI3hCNyB8IFsjeDAzMDAtI3gwMzZGXSB8IFsjeDIwM0YtI3gyMDQwXVxyXG4vL1xyXG4vLyBRTmFtZSAgICAgICAgICA6Oj0gUHJlZml4ZWROYW1lfCBVbnByZWZpeGVkTmFtZVxyXG4vLyBQcmVmaXhlZE5hbWUgICA6Oj0gUHJlZml4ICc6JyBMb2NhbFBhcnRcclxuLy8gVW5wcmVmaXhlZE5hbWUgOjo9IExvY2FsUGFydFxyXG4vLyBQcmVmaXggICAgICAgICA6Oj0gTkNOYW1lXHJcbi8vIExvY2FsUGFydCAgICAgIDo6PSBOQ05hbWVcclxuLy8gTkNOYW1lICAgICAgICAgOjo9IE5hbWUgLSAoQ2hhciogJzonIENoYXIqKVxyXG4vLyAgICAgICAgICAgICAgICAgICAgIyBBbiBYTUwgTmFtZSwgbWludXMgdGhlIFwiOlwiXHJcbi8vXHJcblxyXG5leHBvcnRzLmlzVmFsaWROYW1lID0gaXNWYWxpZE5hbWU7XHJcbmV4cG9ydHMuaXNWYWxpZFFOYW1lID0gaXNWYWxpZFFOYW1lO1xyXG5cclxuLy8gTW9zdCBuYW1lcyB3aWxsIGJlIEFTQ0lJIG9ubHkuIFRyeSBtYXRjaGluZyBhZ2FpbnN0IHNpbXBsZSByZWdleHBzIGZpcnN0XHJcbnZhciBzaW1wbGVuYW1lID0gL15bXzpBLVphLXpdWy0uOlxcd10rJC87XHJcbnZhciBzaW1wbGVxbmFtZSA9IC9eKFtfQS1aYS16XVstLlxcd10rfFtfQS1aYS16XVstLlxcd10rOltfQS1aYS16XVstLlxcd10rKSQvO1xyXG5cclxuLy8gSWYgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgYWJvdmUgZmFpbCwgdHJ5IG1vcmUgY29tcGxleCBvbmVzIHRoYXQgd29ya1xyXG4vLyBmb3IgYW55IGlkZW50aWZpZXJzIHVzaW5nIGNvZGVwb2ludHMgZnJvbSB0aGUgVW5pY29kZSBCTVBcclxudmFyIG5jbmFtZXN0YXJ0Y2hhcnMgPSBcIl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyZmZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcIjtcclxudmFyIG5jbmFtZWNoYXJzID0gXCItLl9BLVphLXowLTlcXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMmZmXFx1MDMwMC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQ1xcdTIwMERcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFwiO1xyXG5cclxudmFyIG5jbmFtZSA9IFwiW1wiICsgbmNuYW1lc3RhcnRjaGFycyArIFwiXVtcIiArIG5jbmFtZWNoYXJzICsgXCJdKlwiO1xyXG52YXIgbmFtZXN0YXJ0Y2hhcnMgPSBuY25hbWVzdGFydGNoYXJzICsgXCI6XCI7XHJcbnZhciBuYW1lY2hhcnMgPSBuY25hbWVjaGFycyArIFwiOlwiO1xyXG52YXIgbmFtZSA9IG5ldyBSZWdFeHAoXCJeW1wiICsgbmFtZXN0YXJ0Y2hhcnMgKyBcIl1cIiArIFwiW1wiICsgbmFtZWNoYXJzICsgXCJdKiRcIik7XHJcbnZhciBxbmFtZSA9IG5ldyBSZWdFeHAoXCJeKFwiICsgbmNuYW1lICsgXCJ8XCIgKyBuY25hbWUgKyBcIjpcIiArIG5jbmFtZSArIFwiKSRcIik7XHJcblxyXG4vLyBYTUwgc2F5cyB0aGF0IHRoZXNlIGNoYXJhY3RlcnMgYXJlIGFsc28gbGVnYWw6XHJcbi8vIFsjeDEwMDAwLSN4RUZGRkZdLiAgU28gaWYgdGhlIHBhdHRlcm5zIGFib3ZlIGZhaWwsIGFuZCB0aGVcclxuLy8gdGFyZ2V0IHN0cmluZyBpbmNsdWRlcyBzdXJyb2dhdGVzLCB0aGVuIHRyeSB0aGUgZm9sbG93aW5nXHJcbi8vIHBhdHRlcm5zIHRoYXQgYWxsb3cgc3Vycm9nYXRlcyBhbmQgdGhlbiBydW4gYW4gZXh0cmEgdmFsaWRhdGlvblxyXG4vLyBzdGVwIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBzdXJyb2dhdGVzIGFyZSBpbiB2YWxpZCBwYWlycyBhbmQgaW5cclxuLy8gdGhlIHJpZ2h0IHJhbmdlLiAgTm90ZSB0aGF0IHNpbmNlIHRoZSBjaGFyYWN0ZXJzIFxcdWYwMDAwIHRvIFxcdTFmMDAwMFxyXG4vLyBhcmUgbm90IGFsbG93ZWQsIGl0IG1lYW5zIHRoYXQgdGhlIGhpZ2ggc3Vycm9nYXRlIGNhbiBvbmx5IGdvIHVwIHRvXHJcbi8vIFxcdURCN2YgaW5zdGVhZCBvZiBcXHVEQkZGLlxyXG52YXIgaGFzc3Vycm9nYXRlcyA9IC9bXFx1RDgwMC1cXHVEQjdGXFx1REMwMC1cXHVERkZGXS87XHJcbnZhciBzdXJyb2dhdGVjaGFycyA9IC9bXFx1RDgwMC1cXHVEQjdGXFx1REMwMC1cXHVERkZGXS9nO1xyXG52YXIgc3Vycm9nYXRlcGFpcnMgPSAvW1xcdUQ4MDAtXFx1REI3Rl1bXFx1REMwMC1cXHVERkZGXS9nO1xyXG5cclxuLy8gTW9kaWZ5IHRoZSB2YXJpYWJsZXMgYWJvdmUgdG8gYWxsb3cgc3Vycm9nYXRlc1xyXG5uY25hbWVzdGFydGNoYXJzICs9IFwiXFx1RDgwMC1cXHVEQjdGXFx1REMwMC1cXHVERkZGXCI7XHJcbm5jbmFtZWNoYXJzICs9IFwiXFx1RDgwMC1cXHVEQjdGXFx1REMwMC1cXHVERkZGXCI7XHJcbm5jbmFtZSA9IFwiW1wiICsgbmNuYW1lc3RhcnRjaGFycyArIFwiXVtcIiArIG5jbmFtZWNoYXJzICsgXCJdKlwiO1xyXG5uYW1lc3RhcnRjaGFycyA9IG5jbmFtZXN0YXJ0Y2hhcnMgKyBcIjpcIjtcclxubmFtZWNoYXJzID0gbmNuYW1lY2hhcnMgKyBcIjpcIjtcclxuXHJcbi8vIEJ1aWxkIGFub3RoZXIgc2V0IG9mIHJlZ2V4cHMgdGhhdCBpbmNsdWRlIHN1cnJvZ2F0ZXNcclxudmFyIHN1cnJvZ2F0ZW5hbWUgPSBuZXcgUmVnRXhwKFwiXltcIiArIG5hbWVzdGFydGNoYXJzICsgXCJdXCIgKyBcIltcIiArIG5hbWVjaGFycyArIFwiXSokXCIpO1xyXG52YXIgc3Vycm9nYXRlcW5hbWUgPSBuZXcgUmVnRXhwKFwiXihcIiArIG5jbmFtZSArIFwifFwiICsgbmNuYW1lICsgXCI6XCIgKyBuY25hbWUgKyBcIikkXCIpO1xyXG5cclxuZnVuY3Rpb24gaXNWYWxpZE5hbWUocykge1xyXG4gIGlmIChzaW1wbGVuYW1lLnRlc3QocykpIHJldHVybiB0cnVlOyAvLyBQbGFpbiBBU0NJSVxyXG4gIGlmIChuYW1lLnRlc3QocykpIHJldHVybiB0cnVlOyAvLyBVbmljb2RlIEJNUFxyXG5cclxuICAvLyBNYXliZSB0aGUgdGVzdHMgYWJvdmUgZmFpbGVkIGJlY2F1c2UgcyBpbmNsdWRlcyBzdXJyb2dhdGUgcGFpcnNcclxuICAvLyBNb3N0IGxpa2VseSwgdGhvdWdoLCB0aGV5IGZhaWxlZCBmb3Igc29tZSBtb3JlIGJhc2ljIHN5bnRheCBwcm9ibGVtXHJcbiAgaWYgKCFoYXNzdXJyb2dhdGVzLnRlc3QocykpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgLy8gSXMgdGhlIHN0cmluZyBhIHZhbGlkIG5hbWUgaWYgd2UgYWxsb3cgc3Vycm9nYXRlcz9cclxuICBpZiAoIXN1cnJvZ2F0ZW5hbWUudGVzdChzKSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAvLyBGaW5hbGx5LCBhcmUgdGhlIHN1cnJvZ2F0ZXMgYWxsIGNvcnJlY3RseSBwYWlyZWQgdXA/XHJcbiAgdmFyIGNoYXJzID0gcy5tYXRjaChzdXJyb2dhdGVjaGFycyksIHBhaXJzID0gcy5tYXRjaChzdXJyb2dhdGVwYWlycyk7XHJcbiAgcmV0dXJuIHBhaXJzICE9PSBudWxsICYmIDIqcGFpcnMubGVuZ3RoID09PSBjaGFycy5sZW5ndGg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWRRTmFtZShzKSB7XHJcbiAgaWYgKHNpbXBsZXFuYW1lLnRlc3QocykpIHJldHVybiB0cnVlOyAvLyBQbGFpbiBBU0NJSVxyXG4gIGlmIChxbmFtZS50ZXN0KHMpKSByZXR1cm4gdHJ1ZTsgLy8gVW5pY29kZSBCTVBcclxuXHJcbiAgaWYgKCFoYXNzdXJyb2dhdGVzLnRlc3QocykpIHJldHVybiBmYWxzZTtcclxuICBpZiAoIXN1cnJvZ2F0ZXFuYW1lLnRlc3QocykpIHJldHVybiBmYWxzZTtcclxuICB2YXIgY2hhcnMgPSBzLm1hdGNoKHN1cnJvZ2F0ZWNoYXJzKSwgcGFpcnMgPSBzLm1hdGNoKHN1cnJvZ2F0ZXBhaXJzKTtcclxuICByZXR1cm4gcGFpcnMgIT09IG51bGwgJiYgMipwYWlycy5sZW5ndGggPT09IGNoYXJzLmxlbmd0aDtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZG9taW5vL2xpYi94bWxuYW1lcy5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoMCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvT2JzZXJ2YWJsZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDQzKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvYW5pbWF0aW9ucy9idW5kbGVzL2FuaW1hdGlvbnMudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoNDgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDczKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvaHR0cC9idW5kbGVzL2h0dHAudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjUuMi4yXHJcbiAqIChjKSAyMDEwLTIwMTggR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cclxuICogTGljZW5zZTogTUlUXHJcbiAqL1xyXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpLCByZXF1aXJlKCdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnJvd3NlcicpLCByZXF1aXJlKCdAYW5ndWxhci9jb21tb24nKSwgcmVxdWlyZSgnQGFuZ3VsYXIvY29tbW9uL2h0dHAnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvaHR0cCcpLCByZXF1aXJlKCdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9hbmltYXRpb25zJyksIHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpLCByZXF1aXJlKCdyeGpzL1N1YmplY3QnKSwgcmVxdWlyZSgndXJsJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvbXBpbGVyJyksIHJlcXVpcmUoJ3J4anMvb3BlcmF0b3IvZmlsdGVyJyksIHJlcXVpcmUoJ3J4anMvb3BlcmF0b3IvZmlyc3QnKSwgcmVxdWlyZSgncnhqcy9vcGVyYXRvci90b1Byb21pc2UnKSkgOlxyXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgnQGFuZ3VsYXIvcGxhdGZvcm0tc2VydmVyJywgWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnLCAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlcicsICdAYW5ndWxhci9hbmltYXRpb25zL2Jyb3dzZXInLCAnQGFuZ3VsYXIvY29tbW9uJywgJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJywgJ0Bhbmd1bGFyL2h0dHAnLCAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJywgJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucycsICdyeGpzL09ic2VydmFibGUnLCAncnhqcy9TdWJqZWN0JywgJ3VybCcsICdAYW5ndWxhci9jb21waWxlcicsICdyeGpzL29wZXJhdG9yL2ZpbHRlcicsICdyeGpzL29wZXJhdG9yL2ZpcnN0JywgJ3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlJ10sIGZhY3RvcnkpIDpcclxuXHQoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcucGxhdGZvcm1TZXJ2ZXIgPSB7fSksZ2xvYmFsLm5nLmNvcmUsZ2xvYmFsLm5nLnBsYXRmb3JtQnJvd3NlcixnbG9iYWwubmcuYW5pbWF0aW9ucy5icm93c2VyLGdsb2JhbC5uZy5jb21tb24sZ2xvYmFsLm5nLmNvbW1vbi5odHRwLGdsb2JhbC5uZy5odHRwLGdsb2JhbC5uZy5wbGF0Zm9ybUJyb3dzZXJEeW5hbWljLGdsb2JhbC5uZy5wbGF0Zm9ybUJyb3dzZXIuYW5pbWF0aW9ucyxnbG9iYWwuUngsZ2xvYmFsLlJ4LGdsb2JhbC51cmwsZ2xvYmFsLm5nLmNvbXBpbGVyLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlKSk7XHJcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvcmUsX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3NlcixfYW5ndWxhcl9jb21tb24sX2FuZ3VsYXJfY29tbW9uX2h0dHAsX2FuZ3VsYXJfaHR0cCxfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXJEeW5hbWljLF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlcl9hbmltYXRpb25zLHJ4anNfT2JzZXJ2YWJsZSxyeGpzX1N1YmplY3QsdXJsLF9hbmd1bGFyX2NvbXBpbGVyLHJ4anNfb3BlcmF0b3JfZmlsdGVyLHJ4anNfb3BlcmF0b3JfZmlyc3Qscnhqc19vcGVyYXRvcl90b1Byb21pc2UpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBBbmd1bGFyIHY1LjIuMlxyXG4gKiAoYykgMjAxMC0yMDE4IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXHJcbiAqIExpY2Vuc2U6IE1JVFxyXG4gKi9cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxyXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXHJcbiAqL1xyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbnZhciBkb21pbm8gPSByZXF1aXJlKCdkb21pbm8nKTtcclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gbWV0aG9kTmFtZVxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gX25vdEltcGxlbWVudGVkKG1ldGhvZE5hbWUpIHtcclxuICAgIHJldHVybiBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBEb21pbm9BZGFwdGVyOiAnICsgbWV0aG9kTmFtZSk7XHJcbn1cclxuLyoqXHJcbiAqIFBhcnNlcyBhIGRvY3VtZW50IHN0cmluZyB0byBhIERvY3VtZW50IG9iamVjdC5cclxuICogQHBhcmFtIHs/fSBodG1sXHJcbiAqIEBwYXJhbSB7Pz19IHVybFxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VEb2N1bWVudChodG1sLCB1cmwkJDEpIHtcclxuICAgIGlmICh1cmwkJDEgPT09IHZvaWQgMCkgeyB1cmwkJDEgPSAnLyc7IH1cclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHdpbmRvdyA9IGRvbWluby5jcmVhdGVXaW5kb3coaHRtbCwgdXJsJCQxKTtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRvYyA9IHdpbmRvdy5kb2N1bWVudDtcclxuICAgIHJldHVybiBkb2M7XHJcbn1cclxuLyoqXHJcbiAqIFNlcmlhbGl6ZXMgYSBkb2N1bWVudCB0byBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7P30gZG9jXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBzZXJpYWxpemVEb2N1bWVudChkb2MpIHtcclxuICAgIHJldHVybiAoLyoqIEB0eXBlIHs/fSAqLyAoZG9jKSkuc2VyaWFsaXplKCk7XHJcbn1cclxuLyoqXHJcbiAqIERPTSBBZGFwdGVyIGZvciB0aGUgc2VydmVyIHBsYXRmb3JtIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZ25hc3MvZG9taW5vLlxyXG4gKi9cclxudmFyIERvbWlub0FkYXB0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRG9taW5vQWRhcHRlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERvbWlub0FkYXB0ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEb21pbm9BZGFwdGVyLm1ha2VDdXJyZW50ID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtXNldFJvb3REb21BZGFwdGVyKG5ldyBEb21pbm9BZGFwdGVyKCkpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVycm9yXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5sb2dFcnJvciA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlcnJvclxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVycm9yKSB7IGNvbnNvbGUuZXJyb3IoZXJyb3IpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVycm9yXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5sb2cgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlcnJvclxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUubG9nR3JvdXAgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlcnJvcikgeyBjb25zb2xlLmVycm9yKGVycm9yKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUubG9nR3JvdXBFbmQgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNET01FdmVudHMgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c05hdGl2ZVNoYWRvd0RPTSA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbm9kZUFcclxuICAgICAqIEBwYXJhbSB7P30gbm9kZUJcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmNvbnRhaW5zID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5vZGVBXHJcbiAgICAgKiBAcGFyYW0gez99IG5vZGVCXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobm9kZUEsIG5vZGVCKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXIgPSBub2RlQjtcclxuICAgICAgICB3aGlsZSAoaW5uZXIpIHtcclxuICAgICAgICAgICAgaWYgKGlubmVyID09PSBub2RlQSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBpbm5lciA9IGlubmVyLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlSHRtbERvY3VtZW50ID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlRG9jdW1lbnQoJzxodG1sPjxoZWFkPjx0aXRsZT5mYWtlVGl0bGU8L3RpdGxlPjwvaGVhZD48Ym9keT48L2JvZHk+PC9odG1sPicpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0RGVmYXVsdERvY3VtZW50ID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFEb21pbm9BZGFwdGVyLmRlZmF1bHREb2MpIHtcclxuICAgICAgICAgICAgRG9taW5vQWRhcHRlci5kZWZhdWx0RG9jID0gZG9taW5vLmNyZWF0ZURvY3VtZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBEb21pbm9BZGFwdGVyLmRlZmF1bHREb2M7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsXHJcbiAgICAgKiBAcGFyYW0gez89fSBkb2NcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVNoYWRvd1Jvb3QgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxcclxuICAgICAqIEBwYXJhbSB7Pz19IGRvY1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsLCBkb2MpIHtcclxuICAgICAgICBpZiAoZG9jID09PSB2b2lkIDApIHsgZG9jID0gZG9jdW1lbnQ7IH1cclxuICAgICAgICBlbC5zaGFkb3dSb290ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICBlbC5zaGFkb3dSb290LnBhcmVudCA9IGVsO1xyXG4gICAgICAgIHJldHVybiBlbC5zaGFkb3dSb290O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0U2hhZG93Um9vdCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5zaGFkb3dSb290OyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmlzVGV4dE5vZGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IERvbWlub0FkYXB0ZXIuZGVmYXVsdERvYy5URVhUX05PREU7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuaXNDb21tZW50Tm9kZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBub2RlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSBEb21pbm9BZGFwdGVyLmRlZmF1bHREb2MuQ09NTUVOVF9OT0RFO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBub2RlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5pc0VsZW1lbnROb2RlID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLm5vZGVUeXBlID09PSBEb21pbm9BZGFwdGVyLmRlZmF1bHREb2MuRUxFTUVOVF9OT0RFIDogZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmhhc1NoYWRvd1Jvb3QgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuc2hhZG93Um9vdCAhPSBudWxsOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmlzU2hhZG93Um9vdCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBub2RlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdGhpcy5nZXRTaGFkb3dSb290KG5vZGUpID09IG5vZGU7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0UHJvcGVydHkgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT09ICdocmVmJykge1xyXG4gICAgICAgICAgICAvLyBEb21pbm8gdHJpZXMgdHAgcmVzb2x2ZSBocmVmLXMgd2hpY2ggd2UgZG8gbm90IHdhbnQuIEp1c3QgcmV0dXJuIHRoZVxyXG4gICAgICAgICAgICAvLyBhdHJpYnV0ZSB2YWx1ZS5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKGVsLCAnaHJlZicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnaW5uZXJUZXh0Jykge1xyXG4gICAgICAgICAgICAvLyBEb21pbm8gZG9lcyBub3Qgc3VwcG9ydCBpbm5lclRleHQuIEp1c3QgbWFwIGl0IHRvIHRleHRDb250ZW50LlxyXG4gICAgICAgICAgICByZXR1cm4gZWwudGV4dENvbnRlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHs/fSAqLyAoZWwpKVtuYW1lXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09PSAnaHJlZicpIHtcclxuICAgICAgICAgICAgLy8gRXZlbnRob3VnaCB0aGUgc2VydmVyIHJlbmRlcmVyIHJlZmxlY3RzIGFueSBwcm9wZXJ0aWVzIHRvIGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgLy8gbWFwICdocmVmJyB0byBhdHJpYnV0ZSBqdXN0IHRvIGhhbmRsZSB3aGVuIHNldFByb3BlcnR5IGlzIGRpcmVjdGx5IGNhbGxlZC5cclxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoZWwsICdocmVmJywgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnaW5uZXJUZXh0Jykge1xyXG4gICAgICAgICAgICAvLyBEb21pbm8gZG9lcyBub3Qgc3VwcG9ydCBpbm5lclRleHQuIEp1c3QgbWFwIGl0IHRvIHRleHRDb250ZW50LlxyXG4gICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAoZWwpKVtuYW1lXSA9IHZhbHVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBkb2NcclxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5nZXRHbG9iYWxFdmVudFRhcmdldCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBkb2NcclxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZG9jLCB0YXJnZXQpIHtcclxuICAgICAgICBpZiAodGFyZ2V0ID09PSAnd2luZG93Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0ID09PSAnZG9jdW1lbnQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YXJnZXQgPT09ICdib2R5Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jLmJvZHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBkb2NcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmdldEJhc2VIcmVmID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGRvY1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGRvYykge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2UgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoZG9jLmRvY3VtZW50RWxlbWVudCwgJ2Jhc2UnKTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBocmVmID0gJyc7XHJcbiAgICAgICAgaWYgKGJhc2UpIHtcclxuICAgICAgICAgICAgaHJlZiA9IHRoaXMuZ2V0SHJlZihiYXNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETyhhbHhodWIpOiBOZWVkIHJlbGF0aXZlIHBhdGggbG9naWMgZnJvbSBCcm93c2VyRG9tQWRhcHRlciBoZXJlP1xyXG4gICAgICAgIHJldHVybiBocmVmO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIC8qKlxyXG4gICAgICogXFxAaW50ZXJuYWxcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuX3JlYWRTdHlsZUF0dHJpYnV0ZSA9IC8qKlxyXG4gICAgICogXFxAaW50ZXJuYWxcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZU1hcCA9IHt9O1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XHJcbiAgICAgICAgaWYgKHN0eWxlQXR0cmlidXRlKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlTGlzdCA9IHN0eWxlQXR0cmlidXRlLnNwbGl0KC87Ky9nKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHN0eWxlTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlTGlzdFtpXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGUgPSAvKiogQHR5cGUgez99ICovIChzdHlsZUxpc3RbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbG9uID0gc3R5bGUuaW5kZXhPZignOicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvbiA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBDU1Mgc3R5bGU6IFwiICsgc3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAoc3R5bGVNYXApKVtzdHlsZS5zdWJzdHIoMCwgY29sb24pLnRyaW0oKV0gPSBzdHlsZS5zdWJzdHIoY29sb24gKyAxKS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0eWxlTWFwO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIC8qKlxyXG4gICAgICogXFxAaW50ZXJuYWxcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZU1hcFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuX3dyaXRlU3R5bGVBdHRyaWJ1dGUgPSAvKipcclxuICAgICAqIFxcQGludGVybmFsXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVNYXBcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZU1hcCkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlQXR0clZhbHVlID0gJyc7XHJcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgaW4gc3R5bGVNYXApIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3VmFsdWUgPSBzdHlsZU1hcFtrZXldO1xyXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlQXR0clZhbHVlICs9IGtleSArICc6JyArIHN0eWxlTWFwW2tleV0gKyAnOyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgc3R5bGVBdHRyVmFsdWUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlTmFtZVxyXG4gICAgICogQHBhcmFtIHs/PX0gc3R5bGVWYWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuc2V0U3R5bGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZU5hbWVcclxuICAgICAqIEBwYXJhbSB7Pz19IHN0eWxlVmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZU5hbWUsIHN0eWxlVmFsdWUpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZU1hcCA9IHRoaXMuX3JlYWRTdHlsZUF0dHJpYnV0ZShlbGVtZW50KTtcclxuICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAoc3R5bGVNYXApKVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcclxuICAgICAgICB0aGlzLl93cml0ZVN0eWxlQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlTWFwKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZU5hbWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLnJlbW92ZVN0eWxlID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVOYW1lXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVOYW1lKSB7IHRoaXMuc2V0U3R5bGUoZWxlbWVudCwgc3R5bGVOYW1lLCBudWxsKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlTmFtZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0U3R5bGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZU5hbWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZU5hbWUpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZU1hcCA9IHRoaXMuX3JlYWRTdHlsZUF0dHJpYnV0ZShlbGVtZW50KTtcclxuICAgICAgICByZXR1cm4gc3R5bGVNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSA/ICgvKiogQHR5cGUgez99ICovIChzdHlsZU1hcCkpW3N0eWxlTmFtZV0gOiAnJztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZU5hbWVcclxuICAgICAqIEBwYXJhbSB7Pz19IHN0eWxlVmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmhhc1N0eWxlID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVOYW1lXHJcbiAgICAgKiBAcGFyYW0gez89fSBzdHlsZVZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLmdldFN0eWxlKGVsZW1lbnQsIHN0eWxlTmFtZSkgfHwgJyc7XHJcbiAgICAgICAgcmV0dXJuIHN0eWxlVmFsdWUgPyB2YWx1ZSA9PSBzdHlsZVZhbHVlIDogdmFsdWUubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxcclxuICAgICAqIEBwYXJhbSB7P30gZXZ0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsXHJcbiAgICAgKiBAcGFyYW0gez99IGV2dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsLCBldnQpIHtcclxuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KGV2dCk7XHJcbiAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV2ZW50IHRvIHRoZSB3aW5kb3cgYWxzby5cclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkb2MgPSBlbC5vd25lckRvY3VtZW50IHx8IGVsO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHdpbiA9ICgvKiogQHR5cGUgez99ICovIChkb2MpKS5kZWZhdWx0VmlldztcclxuICAgICAgICBpZiAod2luKSB7XHJcbiAgICAgICAgICAgIHdpbi5kaXNwYXRjaEV2ZW50KGV2dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0SGlzdG9yeSA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkgeyB0aHJvdyBfbm90SW1wbGVtZW50ZWQoJ2dldEhpc3RvcnknKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgdGhyb3cgX25vdEltcGxlbWVudGVkKCdnZXRMb2NhdGlvbicpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5nZXRVc2VyQWdlbnQgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdGYWtlIHVzZXIgYWdlbnQnOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c1dlYkFuaW1hdGlvbiA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLnBlcmZvcm1hbmNlTm93ID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBEYXRlLm5vdygpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5nZXRBbmltYXRpb25QcmVmaXggPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuICcnOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5nZXRUcmFuc2l0aW9uRW5kID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiAndHJhbnNpdGlvbmVuZCc7IH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzQW5pbWF0aW9uID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5nZXREaXN0cmlidXRlZE5vZGVzID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWwpIHsgdGhyb3cgX25vdEltcGxlbWVudGVkKCdnZXREaXN0cmlidXRlZE5vZGVzJyk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzQ29va2llcyA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0Q29va2llID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChuYW1lKSB7IHRocm93IF9ub3RJbXBsZW1lbnRlZCgnZ2V0Q29va2llJyk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuc2V0Q29va2llID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkgeyB0aHJvdyBfbm90SW1wbGVtZW50ZWQoJ3NldENvb2tpZScpOyB9O1xyXG4gICAgcmV0dXJuIERvbWlub0FkYXB0ZXI7XHJcbn0oX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1QnJvd3NlckRvbUFkYXB0ZXIpKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogUmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgcGxhdGZvcm0gc3RhdGUuXHJcbiAqXHJcbiAqIFxcQGV4cGVyaW1lbnRhbFxyXG4gKi9cclxudmFyIFBsYXRmb3JtU3RhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQbGF0Zm9ybVN0YXRlKF9kb2MpIHtcclxuICAgICAgICB0aGlzLl9kb2MgPSBfZG9jO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBwbGF0Zm9ybSB0byBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcGxhdGZvcm0gdG8gc3RyaW5nLlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgUGxhdGZvcm1TdGF0ZS5wcm90b3R5cGUucmVuZGVyVG9TdHJpbmcgPSAvKipcclxuICAgICAqIFJlbmRlcnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHBsYXRmb3JtIHRvIHN0cmluZy5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcmlhbGl6ZURvY3VtZW50KHRoaXMuX2RvYyk7IH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgRE9NIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgRE9NIHN0YXRlLlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgUGxhdGZvcm1TdGF0ZS5wcm90b3R5cGUuZ2V0RG9jdW1lbnQgPSAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgRE9NIHN0YXRlLlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZG9jOyB9O1xyXG4gICAgUGxhdGZvcm1TdGF0ZS5kZWNvcmF0b3JzID0gW1xyXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXHJcbiAgICBdO1xyXG4gICAgLyoqIEBub2NvbGxhcHNlICovXHJcbiAgICBQbGF0Zm9ybVN0YXRlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5ET0NVTUVOVCxdIH0sXSB9LFxyXG4gICAgXTsgfTtcclxuICAgIHJldHVybiBQbGF0Zm9ybVN0YXRlO1xyXG59KCkpO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxyXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXHJcbiAqL1xyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbnZhciB4aHIyID0gcmVxdWlyZSgneGhyMicpO1xyXG52YXIgaXNBYnNvbHV0ZVVybCA9IC9eW2EtekEtWlxcLVxcKy5dKzpcXC9cXC8vO1xyXG4vKipcclxuICogQHBhcmFtIHs/fSB1cmxcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUmVxdWVzdFVybCh1cmwkJDEpIHtcclxuICAgIGlmICghaXNBYnNvbHV0ZVVybC50ZXN0KHVybCQkMSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVUkxzIHJlcXVlc3RlZCB2aWEgSHR0cCBvbiB0aGUgc2VydmVyIG11c3QgYmUgYWJzb2x1dGUuIFVSTDogXCIgKyB1cmwkJDEpO1xyXG4gICAgfVxyXG59XHJcbnZhciBTZXJ2ZXJYaHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZXJ2ZXJYaHIoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFNlcnZlclhoci5wcm90b3R5cGUuYnVpbGQgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyB4aHIyLlhNTEh0dHBSZXF1ZXN0KCk7IH07XHJcbiAgICBTZXJ2ZXJYaHIuZGVjb3JhdG9ycyA9IFtcclxuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxyXG4gICAgXTtcclxuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xyXG4gICAgU2VydmVyWGhyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XHJcbiAgICByZXR1cm4gU2VydmVyWGhyO1xyXG59KCkpO1xyXG52YXIgU2VydmVyWHNyZlN0cmF0ZWd5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2VydmVyWHNyZlN0cmF0ZWd5KCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHJlcVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgU2VydmVyWHNyZlN0cmF0ZWd5LnByb3RvdHlwZS5jb25maWd1cmVSZXF1ZXN0ID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHJlcVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHJlcSkgeyB9O1xyXG4gICAgU2VydmVyWHNyZlN0cmF0ZWd5LmRlY29yYXRvcnMgPSBbXHJcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcclxuICAgIF07XHJcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cclxuICAgIFNlcnZlclhzcmZTdHJhdGVneS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xyXG4gICAgcmV0dXJuIFNlcnZlclhzcmZTdHJhdGVneTtcclxufSgpKTtcclxuLyoqXHJcbiAqIEBhYnN0cmFjdFxyXG4gKi9cclxudmFyIFpvbmVNYWNyb1Rhc2tXcmFwcGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gWm9uZU1hY3JvVGFza1dyYXBwZXIoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgWm9uZU1hY3JvVGFza1dyYXBwZXIucHJvdG90eXBlLndyYXAgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHJlcXVlc3QpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhc2sgPSAvKiogQHR5cGUgez99ICovICgobnVsbCkpO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2hlZHVsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ViID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2F2ZWRSZXN1bHQgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzYXZlZEVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2NoZWR1bGVUYXNrID0gZnVuY3Rpb24gKF90YXNrKSB7XHJcbiAgICAgICAgICAgICAgICB0YXNrID0gX3Rhc2s7XHJcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVsZWdhdGUgPSBfdGhpcy5kZWxlZ2F0ZShyZXF1ZXN0KTtcclxuICAgICAgICAgICAgICAgIHN1YiA9IGRlbGVnYXRlLnN1YnNjcmliZShmdW5jdGlvbiAocmVzKSB7IHJldHVybiBzYXZlZFJlc3VsdCA9IHJlczsgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NoZWR1bGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gaHR0cCBvYnNlcnZhYmxlIHdhcyBjb21wbGV0ZWQgdHdpY2UuIFRoaXMgc2hvdWxkblxcJ3QgaGFwcGVuLCBwbGVhc2UgZmlsZSBhIGJ1Zy4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2F2ZWRFcnJvciA9IGVycjtcclxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrLmludm9rZSgpO1xyXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NoZWR1bGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gaHR0cCBvYnNlcnZhYmxlIHdhcyBjb21wbGV0ZWQgdHdpY2UuIFRoaXMgc2hvdWxkblxcJ3QgaGFwcGVuLCBwbGVhc2UgZmlsZSBhIGJ1Zy4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzay5pbnZva2UoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYW5jZWxUYXNrID0gZnVuY3Rpb24gKF90YXNrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNjaGVkdWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1Yikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2F2ZWRFcnJvciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHNhdmVkRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChzYXZlZFJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gTW9ja0JhY2tlbmQgZm9yIEh0dHAgaXMgc3luY2hyb25vdXMsIHdoaWNoIG1lYW5zIHRoYXQgaWYgc2NoZWR1bGVUYXNrIGlzIGJ5XHJcbiAgICAgICAgICAgIC8vIHNjaGVkdWxlTWFjcm9UYXNrLCB0aGUgcmVxdWVzdCB3aWxsIGhpdCBNb2NrQmFja2VuZCBhbmQgdGhlIHJlc3BvbnNlIHdpbGwgYmVcclxuICAgICAgICAgICAgLy8gc2VudCwgY2F1c2luZyB0YXNrLmludm9rZSgpIHRvIGJlIGNhbGxlZC5cclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gX3Rhc2sgPSBab25lLmN1cnJlbnQuc2NoZWR1bGVNYWNyb1Rhc2soJ1pvbmVNYWNyb1Rhc2tXcmFwcGVyLnN1YnNjcmliZScsIG9uQ29tcGxldGUsIHt9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LCBjYW5jZWxUYXNrKTtcclxuICAgICAgICAgICAgc2NoZWR1bGVUYXNrKF90YXNrKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzY2hlZHVsZWQgJiYgdGFzaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2suem9uZS5jYW5jZWxUYXNrKHRhc2spO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHN1Yikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFpvbmVNYWNyb1Rhc2tXcmFwcGVyO1xyXG59KCkpO1xyXG52YXIgWm9uZU1hY3JvVGFza0Nvbm5lY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoWm9uZU1hY3JvVGFza0Nvbm5lY3Rpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBab25lTWFjcm9UYXNrQ29ubmVjdGlvbihyZXF1ZXN0LCBiYWNrZW5kKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcclxuICAgICAgICBfdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcclxuICAgICAgICB2YWxpZGF0ZVJlcXVlc3RVcmwocmVxdWVzdC51cmwpO1xyXG4gICAgICAgIF90aGlzLnJlc3BvbnNlID0gX3RoaXMud3JhcChyZXF1ZXN0KTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgWm9uZU1hY3JvVGFza0Nvbm5lY3Rpb24ucHJvdG90eXBlLmRlbGVnYXRlID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbiA9IHRoaXMuYmFja2VuZC5jcmVhdGVDb25uZWN0aW9uKHJlcXVlc3QpO1xyXG4gICAgICAgIHJldHVybiAvKiogQHR5cGUgez99ICovICh0aGlzLmxhc3RDb25uZWN0aW9uLnJlc3BvbnNlKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9uZU1hY3JvVGFza0Nvbm5lY3Rpb24ucHJvdG90eXBlLCBcInJlYWR5U3RhdGVcIiwge1xyXG4gICAgICAgIGdldDogLyoqXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMubGFzdENvbm5lY3Rpb24gPyB0aGlzLmxhc3RDb25uZWN0aW9uLnJlYWR5U3RhdGUgOiBfYW5ndWxhcl9odHRwLlJlYWR5U3RhdGUuVW5zZW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFpvbmVNYWNyb1Rhc2tDb25uZWN0aW9uO1xyXG59KFpvbmVNYWNyb1Rhc2tXcmFwcGVyKSk7XHJcbnZhciBab25lTWFjcm9UYXNrQmFja2VuZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFpvbmVNYWNyb1Rhc2tCYWNrZW5kKGJhY2tlbmQpIHtcclxuICAgICAgICB0aGlzLmJhY2tlbmQgPSBiYWNrZW5kO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFpvbmVNYWNyb1Rhc2tCYWNrZW5kLnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab25lTWFjcm9UYXNrQ29ubmVjdGlvbihyZXF1ZXN0LCB0aGlzLmJhY2tlbmQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBab25lTWFjcm9UYXNrQmFja2VuZDtcclxufSgpKTtcclxudmFyIFpvbmVDbGllbnRCYWNrZW5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFpvbmVDbGllbnRCYWNrZW5kLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gWm9uZUNsaWVudEJhY2tlbmQoYmFja2VuZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFpvbmVDbGllbnRCYWNrZW5kLnByb3RvdHlwZS5oYW5kbGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHJlcXVlc3QpIHsgcmV0dXJuIHRoaXMud3JhcChyZXF1ZXN0KTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSByZXF1ZXN0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBab25lQ2xpZW50QmFja2VuZC5wcm90b3R5cGUuZGVsZWdhdGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHJlcXVlc3QpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmhhbmRsZShyZXF1ZXN0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gWm9uZUNsaWVudEJhY2tlbmQ7XHJcbn0oWm9uZU1hY3JvVGFza1dyYXBwZXIpKTtcclxuLyoqXHJcbiAqIEBwYXJhbSB7P30geGhyQmFja2VuZFxyXG4gKiBAcGFyYW0gez99IG9wdGlvbnNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGh0dHBGYWN0b3J5KHhockJhY2tlbmQsIG9wdGlvbnMpIHtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hY3JvQmFja2VuZCA9IG5ldyBab25lTWFjcm9UYXNrQmFja2VuZCh4aHJCYWNrZW5kKTtcclxuICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfaHR0cC5IdHRwKG1hY3JvQmFja2VuZCwgb3B0aW9ucyk7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gYmFja2VuZFxyXG4gKiBAcGFyYW0gez99IGludGVyY2VwdG9yc1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gem9uZVdyYXBwZWRJbnRlcmNlcHRpbmdIYW5kbGVyKGJhY2tlbmQsIGludGVyY2VwdG9ycykge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVhbEJhY2tlbmQgPSBfYW5ndWxhcl9jb21tb25faHR0cC7JtWludGVyY2VwdGluZ0hhbmRsZXIoYmFja2VuZCwgaW50ZXJjZXB0b3JzKTtcclxuICAgIHJldHVybiBuZXcgWm9uZUNsaWVudEJhY2tlbmQocmVhbEJhY2tlbmQpO1xyXG59XHJcbnZhciBTRVJWRVJfSFRUUF9QUk9WSURFUlMgPSBbXHJcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2h0dHAuSHR0cCwgdXNlRmFjdG9yeTogaHR0cEZhY3RvcnksIGRlcHM6IFtfYW5ndWxhcl9odHRwLlhIUkJhY2tlbmQsIF9hbmd1bGFyX2h0dHAuUmVxdWVzdE9wdGlvbnNdIH0sXHJcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2h0dHAuQnJvd3NlclhociwgdXNlQ2xhc3M6IFNlcnZlclhociB9LCB7IHByb3ZpZGU6IF9hbmd1bGFyX2h0dHAuWFNSRlN0cmF0ZWd5LCB1c2VDbGFzczogU2VydmVyWHNyZlN0cmF0ZWd5IH0sXHJcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2NvbW1vbl9odHRwLlhockZhY3RvcnksIHVzZUNsYXNzOiBTZXJ2ZXJYaHIgfSwge1xyXG4gICAgICAgIHByb3ZpZGU6IF9hbmd1bGFyX2NvbW1vbl9odHRwLkh0dHBIYW5kbGVyLFxyXG4gICAgICAgIHVzZUZhY3Rvcnk6IHpvbmVXcmFwcGVkSW50ZXJjZXB0aW5nSGFuZGxlcixcclxuICAgICAgICBkZXBzOiBbX2FuZ3VsYXJfY29tbW9uX2h0dHAuSHR0cEJhY2tlbmQsIFtuZXcgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpLCBfYW5ndWxhcl9jb21tb25faHR0cC5IVFRQX0lOVEVSQ0VQVE9SU11dXHJcbiAgICB9XHJcbl07XHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIENvbmZpZyBvYmplY3QgcGFzc2VkIHRvIGluaXRpYWxpemUgdGhlIHBsYXRmb3JtLlxyXG4gKlxyXG4gKiBcXEBleHBlcmltZW50YWxcclxuICogQHJlY29yZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUaGUgREkgdG9rZW4gZm9yIHNldHRpbmcgdGhlIGluaXRpYWwgY29uZmlnIGZvciB0aGUgcGxhdGZvcm0uXHJcbiAqXHJcbiAqIFxcQGV4cGVyaW1lbnRhbFxyXG4gKi9cclxudmFyIElOSVRJQUxfQ09ORklHID0gbmV3IF9hbmd1bGFyX2NvcmUuSW5qZWN0aW9uVG9rZW4oJ1NlcnZlci5JTklUSUFMX0NPTkZJRycpO1xyXG4vKipcclxuICogQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBjYWxsaW5nIGByZW5kZXJNb2R1bGVGYWN0b3J5YCBvciBgcmVuZGVyTW9kdWxlYCBqdXN0XHJcbiAqIGJlZm9yZSBjdXJyZW50IHBsYXRmb3JtIHN0YXRlIGlzIHJlbmRlcmVkIHRvIHN0cmluZy5cclxuICpcclxuICogXFxAZXhwZXJpbWVudGFsXHJcbiAqL1xyXG52YXIgQkVGT1JFX0FQUF9TRVJJQUxJWkVEID0gbmV3IF9hbmd1bGFyX2NvcmUuSW5qZWN0aW9uVG9rZW4oJ1NlcnZlci5SRU5ERVJfTU9EVUxFX0hPT0snKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogQHBhcmFtIHs/fSB1cmxTdHJcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlVXJsKHVybFN0cikge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyc2VkVXJsID0gdXJsLnBhcnNlKHVybFN0cik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHBhdGhuYW1lOiBwYXJzZWRVcmwucGF0aG5hbWUgfHwgJycsXHJcbiAgICAgICAgc2VhcmNoOiBwYXJzZWRVcmwuc2VhcmNoIHx8ICcnLFxyXG4gICAgICAgIGhhc2g6IHBhcnNlZFVybC5oYXNoIHx8ICcnLFxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogU2VydmVyLXNpZGUgaW1wbGVtZW50YXRpb24gb2YgVVJMIHN0YXRlLiBJbXBsZW1lbnRzIGBwYXRobmFtZWAsIGBzZWFyY2hgLCBhbmQgYGhhc2hgXHJcbiAqIGJ1dCBub3QgdGhlIHN0YXRlIHN0YWNrLlxyXG4gKi9cclxudmFyIFNlcnZlclBsYXRmb3JtTG9jYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZXJ2ZXJQbGF0Zm9ybUxvY2F0aW9uKF9kb2MsIF9jb25maWcpIHtcclxuICAgICAgICB0aGlzLl9kb2MgPSBfZG9jO1xyXG4gICAgICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XHJcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcclxuICAgICAgICB0aGlzLmhhc2ggPSAnJztcclxuICAgICAgICB0aGlzLl9oYXNoVXBkYXRlID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZmlnID0gLyoqIEB0eXBlIHs/fSAqLyAoX2NvbmZpZyk7XHJcbiAgICAgICAgaWYgKCEhY29uZmlnICYmICEhY29uZmlnLnVybCkge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJzZWRVcmwgPSBwYXJzZVVybChjb25maWcudXJsKTtcclxuICAgICAgICAgICAgdGhpcy5wYXRobmFtZSA9IHBhcnNlZFVybC5wYXRobmFtZTtcclxuICAgICAgICAgICAgdGhpcy5zZWFyY2ggPSBwYXJzZWRVcmwuc2VhcmNoO1xyXG4gICAgICAgICAgICB0aGlzLmhhc2ggPSBwYXJzZWRVcmwuaGFzaDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFNlcnZlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLmdldEJhc2VIcmVmRnJvbURPTSA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gLyoqIEB0eXBlIHs/fSAqLyAoKF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmdldEJhc2VIcmVmKHRoaXMuX2RvYykpKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBmblxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUub25Qb3BTdGF0ZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBmblxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgLy8gTm8tb3A6IGEgc3RhdGUgc3RhY2sgaXMgbm90IGltcGxlbWVudGVkLCBzb1xyXG4gICAgICAgIC8vIG5vIGV2ZW50cyB3aWxsIGV2ZXIgY29tZS5cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZm5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFNlcnZlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLm9uSGFzaENoYW5nZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBmblxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGZuKSB7IHRoaXMuX2hhc2hVcGRhdGUuc3Vic2NyaWJlKGZuKTsgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2ZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJ1cmxcIiwge1xyXG4gICAgICAgIGdldDogLyoqXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlwiICsgdGhpcy5wYXRobmFtZSArIHRoaXMuc2VhcmNoICsgdGhpcy5oYXNoOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHs/fSBvbGRVcmxcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFNlcnZlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLnNldEhhc2ggPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7P30gb2xkVXJsXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAodmFsdWUsIG9sZFVybCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzaCA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgLy8gRG9uJ3QgZmlyZSBldmVudHMgaWYgdGhlIGhhc2ggaGFzIG5vdCBjaGFuZ2VkLlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgICgvKiogQHR5cGUgez99ICovICh0aGlzKSkuaGFzaCA9IHZhbHVlO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld1VybCA9IHRoaXMudXJsO1xyXG4gICAgICAgIHNjaGVkdWxlTWljcm9UYXNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9oYXNoVXBkYXRlLm5leHQoLyoqIEB0eXBlIHs/fSAqLyAoeyB0eXBlOiAnaGFzaGNoYW5nZScsIG9sZFVybDogb2xkVXJsLCBuZXdVcmw6IG5ld1VybCB9KSk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSB0aXRsZVxyXG4gICAgICogQHBhcmFtIHs/fSBuZXdVcmxcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFNlcnZlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSB0aXRsZVxyXG4gICAgICogQHBhcmFtIHs/fSBuZXdVcmxcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIG5ld1VybCkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZFVybCA9IHRoaXMudXJsO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnNlZFVybCA9IHBhcnNlVXJsKG5ld1VybCk7XHJcbiAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKHRoaXMpKS5wYXRobmFtZSA9IHBhcnNlZFVybC5wYXRobmFtZTtcclxuICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAodGhpcykpLnNlYXJjaCA9IHBhcnNlZFVybC5zZWFyY2g7XHJcbiAgICAgICAgdGhpcy5zZXRIYXNoKHBhcnNlZFVybC5oYXNoLCBvbGRVcmwpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSB0aXRsZVxyXG4gICAgICogQHBhcmFtIHs/fSBuZXdVcmxcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFNlcnZlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLnB1c2hTdGF0ZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSB0aXRsZVxyXG4gICAgICogQHBhcmFtIHs/fSBuZXdVcmxcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIG5ld1VybCkge1xyXG4gICAgICAgIHRoaXMucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgbmV3VXJsKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFNlcnZlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLmZvcndhcmQgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUuYmFjayA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpOyB9O1xyXG4gICAgU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5kZWNvcmF0b3JzID0gW1xyXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXHJcbiAgICBdO1xyXG4gICAgLyoqIEBub2NvbGxhcHNlICovXHJcbiAgICBTZXJ2ZXJQbGF0Zm9ybUxvY2F0aW9uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5ET0NVTUVOVCxdIH0sXSB9LFxyXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtJTklUSUFMX0NPTkZJRyxdIH0sXSB9LFxyXG4gICAgXTsgfTtcclxuICAgIHJldHVybiBTZXJ2ZXJQbGF0Zm9ybUxvY2F0aW9uO1xyXG59KCkpO1xyXG4vKipcclxuICogQHBhcmFtIHs/fSBmblxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gc2NoZWR1bGVNaWNyb1Rhc2soZm4pIHtcclxuICAgIFpvbmUuY3VycmVudC5zY2hlZHVsZU1pY3JvVGFzaygnc2NoZWR1bGVNaWNyb3Rhc2snLCBmbik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG52YXIgRU1QVFlfQVJSQVkgPSBbXTtcclxudmFyIFNlcnZlclJlbmRlcmVyRmFjdG9yeTIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyKG5nWm9uZSwgZG9jdW1lbnQsIHNoYXJlZFN0eWxlc0hvc3QpIHtcclxuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XHJcbiAgICAgICAgdGhpcy5zaGFyZWRTdHlsZXNIb3N0ID0gc2hhcmVkU3R5bGVzSG9zdDtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyQnlDb21wSWQgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBuZXcgX2FuZ3VsYXJfY29tcGlsZXIuRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCk7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0UmVuZGVyZXIgPSBuZXcgRGVmYXVsdFNlcnZlclJlbmRlcmVyMihkb2N1bWVudCwgbmdab25lLCB0aGlzLnNjaGVtYSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyLnByb3RvdHlwZS5jcmVhdGVSZW5kZXJlciA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50LCB0eXBlKSB7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICF0eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRSZW5kZXJlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoICh0eXBlLmVuY2Fwc3VsYXRpb24pIHtcclxuICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5hdGl2ZTpcclxuICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkOiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZW5kZXJlciA9IHRoaXMucmVuZGVyZXJCeUNvbXBJZC5nZXQodHlwZS5pZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIgPSBuZXcgRW11bGF0ZWRFbmNhcHN1bGF0aW9uU2VydmVyUmVuZGVyZXIyKHRoaXMuZG9jdW1lbnQsIHRoaXMubmdab25lLCB0aGlzLnNoYXJlZFN0eWxlc0hvc3QsIHRoaXMuc2NoZW1hLCB0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyQnlDb21wSWQuc2V0KHR5cGUuaWQsIHJlbmRlcmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICgvKiogQHR5cGUgez99ICovIChyZW5kZXJlcikpLmFwcGx5VG9Ib3N0KGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmU6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hdGl2ZSBlbmNhcHN1bGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhlIHNlcnZlciEnKTtcclxuICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVyQnlDb21wSWQuaGFzKHR5cGUuaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1ZmxhdHRlblN0eWxlcyh0eXBlLmlkLCB0eXBlLnN0eWxlcywgW10pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkU3R5bGVzSG9zdC5hZGRTdHlsZXMoc3R5bGVzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyQnlDb21wSWQuc2V0KHR5cGUuaWQsIHRoaXMuZGVmYXVsdFJlbmRlcmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRSZW5kZXJlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFNlcnZlclJlbmRlcmVyRmFjdG9yeTIucHJvdG90eXBlLmJlZ2luID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFNlcnZlclJlbmRlcmVyRmFjdG9yeTIucHJvdG90eXBlLmVuZCA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgU2VydmVyUmVuZGVyZXJGYWN0b3J5Mi5kZWNvcmF0b3JzID0gW1xyXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXHJcbiAgICBdO1xyXG4gICAgLyoqIEBub2NvbGxhcHNlICovXHJcbiAgICBTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ1pvbmUsIH0sXHJcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkRPQ1VNRU5ULF0gfSxdIH0sXHJcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVTaGFyZWRTdHlsZXNIb3N0LCB9LFxyXG4gICAgXTsgfTtcclxuICAgIHJldHVybiBTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyO1xyXG59KCkpO1xyXG52YXIgRGVmYXVsdFNlcnZlclJlbmRlcmVyMiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIoZG9jdW1lbnQsIG5nWm9uZSwgc2NoZW1hKSB7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xyXG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xyXG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLmRlc3Ryb3kgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gez89fSBuYW1lc3BhY2VcclxuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gez89fSBuYW1lc3BhY2VcclxuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG5hbWUsIG5hbWVzcGFjZSwgZGVidWdJbmZvKSB7XHJcbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuY3JlYXRlRWxlbWVudE5TKF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtU5BTUVTUEFDRV9VUklTW25hbWVzcGFjZV0sIG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuY3JlYXRlRWxlbWVudChuYW1lKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuY3JlYXRlQ29tbWVudCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAodmFsdWUsIGRlYnVnSW5mbykgeyByZXR1cm4gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuY3JlYXRlQ29tbWVudCh2YWx1ZSk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAodmFsdWUsIGRlYnVnSW5mbykgeyByZXR1cm4gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuY3JlYXRlVGV4dE5vZGUodmFsdWUpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxyXG4gICAgICogQHBhcmFtIHs/fSBuZXdDaGlsZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XHJcbiAgICAgKiBAcGFyYW0gez99IG5ld0NoaWxkXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAocGFyZW50LCBuZXdDaGlsZCkgeyBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5hcHBlbmRDaGlsZChwYXJlbnQsIG5ld0NoaWxkKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcclxuICAgICAqIEBwYXJhbSB7P30gbmV3Q2hpbGRcclxuICAgICAqIEBwYXJhbSB7P30gcmVmQ2hpbGRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcclxuICAgICAqIEBwYXJhbSB7P30gbmV3Q2hpbGRcclxuICAgICAqIEBwYXJhbSB7P30gcmVmQ2hpbGRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChwYXJlbnQsIG5ld0NoaWxkLCByZWZDaGlsZCkge1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuaW5zZXJ0QmVmb3JlKHBhcmVudCwgcmVmQ2hpbGQsIG5ld0NoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxyXG4gICAgICogQHBhcmFtIHs/fSBvbGRDaGlsZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XHJcbiAgICAgKiBAcGFyYW0gez99IG9sZENoaWxkXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAocGFyZW50LCBvbGRDaGlsZCkge1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkucmVtb3ZlQ2hpbGQocGFyZW50LCBvbGRDaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3Rvck9yTm9kZVxyXG4gICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5zZWxlY3RSb290RWxlbWVudCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3Rvck9yTm9kZVxyXG4gICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoc2VsZWN0b3JPck5vZGUsIGRlYnVnSW5mbykge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3JPck5vZGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGVsID0gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkucXVlcnlTZWxlY3Rvcih0aGlzLmRvY3VtZW50LCBzZWxlY3Rvck9yTm9kZSk7XHJcbiAgICAgICAgICAgIGlmICghZWwpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzZWxlY3RvciBcXFwiXCIgKyBzZWxlY3Rvck9yTm9kZSArIFwiXFxcIiBkaWQgbm90IG1hdGNoIGFueSBlbGVtZW50c1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwgPSBzZWxlY3Rvck9yTm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuY2xlYXJOb2RlcyhlbCk7XHJcbiAgICAgICAgcmV0dXJuIGVsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBub2RlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5wYXJlbnROb2RlID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5wYXJlbnRFbGVtZW50KG5vZGUpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLm5leHRTaWJsaW5nID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5uZXh0U2libGluZyhub2RlKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbFxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gez89fSBuYW1lc3BhY2VcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbFxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gez89fSBuYW1lc3BhY2VcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsdWUsIG5hbWVzcGFjZSkge1xyXG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuc2V0QXR0cmlidXRlTlMoZWwsIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtU5BTUVTUEFDRV9VUklTW25hbWVzcGFjZV0sIG5hbWVzcGFjZSArICc6JyArIG5hbWUsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLnNldEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUsIG5hbWVzcGFjZSkge1xyXG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkucmVtb3ZlQXR0cmlidXRlTlMoZWwsIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtU5BTUVTUEFDRV9VUklTW25hbWVzcGFjZV0sIG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkucmVtb3ZlQXR0cmlidXRlKGVsLCBuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLmFkZENsYXNzID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbCwgbmFtZSkgeyBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5hZGRDbGFzcyhlbCwgbmFtZSk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsLCBuYW1lKSB7IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLnJlbW92ZUNsYXNzKGVsLCBuYW1lKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbFxyXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHs/fSBmbGFnc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuc2V0U3R5bGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxcclxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7P30gZmxhZ3NcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbCwgc3R5bGUsIHZhbHVlLCBmbGFncykge1xyXG4gICAgICAgIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLnNldFN0eWxlKGVsLCBzdHlsZSwgdmFsdWUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbFxyXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxyXG4gICAgICogQHBhcmFtIHs/fSBmbGFnc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUucmVtb3ZlU3R5bGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxcclxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVcclxuICAgICAqIEBwYXJhbSB7P30gZmxhZ3NcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbCwgc3R5bGUsIGZsYWdzKSB7XHJcbiAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkucmVtb3ZlU3R5bGUoZWwsIHN0eWxlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdGFnTmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eU5hbWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLl9pc1NhZmVUb1JlZmxlY3RQcm9wZXJ0eSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB0YWdOYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5TmFtZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BlcnR5TmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYS5zZWN1cml0eUNvbnRleHQodGFnTmFtZSwgcHJvcGVydHlOYW1lLCB0cnVlKSA9PT1cclxuICAgICAgICAgICAgdGhpcy5zY2hlbWEuc2VjdXJpdHlDb250ZXh0KHRhZ05hbWUsIHByb3BlcnR5TmFtZSwgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbFxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbFxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgY2hlY2tOb1N5bnRoZXRpY1Byb3AobmFtZSwgJ3Byb3BlcnR5Jyk7XHJcbiAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuc2V0UHJvcGVydHkoZWwsIG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAvLyBNaXJyb3IgcHJvcGVydHkgdmFsdWVzIGZvciBrbm93biBIVE1MIGVsZW1lbnQgcHJvcGVydGllcyBpbiB0aGUgYXR0cmlidXRlcy5cclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWdOYW1lID0gKC8qKiBAdHlwZSB7P30gKi8gKGVsLnRhZ05hbWUpKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykgJiZcclxuICAgICAgICAgICAgdGhpcy5zY2hlbWEuaGFzRWxlbWVudCh0YWdOYW1lLCBFTVBUWV9BUlJBWSkgJiZcclxuICAgICAgICAgICAgdGhpcy5zY2hlbWEuaGFzUHJvcGVydHkodGFnTmFtZSwgbmFtZSwgRU1QVFlfQVJSQVkpICYmXHJcbiAgICAgICAgICAgIHRoaXMuX2lzU2FmZVRvUmVmbGVjdFByb3BlcnR5KHRhZ05hbWUsIG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGVsLCBuYW1lLCB2YWx1ZS50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLnNldFZhbHVlID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkgeyBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5zZXRUZXh0KG5vZGUsIHZhbHVlKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSB7P30gZXZlbnROYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5saXN0ZW4gPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50TmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gTm90ZTogV2UgYXJlIG5vdCB1c2luZyB0aGUgRXZlbnRzUGx1Z2luIGhlcmUgYXMgdGhpcyBpcyBub3QgbmVlZGVkXHJcbiAgICAgICAgLy8gdG8gcnVuIG91ciB0ZXN0cy5cclxuICAgICAgICBjaGVja05vU3ludGhldGljUHJvcChldmVudE5hbWUsICdsaXN0ZW5lcicpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsID0gdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5nZXRHbG9iYWxFdmVudFRhcmdldCh0aGlzLmRvY3VtZW50LCB0YXJnZXQpIDogdGFyZ2V0O1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHNpZGVIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5uZ1pvbmUucnVuR3VhcmRlZChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhldmVudCk7IH0pOyB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiAoX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkub25BbmRDYW5jZWwoZWwsIGV2ZW50TmFtZSwgb3V0c2lkZUhhbmRsZXIpKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjI7XHJcbn0oKSk7XHJcbnZhciBBVF9DSEFSQ09ERSA9ICdAJy5jaGFyQ29kZUF0KDApO1xyXG4vKipcclxuICogQHBhcmFtIHs/fSBuYW1lXHJcbiAqIEBwYXJhbSB7P30gbmFtZUtpbmRcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGNoZWNrTm9TeW50aGV0aWNQcm9wKG5hbWUsIG5hbWVLaW5kKSB7XHJcbiAgICBpZiAobmFtZS5jaGFyQ29kZUF0KDApID09PSBBVF9DSEFSQ09ERSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvdW5kIHRoZSBzeW50aGV0aWMgXCIgKyBuYW1lS2luZCArIFwiIFwiICsgbmFtZSArIFwiLiBQbGVhc2UgaW5jbHVkZSBlaXRoZXIgXFxcIkJyb3dzZXJBbmltYXRpb25zTW9kdWxlXFxcIiBvciBcXFwiTm9vcEFuaW1hdGlvbnNNb2R1bGVcXFwiIGluIHlvdXIgYXBwbGljYXRpb24uXCIpO1xyXG4gICAgfVxyXG59XHJcbnZhciBFbXVsYXRlZEVuY2Fwc3VsYXRpb25TZXJ2ZXJSZW5kZXJlcjIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRW11bGF0ZWRFbmNhcHN1bGF0aW9uU2VydmVyUmVuZGVyZXIyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRW11bGF0ZWRFbmNhcHN1bGF0aW9uU2VydmVyUmVuZGVyZXIyKGRvY3VtZW50LCBuZ1pvbmUsIHNoYXJlZFN0eWxlc0hvc3QsIHNjaGVtYSwgY29tcG9uZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIG5nWm9uZSwgc2NoZW1hKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVmbGF0dGVuU3R5bGVzKGNvbXBvbmVudC5pZCwgY29tcG9uZW50LnN0eWxlcywgW10pO1xyXG4gICAgICAgIHNoYXJlZFN0eWxlc0hvc3QuYWRkU3R5bGVzKHN0eWxlcyk7XHJcbiAgICAgICAgX3RoaXMuY29udGVudEF0dHIgPSBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVzaGltQ29udGVudEF0dHJpYnV0ZShjb21wb25lbnQuaWQpO1xyXG4gICAgICAgIF90aGlzLmhvc3RBdHRyID0gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1c2hpbUhvc3RBdHRyaWJ1dGUoY29tcG9uZW50LmlkKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRW11bGF0ZWRFbmNhcHN1bGF0aW9uU2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5hcHBseVRvSG9zdCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWxlbWVudCkgeyBfc3VwZXIucHJvdG90eXBlLnNldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIGVsZW1lbnQsIHRoaXMuaG9zdEF0dHIsICcnKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgRW11bGF0ZWRFbmNhcHN1bGF0aW9uU2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAocGFyZW50LCBuYW1lKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWwgPSBfc3VwZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLCBwYXJlbnQsIG5hbWUpO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2V0QXR0cmlidXRlLmNhbGwodGhpcywgZWwsIHRoaXMuY29udGVudEF0dHIsICcnKTtcclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEVtdWxhdGVkRW5jYXBzdWxhdGlvblNlcnZlclJlbmRlcmVyMjtcclxufShEZWZhdWx0U2VydmVyUmVuZGVyZXIyKSk7XHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxudmFyIFNlcnZlclN0eWxlc0hvc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2VydmVyU3R5bGVzSG9zdCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNlcnZlclN0eWxlc0hvc3QoZG9jLCB0cmFuc2l0aW9uSWQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmRvYyA9IGRvYztcclxuICAgICAgICBfdGhpcy50cmFuc2l0aW9uSWQgPSB0cmFuc2l0aW9uSWQ7XHJcbiAgICAgICAgX3RoaXMuaGVhZCA9IG51bGw7XHJcbiAgICAgICAgX3RoaXMuaGVhZCA9IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmdldEVsZW1lbnRzQnlUYWdOYW1lKGRvYywgJ2hlYWQnKVswXTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFNlcnZlclN0eWxlc0hvc3QucHJvdG90eXBlLl9hZGRTdHlsZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWRhcHRlciA9IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsID0gYWRhcHRlci5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG4gICAgICAgIGFkYXB0ZXIuc2V0VGV4dChlbCwgc3R5bGUpO1xyXG4gICAgICAgIGlmICghIXRoaXMudHJhbnNpdGlvbklkKSB7XHJcbiAgICAgICAgICAgIGFkYXB0ZXIuc2V0QXR0cmlidXRlKGVsLCAnbmctdHJhbnNpdGlvbicsIHRoaXMudHJhbnNpdGlvbklkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWRhcHRlci5hcHBlbmRDaGlsZCh0aGlzLmhlYWQsIGVsKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYWRkaXRpb25zXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBTZXJ2ZXJTdHlsZXNIb3N0LnByb3RvdHlwZS5vblN0eWxlc0FkZGVkID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGFkZGl0aW9uc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGFkZGl0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgYWRkaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7IHJldHVybiBfdGhpcy5fYWRkU3R5bGUoc3R5bGUpOyB9KTtcclxuICAgIH07XHJcbiAgICBTZXJ2ZXJTdHlsZXNIb3N0LmRlY29yYXRvcnMgPSBbXHJcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcclxuICAgIF07XHJcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cclxuICAgIFNlcnZlclN0eWxlc0hvc3QuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXHJcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkRPQ1VNRU5ULF0gfSxdIH0sXHJcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtVRSQU5TSVRJT05fSUQsXSB9LF0gfSxcclxuICAgIF07IH07XHJcbiAgICByZXR1cm4gU2VydmVyU3R5bGVzSG9zdDtcclxufShfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVTaGFyZWRTdHlsZXNIb3N0KSk7XHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxudmFyIElOVEVSTkFMX1NFUlZFUl9QTEFURk9STV9QUk9WSURFUlMgPSBbXHJcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5ET0NVTUVOVCwgdXNlRmFjdG9yeTogX2RvY3VtZW50LCBkZXBzOiBbX2FuZ3VsYXJfY29yZS5JbmplY3Rvcl0gfSxcclxuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5QTEFURk9STV9JRCwgdXNlVmFsdWU6IF9hbmd1bGFyX2NvbW1vbi7JtVBMQVRGT1JNX1NFUlZFUl9JRCB9LFxyXG4gICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLlBMQVRGT1JNX0lOSVRJQUxJWkVSLCB1c2VGYWN0b3J5OiBpbml0RG9taW5vQWRhcHRlciwgbXVsdGk6IHRydWUsIGRlcHM6IFtfYW5ndWxhcl9jb3JlLkluamVjdG9yXSB9LCB7XHJcbiAgICAgICAgcHJvdmlkZTogX2FuZ3VsYXJfY29tbW9uLlBsYXRmb3JtTG9jYXRpb24sXHJcbiAgICAgICAgdXNlQ2xhc3M6IFNlcnZlclBsYXRmb3JtTG9jYXRpb24sXHJcbiAgICAgICAgZGVwczogW19hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5ET0NVTUVOVCwgW19hbmd1bGFyX2NvcmUuT3B0aW9uYWwsIElOSVRJQUxfQ09ORklHXV1cclxuICAgIH0sXHJcbiAgICB7IHByb3ZpZGU6IFBsYXRmb3JtU3RhdGUsIGRlcHM6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuRE9DVU1FTlRdIH0sXHJcbiAgICAvLyBBZGQgc3BlY2lhbCBwcm92aWRlciB0aGF0IGFsbG93cyBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgcGxhdGZvcm1TZXJ2ZXIqIHRvIGJlIGNyZWF0ZWQuXHJcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuybVBTExPV19NVUxUSVBMRV9QTEFURk9STVMsIHVzZVZhbHVlOiB0cnVlIH1cclxuXTtcclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gaW5qZWN0b3JcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGluaXREb21pbm9BZGFwdGVyKGluamVjdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBEb21pbm9BZGFwdGVyLm1ha2VDdXJyZW50KCk7IH07XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gcmVuZGVyZXJcclxuICogQHBhcmFtIHs/fSBlbmdpbmVcclxuICogQHBhcmFtIHs/fSB6b25lXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVNlcnZlclJlbmRlcmVyRmFjdG9yeShyZW5kZXJlciwgZW5naW5lLCB6b25lKSB7XHJcbiAgICByZXR1cm4gbmV3IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlcl9hbmltYXRpb25zLsm1QW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5KHJlbmRlcmVyLCBlbmdpbmUsIHpvbmUpO1xyXG59XHJcbnZhciBTRVJWRVJfUkVOREVSX1BST1ZJREVSUyA9IFtcclxuICAgIFNlcnZlclJlbmRlcmVyRmFjdG9yeTIsXHJcbiAgICB7XHJcbiAgICAgICAgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlckZhY3RvcnkyLFxyXG4gICAgICAgIHVzZUZhY3Rvcnk6IGluc3RhbnRpYXRlU2VydmVyUmVuZGVyZXJGYWN0b3J5LFxyXG4gICAgICAgIGRlcHM6IFtTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyLCBfYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIuybVBbmltYXRpb25FbmdpbmUsIF9hbmd1bGFyX2NvcmUuTmdab25lXVxyXG4gICAgfSxcclxuICAgIFNlcnZlclN0eWxlc0hvc3QsXHJcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtVNoYXJlZFN0eWxlc0hvc3QsIHVzZUV4aXN0aW5nOiBTZXJ2ZXJTdHlsZXNIb3N0IH0sXHJcbl07XHJcbi8qKlxyXG4gKiBUaGUgbmcgbW9kdWxlIGZvciB0aGUgc2VydmVyLlxyXG4gKlxyXG4gKiBcXEBleHBlcmltZW50YWxcclxuICovXHJcbnZhciBTZXJ2ZXJNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZXJ2ZXJNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBTZXJ2ZXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcclxuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUsIGFyZ3M6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW19hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5Ccm93c2VyTW9kdWxlXSxcclxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbX2FuZ3VsYXJfaHR0cC5IdHRwTW9kdWxlLCBfYW5ndWxhcl9jb21tb25faHR0cC5IdHRwQ2xpZW50TW9kdWxlLCBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXJfYW5pbWF0aW9ucy5Ob29wQW5pbWF0aW9uc01vZHVsZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNFUlZFUl9SRU5ERVJfUFJPVklERVJTLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBTRVJWRVJfSFRUUF9QUk9WSURFUlMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5UZXN0YWJpbGl0eSwgdXNlVmFsdWU6IG51bGwgfSxcclxuICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgfSxdIH0sXHJcbiAgICBdO1xyXG4gICAgLyoqIEBub2NvbGxhcHNlICovXHJcbiAgICBTZXJ2ZXJNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcclxuICAgIHJldHVybiBTZXJ2ZXJNb2R1bGU7XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IGluamVjdG9yXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBfZG9jdW1lbnQoaW5qZWN0b3IpIHtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbmZpZyA9IGluamVjdG9yLmdldChJTklUSUFMX0NPTkZJRywgbnVsbCk7XHJcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5kb2N1bWVudCkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZURvY3VtZW50KGNvbmZpZy5kb2N1bWVudCwgY29uZmlnLnVybCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuY3JlYXRlSHRtbERvY3VtZW50KCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFxcQGV4cGVyaW1lbnRhbFxyXG4gKi9cclxudmFyIHBsYXRmb3JtU2VydmVyID0gX2FuZ3VsYXJfY29yZS5jcmVhdGVQbGF0Zm9ybUZhY3RvcnkoX2FuZ3VsYXJfY29yZS5wbGF0Zm9ybUNvcmUsICdzZXJ2ZXInLCBJTlRFUk5BTF9TRVJWRVJfUExBVEZPUk1fUFJPVklERVJTKTtcclxuLyoqXHJcbiAqIFRoZSBzZXJ2ZXIgcGxhdGZvcm0gdGhhdCBzdXBwb3J0cyB0aGUgcnVudGltZSBjb21waWxlci5cclxuICpcclxuICogXFxAZXhwZXJpbWVudGFsXHJcbiAqL1xyXG52YXIgcGxhdGZvcm1EeW5hbWljU2VydmVyID0gX2FuZ3VsYXJfY29yZS5jcmVhdGVQbGF0Zm9ybUZhY3RvcnkoX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyRHluYW1pYy7JtXBsYXRmb3JtQ29yZUR5bmFtaWMsICdzZXJ2ZXJEeW5hbWljJywgSU5URVJOQUxfU0VSVkVSX1BMQVRGT1JNX1BST1ZJREVSUyk7XHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gZG9jXHJcbiAqIEBwYXJhbSB7P30gYXBwSWRcclxuICogQHBhcmFtIHs/fSB0cmFuc2ZlclN0b3JlXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBzZXJpYWxpemVUcmFuc2ZlclN0YXRlRmFjdG9yeShkb2MsIGFwcElkLCB0cmFuc2ZlclN0b3JlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuICAgICAgICBzY3JpcHQuaWQgPSBhcHBJZCArICctc3RhdGUnO1xyXG4gICAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xyXG4gICAgICAgIHNjcmlwdC50ZXh0Q29udGVudCA9IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWVzY2FwZUh0bWwodHJhbnNmZXJTdG9yZS50b0pzb24oKSk7XHJcbiAgICAgICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIE5nTW9kdWxlIHRvIGluc3RhbGwgb24gdGhlIHNlcnZlciBzaWRlIHdoaWxlIHVzaW5nIHRoZSBgVHJhbnNmZXJTdGF0ZWAgdG8gdHJhbnNmZXIgc3RhdGUgZnJvbVxyXG4gKiBzZXJ2ZXIgdG8gY2xpZW50LlxyXG4gKlxyXG4gKiBcXEBleHBlcmltZW50YWxcclxuICovXHJcbnZhciBTZXJ2ZXJUcmFuc2ZlclN0YXRlTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2VydmVyVHJhbnNmZXJTdGF0ZU1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIFNlcnZlclRyYW5zZmVyU3RhdGVNb2R1bGUuZGVjb3JhdG9ycyA9IFtcclxuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUsIGFyZ3M6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5UcmFuc2ZlclN0YXRlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBCRUZPUkVfQVBQX1NFUklBTElaRUQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBzZXJpYWxpemVUcmFuc2ZlclN0YXRlRmFjdG9yeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHM6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuRE9DVU1FTlQsIF9hbmd1bGFyX2NvcmUuQVBQX0lELCBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuVHJhbnNmZXJTdGF0ZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgIH0sXSB9LFxyXG4gICAgXTtcclxuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xyXG4gICAgU2VydmVyVHJhbnNmZXJTdGF0ZU1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xyXG4gICAgcmV0dXJuIFNlcnZlclRyYW5zZmVyU3RhdGVNb2R1bGU7XHJcbn0oKSk7XHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gcGxhdGZvcm1GYWN0b3J5XHJcbiAqIEBwYXJhbSB7P30gb3B0aW9uc1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gX2dldFBsYXRmb3JtKHBsYXRmb3JtRmFjdG9yeSwgb3B0aW9ucykge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXh0cmFQcm92aWRlcnMgPSBvcHRpb25zLmV4dHJhUHJvdmlkZXJzID8gb3B0aW9ucy5leHRyYVByb3ZpZGVycyA6IFtdO1xyXG4gICAgcmV0dXJuIHBsYXRmb3JtRmFjdG9yeShbXHJcbiAgICAgICAgeyBwcm92aWRlOiBJTklUSUFMX0NPTkZJRywgdXNlVmFsdWU6IHsgZG9jdW1lbnQ6IG9wdGlvbnMuZG9jdW1lbnQsIHVybDogb3B0aW9ucy51cmwgfSB9LFxyXG4gICAgICAgIGV4dHJhUHJvdmlkZXJzXHJcbiAgICBdKTtcclxufVxyXG4vKipcclxuICogQHRlbXBsYXRlIFRcclxuICogQHBhcmFtIHs/fSBwbGF0Zm9ybVxyXG4gKiBAcGFyYW0gez99IG1vZHVsZVJlZlByb21pc2VcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIF9yZW5kZXIocGxhdGZvcm0sIG1vZHVsZVJlZlByb21pc2UpIHtcclxuICAgIHJldHVybiBtb2R1bGVSZWZQcm9taXNlLnRoZW4oZnVuY3Rpb24gKG1vZHVsZVJlZikge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zaXRpb25JZCA9IG1vZHVsZVJlZi5pbmplY3Rvci5nZXQoX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1VFJBTlNJVElPTl9JRCwgbnVsbCk7XHJcbiAgICAgICAgaWYgKCF0cmFuc2l0aW9uSWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVuZGVyTW9kdWxlW0ZhY3RvcnldKCkgcmVxdWlyZXMgdGhlIHVzZSBvZiBCcm93c2VyTW9kdWxlLndpdGhTZXJ2ZXJUcmFuc2l0aW9uKCkgdG8gZW5zdXJlXFxudGhlIHNlcnZlci1yZW5kZXJlZCBhcHAgY2FuIGJlIHByb3Blcmx5IGJvb3RzdHJhcHBlZCBpbnRvIGEgY2xpZW50IGFwcC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFwcGxpY2F0aW9uUmVmID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChfYW5ndWxhcl9jb3JlLkFwcGxpY2F0aW9uUmVmKTtcclxuICAgICAgICByZXR1cm4gcnhqc19vcGVyYXRvcl90b1Byb21pc2UudG9Qcm9taXNlXHJcbiAgICAgICAgICAgIC5jYWxsKHJ4anNfb3BlcmF0b3JfZmlyc3QuZmlyc3QuY2FsbChyeGpzX29wZXJhdG9yX2ZpbHRlci5maWx0ZXIuY2FsbChhcHBsaWNhdGlvblJlZi5pc1N0YWJsZSwgZnVuY3Rpb24gKGlzU3RhYmxlKSB7IHJldHVybiBpc1N0YWJsZTsgfSkpKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXRmb3JtU3RhdGUgPSBwbGF0Zm9ybS5pbmplY3Rvci5nZXQoUGxhdGZvcm1TdGF0ZSk7XHJcbiAgICAgICAgICAgIC8vIFJ1biBhbnkgQkVGT1JFX0FQUF9TRVJJQUxJWkVEIGNhbGxiYWNrcyBqdXN0IGJlZm9yZSByZW5kZXJpbmcgdG8gc3RyaW5nLlxyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYWxsYmFja3MgPSBtb2R1bGVSZWYuaW5qZWN0b3IuZ2V0KEJFRk9SRV9BUFBfU0VSSUFMSVpFRCwgbnVsbCk7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY2FsbGJhY2tzXzEgPSBjYWxsYmFja3M7IF9pIDwgY2FsbGJhY2tzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoICgvKiogQHR5cGUgez99ICovIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGV4Y2VwdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignSWdub3JpbmcgQkVGT1JFX0FQUF9TRVJJQUxJWkVEIEV4Y2VwdGlvbjogJywgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHB1dCA9IHBsYXRmb3JtU3RhdGUucmVuZGVyVG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgcGxhdGZvcm0uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbmRlcnMgYSBNb2R1bGUgdG8gc3RyaW5nLlxyXG4gKlxyXG4gKiBgZG9jdW1lbnRgIGlzIHRoZSBmdWxsIGRvY3VtZW50IEhUTUwgb2YgdGhlIHBhZ2UgdG8gcmVuZGVyLCBhcyBhIHN0cmluZy5cclxuICogYHVybGAgaXMgdGhlIFVSTCBmb3IgdGhlIGN1cnJlbnQgcmVuZGVyIHJlcXVlc3QuXHJcbiAqIGBleHRyYVByb3ZpZGVyc2AgYXJlIHRoZSBwbGF0Zm9ybSBsZXZlbCBwcm92aWRlcnMgZm9yIHRoZSBjdXJyZW50IHJlbmRlciByZXF1ZXN0LlxyXG4gKlxyXG4gKiBEbyBub3QgdXNlIHRoaXMgaW4gYSBwcm9kdWN0aW9uIHNlcnZlciBlbnZpcm9ubWVudC4gVXNlIHByZS1jb21waWxlZCB7XFxAbGluayBOZ01vZHVsZUZhY3Rvcnl9IHdpdGhcclxuICoge1xcQGxpbmsgcmVuZGVyTW9kdWxlRmFjdG9yeX0gaW5zdGVhZC5cclxuICpcclxuICogXFxAZXhwZXJpbWVudGFsXHJcbiAqIEB0ZW1wbGF0ZSBUXHJcbiAqIEBwYXJhbSB7P30gbW9kdWxlXHJcbiAqIEBwYXJhbSB7P30gb3B0aW9uc1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyTW9kdWxlKG1vZHVsZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxhdGZvcm0gPSBfZ2V0UGxhdGZvcm0ocGxhdGZvcm1EeW5hbWljU2VydmVyLCBvcHRpb25zKTtcclxuICAgIHJldHVybiBfcmVuZGVyKHBsYXRmb3JtLCBwbGF0Zm9ybS5ib290c3RyYXBNb2R1bGUobW9kdWxlKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbmRlcnMgYSB7XFxAbGluayBOZ01vZHVsZUZhY3Rvcnl9IHRvIHN0cmluZy5cclxuICpcclxuICogYGRvY3VtZW50YCBpcyB0aGUgZnVsbCBkb2N1bWVudCBIVE1MIG9mIHRoZSBwYWdlIHRvIHJlbmRlciwgYXMgYSBzdHJpbmcuXHJcbiAqIGB1cmxgIGlzIHRoZSBVUkwgZm9yIHRoZSBjdXJyZW50IHJlbmRlciByZXF1ZXN0LlxyXG4gKiBgZXh0cmFQcm92aWRlcnNgIGFyZSB0aGUgcGxhdGZvcm0gbGV2ZWwgcHJvdmlkZXJzIGZvciB0aGUgY3VycmVudCByZW5kZXIgcmVxdWVzdC5cclxuICpcclxuICogXFxAZXhwZXJpbWVudGFsXHJcbiAqIEB0ZW1wbGF0ZSBUXHJcbiAqIEBwYXJhbSB7P30gbW9kdWxlRmFjdG9yeVxyXG4gKiBAcGFyYW0gez99IG9wdGlvbnNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIHJlbmRlck1vZHVsZUZhY3RvcnkobW9kdWxlRmFjdG9yeSwgb3B0aW9ucykge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxhdGZvcm0gPSBfZ2V0UGxhdGZvcm0ocGxhdGZvcm1TZXJ2ZXIsIG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIF9yZW5kZXIocGxhdGZvcm0sIHBsYXRmb3JtLmJvb3RzdHJhcE1vZHVsZUZhY3RvcnkobW9kdWxlRmFjdG9yeSkpO1xyXG59XHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogXFxAc3RhYmxlXHJcbiAqL1xyXG52YXIgVkVSU0lPTiA9IG5ldyBfYW5ndWxhcl9jb3JlLlZlcnNpb24oJzUuMi4yJyk7XHJcblxyXG5leHBvcnRzLlBsYXRmb3JtU3RhdGUgPSBQbGF0Zm9ybVN0YXRlO1xyXG5leHBvcnRzLlNlcnZlck1vZHVsZSA9IFNlcnZlck1vZHVsZTtcclxuZXhwb3J0cy5wbGF0Zm9ybUR5bmFtaWNTZXJ2ZXIgPSBwbGF0Zm9ybUR5bmFtaWNTZXJ2ZXI7XHJcbmV4cG9ydHMucGxhdGZvcm1TZXJ2ZXIgPSBwbGF0Zm9ybVNlcnZlcjtcclxuZXhwb3J0cy5CRUZPUkVfQVBQX1NFUklBTElaRUQgPSBCRUZPUkVfQVBQX1NFUklBTElaRUQ7XHJcbmV4cG9ydHMuSU5JVElBTF9DT05GSUcgPSBJTklUSUFMX0NPTkZJRztcclxuZXhwb3J0cy5TZXJ2ZXJUcmFuc2ZlclN0YXRlTW9kdWxlID0gU2VydmVyVHJhbnNmZXJTdGF0ZU1vZHVsZTtcclxuZXhwb3J0cy5yZW5kZXJNb2R1bGUgPSByZW5kZXJNb2R1bGU7XHJcbmV4cG9ydHMucmVuZGVyTW9kdWxlRmFjdG9yeSA9IHJlbmRlck1vZHVsZUZhY3Rvcnk7XHJcbmV4cG9ydHMuVkVSU0lPTiA9IFZFUlNJT047XHJcbmV4cG9ydHMuybVJTlRFUk5BTF9TRVJWRVJfUExBVEZPUk1fUFJPVklERVJTID0gSU5URVJOQUxfU0VSVkVSX1BMQVRGT1JNX1BST1ZJREVSUztcclxuZXhwb3J0cy7JtVNFUlZFUl9SRU5ERVJfUFJPVklERVJTID0gU0VSVkVSX1JFTkRFUl9QUk9WSURFUlM7XHJcbmV4cG9ydHMuybVTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyID0gU2VydmVyUmVuZGVyZXJGYWN0b3J5MjtcclxuZXhwb3J0cy7JtWggPSBTRVJWRVJfSFRUUF9QUk9WSURFUlM7XHJcbmV4cG9ydHMuybVkID0gU2VydmVyWGhyO1xyXG5leHBvcnRzLsm1ZSA9IFNlcnZlclhzcmZTdHJhdGVneTtcclxuZXhwb3J0cy7JtWYgPSBodHRwRmFjdG9yeTtcclxuZXhwb3J0cy7JtWcgPSB6b25lV3JhcHBlZEludGVyY2VwdGluZ0hhbmRsZXI7XHJcbmV4cG9ydHMuybVhID0gaW5zdGFudGlhdGVTZXJ2ZXJSZW5kZXJlckZhY3Rvcnk7XHJcbmV4cG9ydHMuybVjID0gU2VydmVyU3R5bGVzSG9zdDtcclxuZXhwb3J0cy7JtWIgPSBzZXJpYWxpemVUcmFuc2ZlclN0YXRlRmFjdG9yeTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XHJcblxyXG59KSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGF0Zm9ybS1zZXJ2ZXIudW1kLmpzLm1hcFxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGFuZ3VsYXIvcGxhdGZvcm0tc2VydmVyL2J1bmRsZXMvcGxhdGZvcm0tc2VydmVyLnVtZC5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjUuMi4yXHJcbiAqIChjKSAyMDEwLTIwMTggR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cclxuICogTGljZW5zZTogTUlUXHJcbiAqL1xyXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvYW5pbWF0aW9ucycpKSA6XHJcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCdAYW5ndWxhci9hbmltYXRpb25zL2Jyb3dzZXInLCBbJ2V4cG9ydHMnLCAnQGFuZ3VsYXIvYW5pbWF0aW9ucyddLCBmYWN0b3J5KSA6XHJcblx0KGZhY3RvcnkoKGdsb2JhbC5uZyA9IGdsb2JhbC5uZyB8fCB7fSwgZ2xvYmFsLm5nLmFuaW1hdGlvbnMgPSBnbG9iYWwubmcuYW5pbWF0aW9ucyB8fCB7fSwgZ2xvYmFsLm5nLmFuaW1hdGlvbnMuYnJvd3NlciA9IHt9KSxnbG9iYWwubmcuYW5pbWF0aW9ucykpO1xyXG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxfYW5ndWxhcl9hbmltYXRpb25zKSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjUuMi4yXHJcbiAqIChjKSAyMDEwLTIwMTggR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cclxuICogTGljZW5zZTogTUlUXHJcbiAqL1xyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHBsYXllcnNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIG9wdGltaXplR3JvdXBQbGF5ZXIocGxheWVycykge1xyXG4gICAgc3dpdGNoIChwbGF5ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfYW5ndWxhcl9hbmltYXRpb25zLk5vb3BBbmltYXRpb25QbGF5ZXIoKTtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIHJldHVybiBwbGF5ZXJzWzBdO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfYW5pbWF0aW9ucy7JtUFuaW1hdGlvbkdyb3VwUGxheWVyKHBsYXllcnMpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IGRyaXZlclxyXG4gKiBAcGFyYW0gez99IG5vcm1hbGl6ZXJcclxuICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7P30ga2V5ZnJhbWVzXHJcbiAqIEBwYXJhbSB7Pz19IHByZVN0eWxlc1xyXG4gKiBAcGFyYW0gez89fSBwb3N0U3R5bGVzXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVLZXlmcmFtZXMoZHJpdmVyLCBub3JtYWxpemVyLCBlbGVtZW50LCBrZXlmcmFtZXMsIHByZVN0eWxlcywgcG9zdFN0eWxlcykge1xyXG4gICAgaWYgKHByZVN0eWxlcyA9PT0gdm9pZCAwKSB7IHByZVN0eWxlcyA9IHt9OyB9XHJcbiAgICBpZiAocG9zdFN0eWxlcyA9PT0gdm9pZCAwKSB7IHBvc3RTdHlsZXMgPSB7fTsgfVxyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gW107XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub3JtYWxpemVkS2V5ZnJhbWVzID0gW107XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2aW91c09mZnNldCA9IC0xO1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNLZXlmcmFtZSA9IG51bGw7XHJcbiAgICBrZXlmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoa2YpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvZmZzZXQgPSAvKiogQHR5cGUgez99ICovIChrZlsnb2Zmc2V0J10pO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzU2FtZU9mZnNldCA9IG9mZnNldCA9PSBwcmV2aW91c09mZnNldDtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub3JtYWxpemVkS2V5ZnJhbWUgPSAoaXNTYW1lT2Zmc2V0ICYmIHByZXZpb3VzS2V5ZnJhbWUpIHx8IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKGtmKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vcm1hbGl6ZWRQcm9wID0gcHJvcDtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9ybWFsaXplZFZhbHVlID0ga2ZbcHJvcF07XHJcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnb2Zmc2V0Jykge1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVyLm5vcm1hbGl6ZVByb3BlcnR5TmFtZShub3JtYWxpemVkUHJvcCwgZXJyb3JzKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAobm9ybWFsaXplZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9hbmltYXRpb25zLsm1UFJFX1NUWUxFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkVmFsdWUgPSBwcmVTdHlsZXNbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfYW5pbWF0aW9ucy5BVVRPX1NUWUxFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkVmFsdWUgPSBwb3N0U3R5bGVzW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkVmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplci5ub3JtYWxpemVTdHlsZVZhbHVlKHByb3AsIG5vcm1hbGl6ZWRQcm9wLCBub3JtYWxpemVkVmFsdWUsIGVycm9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRLZXlmcmFtZVtub3JtYWxpemVkUHJvcF0gPSBub3JtYWxpemVkVmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFpc1NhbWVPZmZzZXQpIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZEtleWZyYW1lcy5wdXNoKG5vcm1hbGl6ZWRLZXlmcmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZpb3VzS2V5ZnJhbWUgPSBub3JtYWxpemVkS2V5ZnJhbWU7XHJcbiAgICAgICAgcHJldmlvdXNPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICB9KTtcclxuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTElORV9TVEFSVCA9ICdcXG4gLSAnO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBhbmltYXRlIGR1ZSB0byB0aGUgZm9sbG93aW5nIGVycm9yczpcIiArIExJTkVfU1RBUlQgKyBlcnJvcnMuam9pbihMSU5FX1NUQVJUKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZEtleWZyYW1lcztcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSBwbGF5ZXJcclxuICogQHBhcmFtIHs/fSBldmVudE5hbWVcclxuICogQHBhcmFtIHs/fSBldmVudFxyXG4gKiBAcGFyYW0gez99IGNhbGxiYWNrXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBsaXN0ZW5PblBsYXllcihwbGF5ZXIsIGV2ZW50TmFtZSwgZXZlbnQsIGNhbGxiYWNrKSB7XHJcbiAgICBzd2l0Y2ggKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGNhc2UgJ3N0YXJ0JzpcclxuICAgICAgICAgICAgcGxheWVyLm9uU3RhcnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soZXZlbnQgJiYgY29weUFuaW1hdGlvbkV2ZW50KGV2ZW50LCAnc3RhcnQnLCBwbGF5ZXIudG90YWxUaW1lKSk7IH0pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdkb25lJzpcclxuICAgICAgICAgICAgcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhldmVudCAmJiBjb3B5QW5pbWF0aW9uRXZlbnQoZXZlbnQsICdkb25lJywgcGxheWVyLnRvdGFsVGltZSkpOyB9KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZGVzdHJveSc6XHJcbiAgICAgICAgICAgIHBsYXllci5vbkRlc3Ryb3koZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soZXZlbnQgJiYgY29weUFuaW1hdGlvbkV2ZW50KGV2ZW50LCAnZGVzdHJveScsIHBsYXllci50b3RhbFRpbWUpKTsgfSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IGVcclxuICogQHBhcmFtIHs/PX0gcGhhc2VOYW1lXHJcbiAqIEBwYXJhbSB7Pz19IHRvdGFsVGltZVxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gY29weUFuaW1hdGlvbkV2ZW50KGUsIHBoYXNlTmFtZSwgdG90YWxUaW1lKSB7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudCA9IG1ha2VBbmltYXRpb25FdmVudChlLmVsZW1lbnQsIGUudHJpZ2dlck5hbWUsIGUuZnJvbVN0YXRlLCBlLnRvU3RhdGUsIHBoYXNlTmFtZSB8fCBlLnBoYXNlTmFtZSwgdG90YWxUaW1lID09IHVuZGVmaW5lZCA/IGUudG90YWxUaW1lIDogdG90YWxUaW1lKTtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRhdGEgPSAoLyoqIEB0eXBlIHs/fSAqLyAoZSkpWydfZGF0YSddO1xyXG4gICAgaWYgKGRhdGEgIT0gbnVsbCkge1xyXG4gICAgICAgICgvKiogQHR5cGUgez99ICovIChldmVudCkpWydfZGF0YSddID0gZGF0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBldmVudDtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7P30gdHJpZ2dlck5hbWVcclxuICogQHBhcmFtIHs/fSBmcm9tU3RhdGVcclxuICogQHBhcmFtIHs/fSB0b1N0YXRlXHJcbiAqIEBwYXJhbSB7Pz19IHBoYXNlTmFtZVxyXG4gKiBAcGFyYW0gez89fSB0b3RhbFRpbWVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VBbmltYXRpb25FdmVudChlbGVtZW50LCB0cmlnZ2VyTmFtZSwgZnJvbVN0YXRlLCB0b1N0YXRlLCBwaGFzZU5hbWUsIHRvdGFsVGltZSkge1xyXG4gICAgaWYgKHBoYXNlTmFtZSA9PT0gdm9pZCAwKSB7IHBoYXNlTmFtZSA9ICcnOyB9XHJcbiAgICBpZiAodG90YWxUaW1lID09PSB2b2lkIDApIHsgdG90YWxUaW1lID0gMDsgfVxyXG4gICAgcmV0dXJuIHsgZWxlbWVudDogZWxlbWVudCwgdHJpZ2dlck5hbWU6IHRyaWdnZXJOYW1lLCBmcm9tU3RhdGU6IGZyb21TdGF0ZSwgdG9TdGF0ZTogdG9TdGF0ZSwgcGhhc2VOYW1lOiBwaGFzZU5hbWUsIHRvdGFsVGltZTogdG90YWxUaW1lIH07XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gbWFwXHJcbiAqIEBwYXJhbSB7P30ga2V5XHJcbiAqIEBwYXJhbSB7P30gZGVmYXVsdFZhbHVlXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRPclNldEFzSW5NYXAobWFwLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWU7XHJcbiAgICBpZiAobWFwIGluc3RhbmNlb2YgTWFwKSB7XHJcbiAgICAgICAgdmFsdWUgPSBtYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUgPSBkZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbHVlID0gbWFwW2tleV07XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IG1hcFtrZXldID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSBjb21tYW5kXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVRpbWVsaW5lQ29tbWFuZChjb21tYW5kKSB7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZXBhcmF0b3JQb3MgPSBjb21tYW5kLmluZGV4T2YoJzonKTtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkID0gY29tbWFuZC5zdWJzdHJpbmcoMSwgc2VwYXJhdG9yUG9zKTtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGFjdGlvbiA9IGNvbW1hbmQuc3Vic3RyKHNlcGFyYXRvclBvcyArIDEpO1xyXG4gICAgcmV0dXJuIFtpZCwgYWN0aW9uXTtcclxufVxyXG52YXIgX2NvbnRhaW5zID0gZnVuY3Rpb24gKGVsbTEsIGVsbTIpIHsgcmV0dXJuIGZhbHNlOyB9O1xyXG52YXIgX21hdGNoZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxudmFyIF9xdWVyeSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvciwgbXVsdGkpIHtcclxuICAgIHJldHVybiBbXTtcclxufTtcclxuaWYgKHR5cGVvZiBFbGVtZW50ICE9ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyB0aGlzIGlzIHdlbGwgc3VwcG9ydGVkIGluIGFsbCBicm93c2Vyc1xyXG4gICAgX2NvbnRhaW5zID0gZnVuY3Rpb24gKGVsbTEsIGVsbTIpIHsgcmV0dXJuIC8qKiBAdHlwZSB7P30gKi8gKGVsbTEuY29udGFpbnMoZWxtMikpOyB9O1xyXG4gICAgaWYgKEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMpIHtcclxuICAgICAgICBfbWF0Y2hlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvcikgeyByZXR1cm4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKTsgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3RvID0gLyoqIEB0eXBlIHs/fSAqLyAoRWxlbWVudC5wcm90b3R5cGUpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZuXzEgPSBwcm90by5tYXRjaGVzU2VsZWN0b3IgfHwgcHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8IHByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XHJcbiAgICAgICAgICAgIHByb3RvLm9NYXRjaGVzU2VsZWN0b3IgfHwgcHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xyXG4gICAgICAgIGlmIChmbl8xKSB7XHJcbiAgICAgICAgICAgIF9tYXRjaGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yKSB7IHJldHVybiBmbl8xLmFwcGx5KGVsZW1lbnQsIFtzZWxlY3Rvcl0pOyB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9xdWVyeSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvciwgbXVsdGkpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHRzID0gW107XHJcbiAgICAgICAgaWYgKG11bHRpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaC5hcHBseShyZXN1bHRzLCBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsbSA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIGlmIChlbG0pIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbG0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSBwcm9wXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBjb250YWluc1ZlbmRvclByZWZpeChwcm9wKSB7XHJcbiAgICAvLyBXZWJraXQgaXMgdGhlIG9ubHkgcmVhbCBwb3B1bGFyIHZlbmRvciBwcmVmaXggbm93YWRheXNcclxuICAgIC8vIGNjOiBodHRwOi8vc2hvdWxkaXByZWZpeC5jb20vXHJcbiAgICByZXR1cm4gcHJvcC5zdWJzdHJpbmcoMSwgNikgPT0gJ2Via2l0JzsgLy8gd2Via2l0IG9yIFdlYmtpdFxyXG59XHJcbnZhciBfQ0FDSEVEX0JPRFkgPSBudWxsO1xyXG52YXIgX0lTX1dFQktJVCA9IGZhbHNlO1xyXG4vKipcclxuICogQHBhcmFtIHs/fSBwcm9wXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZVN0eWxlUHJvcGVydHkocHJvcCkge1xyXG4gICAgaWYgKCFfQ0FDSEVEX0JPRFkpIHtcclxuICAgICAgICBfQ0FDSEVEX0JPRFkgPSBnZXRCb2R5Tm9kZSgpIHx8IHt9O1xyXG4gICAgICAgIF9JU19XRUJLSVQgPSAvKiogQHR5cGUgez99ICovICgoX0NBQ0hFRF9CT0RZKSkuc3R5bGUgPyAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIC8qKiBAdHlwZSB7P30gKi8gKChfQ0FDSEVEX0JPRFkpKS5zdHlsZSkgOiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRydWU7XHJcbiAgICBpZiAoLyoqIEB0eXBlIHs/fSAqLyAoKF9DQUNIRURfQk9EWSkpLnN0eWxlICYmICFjb250YWluc1ZlbmRvclByZWZpeChwcm9wKSkge1xyXG4gICAgICAgIHJlc3VsdCA9IHByb3AgaW4gLyoqIEB0eXBlIHs/fSAqLyAoKF9DQUNIRURfQk9EWSkpLnN0eWxlO1xyXG4gICAgICAgIGlmICghcmVzdWx0ICYmIF9JU19XRUJLSVQpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FtZWxQcm9wID0gJ1dlYmtpdCcgKyBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zdWJzdHIoMSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGNhbWVsUHJvcCBpbiAvKiogQHR5cGUgez99ICovICgoX0NBQ0hFRF9CT0RZKSkuc3R5bGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGdldEJvZHlOb2RlKCkge1xyXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxudmFyIG1hdGNoZXNFbGVtZW50ID0gX21hdGNoZXM7XHJcbnZhciBjb250YWluc0VsZW1lbnQgPSBfY29udGFpbnM7XHJcbnZhciBpbnZva2VRdWVyeSA9IF9xdWVyeTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxuLyoqXHJcbiAqIFxcQGV4cGVyaW1lbnRhbFxyXG4gKi9cclxudmFyIE5vb3BBbmltYXRpb25Ecml2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb29wQW5pbWF0aW9uRHJpdmVyKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHByb3BcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5vb3BBbmltYXRpb25Ecml2ZXIucHJvdG90eXBlLnZhbGlkYXRlU3R5bGVQcm9wZXJ0eSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBwcm9wXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gdmFsaWRhdGVTdHlsZVByb3BlcnR5KHByb3ApOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIE5vb3BBbmltYXRpb25Ecml2ZXIucHJvdG90eXBlLm1hdGNoZXNFbGVtZW50ID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiBtYXRjaGVzRWxlbWVudChlbGVtZW50LCBzZWxlY3Rvcik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsbTFcclxuICAgICAqIEBwYXJhbSB7P30gZWxtMlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTm9vcEFuaW1hdGlvbkRyaXZlci5wcm90b3R5cGUuY29udGFpbnNFbGVtZW50ID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsbTFcclxuICAgICAqIEBwYXJhbSB7P30gZWxtMlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsbTEsIGVsbTIpIHsgcmV0dXJuIGNvbnRhaW5zRWxlbWVudChlbG0xLCBlbG0yKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXHJcbiAgICAgKiBAcGFyYW0gez99IG11bHRpXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOb29wQW5pbWF0aW9uRHJpdmVyLnByb3RvdHlwZS5xdWVyeSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXHJcbiAgICAgKiBAcGFyYW0gez99IG11bHRpXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IsIG11bHRpKSB7XHJcbiAgICAgICAgcmV0dXJuIGludm9rZVF1ZXJ5KGVsZW1lbnQsIHNlbGVjdG9yLCBtdWx0aSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gcHJvcFxyXG4gICAgICogQHBhcmFtIHs/PX0gZGVmYXVsdFZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOb29wQW5pbWF0aW9uRHJpdmVyLnByb3RvdHlwZS5jb21wdXRlU3R5bGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBwcm9wXHJcbiAgICAgKiBAcGFyYW0gez89fSBkZWZhdWx0VmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8ICcnO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGtleWZyYW1lc1xyXG4gICAgICogQHBhcmFtIHs/fSBkdXJhdGlvblxyXG4gICAgICogQHBhcmFtIHs/fSBkZWxheVxyXG4gICAgICogQHBhcmFtIHs/fSBlYXNpbmdcclxuICAgICAqIEBwYXJhbSB7Pz19IHByZXZpb3VzUGxheWVyc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTm9vcEFuaW1hdGlvbkRyaXZlci5wcm90b3R5cGUuYW5pbWF0ZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGtleWZyYW1lc1xyXG4gICAgICogQHBhcmFtIHs/fSBkdXJhdGlvblxyXG4gICAgICogQHBhcmFtIHs/fSBkZWxheVxyXG4gICAgICogQHBhcmFtIHs/fSBlYXNpbmdcclxuICAgICAqIEBwYXJhbSB7Pz19IHByZXZpb3VzUGxheWVyc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIHByZXZpb3VzUGxheWVycykge1xyXG4gICAgICAgIGlmIChwcmV2aW91c1BsYXllcnMgPT09IHZvaWQgMCkgeyBwcmV2aW91c1BsYXllcnMgPSBbXTsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfYW5pbWF0aW9ucy5Ob29wQW5pbWF0aW9uUGxheWVyKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5vb3BBbmltYXRpb25Ecml2ZXI7XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBcXEBleHBlcmltZW50YWxcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG52YXIgQW5pbWF0aW9uRHJpdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uRHJpdmVyKCkge1xyXG4gICAgfVxyXG4gICAgQW5pbWF0aW9uRHJpdmVyLk5PT1AgPSBuZXcgTm9vcEFuaW1hdGlvbkRyaXZlcigpO1xyXG4gICAgcmV0dXJuIEFuaW1hdGlvbkRyaXZlcjtcclxufSgpKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxudmFyIE9ORV9TRUNPTkQgPSAxMDAwO1xyXG52YXIgU1VCU1RJVFVUSU9OX0VYUFJfU1RBUlQgPSAne3snO1xyXG52YXIgU1VCU1RJVFVUSU9OX0VYUFJfRU5EID0gJ319JztcclxudmFyIEVOVEVSX0NMQVNTTkFNRSA9ICduZy1lbnRlcic7XHJcbnZhciBMRUFWRV9DTEFTU05BTUUgPSAnbmctbGVhdmUnO1xyXG5cclxuXHJcbnZhciBOR19UUklHR0VSX0NMQVNTTkFNRSA9ICduZy10cmlnZ2VyJztcclxudmFyIE5HX1RSSUdHRVJfU0VMRUNUT1IgPSAnLm5nLXRyaWdnZXInO1xyXG52YXIgTkdfQU5JTUFUSU5HX0NMQVNTTkFNRSA9ICduZy1hbmltYXRpbmcnO1xyXG52YXIgTkdfQU5JTUFUSU5HX1NFTEVDVE9SID0gJy5uZy1hbmltYXRpbmcnO1xyXG4vKipcclxuICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZVRpbWluZ1ZhbHVlKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoZXMgPSAoLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpKS5tYXRjaCgvXigtP1tcXC5cXGRdKykobT9zKS8pO1xyXG4gICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoIDwgMilcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHJldHVybiBfY29udmVydFRpbWVWYWx1ZVRvTVMocGFyc2VGbG9hdChtYXRjaGVzWzFdKSwgbWF0Y2hlc1syXSk7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gdmFsdWVcclxuICogQHBhcmFtIHs/fSB1bml0XHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBfY29udmVydFRpbWVWYWx1ZVRvTVModmFsdWUsIHVuaXQpIHtcclxuICAgIHN3aXRjaCAodW5pdCkge1xyXG4gICAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgKiBPTkVfU0VDT05EO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIC8vIG1zIG9yIHNvbWV0aGluZyBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSB0aW1pbmdzXHJcbiAqIEBwYXJhbSB7P30gZXJyb3JzXHJcbiAqIEBwYXJhbSB7Pz19IGFsbG93TmVnYXRpdmVWYWx1ZXNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVUaW1pbmcodGltaW5ncywgZXJyb3JzLCBhbGxvd05lZ2F0aXZlVmFsdWVzKSB7XHJcbiAgICByZXR1cm4gdGltaW5ncy5oYXNPd25Qcm9wZXJ0eSgnZHVyYXRpb24nKSA/IC8qKiBAdHlwZSB7P30gKi8gKHRpbWluZ3MpIDpcclxuICAgICAgICBwYXJzZVRpbWVFeHByZXNzaW9uKC8qKiBAdHlwZSB7P30gKi8gKHRpbWluZ3MpLCBlcnJvcnMsIGFsbG93TmVnYXRpdmVWYWx1ZXMpO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IGV4cFxyXG4gKiBAcGFyYW0gez99IGVycm9yc1xyXG4gKiBAcGFyYW0gez89fSBhbGxvd05lZ2F0aXZlVmFsdWVzXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVRpbWVFeHByZXNzaW9uKGV4cCwgZXJyb3JzLCBhbGxvd05lZ2F0aXZlVmFsdWVzKSB7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWdleCA9IC9eKC0/W1xcLlxcZF0rKShtP3MpKD86XFxzKygtP1tcXC5cXGRdKykobT9zKSk/KD86XFxzKyhbLWEtel0rKD86XFwoLis/XFwpKT8pKT8kL2k7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkdXJhdGlvbjtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlbGF5ID0gMDtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGVhc2luZyA9ICcnO1xyXG4gICAgaWYgKHR5cGVvZiBleHAgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlcyA9IGV4cC5tYXRjaChyZWdleCk7XHJcbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgZXJyb3JzLnB1c2goXCJUaGUgcHJvdmlkZWQgdGltaW5nIHZhbHVlIFxcXCJcIiArIGV4cCArIFwiXFxcIiBpcyBpbnZhbGlkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZHVyYXRpb246IDAsIGRlbGF5OiAwLCBlYXNpbmc6ICcnIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGR1cmF0aW9uID0gX2NvbnZlcnRUaW1lVmFsdWVUb01TKHBhcnNlRmxvYXQobWF0Y2hlc1sxXSksIG1hdGNoZXNbMl0pO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlbGF5TWF0Y2ggPSBtYXRjaGVzWzNdO1xyXG4gICAgICAgIGlmIChkZWxheU1hdGNoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZGVsYXkgPSBfY29udmVydFRpbWVWYWx1ZVRvTVMoTWF0aC5mbG9vcihwYXJzZUZsb2F0KGRlbGF5TWF0Y2gpKSwgbWF0Y2hlc1s0XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVhc2luZ1ZhbCA9IG1hdGNoZXNbNV07XHJcbiAgICAgICAgaWYgKGVhc2luZ1ZhbCkge1xyXG4gICAgICAgICAgICBlYXNpbmcgPSBlYXNpbmdWYWw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZHVyYXRpb24gPSAvKiogQHR5cGUgez99ICovIChleHApO1xyXG4gICAgfVxyXG4gICAgaWYgKCFhbGxvd05lZ2F0aXZlVmFsdWVzKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbnNFcnJvcnMgPSBmYWxzZTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydEluZGV4ID0gZXJyb3JzLmxlbmd0aDtcclxuICAgICAgICBpZiAoZHVyYXRpb24gPCAwKSB7XHJcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiRHVyYXRpb24gdmFsdWVzIGJlbG93IDAgYXJlIG5vdCBhbGxvd2VkIGZvciB0aGlzIGFuaW1hdGlvbiBzdGVwLlwiKTtcclxuICAgICAgICAgICAgY29udGFpbnNFcnJvcnMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVsYXkgPCAwKSB7XHJcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiRGVsYXkgdmFsdWVzIGJlbG93IDAgYXJlIG5vdCBhbGxvd2VkIGZvciB0aGlzIGFuaW1hdGlvbiBzdGVwLlwiKTtcclxuICAgICAgICAgICAgY29udGFpbnNFcnJvcnMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udGFpbnNFcnJvcnMpIHtcclxuICAgICAgICAgICAgZXJyb3JzLnNwbGljZShzdGFydEluZGV4LCAwLCBcIlRoZSBwcm92aWRlZCB0aW1pbmcgdmFsdWUgXFxcIlwiICsgZXhwICsgXCJcXFwiIGlzIGludmFsaWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7IGR1cmF0aW9uOiBkdXJhdGlvbiwgZGVsYXk6IGRlbGF5LCBlYXNpbmc6IGVhc2luZyB9O1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IG9ialxyXG4gKiBAcGFyYW0gez89fSBkZXN0aW5hdGlvblxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gY29weU9iaihvYmosIGRlc3RpbmF0aW9uKSB7XHJcbiAgICBpZiAoZGVzdGluYXRpb24gPT09IHZvaWQgMCkgeyBkZXN0aW5hdGlvbiA9IHt9OyB9XHJcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgZGVzdGluYXRpb25bcHJvcF0gPSBvYmpbcHJvcF07IH0pO1xyXG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHN0eWxlc1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVzKHN0eWxlcykge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9ybWFsaXplZFN0eWxlcyA9IHt9O1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGVzKSkge1xyXG4gICAgICAgIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBjb3B5U3R5bGVzKGRhdGEsIGZhbHNlLCBub3JtYWxpemVkU3R5bGVzKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb3B5U3R5bGVzKHN0eWxlcywgZmFsc2UsIG5vcm1hbGl6ZWRTdHlsZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRTdHlsZXM7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gc3R5bGVzXHJcbiAqIEBwYXJhbSB7P30gcmVhZFByb3RvdHlwZVxyXG4gKiBAcGFyYW0gez89fSBkZXN0aW5hdGlvblxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gY29weVN0eWxlcyhzdHlsZXMsIHJlYWRQcm90b3R5cGUsIGRlc3RpbmF0aW9uKSB7XHJcbiAgICBpZiAoZGVzdGluYXRpb24gPT09IHZvaWQgMCkgeyBkZXN0aW5hdGlvbiA9IHt9OyB9XHJcbiAgICBpZiAocmVhZFByb3RvdHlwZSkge1xyXG4gICAgICAgIC8vIHdlIG1ha2UgdXNlIG9mIGEgZm9yLWluIGxvb3Agc28gdGhhdCB0aGVcclxuICAgICAgICAvLyBwcm90b3R5cGljYWxseSBpbmhlcml0ZWQgcHJvcGVydGllcyBhcmVcclxuICAgICAgICAvLyByZXZlYWxlZCBmcm9tIHRoZSBiYWNrRmlsbCBtYXBcclxuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHByb3AgaW4gc3R5bGVzKSB7XHJcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BdID0gc3R5bGVzW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvcHlPYmooc3R5bGVzLCBkZXN0aW5hdGlvbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVzdGluYXRpb247XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gKiBAcGFyYW0gez99IHN0eWxlc1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0U3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xyXG4gICAgaWYgKGVsZW1lbnRbJ3N0eWxlJ10pIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FtZWxQcm9wID0gZGFzaENhc2VUb0NhbWVsQ2FzZShwcm9wKTtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtjYW1lbFByb3BdID0gc3R5bGVzW3Byb3BdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICogQHBhcmFtIHs/fSBzdHlsZXNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGVyYXNlU3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xyXG4gICAgaWYgKGVsZW1lbnRbJ3N0eWxlJ10pIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FtZWxQcm9wID0gZGFzaENhc2VUb0NhbWVsQ2FzZShwcm9wKTtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtjYW1lbFByb3BdID0gJyc7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gc3RlcHNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFuaW1hdGlvbkVudHJ5KHN0ZXBzKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdGVwcykpIHtcclxuICAgICAgICBpZiAoc3RlcHMubGVuZ3RoID09IDEpXHJcbiAgICAgICAgICAgIHJldHVybiBzdGVwc1swXTtcclxuICAgICAgICByZXR1cm4gX2FuZ3VsYXJfYW5pbWF0aW9ucy5zZXF1ZW5jZShzdGVwcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLyoqIEB0eXBlIHs/fSAqLyAoc3RlcHMpO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHZhbHVlXHJcbiAqIEBwYXJhbSB7P30gb3B0aW9uc1xyXG4gKiBAcGFyYW0gez99IGVycm9yc1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVTdHlsZVBhcmFtcyh2YWx1ZSwgb3B0aW9ucywgZXJyb3JzKSB7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbXMgPSBvcHRpb25zLnBhcmFtcyB8fCB7fTtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoZXMgPSBleHRyYWN0U3R5bGVQYXJhbXModmFsdWUpO1xyXG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgbWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YXJOYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICghcGFyYW1zLmhhc093blByb3BlcnR5KHZhck5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChcIlVuYWJsZSB0byByZXNvbHZlIHRoZSBsb2NhbCBhbmltYXRpb24gcGFyYW0gXCIgKyB2YXJOYW1lICsgXCIgaW4gdGhlIGdpdmVuIGxpc3Qgb2YgdmFsdWVzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxudmFyIFBBUkFNX1JFR0VYID0gbmV3IFJlZ0V4cChTVUJTVElUVVRJT05fRVhQUl9TVEFSVCArIFwiXFxcXHMqKC4rPylcXFxccypcIiArIFNVQlNUSVRVVElPTl9FWFBSX0VORCwgJ2cnKTtcclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gdmFsdWVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RTdHlsZVBhcmFtcyh2YWx1ZSkge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1zID0gW107XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbCA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2ggPSB2b2lkIDA7XHJcbiAgICAgICAgd2hpbGUgKG1hdGNoID0gUEFSQU1fUkVHRVguZXhlYyh2YWwpKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKG1hdGNoWzFdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFBBUkFNX1JFR0VYLmxhc3RJbmRleCA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFyYW1zO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHZhbHVlXHJcbiAqIEBwYXJhbSB7P30gcGFyYW1zXHJcbiAqIEBwYXJhbSB7P30gZXJyb3JzXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVBhcmFtcyh2YWx1ZSwgcGFyYW1zLCBlcnJvcnMpIHtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIG9yaWdpbmFsID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ciA9IG9yaWdpbmFsLnJlcGxhY2UoUEFSQU1fUkVHRVgsIGZ1bmN0aW9uIChfLCB2YXJOYW1lKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9jYWxWYWwgPSBwYXJhbXNbdmFyTmFtZV07XHJcbiAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHRoZSB2YWx1ZSB3YXMgbmV2ZXIgb3ZlcmlkZGVuIGJ5IHRoZSBkYXRhIHBhc3NlZCBpbiBieSB0aGUgdXNlclxyXG4gICAgICAgIGlmICghcGFyYW1zLmhhc093blByb3BlcnR5KHZhck5hbWUpKSB7XHJcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiUGxlYXNlIHByb3ZpZGUgYSB2YWx1ZSBmb3IgdGhlIGFuaW1hdGlvbiBwYXJhbSBcIiArIHZhck5hbWUpO1xyXG4gICAgICAgICAgICBsb2NhbFZhbCA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbG9jYWxWYWwudG9TdHJpbmcoKTtcclxuICAgIH0pO1xyXG4gICAgLy8gd2UgZG8gdGhpcyB0byBhc3NlcnQgdGhhdCBudW1lcmljIHZhbHVlcyBzdGF5IGFzIHRoZXkgYXJlXHJcbiAgICByZXR1cm4gc3RyID09IG9yaWdpbmFsID8gdmFsdWUgOiBzdHI7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gaXRlcmF0b3JcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJyID0gW107XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpdGVtID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgd2hpbGUgKCFpdGVtLmRvbmUpIHtcclxuICAgICAgICBhcnIucHVzaChpdGVtLnZhbHVlKTtcclxuICAgICAgICBpdGVtID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycjtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSBzb3VyY2VcclxuICogQHBhcmFtIHs/fSBkZXN0aW5hdGlvblxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuXHJcbnZhciBEQVNIX0NBU0VfUkVHRVhQID0gLy0rKFthLXowLTldKS9nO1xyXG4vKipcclxuICogQHBhcmFtIHs/fSBpbnB1dFxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gZGFzaENhc2VUb0NhbWVsQ2FzZShpbnB1dCkge1xyXG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoREFTSF9DQVNFX1JFR0VYUCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbVsxXS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gZHVyYXRpb25cclxuICogQHBhcmFtIHs/fSBkZWxheVxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gYWxsb3dQcmV2aW91c1BsYXllclN0eWxlc01lcmdlKGR1cmF0aW9uLCBkZWxheSkge1xyXG4gICAgcmV0dXJuIGR1cmF0aW9uID09PSAwIHx8IGRlbGF5ID09PSAwO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHZpc2l0b3JcclxuICogQHBhcmFtIHs/fSBub2RlXHJcbiAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gdmlzaXREc2xOb2RlKHZpc2l0b3IsIG5vZGUsIGNvbnRleHQpIHtcclxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSA3IC8qIFRyaWdnZXIgKi86XHJcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VHJpZ2dlcihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICBjYXNlIDAgLyogU3RhdGUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3RhdGUobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgY2FzZSAxIC8qIFRyYW5zaXRpb24gKi86XHJcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VHJhbnNpdGlvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICBjYXNlIDIgLyogU2VxdWVuY2UgKi86XHJcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U2VxdWVuY2Uobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgY2FzZSAzIC8qIEdyb3VwICovOlxyXG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEdyb3VwKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIGNhc2UgNCAvKiBBbmltYXRlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGUobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgY2FzZSA1IC8qIEtleWZyYW1lcyAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXlmcmFtZXMobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgY2FzZSA2IC8qIFN0eWxlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFN0eWxlKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIGNhc2UgOCAvKiBSZWZlcmVuY2UgKi86XHJcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVmZXJlbmNlKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIGNhc2UgOSAvKiBBbmltYXRlQ2hpbGQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0ZUNoaWxkKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIGNhc2UgMTAgLyogQW5pbWF0ZVJlZiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRlUmVmKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIGNhc2UgMTEgLyogUXVlcnkgKi86XHJcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UXVlcnkobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgY2FzZSAxMiAvKiBTdGFnZ2VyICovOlxyXG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFN0YWdnZXIobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlc29sdmUgYW5pbWF0aW9uIG1ldGFkYXRhIG5vZGUgI1wiICsgbm9kZS50eXBlKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxyXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXHJcbiAqL1xyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbnZhciBBTllfU1RBVEUgPSAnKic7XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHRyYW5zaXRpb25WYWx1ZVxyXG4gKiBAcGFyYW0gez99IGVycm9yc1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VUcmFuc2l0aW9uRXhwcih0cmFuc2l0aW9uVmFsdWUsIGVycm9ycykge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwcmVzc2lvbnMgPSBbXTtcclxuICAgIGlmICh0eXBlb2YgdHJhbnNpdGlvblZhbHVlID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKHRyYW5zaXRpb25WYWx1ZSkpXHJcbiAgICAgICAgICAgIC5zcGxpdCgvXFxzKixcXHMqLylcclxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gcGFyc2VJbm5lclRyYW5zaXRpb25TdHIoc3RyLCBleHByZXNzaW9ucywgZXJyb3JzKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBleHByZXNzaW9ucy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKHRyYW5zaXRpb25WYWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4cHJlc3Npb25zO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IGV2ZW50U3RyXHJcbiAqIEBwYXJhbSB7P30gZXhwcmVzc2lvbnNcclxuICogQHBhcmFtIHs/fSBlcnJvcnNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlSW5uZXJUcmFuc2l0aW9uU3RyKGV2ZW50U3RyLCBleHByZXNzaW9ucywgZXJyb3JzKSB7XHJcbiAgICBpZiAoZXZlbnRTdHJbMF0gPT0gJzonKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gcGFyc2VBbmltYXRpb25BbGlhcyhldmVudFN0ciwgZXJyb3JzKTtcclxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudFN0ciA9IC8qKiBAdHlwZSB7P30gKi8gKHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaCA9IGV2ZW50U3RyLm1hdGNoKC9eKFxcKnxbLVxcd10rKVxccyooPD9bPS1dPilcXHMqKFxcKnxbLVxcd10rKSQvKTtcclxuICAgIGlmIChtYXRjaCA9PSBudWxsIHx8IG1hdGNoLmxlbmd0aCA8IDQpIHtcclxuICAgICAgICBlcnJvcnMucHVzaChcIlRoZSBwcm92aWRlZCB0cmFuc2l0aW9uIGV4cHJlc3Npb24gXFxcIlwiICsgZXZlbnRTdHIgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZFwiKTtcclxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnM7XHJcbiAgICB9XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmcm9tU3RhdGUgPSBtYXRjaFsxXTtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlcGFyYXRvciA9IG1hdGNoWzJdO1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9TdGF0ZSA9IG1hdGNoWzNdO1xyXG4gICAgZXhwcmVzc2lvbnMucHVzaChtYWtlTGFtYmRhRnJvbVN0YXRlcyhmcm9tU3RhdGUsIHRvU3RhdGUpKTtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzRnVsbEFueVN0YXRlRXhwciA9IGZyb21TdGF0ZSA9PSBBTllfU1RBVEUgJiYgdG9TdGF0ZSA9PSBBTllfU1RBVEU7XHJcbiAgICBpZiAoc2VwYXJhdG9yWzBdID09ICc8JyAmJiAhaXNGdWxsQW55U3RhdGVFeHByKSB7XHJcbiAgICAgICAgZXhwcmVzc2lvbnMucHVzaChtYWtlTGFtYmRhRnJvbVN0YXRlcyh0b1N0YXRlLCBmcm9tU3RhdGUpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSBhbGlhc1xyXG4gKiBAcGFyYW0gez99IGVycm9yc1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VBbmltYXRpb25BbGlhcyhhbGlhcywgZXJyb3JzKSB7XHJcbiAgICBzd2l0Y2ggKGFsaWFzKSB7XHJcbiAgICAgICAgY2FzZSAnOmVudGVyJzpcclxuICAgICAgICAgICAgcmV0dXJuICd2b2lkID0+IConO1xyXG4gICAgICAgIGNhc2UgJzpsZWF2ZSc6XHJcbiAgICAgICAgICAgIHJldHVybiAnKiA9PiB2b2lkJztcclxuICAgICAgICBjYXNlICc6aW5jcmVtZW50JzpcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmcm9tU3RhdGUsIHRvU3RhdGUpIHsgcmV0dXJuIHBhcnNlRmxvYXQodG9TdGF0ZSkgPiBwYXJzZUZsb2F0KGZyb21TdGF0ZSk7IH07XHJcbiAgICAgICAgY2FzZSAnOmRlY3JlbWVudCc6XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZnJvbVN0YXRlLCB0b1N0YXRlKSB7IHJldHVybiBwYXJzZUZsb2F0KHRvU3RhdGUpIDwgcGFyc2VGbG9hdChmcm9tU3RhdGUpOyB9O1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiVGhlIHRyYW5zaXRpb24gYWxpYXMgdmFsdWUgXFxcIlwiICsgYWxpYXMgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuICcqID0+IConO1xyXG4gICAgfVxyXG59XHJcbi8vIERPIE5PVCBSRUZBQ1RPUiAuLi4ga2VlcCB0aGUgZm9sbG93IHNldCBpbnN0YW50aWF0aW9uc1xyXG4vLyB3aXRoIHRoZSB2YWx1ZXMgaW50YWN0IChjbG9zdXJlIGNvbXBpbGVyIGZvciBzb21lIHJlYXNvblxyXG4vLyByZW1vdmVzIGZvbGxvdy11cCBsaW5lcyB0aGF0IGFkZCB0aGUgdmFsdWVzIG91dHNpZGUgb2ZcclxuLy8gdGhlIGNvbnN0cnVjdG9yLi4uXHJcbnZhciBUUlVFX0JPT0xFQU5fVkFMVUVTID0gbmV3IFNldChbJ3RydWUnLCAnMSddKTtcclxudmFyIEZBTFNFX0JPT0xFQU5fVkFMVUVTID0gbmV3IFNldChbJ2ZhbHNlJywgJzAnXSk7XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IGxoc1xyXG4gKiBAcGFyYW0gez99IHJoc1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZUxhbWJkYUZyb21TdGF0ZXMobGhzLCByaHMpIHtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIExIU19NQVRDSF9CT09MRUFOID0gVFJVRV9CT09MRUFOX1ZBTFVFUy5oYXMobGhzKSB8fCBGQUxTRV9CT09MRUFOX1ZBTFVFUy5oYXMobGhzKTtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIFJIU19NQVRDSF9CT09MRUFOID0gVFJVRV9CT09MRUFOX1ZBTFVFUy5oYXMocmhzKSB8fCBGQUxTRV9CT09MRUFOX1ZBTFVFUy5oYXMocmhzKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZnJvbVN0YXRlLCB0b1N0YXRlKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGhzTWF0Y2ggPSBsaHMgPT0gQU5ZX1NUQVRFIHx8IGxocyA9PSBmcm9tU3RhdGU7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmhzTWF0Y2ggPSByaHMgPT0gQU5ZX1NUQVRFIHx8IHJocyA9PSB0b1N0YXRlO1xyXG4gICAgICAgIGlmICghbGhzTWF0Y2ggJiYgTEhTX01BVENIX0JPT0xFQU4gJiYgdHlwZW9mIGZyb21TdGF0ZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIGxoc01hdGNoID0gZnJvbVN0YXRlID8gVFJVRV9CT09MRUFOX1ZBTFVFUy5oYXMobGhzKSA6IEZBTFNFX0JPT0xFQU5fVkFMVUVTLmhhcyhsaHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXJoc01hdGNoICYmIFJIU19NQVRDSF9CT09MRUFOICYmIHR5cGVvZiB0b1N0YXRlID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgcmhzTWF0Y2ggPSB0b1N0YXRlID8gVFJVRV9CT09MRUFOX1ZBTFVFUy5oYXMocmhzKSA6IEZBTFNFX0JPT0xFQU5fVkFMVUVTLmhhcyhyaHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGhzTWF0Y2ggJiYgcmhzTWF0Y2g7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbnZhciBTRUxGX1RPS0VOID0gJzpzZWxmJztcclxudmFyIFNFTEZfVE9LRU5fUkVHRVggPSBuZXcgUmVnRXhwKFwicypcIiArIFNFTEZfVE9LRU4gKyBcInMqLD9cIiwgJ2cnKTtcclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gZHJpdmVyXHJcbiAqIEBwYXJhbSB7P30gbWV0YWRhdGFcclxuICogQHBhcmFtIHs/fSBlcnJvcnNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGJ1aWxkQW5pbWF0aW9uQXN0KGRyaXZlciwgbWV0YWRhdGEsIGVycm9ycykge1xyXG4gICAgcmV0dXJuIG5ldyBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvcihkcml2ZXIpLmJ1aWxkKG1ldGFkYXRhLCBlcnJvcnMpO1xyXG59XHJcbnZhciBST09UX1NFTEVDVE9SID0gJyc7XHJcbnZhciBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yKF9kcml2ZXIpIHtcclxuICAgICAgICB0aGlzLl9kcml2ZXIgPSBfZHJpdmVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXHJcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLmJ1aWxkID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXHJcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBlcnJvcnMpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZXh0ID0gbmV3IEFuaW1hdGlvbkFzdEJ1aWxkZXJDb250ZXh0KGVycm9ycyk7XHJcbiAgICAgICAgdGhpcy5fcmVzZXRDb250ZXh0U3R5bGVUaW1pbmdTdGF0ZShjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHs/fSAqLyAodmlzaXREc2xOb2RlKHRoaXMsIG5vcm1hbGl6ZUFuaW1hdGlvbkVudHJ5KG1ldGFkYXRhKSwgY29udGV4dCkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX3Jlc2V0Q29udGV4dFN0eWxlVGltaW5nU3RhdGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeVNlbGVjdG9yID0gUk9PVF9TRUxFQ1RPUjtcclxuICAgICAgICBjb250ZXh0LmNvbGxlY3RlZFN0eWxlcyA9IHt9O1xyXG4gICAgICAgIGNvbnRleHQuY29sbGVjdGVkU3R5bGVzW1JPT1RfU0VMRUNUT1JdID0ge307XHJcbiAgICAgICAgY29udGV4dC5jdXJyZW50VGltZSA9IDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyaWdnZXIgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeUNvdW50ID0gY29udGV4dC5xdWVyeUNvdW50ID0gMDtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBDb3VudCA9IGNvbnRleHQuZGVwQ291bnQgPSAwO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlcyA9IFtdO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zaXRpb25zID0gW107XHJcbiAgICAgICAgaWYgKG1ldGFkYXRhLm5hbWUuY2hhckF0KDApID09ICdAJykge1xyXG4gICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKCdhbmltYXRpb24gdHJpZ2dlcnMgY2Fubm90IGJlIHByZWZpeGVkIHdpdGggYW4gYEBgIHNpZ24gKGUuZy4gdHJpZ2dlcihcXCdAZm9vXFwnLCBbLi4uXSkpJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1ldGFkYXRhLmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlZikge1xyXG4gICAgICAgICAgICBfdGhpcy5fcmVzZXRDb250ZXh0U3R5bGVUaW1pbmdTdGF0ZShjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGRlZi50eXBlID09IDAgLyogU3RhdGUgKi8pIHtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlRGVmXzEgPSAvKiogQHR5cGUgez99ICovIChkZWYpO1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZV8xID0gc3RhdGVEZWZfMS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgbmFtZV8xLnNwbGl0KC9cXHMqLFxccyovKS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVEZWZfMS5uYW1lID0gbjtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZXMucHVzaChfdGhpcy52aXNpdFN0YXRlKHN0YXRlRGVmXzEsIGNvbnRleHQpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc3RhdGVEZWZfMS5uYW1lID0gbmFtZV8xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZi50eXBlID09IDEgLyogVHJhbnNpdGlvbiAqLykge1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNpdGlvbiA9IF90aGlzLnZpc2l0VHJhbnNpdGlvbigvKiogQHR5cGUgez99ICovIChkZWYpLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5Q291bnQgKz0gdHJhbnNpdGlvbi5xdWVyeUNvdW50O1xyXG4gICAgICAgICAgICAgICAgZGVwQ291bnQgKz0gdHJhbnNpdGlvbi5kZXBDb3VudDtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zLnB1c2godHJhbnNpdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKCdvbmx5IHN0YXRlKCkgYW5kIHRyYW5zaXRpb24oKSBkZWZpbml0aW9ucyBjYW4gc2l0IGluc2lkZSBvZiBhIHRyaWdnZXIoKScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogNyAvKiBUcmlnZ2VyICovLFxyXG4gICAgICAgICAgICBuYW1lOiBtZXRhZGF0YS5uYW1lLCBzdGF0ZXM6IHN0YXRlcywgdHJhbnNpdGlvbnM6IHRyYW5zaXRpb25zLCBxdWVyeUNvdW50OiBxdWVyeUNvdW50LCBkZXBDb3VudDogZGVwQ291bnQsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdGF0ZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZUFzdCA9IHRoaXMudmlzaXRTdHlsZShtZXRhZGF0YS5zdHlsZXMsIGNvbnRleHQpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdFBhcmFtcyA9IChtZXRhZGF0YS5vcHRpb25zICYmIG1ldGFkYXRhLm9wdGlvbnMucGFyYW1zKSB8fCBudWxsO1xyXG4gICAgICAgIGlmIChzdHlsZUFzdC5jb250YWluc0R5bmFtaWNTdHlsZXMpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWlzc2luZ1N1YnNfMSA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1zXzEgPSBhc3RQYXJhbXMgfHwge307XHJcbiAgICAgICAgICAgIHN0eWxlQXN0LnN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlc09ial8xID0gLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0eWxlc09ial8xKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RTdHlsZVBhcmFtcyhzdHlsZXNPYmpfMVtwcm9wXSkuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtc18xLmhhc093blByb3BlcnR5KHN1YikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nU3Vic18xLmFkZChzdWIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChtaXNzaW5nU3Vic18xLnNpemUpIHtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1pc3NpbmdTdWJzQXJyID0gaXRlcmF0b3JUb0FycmF5KG1pc3NpbmdTdWJzXzEudmFsdWVzKCkpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcInN0YXRlKFxcXCJcIiArIG1ldGFkYXRhLm5hbWUgKyBcIlxcXCIsIC4uLikgbXVzdCBkZWZpbmUgZGVmYXVsdCB2YWx1ZXMgZm9yIGFsbCB0aGUgZm9sbG93aW5nIHN0eWxlIHN1YnN0aXR1dGlvbnM6IFwiICsgbWlzc2luZ1N1YnNBcnIuam9pbignLCAnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogMCAvKiBTdGF0ZSAqLyxcclxuICAgICAgICAgICAgbmFtZTogbWV0YWRhdGEubmFtZSxcclxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlQXN0LFxyXG4gICAgICAgICAgICBvcHRpb25zOiBhc3RQYXJhbXMgPyB7IHBhcmFtczogYXN0UGFyYW1zIH0gOiBudWxsXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHJhbnNpdGlvbiA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0LnF1ZXJ5Q291bnQgPSAwO1xyXG4gICAgICAgIGNvbnRleHQuZGVwQ291bnQgPSAwO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuaW1hdGlvbiA9IHZpc2l0RHNsTm9kZSh0aGlzLCBub3JtYWxpemVBbmltYXRpb25FbnRyeShtZXRhZGF0YS5hbmltYXRpb24pLCBjb250ZXh0KTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVycyA9IHBhcnNlVHJhbnNpdGlvbkV4cHIobWV0YWRhdGEuZXhwciwgY29udGV4dC5lcnJvcnMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IDEgLyogVHJhbnNpdGlvbiAqLyxcclxuICAgICAgICAgICAgbWF0Y2hlcnM6IG1hdGNoZXJzLFxyXG4gICAgICAgICAgICBhbmltYXRpb246IGFuaW1hdGlvbixcclxuICAgICAgICAgICAgcXVlcnlDb3VudDogY29udGV4dC5xdWVyeUNvdW50LFxyXG4gICAgICAgICAgICBkZXBDb3VudDogY29udGV4dC5kZXBDb3VudCxcclxuICAgICAgICAgICAgb3B0aW9uczogbm9ybWFsaXplQW5pbWF0aW9uT3B0aW9ucyhtZXRhZGF0YS5vcHRpb25zKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNlcXVlbmNlID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogMiAvKiBTZXF1ZW5jZSAqLyxcclxuICAgICAgICAgICAgc3RlcHM6IG1ldGFkYXRhLnN0ZXBzLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gdmlzaXREc2xOb2RlKF90aGlzLCBzLCBjb250ZXh0KTsgfSksXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IG5vcm1hbGl6ZUFuaW1hdGlvbk9wdGlvbnMobWV0YWRhdGEub3B0aW9ucylcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRHcm91cCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRUaW1lID0gY29udGV4dC5jdXJyZW50VGltZTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmdXJ0aGVzdFRpbWUgPSAwO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ZXBzID0gbWV0YWRhdGEuc3RlcHMubWFwKGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJBc3QgPSB2aXNpdERzbE5vZGUoX3RoaXMsIHN0ZXAsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBmdXJ0aGVzdFRpbWUgPSBNYXRoLm1heChmdXJ0aGVzdFRpbWUsIGNvbnRleHQuY3VycmVudFRpbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5uZXJBc3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29udGV4dC5jdXJyZW50VGltZSA9IGZ1cnRoZXN0VGltZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAzIC8qIEdyb3VwICovLFxyXG4gICAgICAgICAgICBzdGVwczogc3RlcHMsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IG5vcm1hbGl6ZUFuaW1hdGlvbk9wdGlvbnMobWV0YWRhdGEub3B0aW9ucylcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbmltYXRlID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWluZ0FzdCA9IGNvbnN0cnVjdFRpbWluZ0FzdChtZXRhZGF0YS50aW1pbmdzLCBjb250ZXh0LmVycm9ycyk7XHJcbiAgICAgICAgY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSB0aW1pbmdBc3Q7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVBc3Q7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVNZXRhZGF0YSA9IG1ldGFkYXRhLnN0eWxlcyA/IG1ldGFkYXRhLnN0eWxlcyA6IF9hbmd1bGFyX2FuaW1hdGlvbnMuc3R5bGUoe30pO1xyXG4gICAgICAgIGlmIChzdHlsZU1ldGFkYXRhLnR5cGUgPT0gNSAvKiBLZXlmcmFtZXMgKi8pIHtcclxuICAgICAgICAgICAgc3R5bGVBc3QgPSB0aGlzLnZpc2l0S2V5ZnJhbWVzKC8qKiBAdHlwZSB7P30gKi8gKHN0eWxlTWV0YWRhdGEpLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlTWV0YWRhdGFfMSA9IC8qKiBAdHlwZSB7P30gKi8gKG1ldGFkYXRhLnN0eWxlcyk7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzRW1wdHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCFzdHlsZU1ldGFkYXRhXzEpIHtcclxuICAgICAgICAgICAgICAgIGlzRW1wdHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3U3R5bGVEYXRhID0ge307XHJcbiAgICAgICAgICAgICAgICBpZiAodGltaW5nQXN0LmVhc2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0eWxlRGF0YVsnZWFzaW5nJ10gPSB0aW1pbmdBc3QuZWFzaW5nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3R5bGVNZXRhZGF0YV8xID0gX2FuZ3VsYXJfYW5pbWF0aW9ucy5zdHlsZShuZXdTdHlsZURhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFRpbWUgKz0gdGltaW5nQXN0LmR1cmF0aW9uICsgdGltaW5nQXN0LmRlbGF5O1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfc3R5bGVBc3QgPSB0aGlzLnZpc2l0U3R5bGUoc3R5bGVNZXRhZGF0YV8xLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgX3N0eWxlQXN0LmlzRW1wdHlTdGVwID0gaXNFbXB0eTtcclxuICAgICAgICAgICAgc3R5bGVBc3QgPSBfc3R5bGVBc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQuY3VycmVudEFuaW1hdGVUaW1pbmdzID0gbnVsbDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiA0IC8qIEFuaW1hdGUgKi8sXHJcbiAgICAgICAgICAgIHRpbWluZ3M6IHRpbWluZ0FzdCxcclxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlQXN0LFxyXG4gICAgICAgICAgICBvcHRpb25zOiBudWxsXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U3R5bGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gdGhpcy5fbWFrZVN0eWxlQXN0KG1ldGFkYXRhLCBjb250ZXh0KTtcclxuICAgICAgICB0aGlzLl92YWxpZGF0ZVN0eWxlQXN0KGFzdCwgY29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIGFzdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLl9tYWtlU3R5bGVBc3QgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0gW107XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWV0YWRhdGEuc3R5bGVzKSkge1xyXG4gICAgICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAobWV0YWRhdGEuc3R5bGVzKSkuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVUdXBsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZVR1cGxlID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlVHVwbGUgPT0gX2FuZ3VsYXJfYW5pbWF0aW9ucy5BVVRPX1NUWUxFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKHN0eWxlVHVwbGUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goXCJUaGUgcHJvdmlkZWQgc3R5bGUgc3RyaW5nIHZhbHVlIFwiICsgc3R5bGVUdXBsZSArIFwiIGlzIG5vdCBhbGxvd2VkLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaCgvKiogQHR5cGUgez99ICovIChzdHlsZVR1cGxlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3R5bGVzLnB1c2gobWV0YWRhdGEuc3R5bGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbnNEeW5hbWljU3R5bGVzID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29sbGVjdGVkRWFzaW5nID0gbnVsbDtcclxuICAgICAgICBzdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVEYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChpc09iamVjdChzdHlsZURhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZU1hcCA9IC8qKiBAdHlwZSB7P30gKi8gKHN0eWxlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlYXNpbmcgPSBzdHlsZU1hcFsnZWFzaW5nJ107XHJcbiAgICAgICAgICAgICAgICBpZiAoZWFzaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkRWFzaW5nID0gLyoqIEB0eXBlIHs/fSAqLyAoZWFzaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3R5bGVNYXBbJ2Vhc2luZyddO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWluc0R5bmFtaWNTdHlsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHByb3AgaW4gc3R5bGVNYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBzdHlsZU1hcFtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnRvU3RyaW5nKCkuaW5kZXhPZihTVUJTVElUVVRJT05fRVhQUl9TVEFSVCkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnNEeW5hbWljU3R5bGVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogNiAvKiBTdHlsZSAqLyxcclxuICAgICAgICAgICAgc3R5bGVzOiBzdHlsZXMsXHJcbiAgICAgICAgICAgIGVhc2luZzogY29sbGVjdGVkRWFzaW5nLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IG1ldGFkYXRhLm9mZnNldCwgY29udGFpbnNEeW5hbWljU3R5bGVzOiBjb250YWluc0R5bmFtaWNTdHlsZXMsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBhc3RcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLl92YWxpZGF0ZVN0eWxlQXN0ID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGFzdFxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1pbmdzID0gY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3M7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kVGltZSA9IGNvbnRleHQuY3VycmVudFRpbWU7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRUaW1lID0gY29udGV4dC5jdXJyZW50VGltZTtcclxuICAgICAgICBpZiAodGltaW5ncyAmJiBzdGFydFRpbWUgPiAwKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0VGltZSAtPSB0aW1pbmdzLmR1cmF0aW9uICsgdGltaW5ncy5kZWxheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXN0LnN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uICh0dXBsZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR1cGxlID09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0dXBsZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fZHJpdmVyLnZhbGlkYXRlU3R5bGVQcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goXCJUaGUgcHJvdmlkZWQgYW5pbWF0aW9uIHByb3BlcnR5IFxcXCJcIiArIHByb3AgKyBcIlxcXCIgaXMgbm90IGEgc3VwcG9ydGVkIENTUyBwcm9wZXJ0eSBmb3IgYW5pbWF0aW9uc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2xsZWN0ZWRTdHlsZXMgPSBjb250ZXh0LmNvbGxlY3RlZFN0eWxlc1svKiogQHR5cGUgez99ICovICgoY29udGV4dC5jdXJyZW50UXVlcnlTZWxlY3RvcikpXTtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbGxlY3RlZEVudHJ5ID0gY29sbGVjdGVkU3R5bGVzW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBkYXRlQ29sbGVjdGVkU3R5bGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbGxlY3RlZEVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSAhPSBlbmRUaW1lICYmIHN0YXJ0VGltZSA+PSBjb2xsZWN0ZWRFbnRyeS5zdGFydFRpbWUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kVGltZSA8PSBjb2xsZWN0ZWRFbnRyeS5lbmRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goXCJUaGUgQ1NTIHByb3BlcnR5IFxcXCJcIiArIHByb3AgKyBcIlxcXCIgdGhhdCBleGlzdHMgYmV0d2VlbiB0aGUgdGltZXMgb2YgXFxcIlwiICsgY29sbGVjdGVkRW50cnkuc3RhcnRUaW1lICsgXCJtc1xcXCIgYW5kIFxcXCJcIiArIGNvbGxlY3RlZEVudHJ5LmVuZFRpbWUgKyBcIm1zXFxcIiBpcyBhbHNvIGJlaW5nIGFuaW1hdGVkIGluIGEgcGFyYWxsZWwgYW5pbWF0aW9uIGJldHdlZW4gdGhlIHRpbWVzIG9mIFxcXCJcIiArIHN0YXJ0VGltZSArIFwibXNcXFwiIGFuZCBcXFwiXCIgKyBlbmRUaW1lICsgXCJtc1xcXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbGxlY3RlZFN0eWxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGFsd2F5cyBjaG9vc2UgdGhlIHNtYWxsZXIgc3RhcnQgdGltZSB2YWx1ZSBzaW5jZSB3ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8gaGF2ZSBhIHJlY29yZCBvZiB0aGUgZW50aXJlIGFuaW1hdGlvbiB3aW5kb3cgd2hlcmVcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc3R5bGUgcHJvcGVydHkgaXMgYmVpbmcgYW5pbWF0ZWQgaW4gYmV0d2VlblxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZSA9IGNvbGxlY3RlZEVudHJ5LnN0YXJ0VGltZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVDb2xsZWN0ZWRTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZFN0eWxlc1twcm9wXSA9IHsgc3RhcnRUaW1lOiBzdGFydFRpbWUsIGVuZFRpbWU6IGVuZFRpbWUgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lm9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZVN0eWxlUGFyYW1zKHR1cGxlW3Byb3BdLCBjb250ZXh0Lm9wdGlvbnMsIGNvbnRleHQuZXJyb3JzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWZyYW1lcyA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHsgdHlwZTogNSAvKiBLZXlmcmFtZXMgKi8sIHN0eWxlczogW10sIG9wdGlvbnM6IG51bGwgfTtcclxuICAgICAgICBpZiAoIWNvbnRleHQuY3VycmVudEFuaW1hdGVUaW1pbmdzKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goXCJrZXlmcmFtZXMoKSBtdXN0IGJlIHBsYWNlZCBpbnNpZGUgb2YgYSBjYWxsIHRvIGFuaW1hdGUoKVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTUFYX0tFWUZSQU1FX09GRlNFVCA9IDE7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG90YWxLZXlmcmFtZXNXaXRoT2Zmc2V0cyA9IDA7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0cyA9IFtdO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldHNPdXRPZk9yZGVyID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ZnJhbWVzT3V0T2ZSYW5nZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZpb3VzT2Zmc2V0ID0gMDtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlmcmFtZXMgPSBtZXRhZGF0YS5zdGVwcy5tYXAoZnVuY3Rpb24gKHN0eWxlcykge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZSQkMSA9IF90aGlzLl9tYWtlU3R5bGVBc3Qoc3R5bGVzLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0VmFsID0gc3R5bGUkJDEub2Zmc2V0ICE9IG51bGwgPyBzdHlsZSQkMS5vZmZzZXQgOiBjb25zdW1lT2Zmc2V0KHN0eWxlJCQxLnN0eWxlcyk7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIGlmIChvZmZzZXRWYWwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdG90YWxLZXlmcmFtZXNXaXRoT2Zmc2V0cysrO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gc3R5bGUkJDEub2Zmc2V0ID0gb2Zmc2V0VmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGtleWZyYW1lc091dE9mUmFuZ2UgPSBrZXlmcmFtZXNPdXRPZlJhbmdlIHx8IG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gMTtcclxuICAgICAgICAgICAgb2Zmc2V0c091dE9mT3JkZXIgPSBvZmZzZXRzT3V0T2ZPcmRlciB8fCBvZmZzZXQgPCBwcmV2aW91c09mZnNldDtcclxuICAgICAgICAgICAgcHJldmlvdXNPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3R5bGUkJDE7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGtleWZyYW1lc091dE9mUmFuZ2UpIHtcclxuICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcIlBsZWFzZSBlbnN1cmUgdGhhdCBhbGwga2V5ZnJhbWUgb2Zmc2V0cyBhcmUgYmV0d2VlbiAwIGFuZCAxXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2Zmc2V0c091dE9mT3JkZXIpIHtcclxuICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcIlBsZWFzZSBlbnN1cmUgdGhhdCBhbGwga2V5ZnJhbWUgb2Zmc2V0cyBhcmUgaW4gb3JkZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlbmd0aCA9IG1ldGFkYXRhLnN0ZXBzLmxlbmd0aDtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBnZW5lcmF0ZWRPZmZzZXQgPSAwO1xyXG4gICAgICAgIGlmICh0b3RhbEtleWZyYW1lc1dpdGhPZmZzZXRzID4gMCAmJiB0b3RhbEtleWZyYW1lc1dpdGhPZmZzZXRzIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goXCJOb3QgYWxsIHN0eWxlKCkgc3RlcHMgd2l0aGluIHRoZSBkZWNsYXJlZCBrZXlmcmFtZXMoKSBjb250YWluIG9mZnNldHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRvdGFsS2V5ZnJhbWVzV2l0aE9mZnNldHMgPT0gMCkge1xyXG4gICAgICAgICAgICBnZW5lcmF0ZWRPZmZzZXQgPSBNQVhfS0VZRlJBTUVfT0ZGU0VUIC8gKGxlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW1pdCA9IGxlbmd0aCAtIDE7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VycmVudFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRBbmltYXRlVGltaW5ncyA9IC8qKiBAdHlwZSB7P30gKi8gKChjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncykpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuaW1hdGVEdXJhdGlvbiA9IGN1cnJlbnRBbmltYXRlVGltaW5ncy5kdXJhdGlvbjtcclxuICAgICAgICBrZXlmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoa2YsIGkpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0ID0gZ2VuZXJhdGVkT2Zmc2V0ID4gMCA/IChpID09IGxpbWl0ID8gMSA6IChnZW5lcmF0ZWRPZmZzZXQgKiBpKSkgOiBvZmZzZXRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkdXJhdGlvblVwVG9UaGlzRnJhbWUgPSBvZmZzZXQgKiBhbmltYXRlRHVyYXRpb247XHJcbiAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFRpbWUgPSBjdXJyZW50VGltZSArIGN1cnJlbnRBbmltYXRlVGltaW5ncy5kZWxheSArIGR1cmF0aW9uVXBUb1RoaXNGcmFtZTtcclxuICAgICAgICAgICAgY3VycmVudEFuaW1hdGVUaW1pbmdzLmR1cmF0aW9uID0gZHVyYXRpb25VcFRvVGhpc0ZyYW1lO1xyXG4gICAgICAgICAgICBfdGhpcy5fdmFsaWRhdGVTdHlsZUFzdChrZiwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGtmLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgYXN0LnN0eWxlcy5wdXNoKGtmKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXN0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogOCAvKiBSZWZlcmVuY2UgKi8sXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbjogdmlzaXREc2xOb2RlKHRoaXMsIG5vcm1hbGl6ZUFuaW1hdGlvbkVudHJ5KG1ldGFkYXRhLmFuaW1hdGlvbiksIGNvbnRleHQpLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QW5pbWF0ZUNoaWxkID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQuZGVwQ291bnQrKztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiA5IC8qIEFuaW1hdGVDaGlsZCAqLyxcclxuICAgICAgICAgICAgb3B0aW9uczogbm9ybWFsaXplQW5pbWF0aW9uT3B0aW9ucyhtZXRhZGF0YS5vcHRpb25zKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFuaW1hdGVSZWYgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogMTAgLyogQW5pbWF0ZVJlZiAqLyxcclxuICAgICAgICAgICAgYW5pbWF0aW9uOiB0aGlzLnZpc2l0UmVmZXJlbmNlKG1ldGFkYXRhLmFuaW1hdGlvbiwgY29udGV4dCksXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IG5vcm1hbGl6ZUFuaW1hdGlvbk9wdGlvbnMobWV0YWRhdGEub3B0aW9ucylcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRRdWVyeSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRTZWxlY3RvciA9IC8qKiBAdHlwZSB7P30gKi8gKChjb250ZXh0LmN1cnJlbnRRdWVyeVNlbGVjdG9yKSk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0aW9ucyA9IC8qKiBAdHlwZSB7P30gKi8gKChtZXRhZGF0YS5vcHRpb25zIHx8IHt9KSk7XHJcbiAgICAgICAgY29udGV4dC5xdWVyeUNvdW50Kys7XHJcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnkgPSBtZXRhZGF0YTtcclxuICAgICAgICB2YXIgX2EgPSBub3JtYWxpemVTZWxlY3RvcihtZXRhZGF0YS5zZWxlY3RvciksIHNlbGVjdG9yID0gX2FbMF0sIGluY2x1ZGVTZWxmID0gX2FbMV07XHJcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlTZWxlY3RvciA9XHJcbiAgICAgICAgICAgIHBhcmVudFNlbGVjdG9yLmxlbmd0aCA/IChwYXJlbnRTZWxlY3RvciArICcgJyArIHNlbGVjdG9yKSA6IHNlbGVjdG9yO1xyXG4gICAgICAgIGdldE9yU2V0QXNJbk1hcChjb250ZXh0LmNvbGxlY3RlZFN0eWxlcywgY29udGV4dC5jdXJyZW50UXVlcnlTZWxlY3Rvciwge30pO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuaW1hdGlvbiA9IHZpc2l0RHNsTm9kZSh0aGlzLCBub3JtYWxpemVBbmltYXRpb25FbnRyeShtZXRhZGF0YS5hbmltYXRpb24pLCBjb250ZXh0KTtcclxuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeSA9IG51bGw7XHJcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlTZWxlY3RvciA9IHBhcmVudFNlbGVjdG9yO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IDExIC8qIFF1ZXJ5ICovLFxyXG4gICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXHJcbiAgICAgICAgICAgIGxpbWl0OiBvcHRpb25zLmxpbWl0IHx8IDAsXHJcbiAgICAgICAgICAgIG9wdGlvbmFsOiAhIW9wdGlvbnMub3B0aW9uYWwsIGluY2x1ZGVTZWxmOiBpbmNsdWRlU2VsZiwgYW5pbWF0aW9uOiBhbmltYXRpb24sXHJcbiAgICAgICAgICAgIG9yaWdpbmFsU2VsZWN0b3I6IG1ldGFkYXRhLnNlbGVjdG9yLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U3RhZ2dlciA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAoIWNvbnRleHQuY3VycmVudFF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goXCJzdGFnZ2VyKCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgb2YgcXVlcnkoKVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltaW5ncyA9IG1ldGFkYXRhLnRpbWluZ3MgPT09ICdmdWxsJyA/XHJcbiAgICAgICAgICAgIHsgZHVyYXRpb246IDAsIGRlbGF5OiAwLCBlYXNpbmc6ICdmdWxsJyB9IDpcclxuICAgICAgICAgICAgcmVzb2x2ZVRpbWluZyhtZXRhZGF0YS50aW1pbmdzLCBjb250ZXh0LmVycm9ycywgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogMTIgLyogU3RhZ2dlciAqLyxcclxuICAgICAgICAgICAgYW5pbWF0aW9uOiB2aXNpdERzbE5vZGUodGhpcywgbm9ybWFsaXplQW5pbWF0aW9uRW50cnkobWV0YWRhdGEuYW5pbWF0aW9uKSwgY29udGV4dCksIHRpbWluZ3M6IHRpbWluZ3MsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvcjtcclxufSgpKTtcclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gc2VsZWN0b3JcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdG9yKHNlbGVjdG9yKSB7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYXNBbXBlcnNhbmQgPSBzZWxlY3Rvci5zcGxpdCgvXFxzKixcXHMqLykuZmluZChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuID09IFNFTEZfVE9LRU47IH0pID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgaWYgKGhhc0FtcGVyc2FuZCkge1xyXG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShTRUxGX1RPS0VOX1JFR0VYLCAnJyk7XHJcbiAgICB9XHJcbiAgICAvLyB0aGUgOmVudGVyIGFuZCA6bGVhdmUgc2VsZWN0b3JzIGFyZSBmaWxsZWQgaW4gYXQgcnVudGltZSBkdXJpbmcgdGltZWxpbmUgYnVpbGRpbmdcclxuICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvQFxcKi9nLCBOR19UUklHR0VSX1NFTEVDVE9SKVxyXG4gICAgICAgIC5yZXBsYWNlKC9AXFx3Ky9nLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIE5HX1RSSUdHRVJfU0VMRUNUT1IgKyAnLScgKyBtYXRjaC5zdWJzdHIoMSk7IH0pXHJcbiAgICAgICAgLnJlcGxhY2UoLzphbmltYXRpbmcvZywgTkdfQU5JTUFUSU5HX1NFTEVDVE9SKTtcclxuICAgIHJldHVybiBbc2VsZWN0b3IsIGhhc0FtcGVyc2FuZF07XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gb2JqXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVQYXJhbXMob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqID8gY29weU9iaihvYmopIDogbnVsbDtcclxufVxyXG52YXIgQW5pbWF0aW9uQXN0QnVpbGRlckNvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBbmltYXRpb25Bc3RCdWlsZGVyQ29udGV4dChlcnJvcnMpIHtcclxuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcclxuICAgICAgICB0aGlzLnF1ZXJ5Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuZGVwQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFRyYW5zaXRpb24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFF1ZXJ5ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRRdWVyeVNlbGVjdG9yID0gbnVsbDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRlVGltaW5ncyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0ZWRTdHlsZXMgPSB7fTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFuaW1hdGlvbkFzdEJ1aWxkZXJDb250ZXh0O1xyXG59KCkpO1xyXG4vKipcclxuICogQHBhcmFtIHs/fSBzdHlsZXNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGNvbnN1bWVPZmZzZXQoc3R5bGVzKSB7XHJcbiAgICBpZiAodHlwZW9mIHN0eWxlcyA9PSAnc3RyaW5nJylcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IG51bGw7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZXMpKSB7XHJcbiAgICAgICAgc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlVHVwbGUpIHtcclxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHN0eWxlVHVwbGUpICYmIHN0eWxlVHVwbGUuaGFzT3duUHJvcGVydHkoJ29mZnNldCcpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvYmogPSAvKiogQHR5cGUgez99ICovIChzdHlsZVR1cGxlKTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHBhcnNlRmxvYXQoLyoqIEB0eXBlIHs/fSAqLyAob2JqWydvZmZzZXQnXSkpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG9ialsnb2Zmc2V0J107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHN0eWxlcykgJiYgc3R5bGVzLmhhc093blByb3BlcnR5KCdvZmZzZXQnKSkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9iaiA9IC8qKiBAdHlwZSB7P30gKi8gKHN0eWxlcyk7XHJcbiAgICAgICAgb2Zmc2V0ID0gcGFyc2VGbG9hdCgvKiogQHR5cGUgez99ICovIChvYmpbJ29mZnNldCddKSk7XHJcbiAgICAgICAgZGVsZXRlIG9ialsnb2Zmc2V0J107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2Zmc2V0O1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHZhbHVlXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gdmFsdWVcclxuICogQHBhcmFtIHs/fSBlcnJvcnNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGNvbnN0cnVjdFRpbWluZ0FzdCh2YWx1ZSwgZXJyb3JzKSB7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1pbmdzID0gbnVsbDtcclxuICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnZHVyYXRpb24nKSkge1xyXG4gICAgICAgIHRpbWluZ3MgPSAvKiogQHR5cGUgez99ICovICh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkdXJhdGlvbiA9IHJlc29sdmVUaW1pbmcoLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpLCBlcnJvcnMpLmR1cmF0aW9uO1xyXG4gICAgICAgIHJldHVybiBtYWtlVGltaW5nQXN0KC8qKiBAdHlwZSB7P30gKi8gKGR1cmF0aW9uKSwgMCwgJycpO1xyXG4gICAgfVxyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyVmFsdWUgPSAvKiogQHR5cGUgez99ICovICh2YWx1ZSk7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0R5bmFtaWMgPSBzdHJWYWx1ZS5zcGxpdCgvXFxzKy8pLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuY2hhckF0KDApID09ICd7JyAmJiB2LmNoYXJBdCgxKSA9PSAneyc7IH0pO1xyXG4gICAgaWYgKGlzRHluYW1pYykge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IC8qKiBAdHlwZSB7P30gKi8gKG1ha2VUaW1pbmdBc3QoMCwgMCwgJycpKTtcclxuICAgICAgICBhc3QuZHluYW1pYyA9IHRydWU7XHJcbiAgICAgICAgYXN0LnN0clZhbHVlID0gc3RyVmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7P30gKi8gKGFzdCk7XHJcbiAgICB9XHJcbiAgICB0aW1pbmdzID0gdGltaW5ncyB8fCByZXNvbHZlVGltaW5nKHN0clZhbHVlLCBlcnJvcnMpO1xyXG4gICAgcmV0dXJuIG1ha2VUaW1pbmdBc3QodGltaW5ncy5kdXJhdGlvbiwgdGltaW5ncy5kZWxheSwgdGltaW5ncy5lYXNpbmcpO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IG9wdGlvbnNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gY29weU9iaihvcHRpb25zKTtcclxuICAgICAgICBpZiAob3B0aW9uc1sncGFyYW1zJ10pIHtcclxuICAgICAgICAgICAgb3B0aW9uc1sncGFyYW1zJ10gPSAvKiogQHR5cGUgez99ICovICgobm9ybWFsaXplUGFyYW1zKG9wdGlvbnNbJ3BhcmFtcyddKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuICAgIHJldHVybiBvcHRpb25zO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IGR1cmF0aW9uXHJcbiAqIEBwYXJhbSB7P30gZGVsYXlcclxuICogQHBhcmFtIHs/fSBlYXNpbmdcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VUaW1pbmdBc3QoZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpIHtcclxuICAgIHJldHVybiB7IGR1cmF0aW9uOiBkdXJhdGlvbiwgZGVsYXk6IGRlbGF5LCBlYXNpbmc6IGVhc2luZyB9O1xyXG59XHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbi8qKlxyXG4gKiBAcmVjb3JkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gKiBAcGFyYW0gez99IGtleWZyYW1lc1xyXG4gKiBAcGFyYW0gez99IHByZVN0eWxlUHJvcHNcclxuICogQHBhcmFtIHs/fSBwb3N0U3R5bGVQcm9wc1xyXG4gKiBAcGFyYW0gez99IGR1cmF0aW9uXHJcbiAqIEBwYXJhbSB7P30gZGVsYXlcclxuICogQHBhcmFtIHs/PX0gZWFzaW5nXHJcbiAqIEBwYXJhbSB7Pz19IHN1YlRpbWVsaW5lXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVUaW1lbGluZUluc3RydWN0aW9uKGVsZW1lbnQsIGtleWZyYW1lcywgcHJlU3R5bGVQcm9wcywgcG9zdFN0eWxlUHJvcHMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBzdWJUaW1lbGluZSkge1xyXG4gICAgaWYgKGVhc2luZyA9PT0gdm9pZCAwKSB7IGVhc2luZyA9IG51bGw7IH1cclxuICAgIGlmIChzdWJUaW1lbGluZSA9PT0gdm9pZCAwKSB7IHN1YlRpbWVsaW5lID0gZmFsc2U7IH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMSAvKiBUaW1lbGluZUFuaW1hdGlvbiAqLyxcclxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgICAgIGtleWZyYW1lczoga2V5ZnJhbWVzLFxyXG4gICAgICAgIHByZVN0eWxlUHJvcHM6IHByZVN0eWxlUHJvcHMsXHJcbiAgICAgICAgcG9zdFN0eWxlUHJvcHM6IHBvc3RTdHlsZVByb3BzLFxyXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcclxuICAgICAgICBkZWxheTogZGVsYXksXHJcbiAgICAgICAgdG90YWxUaW1lOiBkdXJhdGlvbiArIGRlbGF5LCBlYXNpbmc6IGVhc2luZywgc3ViVGltZWxpbmU6IHN1YlRpbWVsaW5lXHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbnZhciBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAoKSB7XHJcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEVsZW1lbnRJbnN0cnVjdGlvbk1hcC5wcm90b3R5cGUuY29uc3VtZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluc3RydWN0aW9ucyA9IHRoaXMuX21hcC5nZXQoZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKGluc3RydWN0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbnM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gaW5zdHJ1Y3Rpb25zXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAucHJvdG90eXBlLmFwcGVuZCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIGluc3RydWN0aW9ucykge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4aXN0aW5nSW5zdHJ1Y3Rpb25zID0gdGhpcy5fbWFwLmdldChlbGVtZW50KTtcclxuICAgICAgICBpZiAoIWV4aXN0aW5nSW5zdHJ1Y3Rpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcC5zZXQoZWxlbWVudCwgZXhpc3RpbmdJbnN0cnVjdGlvbnMgPSBbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4aXN0aW5nSW5zdHJ1Y3Rpb25zLnB1c2guYXBwbHkoZXhpc3RpbmdJbnN0cnVjdGlvbnMsIGluc3RydWN0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEVsZW1lbnRJbnN0cnVjdGlvbk1hcC5wcm90b3R5cGUuaGFzID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiB0aGlzLl9tYXAuaGFzKGVsZW1lbnQpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAucHJvdG90eXBlLmNsZWFyID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IHRoaXMuX21hcC5jbGVhcigpOyB9O1xyXG4gICAgcmV0dXJuIEVsZW1lbnRJbnN0cnVjdGlvbk1hcDtcclxufSgpKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxudmFyIE9ORV9GUkFNRV9JTl9NSUxMSVNFQ09ORFMgPSAxO1xyXG52YXIgRU5URVJfVE9LRU4gPSAnOmVudGVyJztcclxudmFyIEVOVEVSX1RPS0VOX1JFR0VYID0gbmV3IFJlZ0V4cChFTlRFUl9UT0tFTiwgJ2cnKTtcclxudmFyIExFQVZFX1RPS0VOID0gJzpsZWF2ZSc7XHJcbnZhciBMRUFWRV9UT0tFTl9SRUdFWCA9IG5ldyBSZWdFeHAoTEVBVkVfVE9LRU4sICdnJyk7XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IGRyaXZlclxyXG4gKiBAcGFyYW0gez99IHJvb3RFbGVtZW50XHJcbiAqIEBwYXJhbSB7P30gYXN0XHJcbiAqIEBwYXJhbSB7P30gZW50ZXJDbGFzc05hbWVcclxuICogQHBhcmFtIHs/fSBsZWF2ZUNsYXNzTmFtZVxyXG4gKiBAcGFyYW0gez89fSBzdGFydGluZ1N0eWxlc1xyXG4gKiBAcGFyYW0gez89fSBmaW5hbFN0eWxlc1xyXG4gKiBAcGFyYW0gez89fSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7Pz19IHN1Ykluc3RydWN0aW9uc1xyXG4gKiBAcGFyYW0gez89fSBlcnJvcnNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGJ1aWxkQW5pbWF0aW9uVGltZWxpbmVzKGRyaXZlciwgcm9vdEVsZW1lbnQsIGFzdCwgZW50ZXJDbGFzc05hbWUsIGxlYXZlQ2xhc3NOYW1lLCBzdGFydGluZ1N0eWxlcywgZmluYWxTdHlsZXMsIG9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucywgZXJyb3JzKSB7XHJcbiAgICBpZiAoc3RhcnRpbmdTdHlsZXMgPT09IHZvaWQgMCkgeyBzdGFydGluZ1N0eWxlcyA9IHt9OyB9XHJcbiAgICBpZiAoZmluYWxTdHlsZXMgPT09IHZvaWQgMCkgeyBmaW5hbFN0eWxlcyA9IHt9OyB9XHJcbiAgICBpZiAoZXJyb3JzID09PSB2b2lkIDApIHsgZXJyb3JzID0gW107IH1cclxuICAgIHJldHVybiBuZXcgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvcigpLmJ1aWxkS2V5ZnJhbWVzKGRyaXZlciwgcm9vdEVsZW1lbnQsIGFzdCwgZW50ZXJDbGFzc05hbWUsIGxlYXZlQ2xhc3NOYW1lLCBzdGFydGluZ1N0eWxlcywgZmluYWxTdHlsZXMsIG9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucywgZXJyb3JzKTtcclxufVxyXG52YXIgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZHJpdmVyXHJcbiAgICAgKiBAcGFyYW0gez99IHJvb3RFbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGFzdFxyXG4gICAgICogQHBhcmFtIHs/fSBlbnRlckNsYXNzTmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSBsZWF2ZUNsYXNzTmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSBzdGFydGluZ1N0eWxlc1xyXG4gICAgICogQHBhcmFtIHs/fSBmaW5hbFN0eWxlc1xyXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gez89fSBzdWJJbnN0cnVjdGlvbnNcclxuICAgICAqIEBwYXJhbSB7Pz19IGVycm9yc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuYnVpbGRLZXlmcmFtZXMgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZHJpdmVyXHJcbiAgICAgKiBAcGFyYW0gez99IHJvb3RFbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGFzdFxyXG4gICAgICogQHBhcmFtIHs/fSBlbnRlckNsYXNzTmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSBsZWF2ZUNsYXNzTmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSBzdGFydGluZ1N0eWxlc1xyXG4gICAgICogQHBhcmFtIHs/fSBmaW5hbFN0eWxlc1xyXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gez89fSBzdWJJbnN0cnVjdGlvbnNcclxuICAgICAqIEBwYXJhbSB7Pz19IGVycm9yc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGRyaXZlciwgcm9vdEVsZW1lbnQsIGFzdCwgZW50ZXJDbGFzc05hbWUsIGxlYXZlQ2xhc3NOYW1lLCBzdGFydGluZ1N0eWxlcywgZmluYWxTdHlsZXMsIG9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucywgZXJyb3JzKSB7XHJcbiAgICAgICAgaWYgKGVycm9ycyA9PT0gdm9pZCAwKSB7IGVycm9ycyA9IFtdOyB9XHJcbiAgICAgICAgc3ViSW5zdHJ1Y3Rpb25zID0gc3ViSW5zdHJ1Y3Rpb25zIHx8IG5ldyBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAoKTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZXh0ID0gbmV3IEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dChkcml2ZXIsIHJvb3RFbGVtZW50LCBzdWJJbnN0cnVjdGlvbnMsIGVudGVyQ2xhc3NOYW1lLCBsZWF2ZUNsYXNzTmFtZSwgZXJyb3JzLCBbXSk7XHJcbiAgICAgICAgY29udGV4dC5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5zZXRTdHlsZXMoW3N0YXJ0aW5nU3R5bGVzXSwgbnVsbCwgY29udGV4dC5lcnJvcnMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHZpc2l0RHNsTm9kZSh0aGlzLCBhc3QsIGNvbnRleHQpO1xyXG4gICAgICAgIC8vIHRoaXMgY2hlY2tzIHRvIHNlZSBpZiBhbiBhY3R1YWwgYW5pbWF0aW9uIGhhcHBlbmVkXHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltZWxpbmVzID0gY29udGV4dC50aW1lbGluZXMuZmlsdGVyKGZ1bmN0aW9uICh0aW1lbGluZSkgeyByZXR1cm4gdGltZWxpbmUuY29udGFpbnNBbmltYXRpb24oKTsgfSk7XHJcbiAgICAgICAgaWYgKHRpbWVsaW5lcy5sZW5ndGggJiYgT2JqZWN0LmtleXMoZmluYWxTdHlsZXMpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0bCA9IHRpbWVsaW5lc1t0aW1lbGluZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGlmICghdGwuYWxsb3dPbmx5VGltZWxpbmVTdHlsZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgdGwuc2V0U3R5bGVzKFtmaW5hbFN0eWxlc10sIG51bGwsIGNvbnRleHQuZXJyb3JzLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGltZWxpbmVzLmxlbmd0aCA/IHRpbWVsaW5lcy5tYXAoZnVuY3Rpb24gKHRpbWVsaW5lKSB7IHJldHVybiB0aW1lbGluZS5idWlsZEtleWZyYW1lcygpOyB9KSA6XHJcbiAgICAgICAgICAgIFtjcmVhdGVUaW1lbGluZUluc3RydWN0aW9uKHJvb3RFbGVtZW50LCBbXSwgW10sIFtdLCAwLCAwLCAnJywgZmFsc2UpXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHJpZ2dlciA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBhc3RcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xyXG4gICAgICAgIC8vIHRoZXNlIHZhbHVlcyBhcmUgbm90IHZpc2l0ZWQgaW4gdGhpcyBBU1RcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U3RhdGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICAvLyB0aGVzZSB2YWx1ZXMgYXJlIG5vdCB2aXNpdGVkIGluIHRoaXMgQVNUXHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGFzdFxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyYW5zaXRpb24gPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICAvLyB0aGVzZSB2YWx1ZXMgYXJlIG5vdCB2aXNpdGVkIGluIHRoaXMgQVNUXHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGFzdFxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFuaW1hdGVDaGlsZCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBhc3RcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRJbnN0cnVjdGlvbnMgPSBjb250ZXh0LnN1Ykluc3RydWN0aW9ucy5jb25zdW1lKGNvbnRleHQuZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKGVsZW1lbnRJbnN0cnVjdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJDb250ZXh0ID0gY29udGV4dC5jcmVhdGVTdWJDb250ZXh0KGFzdC5vcHRpb25zKTtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRUaW1lID0gY29udGV4dC5jdXJyZW50VGltZWxpbmUuY3VycmVudFRpbWU7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZFRpbWUgPSB0aGlzLl92aXNpdFN1Ykluc3RydWN0aW9ucyhlbGVtZW50SW5zdHJ1Y3Rpb25zLCBpbm5lckNvbnRleHQsIC8qKiBAdHlwZSB7P30gKi8gKGlubmVyQ29udGV4dC5vcHRpb25zKSk7XHJcbiAgICAgICAgICAgIGlmIChzdGFydFRpbWUgIT0gZW5kVGltZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgZG8gdGhpcyBvbiB0aGUgdXBwZXIgY29udGV4dCBiZWNhdXNlIHdlIGNyZWF0ZWQgYSBzdWIgY29udGV4dCBmb3JcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdWIgY2hpbGQgYW5pbWF0aW9uc1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUoZW5kVGltZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGFzdFxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFuaW1hdGVSZWYgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lckNvbnRleHQgPSBjb250ZXh0LmNyZWF0ZVN1YkNvbnRleHQoYXN0Lm9wdGlvbnMpO1xyXG4gICAgICAgIGlubmVyQ29udGV4dC50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUoKTtcclxuICAgICAgICB0aGlzLnZpc2l0UmVmZXJlbmNlKGFzdC5hbmltYXRpb24sIGlubmVyQ29udGV4dCk7XHJcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUoaW5uZXJDb250ZXh0LmN1cnJlbnRUaW1lbGluZS5jdXJyZW50VGltZSk7XHJcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uc1xyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdFN1Ykluc3RydWN0aW9ucyA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvbnNcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb25zLCBjb250ZXh0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRUaW1lID0gY29udGV4dC5jdXJyZW50VGltZWxpbmUuY3VycmVudFRpbWU7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnVydGhlc3RUaW1lID0gc3RhcnRUaW1lO1xyXG4gICAgICAgIC8vIHRoaXMgaXMgYSBzcGVjaWFsLWNhc2UgZm9yIHdoZW4gYSB1c2VyIHdhbnRzIHRvIHNraXAgYSBzdWJcclxuICAgICAgICAvLyBhbmltYXRpb24gZnJvbSBiZWluZyBmaXJlZCBlbnRpcmVseS5cclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gIT0gbnVsbCA/IHJlc29sdmVUaW1pbmdWYWx1ZShvcHRpb25zLmR1cmF0aW9uKSA6IG51bGw7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVsYXkgPSBvcHRpb25zLmRlbGF5ICE9IG51bGwgPyByZXNvbHZlVGltaW5nVmFsdWUob3B0aW9ucy5kZWxheSkgOiBudWxsO1xyXG4gICAgICAgIGlmIChkdXJhdGlvbiAhPT0gMCkge1xyXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluc3RydWN0aW9uVGltaW5ncyA9IGNvbnRleHQuYXBwZW5kSW5zdHJ1Y3Rpb25Ub1RpbWVsaW5lKGluc3RydWN0aW9uLCBkdXJhdGlvbiwgZGVsYXkpO1xyXG4gICAgICAgICAgICAgICAgZnVydGhlc3RUaW1lID1cclxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChmdXJ0aGVzdFRpbWUsIGluc3RydWN0aW9uVGltaW5ncy5kdXJhdGlvbiArIGluc3RydWN0aW9uVGltaW5ncy5kZWxheSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVydGhlc3RUaW1lO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBhc3RcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0LnVwZGF0ZU9wdGlvbnMoYXN0Lm9wdGlvbnMsIHRydWUpO1xyXG4gICAgICAgIHZpc2l0RHNsTm9kZSh0aGlzLCBhc3QuYW5pbWF0aW9uLCBjb250ZXh0KTtcclxuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2VxdWVuY2UgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1YkNvbnRleHRDb3VudCA9IGNvbnRleHQuc3ViQ29udGV4dENvdW50O1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0eCA9IGNvbnRleHQ7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0aW9ucyA9IGFzdC5vcHRpb25zO1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIChvcHRpb25zLnBhcmFtcyB8fCBvcHRpb25zLmRlbGF5KSkge1xyXG4gICAgICAgICAgICBjdHggPSBjb250ZXh0LmNyZWF0ZVN1YkNvbnRleHQob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUoKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVsYXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN0eC5wcmV2aW91c05vZGUudHlwZSA9PSA2IC8qIFN0eWxlICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmN1cnJlbnRUaW1lbGluZS5zbmFwc2hvdEN1cnJlbnRTdHlsZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBjdHgucHJldmlvdXNOb2RlID0gREVGQVVMVF9OT09QX1BSRVZJT1VTX05PREU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWxheSA9IHJlc29sdmVUaW1pbmdWYWx1ZShvcHRpb25zLmRlbGF5KTtcclxuICAgICAgICAgICAgICAgIGN0eC5kZWxheU5leHRTdGVwKGRlbGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXN0LnN0ZXBzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBhc3Quc3RlcHMuZm9yRWFjaChmdW5jdGlvbiAocykgeyByZXR1cm4gdmlzaXREc2xOb2RlKF90aGlzLCBzLCBjdHgpOyB9KTtcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBoZXJlIGp1c3QgaW5jYXNlIHRoZSBpbm5lciBzdGVwcyBvbmx5IGNvbnRhaW4gb3IgZW5kIHdpdGggYSBzdHlsZSgpIGNhbGxcclxuICAgICAgICAgICAgY3R4LmN1cnJlbnRUaW1lbGluZS5hcHBseVN0eWxlc1RvS2V5ZnJhbWUoKTtcclxuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHNvbWUgYW5pbWF0aW9uIGZ1bmN0aW9uIHdpdGhpbiB0aGUgc2VxdWVuY2VcclxuICAgICAgICAgICAgLy8gZW5kZWQgdXAgY3JlYXRpbmcgYSBzdWIgdGltZWxpbmUgKHdoaWNoIG1lYW5zIHRoZSBjdXJyZW50XHJcbiAgICAgICAgICAgIC8vIHRpbWVsaW5lIGNhbm5vdCBvdmVybGFwIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBzZXF1ZW5jZSlcclxuICAgICAgICAgICAgaWYgKGN0eC5zdWJDb250ZXh0Q291bnQgPiBzdWJDb250ZXh0Q291bnQpIHtcclxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0R3JvdXAgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyVGltZWxpbmVzID0gW107XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnVydGhlc3RUaW1lID0gY29udGV4dC5jdXJyZW50VGltZWxpbmUuY3VycmVudFRpbWU7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVsYXkgPSBhc3Qub3B0aW9ucyAmJiBhc3Qub3B0aW9ucy5kZWxheSA/IHJlc29sdmVUaW1pbmdWYWx1ZShhc3Qub3B0aW9ucy5kZWxheSkgOiAwO1xyXG4gICAgICAgIGFzdC5zdGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dChhc3Qub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGlmIChkZWxheSkge1xyXG4gICAgICAgICAgICAgICAgaW5uZXJDb250ZXh0LmRlbGF5TmV4dFN0ZXAoZGVsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZpc2l0RHNsTm9kZShfdGhpcywgcywgaW5uZXJDb250ZXh0KTtcclxuICAgICAgICAgICAgZnVydGhlc3RUaW1lID0gTWF0aC5tYXgoZnVydGhlc3RUaW1lLCBpbm5lckNvbnRleHQuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lKTtcclxuICAgICAgICAgICAgaW5uZXJUaW1lbGluZXMucHVzaChpbm5lckNvbnRleHQuY3VycmVudFRpbWVsaW5lKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyB0aGlzIG9wZXJhdGlvbiBpcyBydW4gYWZ0ZXIgdGhlIEFTVCBsb29wIGJlY2F1c2Ugb3RoZXJ3aXNlXHJcbiAgICAgICAgLy8gaWYgdGhlIHBhcmVudCB0aW1lbGluZSdzIGNvbGxlY3RlZCBzdHlsZXMgd2VyZSB1cGRhdGVkIHRoZW5cclxuICAgICAgICAvLyBpdCB3b3VsZCBwYXNzIGluIGludmFsaWQgZGF0YSBpbnRvIHRoZSBuZXctdG8tYmUgZm9ya2VkIGl0ZW1zXHJcbiAgICAgICAgaW5uZXJUaW1lbGluZXMuZm9yRWFjaChmdW5jdGlvbiAodGltZWxpbmUpIHsgcmV0dXJuIGNvbnRleHQuY3VycmVudFRpbWVsaW5lLm1lcmdlVGltZWxpbmVDb2xsZWN0ZWRTdHlsZXModGltZWxpbmUpOyB9KTtcclxuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybUludG9OZXdUaW1lbGluZShmdXJ0aGVzdFRpbWUpO1xyXG4gICAgICAgIGNvbnRleHQucHJldmlvdXNOb2RlID0gYXN0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBhc3RcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0VGltaW5nID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGFzdFxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKCgvKiogQHR5cGUgez99ICovIChhc3QpKS5keW5hbWljKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0clZhbHVlID0gKC8qKiBAdHlwZSB7P30gKi8gKGFzdCkpLnN0clZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1pbmdWYWx1ZSA9IGNvbnRleHQucGFyYW1zID8gaW50ZXJwb2xhdGVQYXJhbXMoc3RyVmFsdWUsIGNvbnRleHQucGFyYW1zLCBjb250ZXh0LmVycm9ycykgOiBzdHJWYWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVUaW1pbmcodGltaW5nVmFsdWUsIGNvbnRleHQuZXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGR1cmF0aW9uOiBhc3QuZHVyYXRpb24sIGRlbGF5OiBhc3QuZGVsYXksIGVhc2luZzogYXN0LmVhc2luZyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QW5pbWF0ZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBhc3RcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWluZ3MgPSBjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncyA9IHRoaXMuX3Zpc2l0VGltaW5nKGFzdC50aW1pbmdzLCBjb250ZXh0KTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lbGluZSA9IGNvbnRleHQuY3VycmVudFRpbWVsaW5lO1xyXG4gICAgICAgIGlmICh0aW1pbmdzLmRlbGF5KSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaW5jcmVtZW50VGltZSh0aW1pbmdzLmRlbGF5KTtcclxuICAgICAgICAgICAgdGltZWxpbmUuc25hcHNob3RDdXJyZW50U3R5bGVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlJCQxID0gYXN0LnN0eWxlO1xyXG4gICAgICAgIGlmIChzdHlsZSQkMS50eXBlID09IDUgLyogS2V5ZnJhbWVzICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaXRLZXlmcmFtZXMoc3R5bGUkJDEsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29udGV4dC5pbmNyZW1lbnRUaW1lKHRpbWluZ3MuZHVyYXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2l0U3R5bGUoLyoqIEB0eXBlIHs/fSAqLyAoc3R5bGUkJDEpLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgdGltZWxpbmUuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQuY3VycmVudEFuaW1hdGVUaW1pbmdzID0gbnVsbDtcclxuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U3R5bGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lbGluZSA9IGNvbnRleHQuY3VycmVudFRpbWVsaW5lO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWluZ3MgPSAvKiogQHR5cGUgez99ICovICgoY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MpKTtcclxuICAgICAgICAvLyB0aGlzIGlzIGEgc3BlY2lhbCBjYXNlIGZvciB3aGVuIGEgc3R5bGUoKSBjYWxsXHJcbiAgICAgICAgLy8gZGlyZWN0bHkgZm9sbG93cyAgYW4gYW5pbWF0ZSgpIGNhbGwgKGJ1dCBub3QgaW5zaWRlIG9mIGFuIGFuaW1hdGUoKSBjYWxsKVxyXG4gICAgICAgIGlmICghdGltaW5ncyAmJiB0aW1lbGluZS5nZXRDdXJyZW50U3R5bGVQcm9wZXJ0aWVzKCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRpbWVsaW5lLmZvcndhcmRGcmFtZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlYXNpbmcgPSAodGltaW5ncyAmJiB0aW1pbmdzLmVhc2luZykgfHwgYXN0LmVhc2luZztcclxuICAgICAgICBpZiAoYXN0LmlzRW1wdHlTdGVwKSB7XHJcbiAgICAgICAgICAgIHRpbWVsaW5lLmFwcGx5RW1wdHlTdGVwKGVhc2luZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aW1lbGluZS5zZXRTdHlsZXMoYXN0LnN0eWxlcywgZWFzaW5nLCBjb250ZXh0LmVycm9ycywgY29udGV4dC5vcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGFzdFxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWZyYW1lcyA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBhc3RcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRBbmltYXRlVGltaW5ncyA9IC8qKiBAdHlwZSB7P30gKi8gKChjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncykpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0VGltZSA9ICgvKiogQHR5cGUgez99ICovICgoY29udGV4dC5jdXJyZW50VGltZWxpbmUpKSkuZHVyYXRpb247XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHVyYXRpb24gPSBjdXJyZW50QW5pbWF0ZVRpbWluZ3MuZHVyYXRpb247XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJDb250ZXh0ID0gY29udGV4dC5jcmVhdGVTdWJDb250ZXh0KCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJUaW1lbGluZSA9IGlubmVyQ29udGV4dC5jdXJyZW50VGltZWxpbmU7XHJcbiAgICAgICAgaW5uZXJUaW1lbGluZS5lYXNpbmcgPSBjdXJyZW50QW5pbWF0ZVRpbWluZ3MuZWFzaW5nO1xyXG4gICAgICAgIGFzdC5zdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvZmZzZXQgPSBzdGVwLm9mZnNldCB8fCAwO1xyXG4gICAgICAgICAgICBpbm5lclRpbWVsaW5lLmZvcndhcmRUaW1lKG9mZnNldCAqIGR1cmF0aW9uKTtcclxuICAgICAgICAgICAgaW5uZXJUaW1lbGluZS5zZXRTdHlsZXMoc3RlcC5zdHlsZXMsIHN0ZXAuZWFzaW5nLCBjb250ZXh0LmVycm9ycywgY29udGV4dC5vcHRpb25zKTtcclxuICAgICAgICAgICAgaW5uZXJUaW1lbGluZS5hcHBseVN0eWxlc1RvS2V5ZnJhbWUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyB0aGlzIHdpbGwgZW5zdXJlIHRoYXQgdGhlIHBhcmVudCB0aW1lbGluZSBnZXRzIGFsbCB0aGUgc3R5bGVzIGZyb21cclxuICAgICAgICAvLyB0aGUgY2hpbGQgZXZlbiBpZiB0aGUgbmV3IHRpbWVsaW5lIGJlbG93IGlzIG5vdCB1c2VkXHJcbiAgICAgICAgY29udGV4dC5jdXJyZW50VGltZWxpbmUubWVyZ2VUaW1lbGluZUNvbGxlY3RlZFN0eWxlcyhpbm5lclRpbWVsaW5lKTtcclxuICAgICAgICAvLyB3ZSBkbyB0aGlzIGJlY2F1c2UgdGhlIHdpbmRvdyBiZXR3ZWVuIHRoaXMgdGltZWxpbmUgYW5kIHRoZSBzdWIgdGltZWxpbmVcclxuICAgICAgICAvLyBzaG91bGQgZW5zdXJlIHRoYXQgdGhlIHN0eWxlcyB3aXRoaW4gYXJlIGV4YWN0bHkgdGhlIHNhbWUgYXMgdGhleSB3ZXJlIGJlZm9yZVxyXG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKHN0YXJ0VGltZSArIGR1cmF0aW9uKTtcclxuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UXVlcnkgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIGluIHRoZSBldmVudCB0aGF0IHRoZSBmaXJzdCBzdGVwIGJlZm9yZSB0aGlzIGlzIGEgc3R5bGUgc3RlcCB3ZSBuZWVkXHJcbiAgICAgICAgLy8gdG8gZW5zdXJlIHRoZSBzdHlsZXMgYXJlIGFwcGxpZWQgYmVmb3JlIHRoZSBjaGlsZHJlbiBhcmUgYW5pbWF0ZWRcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5jdXJyZW50VGltZTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25zID0gLyoqIEB0eXBlIHs/fSAqLyAoKGFzdC5vcHRpb25zIHx8IHt9KSk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVsYXkgPSBvcHRpb25zLmRlbGF5ID8gcmVzb2x2ZVRpbWluZ1ZhbHVlKG9wdGlvbnMuZGVsYXkpIDogMDtcclxuICAgICAgICBpZiAoZGVsYXkgJiYgKGNvbnRleHQucHJldmlvdXNOb2RlLnR5cGUgPT09IDYgLyogU3R5bGUgKi8gfHxcclxuICAgICAgICAgICAgKHN0YXJ0VGltZSA9PSAwICYmIGNvbnRleHQuY3VycmVudFRpbWVsaW5lLmdldEN1cnJlbnRTdHlsZVByb3BlcnRpZXMoKS5sZW5ndGgpKSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5zbmFwc2hvdEN1cnJlbnRTdHlsZXMoKTtcclxuICAgICAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBERUZBVUxUX05PT1BfUFJFVklPVVNfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnVydGhlc3RUaW1lID0gc3RhcnRUaW1lO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsbXMgPSBjb250ZXh0Lmludm9rZVF1ZXJ5KGFzdC5zZWxlY3RvciwgYXN0Lm9yaWdpbmFsU2VsZWN0b3IsIGFzdC5saW1pdCwgYXN0LmluY2x1ZGVTZWxmLCBvcHRpb25zLm9wdGlvbmFsID8gdHJ1ZSA6IGZhbHNlLCBjb250ZXh0LmVycm9ycyk7XHJcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlUb3RhbCA9IGVsbXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNhbWVFbGVtZW50VGltZWxpbmUgPSBudWxsO1xyXG4gICAgICAgIGVsbXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeUluZGV4ID0gaTtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJDb250ZXh0ID0gY29udGV4dC5jcmVhdGVTdWJDb250ZXh0KGFzdC5vcHRpb25zLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgaWYgKGRlbGF5KSB7XHJcbiAgICAgICAgICAgICAgICBpbm5lckNvbnRleHQuZGVsYXlOZXh0U3RlcChkZWxheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IGNvbnRleHQuZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgc2FtZUVsZW1lbnRUaW1lbGluZSA9IGlubmVyQ29udGV4dC5jdXJyZW50VGltZWxpbmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmlzaXREc2xOb2RlKF90aGlzLCBhc3QuYW5pbWF0aW9uLCBpbm5lckNvbnRleHQpO1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGhlcmUganVzdCBpbmNhc2UgdGhlIGlubmVyIHN0ZXBzIG9ubHkgY29udGFpbiBvciBlbmRcclxuICAgICAgICAgICAgLy8gd2l0aCBhIHN0eWxlKCkgY2FsbCAod2hpY2ggaXMgaGVyZSB0byBzaWduYWwgdGhhdCB0aGlzIGlzIGEgcHJlcGFyYXRvcnlcclxuICAgICAgICAgICAgLy8gY2FsbCB0byBzdHlsZSBhbiBlbGVtZW50IGJlZm9yZSBpdCBpcyBhbmltYXRlZCBhZ2FpbilcclxuICAgICAgICAgICAgaW5uZXJDb250ZXh0LmN1cnJlbnRUaW1lbGluZS5hcHBseVN0eWxlc1RvS2V5ZnJhbWUoKTtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kVGltZSA9IGlubmVyQ29udGV4dC5jdXJyZW50VGltZWxpbmUuY3VycmVudFRpbWU7XHJcbiAgICAgICAgICAgIGZ1cnRoZXN0VGltZSA9IE1hdGgubWF4KGZ1cnRoZXN0VGltZSwgZW5kVGltZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlJbmRleCA9IDA7XHJcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlUb3RhbCA9IDA7XHJcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUoZnVydGhlc3RUaW1lKTtcclxuICAgICAgICBpZiAoc2FtZUVsZW1lbnRUaW1lbGluZSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5tZXJnZVRpbWVsaW5lQ29sbGVjdGVkU3R5bGVzKHNhbWVFbGVtZW50VGltZWxpbmUpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5zbmFwc2hvdEN1cnJlbnRTdHlsZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGFzdFxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFN0YWdnZXIgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRDb250ZXh0ID0gLyoqIEB0eXBlIHs/fSAqLyAoKGNvbnRleHQucGFyZW50Q29udGV4dCkpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRsID0gY29udGV4dC5jdXJyZW50VGltZWxpbmU7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltaW5ncyA9IGFzdC50aW1pbmdzO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGR1cmF0aW9uID0gTWF0aC5hYnModGltaW5ncy5kdXJhdGlvbik7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF4VGltZSA9IGR1cmF0aW9uICogKGNvbnRleHQuY3VycmVudFF1ZXJ5VG90YWwgLSAxKTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWxheSA9IGR1cmF0aW9uICogY29udGV4dC5jdXJyZW50UXVlcnlJbmRleDtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFnZ2VyVHJhbnNmb3JtZXIgPSB0aW1pbmdzLmR1cmF0aW9uIDwgMCA/ICdyZXZlcnNlJyA6IHRpbWluZ3MuZWFzaW5nO1xyXG4gICAgICAgIHN3aXRjaCAoc3RhZ2dlclRyYW5zZm9ybWVyKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3JldmVyc2UnOlxyXG4gICAgICAgICAgICAgICAgZGVsYXkgPSBtYXhUaW1lIC0gZGVsYXk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZnVsbCc6XHJcbiAgICAgICAgICAgICAgICBkZWxheSA9IHBhcmVudENvbnRleHQuY3VycmVudFN0YWdnZXJUaW1lO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWVsaW5lID0gY29udGV4dC5jdXJyZW50VGltZWxpbmU7XHJcbiAgICAgICAgaWYgKGRlbGF5KSB7XHJcbiAgICAgICAgICAgIHRpbWVsaW5lLmRlbGF5TmV4dFN0ZXAoZGVsYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydGluZ1RpbWUgPSB0aW1lbGluZS5jdXJyZW50VGltZTtcclxuICAgICAgICB2aXNpdERzbE5vZGUodGhpcywgYXN0LmFuaW1hdGlvbiwgY29udGV4dCk7XHJcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XHJcbiAgICAgICAgLy8gdGltZSA9IGR1cmF0aW9uICsgZGVsYXlcclxuICAgICAgICAvLyB0aGUgcmVhc29uIHdoeSB0aGlzIGNvbXB1dGF0aW9uIGlzIHNvIGNvbXBsZXggaXMgYmVjYXVzZVxyXG4gICAgICAgIC8vIHRoZSBpbm5lciB0aW1lbGluZSBtYXkgZWl0aGVyIGhhdmUgYSBkZWxheSB2YWx1ZSBvciBhIHN0cmV0Y2hlZFxyXG4gICAgICAgIC8vIGtleWZyYW1lIGRlcGVuZGluZyBvbiBpZiBhIHN1YnRpbWVsaW5lIGlzIG5vdCB1c2VkIG9yIGlzIHVzZWQuXHJcbiAgICAgICAgcGFyZW50Q29udGV4dC5jdXJyZW50U3RhZ2dlclRpbWUgPVxyXG4gICAgICAgICAgICAodGwuY3VycmVudFRpbWUgLSBzdGFydGluZ1RpbWUpICsgKHRsLnN0YXJ0VGltZSAtIHBhcmVudENvbnRleHQuY3VycmVudFRpbWVsaW5lLnN0YXJ0VGltZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3I7XHJcbn0oKSk7XHJcbnZhciBERUZBVUxUX05PT1BfUFJFVklPVVNfTk9ERSA9IC8qKiBAdHlwZSB7P30gKi8gKHt9KTtcclxudmFyIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dChfZHJpdmVyLCBlbGVtZW50LCBzdWJJbnN0cnVjdGlvbnMsIF9lbnRlckNsYXNzTmFtZSwgX2xlYXZlQ2xhc3NOYW1lLCBlcnJvcnMsIHRpbWVsaW5lcywgaW5pdGlhbFRpbWVsaW5lKSB7XHJcbiAgICAgICAgdGhpcy5fZHJpdmVyID0gX2RyaXZlcjtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIHRoaXMuc3ViSW5zdHJ1Y3Rpb25zID0gc3ViSW5zdHJ1Y3Rpb25zO1xyXG4gICAgICAgIHRoaXMuX2VudGVyQ2xhc3NOYW1lID0gX2VudGVyQ2xhc3NOYW1lO1xyXG4gICAgICAgIHRoaXMuX2xlYXZlQ2xhc3NOYW1lID0gX2xlYXZlQ2xhc3NOYW1lO1xyXG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xyXG4gICAgICAgIHRoaXMudGltZWxpbmVzID0gdGltZWxpbmVzO1xyXG4gICAgICAgIHRoaXMucGFyZW50Q29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNOb2RlID0gREVGQVVMVF9OT09QX1BSRVZJT1VTX05PREU7XHJcbiAgICAgICAgdGhpcy5zdWJDb250ZXh0Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHRoaXMuY3VycmVudFF1ZXJ5SW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFF1ZXJ5VG90YWwgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YWdnZXJUaW1lID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lbGluZSA9IGluaXRpYWxUaW1lbGluZSB8fCBuZXcgVGltZWxpbmVCdWlsZGVyKHRoaXMuX2RyaXZlciwgZWxlbWVudCwgMCk7XHJcbiAgICAgICAgdGltZWxpbmVzLnB1c2godGhpcy5jdXJyZW50VGltZWxpbmUpO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUsIFwicGFyYW1zXCIsIHtcclxuICAgICAgICBnZXQ6IC8qKlxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5vcHRpb25zLnBhcmFtczsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHs/PX0gc2tpcElmRXhpc3RzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25UaW1lbGluZUNvbnRleHQucHJvdG90eXBlLnVwZGF0ZU9wdGlvbnMgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHs/PX0gc2tpcElmRXhpc3RzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAob3B0aW9ucywgc2tpcElmRXhpc3RzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIW9wdGlvbnMpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXdPcHRpb25zID0gLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0aW9uc1RvVXBkYXRlID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgIC8vIE5PVEU6IHRoaXMgd2lsbCBnZXQgcGF0Y2hlZCB1cCB3aGVuIG90aGVyIGFuaW1hdGlvbiBtZXRob2RzIHN1cHBvcnQgZHVyYXRpb24gb3ZlcnJpZGVzXHJcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuZHVyYXRpb24gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9uc1RvVXBkYXRlKSkuZHVyYXRpb24gPSByZXNvbHZlVGltaW5nVmFsdWUobmV3T3B0aW9ucy5kdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXdPcHRpb25zLmRlbGF5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgb3B0aW9uc1RvVXBkYXRlLmRlbGF5ID0gcmVzb2x2ZVRpbWluZ1ZhbHVlKG5ld09wdGlvbnMuZGVsYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXdQYXJhbXMgPSBuZXdPcHRpb25zLnBhcmFtcztcclxuICAgICAgICBpZiAobmV3UGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtc1RvVXBkYXRlXzEgPSAvKiogQHR5cGUgez99ICovICgob3B0aW9uc1RvVXBkYXRlLnBhcmFtcykpO1xyXG4gICAgICAgICAgICBpZiAoIXBhcmFtc1RvVXBkYXRlXzEpIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtc1RvVXBkYXRlXzEgPSB0aGlzLm9wdGlvbnMucGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgT2JqZWN0LmtleXMobmV3UGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNraXBJZkV4aXN0cyB8fCAhcGFyYW1zVG9VcGRhdGVfMS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1RvVXBkYXRlXzFbbmFtZV0gPSBpbnRlcnBvbGF0ZVBhcmFtcyhuZXdQYXJhbXNbbmFtZV0sIHBhcmFtc1RvVXBkYXRlXzEsIF90aGlzLmVycm9ycyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUuX2NvcHlPcHRpb25zID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkUGFyYW1zXzEgPSB0aGlzLm9wdGlvbnMucGFyYW1zO1xyXG4gICAgICAgICAgICBpZiAob2xkUGFyYW1zXzEpIHtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtc18xID0gb3B0aW9uc1sncGFyYW1zJ10gPSB7fTtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9sZFBhcmFtc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHBhcmFtc18xW25hbWVdID0gb2xkUGFyYW1zXzFbbmFtZV07IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHs/PX0gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/PX0gbmV3VGltZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0LnByb3RvdHlwZS5jcmVhdGVTdWJDb250ZXh0ID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gez89fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez89fSBuZXdUaW1lXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAob3B0aW9ucywgZWxlbWVudCwgbmV3VGltZSkge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IG51bGw7IH1cclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YXJnZXQgPSBlbGVtZW50IHx8IHRoaXMuZWxlbWVudDtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZXh0ID0gbmV3IEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dCh0aGlzLl9kcml2ZXIsIHRhcmdldCwgdGhpcy5zdWJJbnN0cnVjdGlvbnMsIHRoaXMuX2VudGVyQ2xhc3NOYW1lLCB0aGlzLl9sZWF2ZUNsYXNzTmFtZSwgdGhpcy5lcnJvcnMsIHRoaXMudGltZWxpbmVzLCB0aGlzLmN1cnJlbnRUaW1lbGluZS5mb3JrKHRhcmdldCwgbmV3VGltZSB8fCAwKSk7XHJcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSB0aGlzLnByZXZpb3VzTm9kZTtcclxuICAgICAgICBjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncyA9IHRoaXMuY3VycmVudEFuaW1hdGVUaW1pbmdzO1xyXG4gICAgICAgIGNvbnRleHQub3B0aW9ucyA9IHRoaXMuX2NvcHlPcHRpb25zKCk7XHJcbiAgICAgICAgY29udGV4dC51cGRhdGVPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5SW5kZXggPSB0aGlzLmN1cnJlbnRRdWVyeUluZGV4O1xyXG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5VG90YWwgPSB0aGlzLmN1cnJlbnRRdWVyeVRvdGFsO1xyXG4gICAgICAgIGNvbnRleHQucGFyZW50Q29udGV4dCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5zdWJDb250ZXh0Q291bnQrKztcclxuICAgICAgICByZXR1cm4gY29udGV4dDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7Pz19IG5ld1RpbWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez89fSBuZXdUaW1lXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobmV3VGltZSkge1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNOb2RlID0gREVGQVVMVF9OT09QX1BSRVZJT1VTX05PREU7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZWxpbmUgPSB0aGlzLmN1cnJlbnRUaW1lbGluZS5mb3JrKHRoaXMuZWxlbWVudCwgbmV3VGltZSk7XHJcbiAgICAgICAgdGhpcy50aW1lbGluZXMucHVzaCh0aGlzLmN1cnJlbnRUaW1lbGluZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWVsaW5lO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvblxyXG4gICAgICogQHBhcmFtIHs/fSBkdXJhdGlvblxyXG4gICAgICogQHBhcmFtIHs/fSBkZWxheVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0LnByb3RvdHlwZS5hcHBlbmRJbnN0cnVjdGlvblRvVGltZWxpbmUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gaW5zdHJ1Y3Rpb25cclxuICAgICAqIEBwYXJhbSB7P30gZHVyYXRpb25cclxuICAgICAqIEBwYXJhbSB7P30gZGVsYXlcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChpbnN0cnVjdGlvbiwgZHVyYXRpb24sIGRlbGF5KSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBkYXRlZFRpbWluZ3MgPSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAhPSBudWxsID8gZHVyYXRpb24gOiBpbnN0cnVjdGlvbi5kdXJhdGlvbixcclxuICAgICAgICAgICAgZGVsYXk6IHRoaXMuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lICsgKGRlbGF5ICE9IG51bGwgPyBkZWxheSA6IDApICsgaW5zdHJ1Y3Rpb24uZGVsYXksXHJcbiAgICAgICAgICAgIGVhc2luZzogJydcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJ1aWxkZXIgPSBuZXcgU3ViVGltZWxpbmVCdWlsZGVyKHRoaXMuX2RyaXZlciwgaW5zdHJ1Y3Rpb24uZWxlbWVudCwgaW5zdHJ1Y3Rpb24ua2V5ZnJhbWVzLCBpbnN0cnVjdGlvbi5wcmVTdHlsZVByb3BzLCBpbnN0cnVjdGlvbi5wb3N0U3R5bGVQcm9wcywgdXBkYXRlZFRpbWluZ3MsIGluc3RydWN0aW9uLnN0cmV0Y2hTdGFydGluZ0tleWZyYW1lKTtcclxuICAgICAgICB0aGlzLnRpbWVsaW5lcy5wdXNoKGJ1aWxkZXIpO1xyXG4gICAgICAgIHJldHVybiB1cGRhdGVkVGltaW5ncztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdGltZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0LnByb3RvdHlwZS5pbmNyZW1lbnRUaW1lID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHRpbWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICh0aW1lKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZWxpbmUuZm9yd2FyZFRpbWUodGhpcy5jdXJyZW50VGltZWxpbmUuZHVyYXRpb24gKyB0aW1lKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZGVsYXlcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUuZGVsYXlOZXh0U3RlcCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBkZWxheVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGRlbGF5KSB7XHJcbiAgICAgICAgLy8gbmVnYXRpdmUgZGVsYXlzIGFyZSBub3QgeWV0IHN1cHBvcnRlZFxyXG4gICAgICAgIGlmIChkZWxheSA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGltZWxpbmUuZGVsYXlOZXh0U3RlcChkZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxyXG4gICAgICogQHBhcmFtIHs/fSBvcmlnaW5hbFNlbGVjdG9yXHJcbiAgICAgKiBAcGFyYW0gez99IGxpbWl0XHJcbiAgICAgKiBAcGFyYW0gez99IGluY2x1ZGVTZWxmXHJcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbmFsXHJcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0LnByb3RvdHlwZS5pbnZva2VRdWVyeSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxyXG4gICAgICogQHBhcmFtIHs/fSBvcmlnaW5hbFNlbGVjdG9yXHJcbiAgICAgKiBAcGFyYW0gez99IGxpbWl0XHJcbiAgICAgKiBAcGFyYW0gez99IGluY2x1ZGVTZWxmXHJcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbmFsXHJcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHNlbGVjdG9yLCBvcmlnaW5hbFNlbGVjdG9yLCBsaW1pdCwgaW5jbHVkZVNlbGYsIG9wdGlvbmFsLCBlcnJvcnMpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHRzID0gW107XHJcbiAgICAgICAgaWYgKGluY2x1ZGVTZWxmKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2VsZWN0b3IubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAvLyBpZiA6c2VsZiBpcyBvbmx5IHVzZWQgdGhlbiB0aGUgc2VsZWN0b3IgaXMgZW1wdHlcclxuICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKEVOVEVSX1RPS0VOX1JFR0VYLCAnLicgKyB0aGlzLl9lbnRlckNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShMRUFWRV9UT0tFTl9SRUdFWCwgJy4nICsgdGhpcy5fbGVhdmVDbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtdWx0aSA9IGxpbWl0ICE9IDE7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRzID0gdGhpcy5fZHJpdmVyLnF1ZXJ5KHRoaXMuZWxlbWVudCwgc2VsZWN0b3IsIG11bHRpKTtcclxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGxpbWl0IDwgMCA/IGVsZW1lbnRzLnNsaWNlKGVsZW1lbnRzLmxlbmd0aCArIGxpbWl0LCBlbGVtZW50cy5sZW5ndGgpIDpcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5zbGljZSgwLCBsaW1pdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoLmFwcGx5KHJlc3VsdHMsIGVsZW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvcHRpb25hbCAmJiByZXN1bHRzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiYHF1ZXJ5KFxcXCJcIiArIG9yaWdpbmFsU2VsZWN0b3IgKyBcIlxcXCIpYCByZXR1cm5lZCB6ZXJvIGVsZW1lbnRzLiAoVXNlIGBxdWVyeShcXFwiXCIgKyBvcmlnaW5hbFNlbGVjdG9yICsgXCJcXFwiLCB7IG9wdGlvbmFsOiB0cnVlIH0pYCBpZiB5b3Ugd2lzaCB0byBhbGxvdyB0aGlzLilcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBbmltYXRpb25UaW1lbGluZUNvbnRleHQ7XHJcbn0oKSk7XHJcbnZhciBUaW1lbGluZUJ1aWxkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUaW1lbGluZUJ1aWxkZXIoX2RyaXZlciwgZWxlbWVudCwgc3RhcnRUaW1lLCBfZWxlbWVudFRpbWVsaW5lU3R5bGVzTG9va3VwKSB7XHJcbiAgICAgICAgdGhpcy5fZHJpdmVyID0gX2RyaXZlcjtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cCA9IF9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXA7XHJcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fcHJldmlvdXNLZXlmcmFtZSA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRLZXlmcmFtZSA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2tleWZyYW1lcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9zdHlsZVN1bW1hcnkgPSB7fTtcclxuICAgICAgICB0aGlzLl9wZW5kaW5nU3R5bGVzID0ge307XHJcbiAgICAgICAgdGhpcy5fYmFja0ZpbGwgPSB7fTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50RW1wdHlTdGVwS2V5ZnJhbWUgPSBudWxsO1xyXG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudFRpbWVsaW5lU3R5bGVzTG9va3VwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlcyA9IE9iamVjdC5jcmVhdGUodGhpcy5fYmFja0ZpbGwsIHt9KTtcclxuICAgICAgICB0aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlcyA9IC8qKiBAdHlwZSB7P30gKi8gKCh0aGlzLl9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXAuZ2V0KGVsZW1lbnQpKSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlcykge1xyXG4gICAgICAgICAgICB0aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlcyA9IHRoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXM7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cC5zZXQoZWxlbWVudCwgdGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvYWRLZXlmcmFtZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmNvbnRhaW5zQW5pbWF0aW9uID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLl9rZXlmcmFtZXMuc2l6ZSkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRTdHlsZVByb3BlcnRpZXMoKS5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5nZXRDdXJyZW50U3R5bGVQcm9wZXJ0aWVzID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jdXJyZW50S2V5ZnJhbWUpOyB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUsIFwiY3VycmVudFRpbWVcIiwge1xyXG4gICAgICAgIGdldDogLyoqXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnN0YXJ0VGltZSArIHRoaXMuZHVyYXRpb247IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGRlbGF5XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmRlbGF5TmV4dFN0ZXAgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZGVsYXlcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChkZWxheSkge1xyXG4gICAgICAgIC8vIGluIHRoZSBldmVudCB0aGF0IGEgc3R5bGUoKSBzdGVwIGlzIHBsYWNlZCByaWdodCBiZWZvcmUgYSBzdGFnZ2VyKClcclxuICAgICAgICAvLyBhbmQgdGhhdCBzdHlsZSgpIHN0ZXAgaXMgdGhlIHZlcnkgZmlyc3Qgc3R5bGUoKSB2YWx1ZSBpbiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgLy8gdGhlbiB3ZSBuZWVkIHRvIG1ha2UgYSBjb3B5IG9mIHRoZSBrZXlmcmFtZSBbMCwgY29weSwgMV0gc28gdGhhdCB0aGUgZGVsYXlcclxuICAgICAgICAvLyBwcm9wZXJseSBhcHBsaWVzIHRoZSBzdHlsZSgpIHZhbHVlcyB0byB3b3JrIHdpdGggdGhlIHN0YWdnZXIuLi5cclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYXNQcmVTdHlsZVN0ZXAgPSB0aGlzLl9rZXlmcmFtZXMuc2l6ZSA9PSAxICYmIE9iamVjdC5rZXlzKHRoaXMuX3BlbmRpbmdTdHlsZXMpLmxlbmd0aDtcclxuICAgICAgICBpZiAodGhpcy5kdXJhdGlvbiB8fCBoYXNQcmVTdHlsZVN0ZXApIHtcclxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkVGltZSh0aGlzLmN1cnJlbnRUaW1lICsgZGVsYXkpO1xyXG4gICAgICAgICAgICBpZiAoaGFzUHJlU3R5bGVTdGVwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBzaG90Q3VycmVudFN0eWxlcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZSArPSBkZWxheTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7Pz19IGN1cnJlbnRUaW1lXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmZvcmsgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/PX0gY3VycmVudFRpbWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBjdXJyZW50VGltZSkge1xyXG4gICAgICAgIHRoaXMuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lbGluZUJ1aWxkZXIodGhpcy5fZHJpdmVyLCBlbGVtZW50LCBjdXJyZW50VGltZSB8fCB0aGlzLmN1cnJlbnRUaW1lLCB0aGlzLl9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5fbG9hZEtleWZyYW1lID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRLZXlmcmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c0tleWZyYW1lID0gdGhpcy5fY3VycmVudEtleWZyYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jdXJyZW50S2V5ZnJhbWUgPSAvKiogQHR5cGUgez99ICovICgodGhpcy5fa2V5ZnJhbWVzLmdldCh0aGlzLmR1cmF0aW9uKSkpO1xyXG4gICAgICAgIGlmICghdGhpcy5fY3VycmVudEtleWZyYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRLZXlmcmFtZSA9IE9iamVjdC5jcmVhdGUodGhpcy5fYmFja0ZpbGwsIHt9KTtcclxuICAgICAgICAgICAgdGhpcy5fa2V5ZnJhbWVzLnNldCh0aGlzLmR1cmF0aW9uLCB0aGlzLl9jdXJyZW50S2V5ZnJhbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuZm9yd2FyZEZyYW1lID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kdXJhdGlvbiArPSBPTkVfRlJBTUVfSU5fTUlMTElTRUNPTkRTO1xyXG4gICAgICAgIHRoaXMuX2xvYWRLZXlmcmFtZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB0aW1lXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmZvcndhcmRUaW1lID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHRpbWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICh0aW1lKSB7XHJcbiAgICAgICAgdGhpcy5hcHBseVN0eWxlc1RvS2V5ZnJhbWUoKTtcclxuICAgICAgICB0aGlzLmR1cmF0aW9uID0gdGltZTtcclxuICAgICAgICB0aGlzLl9sb2FkS2V5ZnJhbWUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcHJvcFxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5fdXBkYXRlU3R5bGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcHJvcFxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlc1twcm9wXSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2dsb2JhbFRpbWVsaW5lU3R5bGVzW3Byb3BdID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fc3R5bGVTdW1tYXJ5W3Byb3BdID0geyB0aW1lOiB0aGlzLmN1cnJlbnRUaW1lLCB2YWx1ZTogdmFsdWUgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuYWxsb3dPbmx5VGltZWxpbmVTdHlsZXMgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2N1cnJlbnRFbXB0eVN0ZXBLZXlmcmFtZSAhPT0gdGhpcy5fY3VycmVudEtleWZyYW1lOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVhc2luZ1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5hcHBseUVtcHR5U3RlcCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlYXNpbmdcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlYXNpbmcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChlYXNpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNLZXlmcmFtZVsnZWFzaW5nJ10gPSBlYXNpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgYW5pbWF0ZShkdXJhdGlvbik6XHJcbiAgICAgICAgLy8gYWxsIG1pc3Npbmcgc3R5bGVzIGFyZSBmaWxsZWQgd2l0aCBhIGAqYCB2YWx1ZSB0aGVuXHJcbiAgICAgICAgLy8gaWYgYW55IGRlc3RpbmF0aW9uIHN0eWxlcyBhcmUgZmlsbGVkIGluIGxhdGVyIG9uIHRoZSBzYW1lXHJcbiAgICAgICAgLy8ga2V5ZnJhbWUgdGhlbiB0aGV5IHdpbGwgb3ZlcnJpZGUgdGhlIG92ZXJyaWRkZW4gc3R5bGVzXHJcbiAgICAgICAgLy8gV2UgdXNlIGBfZ2xvYmFsVGltZWxpbmVTdHlsZXNgIGhlcmUgYmVjYXVzZSB0aGVyZSBtYXkgYmVcclxuICAgICAgICAvLyBzdHlsZXMgaW4gcHJldmlvdXMga2V5ZnJhbWVzIHRoYXQgYXJlIG5vdCBwcmVzZW50IGluIHRoaXMgdGltZWxpbmVcclxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fYmFja0ZpbGxbcHJvcF0gPSBfdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXNbcHJvcF0gfHwgX2FuZ3VsYXJfYW5pbWF0aW9ucy5BVVRPX1NUWUxFO1xyXG4gICAgICAgICAgICBfdGhpcy5fY3VycmVudEtleWZyYW1lW3Byb3BdID0gX2FuZ3VsYXJfYW5pbWF0aW9ucy5BVVRPX1NUWUxFO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRFbXB0eVN0ZXBLZXlmcmFtZSA9IHRoaXMuX2N1cnJlbnRLZXlmcmFtZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcclxuICAgICAqIEBwYXJhbSB7P30gZWFzaW5nXHJcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xyXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5zZXRTdHlsZXMgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcclxuICAgICAqIEBwYXJhbSB7P30gZWFzaW5nXHJcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xyXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGlucHV0LCBlYXNpbmcsIGVycm9ycywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGVhc2luZykge1xyXG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c0tleWZyYW1lWydlYXNpbmcnXSA9IGVhc2luZztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1zID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJhbXMpIHx8IHt9O1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcyA9IGZsYXR0ZW5TdHlsZXMoaW5wdXQsIHRoaXMuX2dsb2JhbFRpbWVsaW5lU3R5bGVzKTtcclxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsID0gaW50ZXJwb2xhdGVQYXJhbXMoc3R5bGVzW3Byb3BdLCBwYXJhbXMsIGVycm9ycyk7XHJcbiAgICAgICAgICAgIF90aGlzLl9wZW5kaW5nU3R5bGVzW3Byb3BdID0gdmFsO1xyXG4gICAgICAgICAgICBpZiAoIV90aGlzLl9sb2NhbFRpbWVsaW5lU3R5bGVzLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fYmFja0ZpbGxbcHJvcF0gPSBfdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXMuaGFzT3duUHJvcGVydHkocHJvcCkgP1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlc1twcm9wXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfYW5pbWF0aW9ucy5BVVRPX1NUWUxFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVTdHlsZShwcm9wLCB2YWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5hcHBseVN0eWxlc1RvS2V5ZnJhbWUgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcyA9IHRoaXMuX3BlbmRpbmdTdHlsZXM7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcHMgPSBPYmplY3Qua2V5cyhzdHlsZXMpO1xyXG4gICAgICAgIGlmIChwcm9wcy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdTdHlsZXMgPSB7fTtcclxuICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbCA9IHN0eWxlc1twcm9wXTtcclxuICAgICAgICAgICAgX3RoaXMuX2N1cnJlbnRLZXlmcmFtZVtwcm9wXSA9IHZhbDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9sb2NhbFRpbWVsaW5lU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2N1cnJlbnRLZXlmcmFtZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2N1cnJlbnRLZXlmcmFtZVtwcm9wXSA9IF90aGlzLl9sb2NhbFRpbWVsaW5lU3R5bGVzW3Byb3BdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLnNuYXBzaG90Q3VycmVudFN0eWxlcyA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWwgPSBfdGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlc1twcm9wXTtcclxuICAgICAgICAgICAgX3RoaXMuX3BlbmRpbmdTdHlsZXNbcHJvcF0gPSB2YWw7XHJcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVTdHlsZShwcm9wLCB2YWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5nZXRGaW5hbEtleWZyYW1lID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9rZXlmcmFtZXMuZ2V0KHRoaXMuZHVyYXRpb24pOyB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUsIFwicHJvcGVydGllc1wiLCB7XHJcbiAgICAgICAgZ2V0OiAvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcGVydGllcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHByb3AgaW4gdGhpcy5fY3VycmVudEtleWZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdGltZWxpbmVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUubWVyZ2VUaW1lbGluZUNvbGxlY3RlZFN0eWxlcyA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB0aW1lbGluZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHRpbWVsaW5lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBPYmplY3Qua2V5cyh0aW1lbGluZS5fc3R5bGVTdW1tYXJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRldGFpbHMwID0gX3RoaXMuX3N0eWxlU3VtbWFyeVtwcm9wXTtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGV0YWlsczEgPSB0aW1lbGluZS5fc3R5bGVTdW1tYXJ5W3Byb3BdO1xyXG4gICAgICAgICAgICBpZiAoIWRldGFpbHMwIHx8IGRldGFpbHMxLnRpbWUgPiBkZXRhaWxzMC50aW1lKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fdXBkYXRlU3R5bGUocHJvcCwgZGV0YWlsczEudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkS2V5ZnJhbWVzID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmFwcGx5U3R5bGVzVG9LZXlmcmFtZSgpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVN0eWxlUHJvcHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zdFN0eWxlUHJvcHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNFbXB0eSA9IHRoaXMuX2tleWZyYW1lcy5zaXplID09PSAxICYmIHRoaXMuZHVyYXRpb24gPT09IDA7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmluYWxLZXlmcmFtZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9rZXlmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5ZnJhbWUsIHRpbWUpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmluYWxLZXlmcmFtZSA9IGNvcHlTdHlsZXMoa2V5ZnJhbWUsIHRydWUpO1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhmaW5hbEtleWZyYW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGZpbmFsS2V5ZnJhbWVbcHJvcF07XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gX2FuZ3VsYXJfYW5pbWF0aW9ucy7JtVBSRV9TVFlMRSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZVN0eWxlUHJvcHMuYWRkKHByb3ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gX2FuZ3VsYXJfYW5pbWF0aW9ucy5BVVRPX1NUWUxFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zdFN0eWxlUHJvcHMuYWRkKHByb3ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFpc0VtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICBmaW5hbEtleWZyYW1lWydvZmZzZXQnXSA9IHRpbWUgLyBfdGhpcy5kdXJhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbEtleWZyYW1lcy5wdXNoKGZpbmFsS2V5ZnJhbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVByb3BzID0gcHJlU3R5bGVQcm9wcy5zaXplID8gaXRlcmF0b3JUb0FycmF5KHByZVN0eWxlUHJvcHMudmFsdWVzKCkpIDogW107XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zdFByb3BzID0gcG9zdFN0eWxlUHJvcHMuc2l6ZSA/IGl0ZXJhdG9yVG9BcnJheShwb3N0U3R5bGVQcm9wcy52YWx1ZXMoKSkgOiBbXTtcclxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIGEgMC1zZWNvbmQgYW5pbWF0aW9uICh3aGljaCBpcyBkZXNpZ25lZCBqdXN0IHRvIHBsYWNlIHN0eWxlcyBvbnNjcmVlbilcclxuICAgICAgICBpZiAoaXNFbXB0eSkge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZjAgPSBmaW5hbEtleWZyYW1lc1swXTtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2YxID0gY29weU9iaihrZjApO1xyXG4gICAgICAgICAgICBrZjBbJ29mZnNldCddID0gMDtcclxuICAgICAgICAgICAga2YxWydvZmZzZXQnXSA9IDE7XHJcbiAgICAgICAgICAgIGZpbmFsS2V5ZnJhbWVzID0gW2tmMCwga2YxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRpbWVsaW5lSW5zdHJ1Y3Rpb24odGhpcy5lbGVtZW50LCBmaW5hbEtleWZyYW1lcywgcHJlUHJvcHMsIHBvc3RQcm9wcywgdGhpcy5kdXJhdGlvbiwgdGhpcy5zdGFydFRpbWUsIHRoaXMuZWFzaW5nLCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRpbWVsaW5lQnVpbGRlcjtcclxufSgpKTtcclxudmFyIFN1YlRpbWVsaW5lQnVpbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTdWJUaW1lbGluZUJ1aWxkZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTdWJUaW1lbGluZUJ1aWxkZXIoZHJpdmVyLCBlbGVtZW50LCBrZXlmcmFtZXMsIHByZVN0eWxlUHJvcHMsIHBvc3RTdHlsZVByb3BzLCB0aW1pbmdzLCBfc3RyZXRjaFN0YXJ0aW5nS2V5ZnJhbWUpIHtcclxuICAgICAgICBpZiAoX3N0cmV0Y2hTdGFydGluZ0tleWZyYW1lID09PSB2b2lkIDApIHsgX3N0cmV0Y2hTdGFydGluZ0tleWZyYW1lID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkcml2ZXIsIGVsZW1lbnQsIHRpbWluZ3MuZGVsYXkpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgX3RoaXMua2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xyXG4gICAgICAgIF90aGlzLnByZVN0eWxlUHJvcHMgPSBwcmVTdHlsZVByb3BzO1xyXG4gICAgICAgIF90aGlzLnBvc3RTdHlsZVByb3BzID0gcG9zdFN0eWxlUHJvcHM7XHJcbiAgICAgICAgX3RoaXMuX3N0cmV0Y2hTdGFydGluZ0tleWZyYW1lID0gX3N0cmV0Y2hTdGFydGluZ0tleWZyYW1lO1xyXG4gICAgICAgIF90aGlzLnRpbWluZ3MgPSB7IGR1cmF0aW9uOiB0aW1pbmdzLmR1cmF0aW9uLCBkZWxheTogdGltaW5ncy5kZWxheSwgZWFzaW5nOiB0aW1pbmdzLmVhc2luZyB9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgU3ViVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5jb250YWluc0FuaW1hdGlvbiA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5rZXlmcmFtZXMubGVuZ3RoID4gMTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgU3ViVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5idWlsZEtleWZyYW1lcyA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleWZyYW1lcyA9IHRoaXMua2V5ZnJhbWVzO1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMudGltaW5ncywgZGVsYXkgPSBfYS5kZWxheSwgZHVyYXRpb24gPSBfYS5kdXJhdGlvbiwgZWFzaW5nID0gX2EuZWFzaW5nO1xyXG4gICAgICAgIGlmICh0aGlzLl9zdHJldGNoU3RhcnRpbmdLZXlmcmFtZSAmJiBkZWxheSkge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXdLZXlmcmFtZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG90YWxUaW1lID0gZHVyYXRpb24gKyBkZWxheTtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRpbmdHYXAgPSBkZWxheSAvIHRvdGFsVGltZTtcclxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIHN0YXJ0aW5nIGtleWZyYW1lIG5vdyBzdGFydHMgb25jZSB0aGUgZGVsYXkgaXMgZG9uZVxyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXdGaXJzdEtleWZyYW1lID0gY29weVN0eWxlcyhrZXlmcmFtZXNbMF0sIGZhbHNlKTtcclxuICAgICAgICAgICAgbmV3Rmlyc3RLZXlmcmFtZVsnb2Zmc2V0J10gPSAwO1xyXG4gICAgICAgICAgICBuZXdLZXlmcmFtZXMucHVzaChuZXdGaXJzdEtleWZyYW1lKTtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkRmlyc3RLZXlmcmFtZSA9IGNvcHlTdHlsZXMoa2V5ZnJhbWVzWzBdLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIG9sZEZpcnN0S2V5ZnJhbWVbJ29mZnNldCddID0gcm91bmRPZmZzZXQoc3RhcnRpbmdHYXApO1xyXG4gICAgICAgICAgICBuZXdLZXlmcmFtZXMucHVzaChvbGRGaXJzdEtleWZyYW1lKTtcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICBXaGVuIHRoZSBrZXlmcmFtZSBpcyBzdHJldGNoZWQgdGhlbiBpdCBtZWFucyB0aGF0IHRoZSBkZWxheSBiZWZvcmUgdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0cyBpcyBnb25lLiBJbnN0ZWFkIHRoZSBmaXJzdCBrZXlmcmFtZSBpcyBwbGFjZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBhbmltYXRpb25cclxuICAgICAgICAgICAgICAgICAgICBhbmQgaXQgaXMgdGhlbiBjb3BpZWQgdG8gd2hlcmUgaXQgc3RhcnRzIHdoZW4gdGhlIG9yaWdpbmFsIGRlbGF5IGlzIG92ZXIuIFRoaXMgYmFzaWNhbGx5XHJcbiAgICAgICAgICAgICAgICAgICAgbWVhbnMgbm90aGluZyBhbmltYXRlcyBkdXJpbmcgdGhhdCBkZWxheSwgYnV0IHRoZSBzdHlsZXMgYXJlIHN0aWxsIHJlbmRlcmVyZWQuIEZvciB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgdG8gd29yayB0aGUgb3JpZ2luYWwgb2Zmc2V0IHZhbHVlcyB0aGF0IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBrZXlmcmFtZXMgbXVzdCBiZSBcIndhcnBlZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgc28gdGhhdCB0aGV5IGNhbiB0YWtlIHRoZSBuZXcga2V5ZnJhbWUgKyBkZWxheSBpbnRvIGFjY291bnQuXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5PTEwMDAsIGR1cmF0aW9uPTEwMDAsIGtleWZyYW1lcyA9IDAgLjUgMVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB0dXJucyBpbnRvXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5PTAsIGR1cmF0aW9uPTIwMDAsIGtleWZyYW1lcyA9IDAgLjMzIC42NiAxXHJcbiAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAvLyBvZmZzZXRzIGJldHdlZW4gMSAuLi4gbiAtMSBhcmUgYWxsIHdhcnBlZCBieSB0aGUga2V5ZnJhbWUgc3RyZXRjaFxyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW1pdCA9IGtleWZyYW1lcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAxOyBpIDw9IGxpbWl0OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtmID0gY29weVN0eWxlcyhrZXlmcmFtZXNbaV0sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZE9mZnNldCA9IC8qKiBAdHlwZSB7P30gKi8gKGtmWydvZmZzZXQnXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lQXRLZXlmcmFtZSA9IGRlbGF5ICsgb2xkT2Zmc2V0ICogZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICBrZlsnb2Zmc2V0J10gPSByb3VuZE9mZnNldCh0aW1lQXRLZXlmcmFtZSAvIHRvdGFsVGltZSk7XHJcbiAgICAgICAgICAgICAgICBuZXdLZXlmcmFtZXMucHVzaChrZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhlIG5ldyBzdGFydGluZyBrZXlmcmFtZSBzaG91bGQgYmUgYWRkZWQgYXQgdGhlIHN0YXJ0XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gdG90YWxUaW1lO1xyXG4gICAgICAgICAgICBkZWxheSA9IDA7XHJcbiAgICAgICAgICAgIGVhc2luZyA9ICcnO1xyXG4gICAgICAgICAgICBrZXlmcmFtZXMgPSBuZXdLZXlmcmFtZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjcmVhdGVUaW1lbGluZUluc3RydWN0aW9uKHRoaXMuZWxlbWVudCwga2V5ZnJhbWVzLCB0aGlzLnByZVN0eWxlUHJvcHMsIHRoaXMucG9zdFN0eWxlUHJvcHMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU3ViVGltZWxpbmVCdWlsZGVyO1xyXG59KFRpbWVsaW5lQnVpbGRlcikpO1xyXG4vKipcclxuICogQHBhcmFtIHs/fSBvZmZzZXRcclxuICogQHBhcmFtIHs/PX0gZGVjaW1hbFBvaW50c1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gcm91bmRPZmZzZXQob2Zmc2V0LCBkZWNpbWFsUG9pbnRzKSB7XHJcbiAgICBpZiAoZGVjaW1hbFBvaW50cyA9PT0gdm9pZCAwKSB7IGRlY2ltYWxQb2ludHMgPSAzOyB9XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtdWx0ID0gTWF0aC5wb3coMTAsIGRlY2ltYWxQb2ludHMgLSAxKTtcclxuICAgIHJldHVybiBNYXRoLnJvdW5kKG9mZnNldCAqIG11bHQpIC8gbXVsdDtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSBpbnB1dFxyXG4gKiBAcGFyYW0gez99IGFsbFN0eWxlc1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gZmxhdHRlblN0eWxlcyhpbnB1dCwgYWxsU3R5bGVzKSB7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSB7fTtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFByb3BlcnRpZXM7XHJcbiAgICBpbnB1dC5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgIGlmICh0b2tlbiA9PT0gJyonKSB7XHJcbiAgICAgICAgICAgIGFsbFByb3BlcnRpZXMgPSBhbGxQcm9wZXJ0aWVzIHx8IE9iamVjdC5rZXlzKGFsbFN0eWxlcyk7XHJcbiAgICAgICAgICAgIGFsbFByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyBzdHlsZXNbcHJvcF0gPSBfYW5ndWxhcl9hbmltYXRpb25zLkFVVE9fU1RZTEU7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29weVN0eWxlcygvKiogQHR5cGUgez99ICovICh0b2tlbiksIGZhbHNlLCBzdHlsZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHN0eWxlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxyXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXHJcbiAqL1xyXG52YXIgQW5pbWF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uKF9kcml2ZXIsIGlucHV0KSB7XHJcbiAgICAgICAgdGhpcy5fZHJpdmVyID0gX2RyaXZlcjtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvcnMgPSBbXTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBidWlsZEFuaW1hdGlvbkFzdChfZHJpdmVyLCBpbnB1dCwgZXJyb3JzKTtcclxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvck1lc3NhZ2UgPSBcImFuaW1hdGlvbiB2YWxpZGF0aW9uIGZhaWxlZDpcXG5cIiArIGVycm9ycy5qb2luKFwiXFxuXCIpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uQXN0ID0gYXN0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRpbmdTdHlsZXNcclxuICAgICAqIEBwYXJhbSB7P30gZGVzdGluYXRpb25TdHlsZXNcclxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHs/PX0gc3ViSW5zdHJ1Y3Rpb25zXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb24ucHJvdG90eXBlLmJ1aWxkVGltZWxpbmVzID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRpbmdTdHlsZXNcclxuICAgICAqIEBwYXJhbSB7P30gZGVzdGluYXRpb25TdHlsZXNcclxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHs/PX0gc3ViSW5zdHJ1Y3Rpb25zXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgc3RhcnRpbmdTdHlsZXMsIGRlc3RpbmF0aW9uU3R5bGVzLCBvcHRpb25zLCBzdWJJbnN0cnVjdGlvbnMpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IEFycmF5LmlzQXJyYXkoc3RhcnRpbmdTdHlsZXMpID8gbm9ybWFsaXplU3R5bGVzKHN0YXJ0aW5nU3R5bGVzKSA6IC8qKiBAdHlwZSB7P30gKi8gKHN0YXJ0aW5nU3R5bGVzKTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXN0ID0gQXJyYXkuaXNBcnJheShkZXN0aW5hdGlvblN0eWxlcykgPyBub3JtYWxpemVTdHlsZXMoZGVzdGluYXRpb25TdHlsZXMpIDogLyoqIEB0eXBlIHs/fSAqLyAoZGVzdGluYXRpb25TdHlsZXMpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFtdO1xyXG4gICAgICAgIHN1Ykluc3RydWN0aW9ucyA9IHN1Ykluc3RydWN0aW9ucyB8fCBuZXcgRWxlbWVudEluc3RydWN0aW9uTWFwKCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gYnVpbGRBbmltYXRpb25UaW1lbGluZXModGhpcy5fZHJpdmVyLCBlbGVtZW50LCB0aGlzLl9hbmltYXRpb25Bc3QsIEVOVEVSX0NMQVNTTkFNRSwgTEVBVkVfQ0xBU1NOQU1FLCBzdGFydCwgZGVzdCwgb3B0aW9ucywgc3ViSW5zdHJ1Y3Rpb25zLCBlcnJvcnMpO1xyXG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yTWVzc2FnZSA9IFwiYW5pbWF0aW9uIGJ1aWxkaW5nIGZhaWxlZDpcXG5cIiArIGVycm9ycy5qb2luKFwiXFxuXCIpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQW5pbWF0aW9uO1xyXG59KCkpO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxyXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXHJcbiAqL1xyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbnZhciBBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyO1xyXG59KCkpO1xyXG4vKipcclxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cclxuICovXHJcbnZhciBOb29wQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTm9vcEFuaW1hdGlvblN0eWxlTm9ybWFsaXplcigpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eU5hbWVcclxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBOb29wQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVQcm9wZXJ0eU5hbWUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcHJvcGVydHlOYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgZXJyb3JzKSB7IHJldHVybiBwcm9wZXJ0eU5hbWU7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdXNlclByb3ZpZGVkUHJvcGVydHlcclxuICAgICAqIEBwYXJhbSB7P30gbm9ybWFsaXplZFByb3BlcnR5XHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgTm9vcEFuaW1hdGlvblN0eWxlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplU3R5bGVWYWx1ZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB1c2VyUHJvdmlkZWRQcm9wZXJ0eVxyXG4gICAgICogQHBhcmFtIHs/fSBub3JtYWxpemVkUHJvcGVydHlcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAodXNlclByb3ZpZGVkUHJvcGVydHksIG5vcm1hbGl6ZWRQcm9wZXJ0eSwgdmFsdWUsIGVycm9ycykge1xyXG4gICAgICAgIHJldHVybiAvKiogQHR5cGUgez99ICovICh2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5vb3BBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXI7XHJcbn0oKSk7XHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbnZhciBXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFdlYkFuaW1hdGlvbnNTdHlsZU5vcm1hbGl6ZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eU5hbWVcclxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVQcm9wZXJ0eU5hbWUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcHJvcGVydHlOYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgZXJyb3JzKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhc2hDYXNlVG9DYW1lbENhc2UocHJvcGVydHlOYW1lKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdXNlclByb3ZpZGVkUHJvcGVydHlcclxuICAgICAqIEBwYXJhbSB7P30gbm9ybWFsaXplZFByb3BlcnR5XHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgV2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplU3R5bGVWYWx1ZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB1c2VyUHJvdmlkZWRQcm9wZXJ0eVxyXG4gICAgICogQHBhcmFtIHs/fSBub3JtYWxpemVkUHJvcGVydHlcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAodXNlclByb3ZpZGVkUHJvcGVydHksIG5vcm1hbGl6ZWRQcm9wZXJ0eSwgdmFsdWUsIGVycm9ycykge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuaXQgPSAnJztcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJWYWwgPSB2YWx1ZS50b1N0cmluZygpLnRyaW0oKTtcclxuICAgICAgICBpZiAoRElNRU5TSU9OQUxfUFJPUF9NQVBbbm9ybWFsaXplZFByb3BlcnR5XSAmJiB2YWx1ZSAhPT0gMCAmJiB2YWx1ZSAhPT0gJzAnKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB1bml0ID0gJ3B4JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbEFuZFN1ZmZpeE1hdGNoID0gdmFsdWUubWF0Y2goL15bKy1dP1tcXGRcXC5dKyhbYS16XSopJC8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbEFuZFN1ZmZpeE1hdGNoICYmIHZhbEFuZFN1ZmZpeE1hdGNoWzFdLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goXCJQbGVhc2UgcHJvdmlkZSBhIENTUyB1bml0IHZhbHVlIGZvciBcIiArIHVzZXJQcm92aWRlZFByb3BlcnR5ICsgXCI6XCIgKyB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0clZhbCArIHVuaXQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFdlYkFuaW1hdGlvbnNTdHlsZU5vcm1hbGl6ZXI7XHJcbn0oQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyKSk7XHJcbnZhciBESU1FTlNJT05BTF9QUk9QX01BUCA9IG1ha2VCb29sZWFuTWFwKCd3aWR0aCxoZWlnaHQsbWluV2lkdGgsbWluSGVpZ2h0LG1heFdpZHRoLG1heEhlaWdodCxsZWZ0LHRvcCxib3R0b20scmlnaHQsZm9udFNpemUsb3V0bGluZVdpZHRoLG91dGxpbmVPZmZzZXQscGFkZGluZ1RvcCxwYWRkaW5nTGVmdCxwYWRkaW5nQm90dG9tLHBhZGRpbmdSaWdodCxtYXJnaW5Ub3AsbWFyZ2luTGVmdCxtYXJnaW5Cb3R0b20sbWFyZ2luUmlnaHQsYm9yZGVyUmFkaXVzLGJvcmRlcldpZHRoLGJvcmRlclRvcFdpZHRoLGJvcmRlckxlZnRXaWR0aCxib3JkZXJSaWdodFdpZHRoLGJvcmRlckJvdHRvbVdpZHRoLHRleHRJbmRlbnQscGVyc3BlY3RpdmUnXHJcbiAgICAuc3BsaXQoJywnKSk7XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IGtleXNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VCb29sZWFuTWFwKGtleXMpIHtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcCA9IHt9O1xyXG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG1hcFtrZXldID0gdHJ1ZTsgfSk7XHJcbiAgICByZXR1cm4gbWFwO1xyXG59XHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbi8qKlxyXG4gKiBAcmVjb3JkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gKiBAcGFyYW0gez99IHRyaWdnZXJOYW1lXHJcbiAqIEBwYXJhbSB7P30gZnJvbVN0YXRlXHJcbiAqIEBwYXJhbSB7P30gdG9TdGF0ZVxyXG4gKiBAcGFyYW0gez99IGlzUmVtb3ZhbFRyYW5zaXRpb25cclxuICogQHBhcmFtIHs/fSBmcm9tU3R5bGVzXHJcbiAqIEBwYXJhbSB7P30gdG9TdHlsZXNcclxuICogQHBhcmFtIHs/fSB0aW1lbGluZXNcclxuICogQHBhcmFtIHs/fSBxdWVyaWVkRWxlbWVudHNcclxuICogQHBhcmFtIHs/fSBwcmVTdHlsZVByb3BzXHJcbiAqIEBwYXJhbSB7P30gcG9zdFN0eWxlUHJvcHNcclxuICogQHBhcmFtIHs/PX0gZXJyb3JzXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudCwgdHJpZ2dlck5hbWUsIGZyb21TdGF0ZSwgdG9TdGF0ZSwgaXNSZW1vdmFsVHJhbnNpdGlvbiwgZnJvbVN0eWxlcywgdG9TdHlsZXMsIHRpbWVsaW5lcywgcXVlcmllZEVsZW1lbnRzLCBwcmVTdHlsZVByb3BzLCBwb3N0U3R5bGVQcm9wcywgZXJyb3JzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDAgLyogVHJhbnNpdGlvbkFuaW1hdGlvbiAqLyxcclxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgICAgIHRyaWdnZXJOYW1lOiB0cmlnZ2VyTmFtZSxcclxuICAgICAgICBpc1JlbW92YWxUcmFuc2l0aW9uOiBpc1JlbW92YWxUcmFuc2l0aW9uLFxyXG4gICAgICAgIGZyb21TdGF0ZTogZnJvbVN0YXRlLFxyXG4gICAgICAgIGZyb21TdHlsZXM6IGZyb21TdHlsZXMsXHJcbiAgICAgICAgdG9TdGF0ZTogdG9TdGF0ZSxcclxuICAgICAgICB0b1N0eWxlczogdG9TdHlsZXMsXHJcbiAgICAgICAgdGltZWxpbmVzOiB0aW1lbGluZXMsXHJcbiAgICAgICAgcXVlcmllZEVsZW1lbnRzOiBxdWVyaWVkRWxlbWVudHMsXHJcbiAgICAgICAgcHJlU3R5bGVQcm9wczogcHJlU3R5bGVQcm9wcyxcclxuICAgICAgICBwb3N0U3R5bGVQcm9wczogcG9zdFN0eWxlUHJvcHMsXHJcbiAgICAgICAgZXJyb3JzOiBlcnJvcnNcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxudmFyIEVNUFRZX09CSkVDVCA9IHt9O1xyXG52YXIgQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBbmltYXRpb25UcmFuc2l0aW9uRmFjdG9yeShfdHJpZ2dlck5hbWUsIGFzdCwgX3N0YXRlU3R5bGVzKSB7XHJcbiAgICAgICAgdGhpcy5fdHJpZ2dlck5hbWUgPSBfdHJpZ2dlck5hbWU7XHJcbiAgICAgICAgdGhpcy5hc3QgPSBhc3Q7XHJcbiAgICAgICAgdGhpcy5fc3RhdGVTdHlsZXMgPSBfc3RhdGVTdHlsZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gY3VycmVudFN0YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IG5leHRTdGF0ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkucHJvdG90eXBlLm1hdGNoID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRTdGF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBuZXh0U3RhdGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChjdXJyZW50U3RhdGUsIG5leHRTdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBvbmVPck1vcmVUcmFuc2l0aW9uc01hdGNoKHRoaXMuYXN0Lm1hdGNoZXJzLCBjdXJyZW50U3RhdGUsIG5leHRTdGF0ZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlTmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcclxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25UcmFuc2l0aW9uRmFjdG9yeS5wcm90b3R5cGUuYnVpbGRTdHlsZXMgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gc3RhdGVOYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xyXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChzdGF0ZU5hbWUsIHBhcmFtcywgZXJyb3JzKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFja3VwU3RhdGVTdHlsZXIgPSB0aGlzLl9zdGF0ZVN0eWxlc1snKiddO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlU3R5bGVyID0gdGhpcy5fc3RhdGVTdHlsZXNbc3RhdGVOYW1lXTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYWNrdXBTdHlsZXMgPSBiYWNrdXBTdGF0ZVN0eWxlciA/IGJhY2t1cFN0YXRlU3R5bGVyLmJ1aWxkU3R5bGVzKHBhcmFtcywgZXJyb3JzKSA6IHt9O1xyXG4gICAgICAgIHJldHVybiBzdGF0ZVN0eWxlciA/IHN0YXRlU3R5bGVyLmJ1aWxkU3R5bGVzKHBhcmFtcywgZXJyb3JzKSA6IGJhY2t1cFN0eWxlcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZHJpdmVyXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gY3VycmVudFN0YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IG5leHRTdGF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBlbnRlckNsYXNzTmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSBsZWF2ZUNsYXNzTmFtZVxyXG4gICAgICogQHBhcmFtIHs/PX0gY3VycmVudE9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7Pz19IG5leHRPcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gez89fSBzdWJJbnN0cnVjdGlvbnNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRyYW5zaXRpb25GYWN0b3J5LnByb3RvdHlwZS5idWlsZCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBkcml2ZXJcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBjdXJyZW50U3RhdGVcclxuICAgICAqIEBwYXJhbSB7P30gbmV4dFN0YXRlXHJcbiAgICAgKiBAcGFyYW0gez99IGVudGVyQ2xhc3NOYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IGxlYXZlQ2xhc3NOYW1lXHJcbiAgICAgKiBAcGFyYW0gez89fSBjdXJyZW50T3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHs/PX0gbmV4dE9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7Pz19IHN1Ykluc3RydWN0aW9uc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGRyaXZlciwgZWxlbWVudCwgY3VycmVudFN0YXRlLCBuZXh0U3RhdGUsIGVudGVyQ2xhc3NOYW1lLCBsZWF2ZUNsYXNzTmFtZSwgY3VycmVudE9wdGlvbnMsIG5leHRPcHRpb25zLCBzdWJJbnN0cnVjdGlvbnMpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvcnMgPSBbXTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2l0aW9uQW5pbWF0aW9uUGFyYW1zID0gdGhpcy5hc3Qub3B0aW9ucyAmJiB0aGlzLmFzdC5vcHRpb25zLnBhcmFtcyB8fCBFTVBUWV9PQkpFQ1Q7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VycmVudEFuaW1hdGlvblBhcmFtcyA9IGN1cnJlbnRPcHRpb25zICYmIGN1cnJlbnRPcHRpb25zLnBhcmFtcyB8fCBFTVBUWV9PQkpFQ1Q7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VycmVudFN0YXRlU3R5bGVzID0gdGhpcy5idWlsZFN0eWxlcyhjdXJyZW50U3RhdGUsIGN1cnJlbnRBbmltYXRpb25QYXJhbXMsIGVycm9ycyk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV4dEFuaW1hdGlvblBhcmFtcyA9IG5leHRPcHRpb25zICYmIG5leHRPcHRpb25zLnBhcmFtcyB8fCBFTVBUWV9PQkpFQ1Q7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV4dFN0YXRlU3R5bGVzID0gdGhpcy5idWlsZFN0eWxlcyhuZXh0U3RhdGUsIG5leHRBbmltYXRpb25QYXJhbXMsIGVycm9ycyk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcmllZEVsZW1lbnRzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVN0eWxlTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc3RTdHlsZU1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1JlbW92YWwgPSBuZXh0U3RhdGUgPT09ICd2b2lkJztcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbmltYXRpb25PcHRpb25zID0geyBwYXJhbXM6IF9fYXNzaWduKHt9LCB0cmFuc2l0aW9uQW5pbWF0aW9uUGFyYW1zLCBuZXh0QW5pbWF0aW9uUGFyYW1zKSB9O1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWVsaW5lcyA9IGJ1aWxkQW5pbWF0aW9uVGltZWxpbmVzKGRyaXZlciwgZWxlbWVudCwgdGhpcy5hc3QuYW5pbWF0aW9uLCBlbnRlckNsYXNzTmFtZSwgbGVhdmVDbGFzc05hbWUsIGN1cnJlbnRTdGF0ZVN0eWxlcywgbmV4dFN0YXRlU3R5bGVzLCBhbmltYXRpb25PcHRpb25zLCBzdWJJbnN0cnVjdGlvbnMsIGVycm9ycyk7XHJcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zaXRpb25JbnN0cnVjdGlvbihlbGVtZW50LCB0aGlzLl90cmlnZ2VyTmFtZSwgY3VycmVudFN0YXRlLCBuZXh0U3RhdGUsIGlzUmVtb3ZhbCwgY3VycmVudFN0YXRlU3R5bGVzLCBuZXh0U3RhdGVTdHlsZXMsIFtdLCBbXSwgcHJlU3R5bGVNYXAsIHBvc3RTdHlsZU1hcCwgZXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGltZWxpbmVzLmZvckVhY2goZnVuY3Rpb24gKHRsKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsbSA9IHRsLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVByb3BzID0gZ2V0T3JTZXRBc0luTWFwKHByZVN0eWxlTWFwLCBlbG0sIHt9KTtcclxuICAgICAgICAgICAgdGwucHJlU3R5bGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBwcmVQcm9wc1twcm9wXSA9IHRydWU7IH0pO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3N0UHJvcHMgPSBnZXRPclNldEFzSW5NYXAocG9zdFN0eWxlTWFwLCBlbG0sIHt9KTtcclxuICAgICAgICAgICAgdGwucG9zdFN0eWxlUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gcG9zdFByb3BzW3Byb3BdID0gdHJ1ZTsgfSk7XHJcbiAgICAgICAgICAgIGlmIChlbG0gIT09IGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJpZWRFbGVtZW50cy5hZGQoZWxtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZWRFbGVtZW50c0xpc3QgPSBpdGVyYXRvclRvQXJyYXkocXVlcmllZEVsZW1lbnRzLnZhbHVlcygpKTtcclxuICAgICAgICByZXR1cm4gY3JlYXRlVHJhbnNpdGlvbkluc3RydWN0aW9uKGVsZW1lbnQsIHRoaXMuX3RyaWdnZXJOYW1lLCBjdXJyZW50U3RhdGUsIG5leHRTdGF0ZSwgaXNSZW1vdmFsLCBjdXJyZW50U3RhdGVTdHlsZXMsIG5leHRTdGF0ZVN0eWxlcywgdGltZWxpbmVzLCBxdWVyaWVkRWxlbWVudHNMaXN0LCBwcmVTdHlsZU1hcCwgcG9zdFN0eWxlTWFwKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3Rvcnk7XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IG1hdGNoRm5zXHJcbiAqIEBwYXJhbSB7P30gY3VycmVudFN0YXRlXHJcbiAqIEBwYXJhbSB7P30gbmV4dFN0YXRlXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBvbmVPck1vcmVUcmFuc2l0aW9uc01hdGNoKG1hdGNoRm5zLCBjdXJyZW50U3RhdGUsIG5leHRTdGF0ZSkge1xyXG4gICAgcmV0dXJuIG1hdGNoRm5zLnNvbWUoZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbihjdXJyZW50U3RhdGUsIG5leHRTdGF0ZSk7IH0pO1xyXG59XHJcbnZhciBBbmltYXRpb25TdGF0ZVN0eWxlcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlU3R5bGVzKHN0eWxlcywgZGVmYXVsdFBhcmFtcykge1xyXG4gICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdFBhcmFtcyA9IGRlZmF1bHRQYXJhbXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXHJcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uU3RhdGVTdHlsZXMucHJvdG90eXBlLmJ1aWxkU3R5bGVzID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xyXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChwYXJhbXMsIGVycm9ycykge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbmFsU3R5bGVzID0ge307XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tYmluZWRQYXJhbXMgPSBjb3B5T2JqKHRoaXMuZGVmYXVsdFBhcmFtcyk7XHJcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBwYXJhbXNba2V5XTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbWJpbmVkUGFyYW1zW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzLnN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVPYmpfMSA9IC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0eWxlT2JqXzEpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWwgPSBzdHlsZU9ial8xW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBpbnRlcnBvbGF0ZVBhcmFtcyh2YWwsIGNvbWJpbmVkUGFyYW1zLCBlcnJvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmaW5hbFN0eWxlc1twcm9wXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZpbmFsU3R5bGVzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBbmltYXRpb25TdGF0ZVN0eWxlcztcclxufSgpKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxuLyoqXHJcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXHJcbiAqIEBwYXJhbSB7P30gbmFtZVxyXG4gKiBAcGFyYW0gez99IGFzdFxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gYnVpbGRUcmlnZ2VyKG5hbWUsIGFzdCkge1xyXG4gICAgcmV0dXJuIG5ldyBBbmltYXRpb25UcmlnZ2VyKG5hbWUsIGFzdCk7XHJcbn1cclxuLyoqXHJcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXHJcbiAqL1xyXG52YXIgQW5pbWF0aW9uVHJpZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRyaWdnZXIobmFtZSwgYXN0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuYXN0ID0gYXN0O1xyXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbkZhY3RvcmllcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3RhdGVzID0ge307XHJcbiAgICAgICAgYXN0LnN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVmYXVsdFBhcmFtcyA9IChhc3Qub3B0aW9ucyAmJiBhc3Qub3B0aW9ucy5wYXJhbXMpIHx8IHt9O1xyXG4gICAgICAgICAgICBfdGhpcy5zdGF0ZXNbYXN0Lm5hbWVdID0gbmV3IEFuaW1hdGlvblN0YXRlU3R5bGVzKGFzdC5zdHlsZSwgZGVmYXVsdFBhcmFtcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYmFsYW5jZVByb3BlcnRpZXModGhpcy5zdGF0ZXMsICd0cnVlJywgJzEnKTtcclxuICAgICAgICBiYWxhbmNlUHJvcGVydGllcyh0aGlzLnN0YXRlcywgJ2ZhbHNlJywgJzAnKTtcclxuICAgICAgICBhc3QudHJhbnNpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLnRyYW5zaXRpb25GYWN0b3JpZXMucHVzaChuZXcgQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkobmFtZSwgYXN0LCBfdGhpcy5zdGF0ZXMpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmZhbGxiYWNrVHJhbnNpdGlvbiA9IGNyZWF0ZUZhbGxiYWNrVHJhbnNpdGlvbihuYW1lLCB0aGlzLnN0YXRlcyk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uVHJpZ2dlci5wcm90b3R5cGUsIFwiY29udGFpbnNRdWVyaWVzXCIsIHtcclxuICAgICAgICBnZXQ6IC8qKlxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5hc3QucXVlcnlDb3VudCA+IDA7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRTdGF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBuZXh0U3RhdGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRyaWdnZXIucHJvdG90eXBlLm1hdGNoVHJhbnNpdGlvbiA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBjdXJyZW50U3RhdGVcclxuICAgICAqIEBwYXJhbSB7P30gbmV4dFN0YXRlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyeSA9IHRoaXMudHJhbnNpdGlvbkZhY3Rvcmllcy5maW5kKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLm1hdGNoKGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIGVudHJ5IHx8IG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRTdGF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcclxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25UcmlnZ2VyLnByb3RvdHlwZS5tYXRjaFN0eWxlcyA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBjdXJyZW50U3RhdGVcclxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXHJcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGN1cnJlbnRTdGF0ZSwgcGFyYW1zLCBlcnJvcnMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mYWxsYmFja1RyYW5zaXRpb24uYnVpbGRTdHlsZXMoY3VycmVudFN0YXRlLCBwYXJhbXMsIGVycm9ycyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFuaW1hdGlvblRyaWdnZXI7XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHRyaWdnZXJOYW1lXHJcbiAqIEBwYXJhbSB7P30gc3RhdGVzXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVGYWxsYmFja1RyYW5zaXRpb24odHJpZ2dlck5hbWUsIHN0YXRlcykge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlcnMgPSBbZnVuY3Rpb24gKGZyb21TdGF0ZSwgdG9TdGF0ZSkgeyByZXR1cm4gdHJ1ZTsgfV07XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbmltYXRpb24gPSB7IHR5cGU6IDIgLyogU2VxdWVuY2UgKi8sIHN0ZXBzOiBbXSwgb3B0aW9uczogbnVsbCB9O1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNpdGlvbiA9IHtcclxuICAgICAgICB0eXBlOiAxIC8qIFRyYW5zaXRpb24gKi8sXHJcbiAgICAgICAgYW5pbWF0aW9uOiBhbmltYXRpb24sXHJcbiAgICAgICAgbWF0Y2hlcnM6IG1hdGNoZXJzLFxyXG4gICAgICAgIG9wdGlvbnM6IG51bGwsXHJcbiAgICAgICAgcXVlcnlDb3VudDogMCxcclxuICAgICAgICBkZXBDb3VudDogMFxyXG4gICAgfTtcclxuICAgIHJldHVybiBuZXcgQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkodHJpZ2dlck5hbWUsIHRyYW5zaXRpb24sIHN0YXRlcyk7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gb2JqXHJcbiAqIEBwYXJhbSB7P30ga2V5MVxyXG4gKiBAcGFyYW0gez99IGtleTJcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGJhbGFuY2VQcm9wZXJ0aWVzKG9iaiwga2V5MSwga2V5Mikge1xyXG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkxKSkge1xyXG4gICAgICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleTIpKSB7XHJcbiAgICAgICAgICAgIG9ialtrZXkyXSA9IG9ialtrZXkxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5MikpIHtcclxuICAgICAgICBvYmpba2V5MV0gPSBvYmpba2V5Ml07XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxudmFyIEVNUFRZX0lOU1RSVUNUSU9OX01BUCA9IG5ldyBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAoKTtcclxudmFyIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGltZWxpbmVBbmltYXRpb25FbmdpbmUoX2RyaXZlciwgX25vcm1hbGl6ZXIpIHtcclxuICAgICAgICB0aGlzLl9kcml2ZXIgPSBfZHJpdmVyO1xyXG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZXIgPSBfbm9ybWFsaXplcjtcclxuICAgICAgICB0aGlzLl9hbmltYXRpb25zID0ge307XHJcbiAgICAgICAgdGhpcy5fcGxheWVyc0J5SWQgPSB7fTtcclxuICAgICAgICB0aGlzLnBsYXllcnMgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpZFxyXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVGltZWxpbmVBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnJlZ2lzdGVyID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGlkXHJcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoaWQsIG1ldGFkYXRhKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gW107XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gYnVpbGRBbmltYXRpb25Bc3QodGhpcy5fZHJpdmVyLCBtZXRhZGF0YSwgZXJyb3JzKTtcclxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gYnVpbGQgdGhlIGFuaW1hdGlvbiBkdWUgdG8gdGhlIGZvbGxvd2luZyBlcnJvcnM6IFwiICsgZXJyb3JzLmpvaW4oXCJcXG5cIikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uc1tpZF0gPSBhc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpXHJcbiAgICAgKiBAcGFyYW0gez99IHByZVN0eWxlc1xyXG4gICAgICogQHBhcmFtIHs/PX0gcG9zdFN0eWxlc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVGltZWxpbmVBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9idWlsZFBsYXllciA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpXHJcbiAgICAgKiBAcGFyYW0gez99IHByZVN0eWxlc1xyXG4gICAgICogQHBhcmFtIHs/PX0gcG9zdFN0eWxlc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGksIHByZVN0eWxlcywgcG9zdFN0eWxlcykge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSBpLmVsZW1lbnQ7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ZnJhbWVzID0gbm9ybWFsaXplS2V5ZnJhbWVzKHRoaXMuX2RyaXZlciwgdGhpcy5fbm9ybWFsaXplciwgZWxlbWVudCwgaS5rZXlmcmFtZXMsIHByZVN0eWxlcywgcG9zdFN0eWxlcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyaXZlci5hbmltYXRlKGVsZW1lbnQsIGtleWZyYW1lcywgaS5kdXJhdGlvbiwgaS5kZWxheSwgaS5lYXNpbmcsIFtdKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gaWRcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVGltZWxpbmVBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmNyZWF0ZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpZFxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoaWQsIGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gW107XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gdGhpcy5fYW5pbWF0aW9uc1tpZF07XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5zdHJ1Y3Rpb25zO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF1dG9TdHlsZXNNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgaWYgKGFzdCkge1xyXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBidWlsZEFuaW1hdGlvblRpbWVsaW5lcyh0aGlzLl9kcml2ZXIsIGVsZW1lbnQsIGFzdCwgRU5URVJfQ0xBU1NOQU1FLCBMRUFWRV9DTEFTU05BTUUsIHt9LCB7fSwgb3B0aW9ucywgRU1QVFlfSU5TVFJVQ1RJT05fTUFQLCBlcnJvcnMpO1xyXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0gZ2V0T3JTZXRBc0luTWFwKGF1dG9TdHlsZXNNYXAsIGluc3QuZWxlbWVudCwge30pO1xyXG4gICAgICAgICAgICAgICAgaW5zdC5wb3N0U3R5bGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBzdHlsZXNbcHJvcF0gPSBudWxsOyB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlcnJvcnMucHVzaCgnVGhlIHJlcXVlc3RlZCBhbmltYXRpb24gZG9lc25cXCd0IGV4aXN0IG9yIGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkJyk7XHJcbiAgICAgICAgICAgIGluc3RydWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY3JlYXRlIHRoZSBhbmltYXRpb24gZHVlIHRvIHRoZSBmb2xsb3dpbmcgZXJyb3JzOiBcIiArIGVycm9ycy5qb2luKFwiXFxuXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXV0b1N0eWxlc01hcC5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZXMsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHN0eWxlc1twcm9wXSA9IF90aGlzLl9kcml2ZXIuY29tcHV0ZVN0eWxlKGVsZW1lbnQsIHByb3AsIF9hbmd1bGFyX2FuaW1hdGlvbnMuQVVUT19TVFlMRSk7IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBpbnN0cnVjdGlvbnMubWFwKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcyA9IGF1dG9TdHlsZXNNYXAuZ2V0KGkuZWxlbWVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fYnVpbGRQbGF5ZXIoaSwge30sIHN0eWxlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gb3B0aW1pemVHcm91cFBsYXllcihwbGF5ZXJzKTtcclxuICAgICAgICB0aGlzLl9wbGF5ZXJzQnlJZFtpZF0gPSBwbGF5ZXI7XHJcbiAgICAgICAgcGxheWVyLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kZXN0cm95KGlkKTsgfSk7XHJcbiAgICAgICAgdGhpcy5wbGF5ZXJzLnB1c2gocGxheWVyKTtcclxuICAgICAgICByZXR1cm4gcGxheWVyO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVGltZWxpbmVBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmRlc3Ryb3kgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gaWRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IHRoaXMuX2dldFBsYXllcihpZCk7XHJcbiAgICAgICAgcGxheWVyLmRlc3Ryb3koKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5fcGxheWVyc0J5SWRbaWRdO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gdGhpcy5wbGF5ZXJzLmluZGV4T2YocGxheWVyKTtcclxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnBsYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGlkXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuX2dldFBsYXllciA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gdGhpcy5fcGxheWVyc0J5SWRbaWRdO1xyXG4gICAgICAgIGlmICghcGxheWVyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHRoZSB0aW1lbGluZSBwbGF5ZXIgcmVmZXJlbmNlZCBieSBcIiArIGlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBsYXllcjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gaWRcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcclxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5saXN0ZW4gPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gaWRcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcclxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChpZCwgZWxlbWVudCwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xyXG4gICAgICAgIC8vIHRyaWdnZXJOYW1lLCBmcm9tU3RhdGUsIHRvU3RhdGUgYXJlIGFsbCBpZ25vcmVkIGZvciB0aW1lbGluZSBhbmltYXRpb25zXHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZUV2ZW50ID0gbWFrZUFuaW1hdGlvbkV2ZW50KGVsZW1lbnQsICcnLCAnJywgJycpO1xyXG4gICAgICAgIGxpc3Rlbk9uUGxheWVyKHRoaXMuX2dldFBsYXllcihpZCksIGV2ZW50TmFtZSwgYmFzZUV2ZW50LCBjYWxsYmFjayk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gaWRcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBjb21tYW5kXHJcbiAgICAgKiBAcGFyYW0gez99IGFyZ3NcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5jb21tYW5kID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGlkXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gY29tbWFuZFxyXG4gICAgICogQHBhcmFtIHs/fSBhcmdzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoaWQsIGVsZW1lbnQsIGNvbW1hbmQsIGFyZ3MpIHtcclxuICAgICAgICBpZiAoY29tbWFuZCA9PSAncmVnaXN0ZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoaWQsIC8qKiBAdHlwZSB7P30gKi8gKGFyZ3NbMF0pKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tbWFuZCA9PSAnY3JlYXRlJykge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25zID0gLyoqIEB0eXBlIHs/fSAqLyAoKGFyZ3NbMF0gfHwge30pKTtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGUoaWQsIGVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IHRoaXMuX2dldFBsYXllcihpZCk7XHJcbiAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3BsYXknOlxyXG4gICAgICAgICAgICAgICAgcGxheWVyLnBsYXkoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdwYXVzZSc6XHJcbiAgICAgICAgICAgICAgICBwbGF5ZXIucGF1c2UoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdyZXNldCc6XHJcbiAgICAgICAgICAgICAgICBwbGF5ZXIucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdyZXN0YXJ0JzpcclxuICAgICAgICAgICAgICAgIHBsYXllci5yZXN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZmluaXNoJzpcclxuICAgICAgICAgICAgICAgIHBsYXllci5maW5pc2goKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdpbml0JzpcclxuICAgICAgICAgICAgICAgIHBsYXllci5pbml0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnc2V0UG9zaXRpb24nOlxyXG4gICAgICAgICAgICAgICAgcGxheWVyLnNldFBvc2l0aW9uKHBhcnNlRmxvYXQoLyoqIEB0eXBlIHs/fSAqLyAoYXJnc1swXSkpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdkZXN0cm95JzpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveShpZCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lO1xyXG59KCkpO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxyXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXHJcbiAqL1xyXG52YXIgUVVFVUVEX0NMQVNTTkFNRSA9ICduZy1hbmltYXRlLXF1ZXVlZCc7XHJcbnZhciBRVUVVRURfU0VMRUNUT1IgPSAnLm5nLWFuaW1hdGUtcXVldWVkJztcclxudmFyIERJU0FCTEVEX0NMQVNTTkFNRSA9ICduZy1hbmltYXRlLWRpc2FibGVkJztcclxudmFyIERJU0FCTEVEX1NFTEVDVE9SID0gJy5uZy1hbmltYXRlLWRpc2FibGVkJztcclxudmFyIFNUQVJfQ0xBU1NOQU1FID0gJ25nLXN0YXItaW5zZXJ0ZWQnO1xyXG52YXIgU1RBUl9TRUxFQ1RPUiA9ICcubmctc3Rhci1pbnNlcnRlZCc7XHJcbnZhciBFTVBUWV9QTEFZRVJfQVJSQVkgPSBbXTtcclxudmFyIE5VTExfUkVNT1ZBTF9TVEFURSA9IHtcclxuICAgIG5hbWVzcGFjZUlkOiAnJyxcclxuICAgIHNldEZvclJlbW92YWw6IG51bGwsXHJcbiAgICBoYXNBbmltYXRpb246IGZhbHNlLFxyXG4gICAgcmVtb3ZlZEJlZm9yZVF1ZXJpZWQ6IGZhbHNlXHJcbn07XHJcbnZhciBOVUxMX1JFTU9WRURfUVVFUklFRF9TVEFURSA9IHtcclxuICAgIG5hbWVzcGFjZUlkOiAnJyxcclxuICAgIHNldEZvclJlbW92YWw6IG51bGwsXHJcbiAgICBoYXNBbmltYXRpb246IGZhbHNlLFxyXG4gICAgcmVtb3ZlZEJlZm9yZVF1ZXJpZWQ6IHRydWVcclxufTtcclxuLyoqXHJcbiAqIEByZWNvcmRcclxuICovXHJcblxyXG52YXIgUkVNT1ZBTF9GTEFHID0gJ19fbmdfcmVtb3ZlZCc7XHJcbi8qKlxyXG4gKiBAcmVjb3JkXHJcbiAqL1xyXG5cclxudmFyIFN0YXRlVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTdGF0ZVZhbHVlKGlucHV0LCBuYW1lc3BhY2VJZCkge1xyXG4gICAgICAgIGlmIChuYW1lc3BhY2VJZCA9PT0gdm9pZCAwKSB7IG5hbWVzcGFjZUlkID0gJyc7IH1cclxuICAgICAgICB0aGlzLm5hbWVzcGFjZUlkID0gbmFtZXNwYWNlSWQ7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNPYmogPSBpbnB1dCAmJiBpbnB1dC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGlzT2JqID8gaW5wdXRbJ3ZhbHVlJ10gOiBpbnB1dDtcclxuICAgICAgICB0aGlzLnZhbHVlID0gbm9ybWFsaXplVHJpZ2dlclZhbHVlKHZhbHVlKTtcclxuICAgICAgICBpZiAoaXNPYmopIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0aW9ucyA9IGNvcHlPYmooLyoqIEB0eXBlIHs/fSAqLyAoaW5wdXQpKTtcclxuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnNbJ3ZhbHVlJ107XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnBhcmFtcykge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucGFyYW1zID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlVmFsdWUucHJvdG90eXBlLCBcInBhcmFtc1wiLCB7XHJcbiAgICAgICAgZ2V0OiAvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIC8qKiBAdHlwZSB7P30gKi8gKHRoaXMub3B0aW9ucy5wYXJhbXMpOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBTdGF0ZVZhbHVlLnByb3RvdHlwZS5hYnNvcmJPcHRpb25zID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3UGFyYW1zID0gb3B0aW9ucy5wYXJhbXM7XHJcbiAgICAgICAgaWYgKG5ld1BhcmFtcykge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRQYXJhbXNfMSA9IC8qKiBAdHlwZSB7P30gKi8gKCh0aGlzLm9wdGlvbnMucGFyYW1zKSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG5ld1BhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9sZFBhcmFtc18xW3Byb3BdID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBvbGRQYXJhbXNfMVtwcm9wXSA9IG5ld1BhcmFtc1twcm9wXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBTdGF0ZVZhbHVlO1xyXG59KCkpO1xyXG52YXIgVk9JRF9WQUxVRSA9ICd2b2lkJztcclxudmFyIERFRkFVTFRfU1RBVEVfVkFMVUUgPSBuZXcgU3RhdGVWYWx1ZShWT0lEX1ZBTFVFKTtcclxudmFyIERFTEVURURfU1RBVEVfVkFMVUUgPSBuZXcgU3RhdGVWYWx1ZSgnREVMRVRFRCcpO1xyXG52YXIgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UoaWQsIGhvc3RFbGVtZW50LCBfZW5naW5lKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuaG9zdEVsZW1lbnQgPSBob3N0RWxlbWVudDtcclxuICAgICAgICB0aGlzLl9lbmdpbmUgPSBfZW5naW5lO1xyXG4gICAgICAgIHRoaXMucGxheWVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3RyaWdnZXJzID0ge307XHJcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50TGlzdGVuZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2hvc3RDbGFzc05hbWUgPSAnbmctdG5zLScgKyBpZDtcclxuICAgICAgICBhZGRDbGFzcyhob3N0RWxlbWVudCwgdGhpcy5faG9zdENsYXNzTmFtZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IHBoYXNlXHJcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5saXN0ZW4gPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IHBoYXNlXHJcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSwgcGhhc2UsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIXRoaXMuX3RyaWdnZXJzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBsaXN0ZW4gb24gdGhlIGFuaW1hdGlvbiB0cmlnZ2VyIGV2ZW50IFxcXCJcIiArIHBoYXNlICsgXCJcXFwiIGJlY2F1c2UgdGhlIGFuaW1hdGlvbiB0cmlnZ2VyIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZG9lc24ndCBleGlzdCFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwaGFzZSA9PSBudWxsIHx8IHBoYXNlLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBsaXN0ZW4gb24gdGhlIGFuaW1hdGlvbiB0cmlnZ2VyIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgYmVjYXVzZSB0aGUgcHJvdmlkZWQgZXZlbnQgaXMgdW5kZWZpbmVkIVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1RyaWdnZXJFdmVudFZhbGlkKHBoYXNlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcHJvdmlkZWQgYW5pbWF0aW9uIHRyaWdnZXIgZXZlbnQgXFxcIlwiICsgcGhhc2UgKyBcIlxcXCIgZm9yIHRoZSBhbmltYXRpb24gdHJpZ2dlciBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGlzIG5vdCBzdXBwb3J0ZWQhXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaXN0ZW5lcnMgPSBnZXRPclNldEFzSW5NYXAodGhpcy5fZWxlbWVudExpc3RlbmVycywgZWxlbWVudCwgW10pO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRhdGEgPSB7IG5hbWU6IG5hbWUsIHBoYXNlOiBwaGFzZSwgY2FsbGJhY2s6IGNhbGxiYWNrIH07XHJcbiAgICAgICAgbGlzdGVuZXJzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlcnNXaXRoU3RhdGVzID0gZ2V0T3JTZXRBc0luTWFwKHRoaXMuX2VuZ2luZS5zdGF0ZXNCeUVsZW1lbnQsIGVsZW1lbnQsIHt9KTtcclxuICAgICAgICBpZiAoIXRyaWdnZXJzV2l0aFN0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBOR19UUklHR0VSX0NMQVNTTkFNRSk7XHJcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIE5HX1RSSUdHRVJfQ0xBU1NOQU1FICsgJy0nICsgbmFtZSk7XHJcbiAgICAgICAgICAgIHRyaWdnZXJzV2l0aFN0YXRlc1tuYW1lXSA9IERFRkFVTFRfU1RBVEVfVkFMVUU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSBldmVudCBsaXN0ZW5lciBpcyByZW1vdmVkIEFGVEVSIHRoZSBmbHVzaCBoYXMgb2NjdXJyZWQgc3VjaFxyXG4gICAgICAgICAgICAvLyB0aGF0IGxlYXZlIGFuaW1hdGlvbnMgY2FsbGJhY2tzIGNhbiBmaXJlIChvdGhlcndpc2UgaWYgdGhlIG5vZGVcclxuICAgICAgICAgICAgLy8gaXMgcmVtb3ZlZCBpbiBiZXR3ZWVuIHRoZW4gdGhlIGxpc3RlbmVycyB3b3VsZCBiZSBkZXJlZ2lzdGVyZWQpXHJcbiAgICAgICAgICAgIC8vIHRoZSBldmVudCBsaXN0ZW5lciBpcyByZW1vdmVkIEFGVEVSIHRoZSBmbHVzaCBoYXMgb2NjdXJyZWQgc3VjaFxyXG4gICAgICAgICAgICAvLyB0aGF0IGxlYXZlIGFuaW1hdGlvbnMgY2FsbGJhY2tzIGNhbiBmaXJlIChvdGhlcndpc2UgaWYgdGhlIG5vZGVcclxuICAgICAgICAgICAgLy8gaXMgcmVtb3ZlZCBpbiBiZXR3ZWVuIHRoZW4gdGhlIGxpc3RlbmVycyB3b3VsZCBiZSBkZXJlZ2lzdGVyZWQpXHJcbiAgICAgICAgICAgIF90aGlzLl9lbmdpbmUuYWZ0ZXJGbHVzaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3RyaWdnZXJzW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRyaWdnZXJzV2l0aFN0YXRlc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSBhc3RcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLnJlZ2lzdGVyID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAqIEBwYXJhbSB7P30gYXN0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobmFtZSwgYXN0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJzW25hbWVdKSB7XHJcbiAgICAgICAgICAgIC8vIHRocm93XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJzW25hbWVdID0gYXN0O1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLl9nZXRUcmlnZ2VyID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlciA9IHRoaXMuX3RyaWdnZXJzW25hbWVdO1xyXG4gICAgICAgIGlmICghdHJpZ2dlcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcHJvdmlkZWQgYW5pbWF0aW9uIHRyaWdnZXIgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cmlnZ2VyO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IHRyaWdnZXJOYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gez89fSBkZWZhdWx0VG9GYWxsYmFja1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUudHJpZ2dlciA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IHRyaWdnZXJOYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gez89fSBkZWZhdWx0VG9GYWxsYmFja1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIHRyaWdnZXJOYW1lLCB2YWx1ZSwgZGVmYXVsdFRvRmFsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChkZWZhdWx0VG9GYWxsYmFjayA9PT0gdm9pZCAwKSB7IGRlZmF1bHRUb0ZhbGxiYWNrID0gdHJ1ZTsgfVxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXIgPSB0aGlzLl9nZXRUcmlnZ2VyKHRyaWdnZXJOYW1lKTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSBuZXcgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllcih0aGlzLmlkLCB0cmlnZ2VyTmFtZSwgZWxlbWVudCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlcnNXaXRoU3RhdGVzID0gdGhpcy5fZW5naW5lLnN0YXRlc0J5RWxlbWVudC5nZXQoZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKCF0cmlnZ2Vyc1dpdGhTdGF0ZXMpIHtcclxuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgTkdfVFJJR0dFUl9DTEFTU05BTUUpO1xyXG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBOR19UUklHR0VSX0NMQVNTTkFNRSArICctJyArIHRyaWdnZXJOYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lLnN0YXRlc0J5RWxlbWVudC5zZXQoZWxlbWVudCwgdHJpZ2dlcnNXaXRoU3RhdGVzID0ge30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmcm9tU3RhdGUgPSB0cmlnZ2Vyc1dpdGhTdGF0ZXNbdHJpZ2dlck5hbWVdO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvU3RhdGUgPSBuZXcgU3RhdGVWYWx1ZSh2YWx1ZSwgdGhpcy5pZCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNPYmogPSB2YWx1ZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKTtcclxuICAgICAgICBpZiAoIWlzT2JqICYmIGZyb21TdGF0ZSkge1xyXG4gICAgICAgICAgICB0b1N0YXRlLmFic29yYk9wdGlvbnMoZnJvbVN0YXRlLm9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmlnZ2Vyc1dpdGhTdGF0ZXNbdHJpZ2dlck5hbWVdID0gdG9TdGF0ZTtcclxuICAgICAgICBpZiAoIWZyb21TdGF0ZSkge1xyXG4gICAgICAgICAgICBmcm9tU3RhdGUgPSBERUZBVUxUX1NUQVRFX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChmcm9tU3RhdGUgPT09IERFTEVURURfU1RBVEVfVkFMVUUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBsYXllcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNSZW1vdmFsID0gdG9TdGF0ZS52YWx1ZSA9PT0gVk9JRF9WQUxVRTtcclxuICAgICAgICAvLyBub3JtYWxseSB0aGlzIGlzbid0IHJlYWNoZWQgYnkgaGVyZSwgaG93ZXZlciwgaWYgYW4gb2JqZWN0IGV4cHJlc3Npb25cclxuICAgICAgICAvLyBpcyBwYXNzZWQgaW4gdGhlbiBpdCBtYXkgYmUgYSBuZXcgb2JqZWN0IGVhY2ggdGltZS4gQ29tcGFyaW5nIHRoZSB2YWx1ZVxyXG4gICAgICAgIC8vIGlzIGltcG9ydGFudCBzaW5jZSB0aGF0IHdpbGwgc3RheSB0aGUgc2FtZSBkZXNwaXRlIHRoZXJlIGJlaW5nIGEgbmV3IG9iamVjdC5cclxuICAgICAgICAvLyBUaGUgcmVtb3ZhbCBhcmMgaGVyZSBpcyBzcGVjaWFsIGNhc2VkIGJlY2F1c2UgdGhlIHNhbWUgZWxlbWVudCBpcyB0cmlnZ2VyZWRcclxuICAgICAgICAvLyB0d2ljZSBpbiB0aGUgZXZlbnQgdGhhdCBpdCBjb250YWlucyBhbmltYXRpb25zIG9uIHRoZSBvdXRlci9pbm5lciBwb3J0aW9uc1xyXG4gICAgICAgIC8vIG9mIHRoZSBob3N0IGNvbnRhaW5lclxyXG4gICAgICAgIGlmICghaXNSZW1vdmFsICYmIGZyb21TdGF0ZS52YWx1ZSA9PT0gdG9TdGF0ZS52YWx1ZSkge1xyXG4gICAgICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgZGVzcGl0ZSB0aGUgdmFsdWUgbm90IGNoYW5naW5nLCBzb21lIGlubmVyIHBhcmFtc1xyXG4gICAgICAgICAgICAvLyBoYXZlIGNoYW5nZWQgd2hpY2ggbWVhbnMgdGhhdCB0aGUgYW5pbWF0aW9uIGZpbmFsIHN0eWxlcyBuZWVkIHRvIGJlIGFwcGxpZWRcclxuICAgICAgICAgICAgaWYgKCFvYmpFcXVhbHMoZnJvbVN0YXRlLnBhcmFtcywgdG9TdGF0ZS5wYXJhbXMpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZyb21TdHlsZXNfMSA9IHRyaWdnZXIubWF0Y2hTdHlsZXMoZnJvbVN0YXRlLnZhbHVlLCBmcm9tU3RhdGUucGFyYW1zLCBlcnJvcnMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9TdHlsZXNfMSA9IHRyaWdnZXIubWF0Y2hTdHlsZXModG9TdGF0ZS52YWx1ZSwgdG9TdGF0ZS5wYXJhbXMsIGVycm9ycyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5yZXBvcnRFcnJvcihlcnJvcnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLmFmdGVyRmx1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcmFzZVN0eWxlcyhlbGVtZW50LCBmcm9tU3R5bGVzXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTdHlsZXMoZWxlbWVudCwgdG9TdHlsZXNfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJzT25FbGVtZW50ID0gZ2V0T3JTZXRBc0luTWFwKHRoaXMuX2VuZ2luZS5wbGF5ZXJzQnlFbGVtZW50LCBlbGVtZW50LCBbXSk7XHJcbiAgICAgICAgcGxheWVyc09uRWxlbWVudC5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcclxuICAgICAgICAgICAgLy8gb25seSByZW1vdmUgdGhlIHBsYXllciBpZiBpdCBpcyBxdWV1ZWQgb24gdGhlIEVYQUNUIHNhbWUgdHJpZ2dlci9uYW1lc3BhY2VcclxuICAgICAgICAgICAgLy8gd2Ugb25seSBhbHNvIGRlYWwgd2l0aCBxdWV1ZWQgcGxheWVycyBoZXJlIGJlY2F1c2UgaWYgdGhlIGFuaW1hdGlvbiBoYXNcclxuICAgICAgICAgICAgLy8gc3RhcnRlZCB0aGVuIHdlIHdhbnQgdG8ga2VlcCB0aGUgcGxheWVyIGFsaXZlIHVudGlsIHRoZSBmbHVzaCBoYXBwZW5zXHJcbiAgICAgICAgICAgIC8vICh3aGljaCBpcyB3aGVyZSB0aGUgcHJldmlvdXNQbGF5ZXJzIGFyZSBwYXNzZWQgaW50byB0aGUgbmV3IHBhbHllcilcclxuICAgICAgICAgICAgaWYgKHBsYXllci5uYW1lc3BhY2VJZCA9PSBfdGhpcy5pZCAmJiBwbGF5ZXIudHJpZ2dlck5hbWUgPT0gdHJpZ2dlck5hbWUgJiYgcGxheWVyLnF1ZXVlZCkge1xyXG4gICAgICAgICAgICAgICAgcGxheWVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zaXRpb24gPSB0cmlnZ2VyLm1hdGNoVHJhbnNpdGlvbihmcm9tU3RhdGUudmFsdWUsIHRvU3RhdGUudmFsdWUpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzRmFsbGJhY2tUcmFuc2l0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCF0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICghZGVmYXVsdFRvRmFsbGJhY2spXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24gPSB0cmlnZ2VyLmZhbGxiYWNrVHJhbnNpdGlvbjtcclxuICAgICAgICAgICAgaXNGYWxsYmFja1RyYW5zaXRpb24gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9lbmdpbmUudG90YWxRdWV1ZWRQbGF5ZXJzKys7XHJcbiAgICAgICAgdGhpcy5fcXVldWUucHVzaCh7IGVsZW1lbnQ6IGVsZW1lbnQsIHRyaWdnZXJOYW1lOiB0cmlnZ2VyTmFtZSwgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiwgZnJvbVN0YXRlOiBmcm9tU3RhdGUsIHRvU3RhdGU6IHRvU3RhdGUsIHBsYXllcjogcGxheWVyLCBpc0ZhbGxiYWNrVHJhbnNpdGlvbjogaXNGYWxsYmFja1RyYW5zaXRpb24gfSk7XHJcbiAgICAgICAgaWYgKCFpc0ZhbGxiYWNrVHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBRVUVVRURfQ0xBU1NOQU1FKTtcclxuICAgICAgICAgICAgcGxheWVyLm9uU3RhcnQoZnVuY3Rpb24gKCkgeyByZW1vdmVDbGFzcyhlbGVtZW50LCBRVUVVRURfQ0xBU1NOQU1FKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBsYXllci5vbkRvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IF90aGlzLnBsYXllcnMuaW5kZXhPZihwbGF5ZXIpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucGxheWVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBfdGhpcy5fZW5naW5lLnBsYXllcnNCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xyXG4gICAgICAgICAgICBpZiAocGxheWVycykge1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXhfMSA9IHBsYXllcnMuaW5kZXhPZihwbGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4XzEgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBsYXllcnMuc3BsaWNlKGluZGV4XzEsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5wbGF5ZXJzLnB1c2gocGxheWVyKTtcclxuICAgICAgICBwbGF5ZXJzT25FbGVtZW50LnB1c2gocGxheWVyKTtcclxuICAgICAgICByZXR1cm4gcGxheWVyO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5kZXJlZ2lzdGVyID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBkZWxldGUgdGhpcy5fdHJpZ2dlcnNbbmFtZV07XHJcbiAgICAgICAgdGhpcy5fZW5naW5lLnN0YXRlc0J5RWxlbWVudC5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZU1hcCwgZWxlbWVudCkgeyBkZWxldGUgc3RhdGVNYXBbbmFtZV07IH0pO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXJzLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9lbGVtZW50TGlzdGVuZXJzLnNldChlbGVtZW50LCBsaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkubmFtZSAhPSBuYW1lOyB9KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLmNsZWFyRWxlbWVudENhY2hlID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lLnN0YXRlc0J5RWxlbWVudC5kZWxldGUoZWxlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudExpc3RlbmVycy5kZWxldGUoZWxlbWVudCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudFBsYXllcnMgPSB0aGlzLl9lbmdpbmUucGxheWVyc0J5RWxlbWVudC5nZXQoZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKGVsZW1lbnRQbGF5ZXJzKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnRQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmRlc3Ryb3koKTsgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5wbGF5ZXJzQnlFbGVtZW50LmRlbGV0ZShlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHJvb3RFbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEBwYXJhbSB7Pz19IGFuaW1hdGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLl9zaWduYWxSZW1vdmFsRm9ySW5uZXJUcmlnZ2VycyA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSByb290RWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gez89fSBhbmltYXRlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAocm9vdEVsZW1lbnQsIGNvbnRleHQsIGFuaW1hdGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChhbmltYXRlID09PSB2b2lkIDApIHsgYW5pbWF0ZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgLy8gZW11bGF0ZSBhIGxlYXZlIGFuaW1hdGlvbiBmb3IgYWxsIGlubmVyIG5vZGVzIHdpdGhpbiB0aGlzIG5vZGUuXHJcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGFuaW1hdGlvbnMgZm91bmQgZm9yIGFueSBvZiB0aGUgbm9kZXMgdGhlbiBjbGVhciB0aGUgY2FjaGVcclxuICAgICAgICAvLyBmb3IgdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgdGhpcy5fZW5naW5lLmRyaXZlci5xdWVyeShyb290RWxlbWVudCwgTkdfVFJJR0dFUl9TRUxFQ1RPUiwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoZWxtKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBhbiBpbm5lciByZW1vdmUoKSBvcGVyYXRpb24gaGFzIGFscmVhZHkga2lja2VkIG9mZlxyXG4gICAgICAgICAgICAvLyB0aGUgYW5pbWF0aW9uIG9uIHRoaXMgZWxlbWVudC4uLlxyXG4gICAgICAgICAgICBpZiAoZWxtW1JFTU9WQUxfRkxBR10pXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVzcGFjZXMgPSBfdGhpcy5fZW5naW5lLmZldGNoTmFtZXNwYWNlc0J5RWxlbWVudChlbG0pO1xyXG4gICAgICAgICAgICBpZiAobmFtZXNwYWNlcy5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzLmZvckVhY2goZnVuY3Rpb24gKG5zKSB7IHJldHVybiBucy50cmlnZ2VyTGVhdmVBbmltYXRpb24oZWxtLCBjb250ZXh0LCBmYWxzZSwgdHJ1ZSk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xlYXJFbGVtZW50Q2FjaGUoZWxtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEBwYXJhbSB7Pz19IGRlc3Ryb3lBZnRlckNvbXBsZXRlXHJcbiAgICAgKiBAcGFyYW0gez89fSBkZWZhdWx0VG9GYWxsYmFja1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUudHJpZ2dlckxlYXZlQW5pbWF0aW9uID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHBhcmFtIHs/PX0gZGVzdHJveUFmdGVyQ29tcGxldGVcclxuICAgICAqIEBwYXJhbSB7Pz19IGRlZmF1bHRUb0ZhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCwgZGVzdHJveUFmdGVyQ29tcGxldGUsIGRlZmF1bHRUb0ZhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VyU3RhdGVzID0gdGhpcy5fZW5naW5lLnN0YXRlc0J5RWxlbWVudC5nZXQoZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKHRyaWdnZXJTdGF0ZXMpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyc18xID0gW107XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRyaWdnZXJTdGF0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXJOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNoZWNrIGlzIGhlcmUgaW4gdGhlIGV2ZW50IHRoYXQgYW4gZWxlbWVudCBpcyByZW1vdmVkXHJcbiAgICAgICAgICAgICAgICAvLyB0d2ljZSAoYm90aCBvbiB0aGUgaG9zdCBsZXZlbCBhbmQgdGhlIGNvbXBvbmVudCBsZXZlbClcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fdHJpZ2dlcnNbdHJpZ2dlck5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gX3RoaXMudHJpZ2dlcihlbGVtZW50LCB0cmlnZ2VyTmFtZSwgVk9JRF9WQUxVRSwgZGVmYXVsdFRvRmFsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVyc18xLnB1c2gocGxheWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAocGxheWVyc18xLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLm1hcmtFbGVtZW50QXNSZW1vdmVkKHRoaXMuaWQsIGVsZW1lbnQsIHRydWUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlc3Ryb3lBZnRlckNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW1pemVHcm91cFBsYXllcihwbGF5ZXJzXzEpLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZW5naW5lLnByb2Nlc3NMZWF2ZU5vZGUoZWxlbWVudCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5wcmVwYXJlTGVhdmVBbmltYXRpb25MaXN0ZW5lcnMgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpc3RlbmVycyA9IHRoaXMuX2VsZW1lbnRMaXN0ZW5lcnMuZ2V0KGVsZW1lbnQpO1xyXG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRlZFRyaWdnZXJzXzEgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlck5hbWUgPSBsaXN0ZW5lci5uYW1lO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRUcmlnZ2Vyc18xLmhhcyh0cmlnZ2VyTmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdmlzaXRlZFRyaWdnZXJzXzEuYWRkKHRyaWdnZXJOYW1lKTtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXIgPSBfdGhpcy5fdHJpZ2dlcnNbdHJpZ2dlck5hbWVdO1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNpdGlvbiA9IHRyaWdnZXIuZmFsbGJhY2tUcmFuc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudFN0YXRlcyA9IC8qKiBAdHlwZSB7P30gKi8gKChfdGhpcy5fZW5naW5lLnN0YXRlc0J5RWxlbWVudC5nZXQoZWxlbWVudCkpKTtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZyb21TdGF0ZSA9IGVsZW1lbnRTdGF0ZXNbdHJpZ2dlck5hbWVdIHx8IERFRkFVTFRfU1RBVEVfVkFMVUU7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b1N0YXRlID0gbmV3IFN0YXRlVmFsdWUoVk9JRF9WQUxVRSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSBuZXcgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllcihfdGhpcy5pZCwgdHJpZ2dlck5hbWUsIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2VuZ2luZS50b3RhbFF1ZXVlZFBsYXllcnMrKztcclxuICAgICAgICAgICAgICAgIF90aGlzLl9xdWV1ZS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJOYW1lOiB0cmlnZ2VyTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGZyb21TdGF0ZTogZnJvbVN0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvU3RhdGU6IHRvU3RhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyOiBwbGF5ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNGYWxsYmFja1RyYW5zaXRpb246IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUucmVtb3ZlTm9kZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmdpbmUgPSB0aGlzLl9lbmdpbmU7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGRFbGVtZW50Q291bnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2lnbmFsUmVtb3ZhbEZvcklubmVyVHJpZ2dlcnMoZWxlbWVudCwgY29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBhICogPT4gVk9JRCBhbmltYXRpb24gd2FzIGRldGVjdGVkIGFuZCBraWNrZWQgb2ZmXHJcbiAgICAgICAgaWYgKHRoaXMudHJpZ2dlckxlYXZlQW5pbWF0aW9uKGVsZW1lbnQsIGNvbnRleHQsIHRydWUpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgLy8gZmluZCB0aGUgcGxheWVyIHRoYXQgaXMgYW5pbWF0aW5nIGFuZCBtYWtlIHN1cmUgdGhhdCB0aGVcclxuICAgICAgICAvLyByZW1vdmFsIGlzIGRlbGF5ZWQgdW50aWwgdGhhdCBwbGF5ZXIgaGFzIGNvbXBsZXRlZFxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5zUG90ZW50aWFsUGFyZW50VHJhbnNpdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChlbmdpbmUudG90YWxBbmltYXRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRQbGF5ZXJzID0gZW5naW5lLnBsYXllcnMubGVuZ3RoID8gZW5naW5lLnBsYXllcnNCeVF1ZXJpZWRFbGVtZW50LmdldChlbGVtZW50KSA6IFtdO1xyXG4gICAgICAgICAgICAvLyB3aGVuIHRoaXMgYGlmIHN0YXRlbWVudGAgZG9lcyBub3QgY29udGludWUgZm9yd2FyZCBpdCBtZWFucyB0aGF0XHJcbiAgICAgICAgICAgIC8vIGEgcHJldmlvdXMgYW5pbWF0aW9uIHF1ZXJ5IGhhcyBzZWxlY3RlZCB0aGUgY3VycmVudCBlbGVtZW50IGFuZFxyXG4gICAgICAgICAgICAvLyBpcyBhbmltYXRpbmcgaXQuIEluIHRoaXMgc2l0dWF0aW9uIHdhbnQgdG8gY29udGludWUgZm93YXJkcyBhbmRcclxuICAgICAgICAgICAgLy8gYWxsb3cgdGhlIGVsZW1lbnQgdG8gYmUgcXVldWVkIHVwIGZvciBhbmltYXRpb24gbGF0ZXIuXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGxheWVycyAmJiBjdXJyZW50UGxheWVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5zUG90ZW50aWFsUGFyZW50VHJhbnNpdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRfMSA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocGFyZW50XzEgPSBwYXJlbnRfMS5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlcnMgPSBlbmdpbmUuc3RhdGVzQnlFbGVtZW50LmdldChwYXJlbnRfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zUG90ZW50aWFsUGFyZW50VHJhbnNpdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhdCB0aGlzIHN0YWdlIHdlIGtub3cgdGhhdCB0aGUgZWxlbWVudCB3aWxsIGVpdGhlciBnZXQgcmVtb3ZlZFxyXG4gICAgICAgIC8vIGR1cmluZyBmbHVzaCBvciB3aWxsIGJlIHBpY2tlZCB1cCBieSBhIHBhcmVudCBxdWVyeS4gRWl0aGVyIHdheVxyXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZmlyZSB0aGUgbGlzdGVuZXJzIGZvciB0aGlzIGVsZW1lbnQgd2hlbiBpdCBET0VTIGdldFxyXG4gICAgICAgIC8vIHJlbW92ZWQgKG9uY2UgdGhlIHF1ZXJ5IHBhcmVudCBhbmltYXRpb24gaXMgZG9uZSBvciBhZnRlciBmbHVzaClcclxuICAgICAgICB0aGlzLnByZXBhcmVMZWF2ZUFuaW1hdGlvbkxpc3RlbmVycyhlbGVtZW50KTtcclxuICAgICAgICAvLyB3aGV0aGVyIG9yIG5vdCBhIHBhcmVudCBoYXMgYW4gYW5pbWF0aW9uIHdlIG5lZWQgdG8gZGVsYXkgdGhlIGRlZmVycmFsIG9mIHRoZSBsZWF2ZVxyXG4gICAgICAgIC8vIG9wZXJhdGlvbiB1bnRpbCB3ZSBoYXZlIG1vcmUgaW5mb3JtYXRpb24gKHdoaWNoIHdlIGRvIGFmdGVyIGZsdXNoKCkgaGFzIGJlZW4gY2FsbGVkKVxyXG4gICAgICAgIGlmIChjb250YWluc1BvdGVudGlhbFBhcmVudFRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgZW5naW5lLm1hcmtFbGVtZW50QXNSZW1vdmVkKHRoaXMuaWQsIGVsZW1lbnQsIGZhbHNlLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHdlIGRvIHRoaXMgYWZ0ZXIgdGhlIGZsdXNoIGhhcyBvY2N1cnJlZCBzdWNoXHJcbiAgICAgICAgICAgIC8vIHRoYXQgdGhlIGNhbGxiYWNrcyBjYW4gYmUgZmlyZWRcclxuICAgICAgICAgICAgZW5naW5lLmFmdGVyRmx1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xlYXJFbGVtZW50Q2FjaGUoZWxlbWVudCk7IH0pO1xyXG4gICAgICAgICAgICBlbmdpbmUuZGVzdHJveUlubmVyQW5pbWF0aW9ucyhlbGVtZW50KTtcclxuICAgICAgICAgICAgZW5naW5lLl9vblJlbW92YWxDb21wbGV0ZShlbGVtZW50LCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5pbnNlcnROb2RlID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgcGFyZW50KSB7IGFkZENsYXNzKGVsZW1lbnQsIHRoaXMuX2hvc3RDbGFzc05hbWUpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG1pY3JvdGFza0lkXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5kcmFpblF1ZXVlZFRyYW5zaXRpb25zID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG1pY3JvdGFza0lkXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobWljcm90YXNrSWQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluc3RydWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IGVudHJ5LnBsYXllcjtcclxuICAgICAgICAgICAgaWYgKHBsYXllci5kZXN0cm95ZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSBlbnRyeS5lbGVtZW50O1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaXN0ZW5lcnMgPSBfdGhpcy5fZWxlbWVudExpc3RlbmVycy5nZXQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lci5uYW1lID09IGVudHJ5LnRyaWdnZXJOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VFdmVudCA9IG1ha2VBbmltYXRpb25FdmVudChlbGVtZW50LCBlbnRyeS50cmlnZ2VyTmFtZSwgZW50cnkuZnJvbVN0YXRlLnZhbHVlLCBlbnRyeS50b1N0YXRlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKGJhc2VFdmVudCkpWydfZGF0YSddID0gbWljcm90YXNrSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Rlbk9uUGxheWVyKGVudHJ5LnBsYXllciwgbGlzdGVuZXIucGhhc2UsIGJhc2VFdmVudCwgbGlzdGVuZXIuY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwbGF5ZXIubWFya2VkRm9yRGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2VuZ2luZS5hZnRlckZsdXNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBub3cgd2UgY2FuIGRlc3Ryb3kgdGhlIGVsZW1lbnQgcHJvcGVybHkgc2luY2UgdGhlIGV2ZW50IGxpc3RlbmVycyBoYXZlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVlbiBib3VuZCB0byB0aGUgcGxheWVyXHJcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcclxuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgLy8gaWYgZGVwQ291bnQgPT0gMCB0aGVtIG1vdmUgdG8gZnJvbnRcclxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGlmIGEgY29udGFpbnMgYiB0aGVuIG1vdmUgYmFja1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkMCA9IGEudHJhbnNpdGlvbi5hc3QuZGVwQ291bnQ7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGQxID0gYi50cmFuc2l0aW9uLmFzdC5kZXBDb3VudDtcclxuICAgICAgICAgICAgaWYgKGQwID09IDAgfHwgZDEgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQwIC0gZDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9lbmdpbmUuZHJpdmVyLmNvbnRhaW5zRWxlbWVudChhLmVsZW1lbnQsIGIuZWxlbWVudCkgPyAxIDogLTE7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLmRlc3Ryb3kgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5kZXN0cm95KCk7IH0pO1xyXG4gICAgICAgIHRoaXMuX3NpZ25hbFJlbW92YWxGb3JJbm5lclRyaWdnZXJzKHRoaXMuaG9zdEVsZW1lbnQsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5lbGVtZW50Q29udGFpbnNEYXRhID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbnNEYXRhID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRMaXN0ZW5lcnMuaGFzKGVsZW1lbnQpKVxyXG4gICAgICAgICAgICBjb250YWluc0RhdGEgPSB0cnVlO1xyXG4gICAgICAgIGNvbnRhaW5zRGF0YSA9XHJcbiAgICAgICAgICAgICh0aGlzLl9xdWV1ZS5maW5kKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkuZWxlbWVudCA9PT0gZWxlbWVudDsgfSkgPyB0cnVlIDogZmFsc2UpIHx8IGNvbnRhaW5zRGF0YTtcclxuICAgICAgICByZXR1cm4gY29udGFpbnNEYXRhO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlO1xyXG59KCkpO1xyXG4vKipcclxuICogQHJlY29yZFxyXG4gKi9cclxuXHJcbnZhciBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZShkcml2ZXIsIF9ub3JtYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5kcml2ZXIgPSBkcml2ZXI7XHJcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplciA9IF9ub3JtYWxpemVyO1xyXG4gICAgICAgIHRoaXMucGxheWVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMubmV3SG9zdEVsZW1lbnRzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMucGxheWVyc0J5RWxlbWVudCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnBsYXllcnNCeVF1ZXJpZWRFbGVtZW50ID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuc3RhdGVzQnlFbGVtZW50ID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWROb2RlcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLnRvdGFsQW5pbWF0aW9ucyA9IDA7XHJcbiAgICAgICAgdGhpcy50b3RhbFF1ZXVlZFBsYXllcnMgPSAwO1xyXG4gICAgICAgIHRoaXMuX25hbWVzcGFjZUxvb2t1cCA9IHt9O1xyXG4gICAgICAgIHRoaXMuX25hbWVzcGFjZUxpc3QgPSBbXTtcclxuICAgICAgICB0aGlzLl9mbHVzaEZucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3doZW5RdWlldEZucyA9IFtdO1xyXG4gICAgICAgIHRoaXMubmFtZXNwYWNlc0J5SG9zdEVsZW1lbnQgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0ZWRFbnRlckVsZW1lbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5vblJlbW92YWxDb21wbGV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7IH07XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICAvKipcclxuICAgICAqIFxcQGludGVybmFsXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuX29uUmVtb3ZhbENvbXBsZXRlID0gLyoqXHJcbiAgICAgKiBcXEBpbnRlcm5hbFxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7IHRoaXMub25SZW1vdmFsQ29tcGxldGUoZWxlbWVudCwgY29udGV4dCk7IH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUsIFwicXVldWVkUGxheWVyc1wiLCB7XHJcbiAgICAgICAgZ2V0OiAvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVycyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9uYW1lc3BhY2VMaXN0LmZvckVhY2goZnVuY3Rpb24gKG5zKSB7XHJcbiAgICAgICAgICAgICAgICBucy5wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGF5ZXIucXVldWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllcnMucHVzaChwbGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHBsYXllcnM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcclxuICAgICAqIEBwYXJhbSB7P30gaG9zdEVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmNyZWF0ZU5hbWVzcGFjZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxyXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5zID0gbmV3IEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UobmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50LCB0aGlzKTtcclxuICAgICAgICBpZiAoaG9zdEVsZW1lbnQucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9iYWxhbmNlTmFtZXNwYWNlTGlzdChucywgaG9zdEVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZGVmZXIgdGhpcyBsYXRlciB1bnRpbCBmbHVzaCBkdXJpbmcgd2hlbiB0aGUgaG9zdCBlbGVtZW50IGhhc1xyXG4gICAgICAgICAgICAvLyBiZWVuIGluc2VydGVkIHNvIHRoYXQgd2Uga25vdyBleGFjdGx5IHdoZXJlIHRvIHBsYWNlIGl0IGluXHJcbiAgICAgICAgICAgIC8vIHRoZSBuYW1lc3BhY2UgbGlzdFxyXG4gICAgICAgICAgICB0aGlzLm5ld0hvc3RFbGVtZW50cy5zZXQoaG9zdEVsZW1lbnQsIG5zKTtcclxuICAgICAgICAgICAgLy8gZ2l2ZW4gdGhhdCB0aGlzIGhvc3QgZWxlbWVudCBpcyBhcGFydCBvZiB0aGUgYW5pbWF0aW9uIGNvZGUsIGl0XHJcbiAgICAgICAgICAgIC8vIG1heSBvciBtYXkgbm90IGJlIGluc2VydGVkIGJ5IGEgcGFyZW50IG5vZGUgdGhhdCBpcyBhbiBvZiBhblxyXG4gICAgICAgICAgICAvLyBhbmltYXRpb24gcmVuZGVyZXIgdHlwZS4gSWYgdGhpcyBoYXBwZW5zIHRoZW4gd2UgY2FuIHN0aWxsIGhhdmVcclxuICAgICAgICAgICAgLy8gYWNjZXNzIHRvIHRoaXMgaXRlbSB3aGVuIHdlIHF1ZXJ5IGZvciA6ZW50ZXIgbm9kZXMuIElmIHRoZSBwYXJlbnRcclxuICAgICAgICAgICAgLy8gaXMgYSByZW5kZXJlciB0aGVuIHRoZSBzZXQgZGF0YS1zdHJ1Y3R1cmUgd2lsbCBub3JtYWxpemUgdGhlIGVudHJ5XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdEVudGVyRWxlbWVudChob3N0RWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lc3BhY2VMb29rdXBbbmFtZXNwYWNlSWRdID0gbnM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5zXHJcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fYmFsYW5jZU5hbWVzcGFjZUxpc3QgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbnNcclxuICAgICAqIEBwYXJhbSB7P30gaG9zdEVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChucywgaG9zdEVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW1pdCA9IHRoaXMuX25hbWVzcGFjZUxpc3QubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAobGltaXQgPj0gMCkge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBsaW1pdDsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5leHROYW1lc3BhY2UgPSB0aGlzLl9uYW1lc3BhY2VMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJpdmVyLmNvbnRhaW5zRWxlbWVudChuZXh0TmFtZXNwYWNlLmhvc3RFbGVtZW50LCBob3N0RWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uYW1lc3BhY2VMaXN0LnNwbGljZShpICsgMSwgMCwgbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9uYW1lc3BhY2VMaXN0LnNwbGljZSgwLCAwLCBucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX25hbWVzcGFjZUxpc3QucHVzaChucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubmFtZXNwYWNlc0J5SG9zdEVsZW1lbnQuc2V0KGhvc3RFbGVtZW50LCBucyk7XHJcbiAgICAgICAgcmV0dXJuIG5zO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxyXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUucmVnaXN0ZXIgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcclxuICAgICAqIEBwYXJhbSB7P30gaG9zdEVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IHRoaXMuX25hbWVzcGFjZUxvb2t1cFtuYW1lc3BhY2VJZF07XHJcbiAgICAgICAgaWYgKCFucykge1xyXG4gICAgICAgICAgICBucyA9IHRoaXMuY3JlYXRlTmFtZXNwYWNlKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBucztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSB0cmlnZ2VyXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5yZWdpc3RlclRyaWdnZXIgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSB0cmlnZ2VyXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIG5hbWUsIHRyaWdnZXIpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IHRoaXMuX25hbWVzcGFjZUxvb2t1cFtuYW1lc3BhY2VJZF07XHJcbiAgICAgICAgaWYgKG5zICYmIG5zLnJlZ2lzdGVyKG5hbWUsIHRyaWdnZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudG90YWxBbmltYXRpb25zKys7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5kZXN0cm95ID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFuYW1lc3BhY2VJZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5zID0gdGhpcy5fZmV0Y2hOYW1lc3BhY2UobmFtZXNwYWNlSWQpO1xyXG4gICAgICAgIHRoaXMuYWZ0ZXJGbHVzaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLm5hbWVzcGFjZXNCeUhvc3RFbGVtZW50LmRlbGV0ZShucy5ob3N0RWxlbWVudCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5fbmFtZXNwYWNlTG9va3VwW25hbWVzcGFjZUlkXTtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBfdGhpcy5fbmFtZXNwYWNlTGlzdC5pbmRleE9mKG5zKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9uYW1lc3BhY2VMaXN0LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFmdGVyRmx1c2hBbmltYXRpb25zRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBucy5kZXN0cm95KGNvbnRleHQpOyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gaWRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9mZXRjaE5hbWVzcGFjZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGlkKSB7IHJldHVybiB0aGlzLl9uYW1lc3BhY2VMb29rdXBbaWRdOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmZldGNoTmFtZXNwYWNlc0J5RWxlbWVudCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIC8vIG5vcm1hbGx5IHRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSBuYW1lc3BhY2UgcGVyIGVsZW1lbnQsIGhvd2V2ZXJcclxuICAgICAgICAvLyBpZiBAdHJpZ2dlcnMgYXJlIHBsYWNlZCBvbiBib3RoIHRoZSBjb21wb25lbnQgZWxlbWVudCBhbmQgdGhlblxyXG4gICAgICAgIC8vIGl0cyBob3N0IGVsZW1lbnQgKHdpdGhpbiB0aGUgY29tcG9uZW50IGNvZGUpIHRoZW4gdGhlcmUgd2lsbCBiZVxyXG4gICAgICAgIC8vIHR3byBuYW1lc3BhY2VzIHJldHVybmVkLiBXZSB1c2UgYSBzZXQgaGVyZSB0byBzaW1wbHkgdGhlIGRlZHVwZVxyXG4gICAgICAgIC8vIG9mIG5hbWVzcGFjZXMgaW5jYXNlIHRoZXJlIGFyZSBtdWx0aXBsZSB0cmlnZ2VycyBib3RoIHRoZSBlbG0gYW5kIGhvc3RcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lc3BhY2VzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRTdGF0ZXMgPSB0aGlzLnN0YXRlc0J5RWxlbWVudC5nZXQoZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKGVsZW1lbnRTdGF0ZXMpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5cyA9IE9iamVjdC5rZXlzKGVsZW1lbnRTdGF0ZXMpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbnNJZCA9IGVsZW1lbnRTdGF0ZXNba2V5c1tpXV0ubmFtZXNwYWNlSWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAobnNJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5zID0gdGhpcy5fZmV0Y2hOYW1lc3BhY2UobnNJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMuYWRkKG5zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5hbWVzcGFjZXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUudHJpZ2dlciA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoaXNFbGVtZW50Tm9kZShlbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aGlzLl9mZXRjaE5hbWVzcGFjZShuYW1lc3BhY2VJZCkudHJpZ2dlcihlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGluc2VydEJlZm9yZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuaW5zZXJ0Tm9kZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxyXG4gICAgICogQHBhcmFtIHs/fSBpbnNlcnRCZWZvcmVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgZWxlbWVudCwgcGFyZW50LCBpbnNlcnRCZWZvcmUpIHtcclxuICAgICAgICBpZiAoIWlzRWxlbWVudE5vZGUoZWxlbWVudCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHdoZW4gYW4gZWxlbWVudCBpcyByZW1vdmVkIGFuZCByZWluc2VydGVkIChtb3ZlIG9wZXJhdGlvbilcclxuICAgICAgICAvLyB3aGVuIHRoaXMgb2NjdXJzIHdlIGRvIG5vdCB3YW50IHRvIHVzZSB0aGUgZWxlbWVudCBmb3IgZGVsZXRpb24gbGF0ZXJcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhaWxzID0gLyoqIEB0eXBlIHs/fSAqLyAoZWxlbWVudFtSRU1PVkFMX0ZMQUddKTtcclxuICAgICAgICBpZiAoZGV0YWlscyAmJiBkZXRhaWxzLnNldEZvclJlbW92YWwpIHtcclxuICAgICAgICAgICAgZGV0YWlscy5zZXRGb3JSZW1vdmFsID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluIHRoZSBldmVudCB0aGF0IHRoZSBuYW1lc3BhY2VJZCBpcyBibGFuayB0aGVuIHRoZSBjYWxsZXJcclxuICAgICAgICAvLyBjb2RlIGRvZXMgbm90IGNvbnRhaW4gYW55IGFuaW1hdGlvbiBjb2RlIGluIGl0LCBidXQgaXQgaXNcclxuICAgICAgICAvLyBqdXN0IGJlaW5nIGNhbGxlZCBzbyB0aGF0IHRoZSBub2RlIGlzIG1hcmtlZCBhcyBiZWluZyBpbnNlcnRlZFxyXG4gICAgICAgIGlmIChuYW1lc3BhY2VJZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9mZXRjaE5hbWVzcGFjZShuYW1lc3BhY2VJZCkuaW5zZXJ0Tm9kZShlbGVtZW50LCBwYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvbmx5ICpkaXJlY3RpdmVzIGFuZCBob3N0IGVsZW1lbnRzIGFyZSBpbnNlcnRlZCBiZWZvcmVcclxuICAgICAgICBpZiAoaW5zZXJ0QmVmb3JlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdEVudGVyRWxlbWVudChlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmNvbGxlY3RFbnRlckVsZW1lbnQgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQpIHsgdGhpcy5jb2xsZWN0ZWRFbnRlckVsZW1lbnRzLnB1c2goZWxlbWVudCk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUubWFya0VsZW1lbnRBc0Rpc2FibGVkID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWROb2Rlcy5oYXMoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZWROb2Rlcy5hZGQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBESVNBQkxFRF9DTEFTU05BTUUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGlzYWJsZWROb2Rlcy5oYXMoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZE5vZGVzLmRlbGV0ZShlbGVtZW50KTtcclxuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgRElTQUJMRURfQ0xBU1NOQU1FKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUucmVtb3ZlTm9kZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgZWxlbWVudCwgY29udGV4dCkge1xyXG4gICAgICAgIGlmICghaXNFbGVtZW50Tm9kZShlbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aGlzLl9vblJlbW92YWxDb21wbGV0ZShlbGVtZW50LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IG5hbWVzcGFjZUlkID8gdGhpcy5fZmV0Y2hOYW1lc3BhY2UobmFtZXNwYWNlSWQpIDogbnVsbDtcclxuICAgICAgICBpZiAobnMpIHtcclxuICAgICAgICAgICAgbnMucmVtb3ZlTm9kZShlbGVtZW50LCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFya0VsZW1lbnRBc1JlbW92ZWQobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGZhbHNlLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7Pz19IGhhc0FuaW1hdGlvblxyXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUubWFya0VsZW1lbnRBc1JlbW92ZWQgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/PX0gaGFzQW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGhhc0FuaW1hdGlvbiwgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuY29sbGVjdGVkTGVhdmVFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgIGVsZW1lbnRbUkVNT1ZBTF9GTEFHXSA9IHtcclxuICAgICAgICAgICAgbmFtZXNwYWNlSWQ6IG5hbWVzcGFjZUlkLFxyXG4gICAgICAgICAgICBzZXRGb3JSZW1vdmFsOiBjb250ZXh0LCBoYXNBbmltYXRpb246IGhhc0FuaW1hdGlvbixcclxuICAgICAgICAgICAgcmVtb3ZlZEJlZm9yZVF1ZXJpZWQ6IGZhbHNlXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IHBoYXNlXHJcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5saXN0ZW4gPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IHBoYXNlXHJcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQsIG5hbWUsIHBoYXNlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGlmIChpc0VsZW1lbnROb2RlKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mZXRjaE5hbWVzcGFjZShuYW1lc3BhY2VJZCkubGlzdGVuKGVsZW1lbnQsIG5hbWUsIHBoYXNlLCBjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVudHJ5XHJcbiAgICAgKiBAcGFyYW0gez99IHN1YlRpbWVsaW5lc1xyXG4gICAgICogQHBhcmFtIHs/fSBlbnRlckNsYXNzTmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSBsZWF2ZUNsYXNzTmFtZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuX2J1aWxkSW5zdHJ1Y3Rpb24gPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZW50cnlcclxuICAgICAqIEBwYXJhbSB7P30gc3ViVGltZWxpbmVzXHJcbiAgICAgKiBAcGFyYW0gez99IGVudGVyQ2xhc3NOYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IGxlYXZlQ2xhc3NOYW1lXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZW50cnksIHN1YlRpbWVsaW5lcywgZW50ZXJDbGFzc05hbWUsIGxlYXZlQ2xhc3NOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGVudHJ5LnRyYW5zaXRpb24uYnVpbGQodGhpcy5kcml2ZXIsIGVudHJ5LmVsZW1lbnQsIGVudHJ5LmZyb21TdGF0ZS52YWx1ZSwgZW50cnkudG9TdGF0ZS52YWx1ZSwgZW50ZXJDbGFzc05hbWUsIGxlYXZlQ2xhc3NOYW1lLCBlbnRyeS5mcm9tU3RhdGUub3B0aW9ucywgZW50cnkudG9TdGF0ZS5vcHRpb25zLCBzdWJUaW1lbGluZXMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBjb250YWluZXJFbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5kZXN0cm95SW5uZXJBbmltYXRpb25zID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5lckVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChjb250YWluZXJFbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50cyA9IHRoaXMuZHJpdmVyLnF1ZXJ5KGNvbnRhaW5lckVsZW1lbnQsIE5HX1RSSUdHRVJfU0VMRUNUT1IsIHRydWUpO1xyXG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIF90aGlzLmRlc3Ryb3lBY3RpdmVBbmltYXRpb25zRm9yRWxlbWVudChlbGVtZW50KTsgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMucGxheWVyc0J5UXVlcmllZEVsZW1lbnQuc2l6ZSA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLmRyaXZlci5xdWVyeShjb250YWluZXJFbGVtZW50LCBOR19BTklNQVRJTkdfU0VMRUNUT1IsIHRydWUpO1xyXG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIF90aGlzLmZpbmlzaEFjdGl2ZVF1ZXJpZWRBbmltYXRpb25PbkVsZW1lbnQoZWxlbWVudCk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5kZXN0cm95QWN0aXZlQW5pbWF0aW9uc0ZvckVsZW1lbnQgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJzID0gdGhpcy5wbGF5ZXJzQnlFbGVtZW50LmdldChlbGVtZW50KTtcclxuICAgICAgICBpZiAocGxheWVycykge1xyXG4gICAgICAgICAgICBwbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xyXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciB3aGVuIGFuIGVsZW1lbnQgaXMgc2V0IGZvciBkZXN0cnVjdGlvbiwgYnV0IGhhc24ndCBzdGFydGVkLlxyXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBzaXR1YXRpb24gd2Ugd2FudCB0byBkZWxheSB0aGUgZGVzdHJ1Y3Rpb24gdW50aWwgdGhlIGZsdXNoIG9jY3Vyc1xyXG4gICAgICAgICAgICAgICAgLy8gc28gdGhhdCBhbnkgZXZlbnQgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIHRoZSBwbGF5ZXIgYXJlIHRyaWdnZXJlZC5cclxuICAgICAgICAgICAgICAgIGlmIChwbGF5ZXIucXVldWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLm1hcmtlZEZvckRlc3Ryb3kgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlTWFwID0gdGhpcy5zdGF0ZXNCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xyXG4gICAgICAgIGlmIChzdGF0ZU1hcCkge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzdGF0ZU1hcCkuZm9yRWFjaChmdW5jdGlvbiAodHJpZ2dlck5hbWUpIHsgcmV0dXJuIHN0YXRlTWFwW3RyaWdnZXJOYW1lXSA9IERFTEVURURfU1RBVEVfVkFMVUU7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuZmluaXNoQWN0aXZlUXVlcmllZEFuaW1hdGlvbk9uRWxlbWVudCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSB0aGlzLnBsYXllcnNCeVF1ZXJpZWRFbGVtZW50LmdldChlbGVtZW50KTtcclxuICAgICAgICBpZiAocGxheWVycykge1xyXG4gICAgICAgICAgICBwbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmZpbmlzaCgpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS53aGVuUmVuZGVyaW5nRG9uZSA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5wbGF5ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGltaXplR3JvdXBQbGF5ZXIoX3RoaXMucGxheWVycykub25Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoKTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUucHJvY2Vzc0xlYXZlTm9kZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGV0YWlscyA9IC8qKiBAdHlwZSB7P30gKi8gKGVsZW1lbnRbUkVNT1ZBTF9GTEFHXSk7XHJcbiAgICAgICAgaWYgKGRldGFpbHMgJiYgZGV0YWlscy5zZXRGb3JSZW1vdmFsKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBwcmV2ZW50IGl0IGZyb20gcmVtb3ZpbmcgaXQgdHdpY2VcclxuICAgICAgICAgICAgZWxlbWVudFtSRU1PVkFMX0ZMQUddID0gTlVMTF9SRU1PVkFMX1NUQVRFO1xyXG4gICAgICAgICAgICBpZiAoZGV0YWlscy5uYW1lc3BhY2VJZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95SW5uZXJBbmltYXRpb25zKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbnMgPSB0aGlzLl9mZXRjaE5hbWVzcGFjZShkZXRhaWxzLm5hbWVzcGFjZUlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChucykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5zLmNsZWFyRWxlbWVudENhY2hlKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX29uUmVtb3ZhbENvbXBsZXRlKGVsZW1lbnQsIGRldGFpbHMuc2V0Rm9yUmVtb3ZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRyaXZlci5tYXRjaGVzRWxlbWVudChlbGVtZW50LCBESVNBQkxFRF9TRUxFQ1RPUikpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRWxlbWVudEFzRGlzYWJsZWQoZWxlbWVudCwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRyaXZlci5xdWVyeShlbGVtZW50LCBESVNBQkxFRF9TRUxFQ1RPUiwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5tYXJrRWxlbWVudEFzRGlzYWJsZWQoZWxlbWVudCwgZmFsc2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/PX0gbWljcm90YXNrSWRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmZsdXNoID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez89fSBtaWNyb3Rhc2tJZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG1pY3JvdGFza0lkKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAobWljcm90YXNrSWQgPT09IHZvaWQgMCkgeyBtaWNyb3Rhc2tJZCA9IC0xOyB9XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVycyA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLm5ld0hvc3RFbGVtZW50cy5zaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV3SG9zdEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG5zLCBlbGVtZW50KSB7IHJldHVybiBfdGhpcy5fYmFsYW5jZU5hbWVzcGFjZUxpc3QobnMsIGVsZW1lbnQpOyB9KTtcclxuICAgICAgICAgICAgdGhpcy5uZXdIb3N0RWxlbWVudHMuY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudG90YWxBbmltYXRpb25zICYmIHRoaXMuY29sbGVjdGVkRW50ZXJFbGVtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHRoaXMuY29sbGVjdGVkRW50ZXJFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxtID0gdGhpcy5jb2xsZWN0ZWRFbnRlckVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoZWxtLCBTVEFSX0NMQVNTTkFNRSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX25hbWVzcGFjZUxpc3QubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICh0aGlzLnRvdGFsUXVldWVkUGxheWVycyB8fCB0aGlzLmNvbGxlY3RlZExlYXZlRWxlbWVudHMubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGVhbnVwRm5zID0gW107XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBwbGF5ZXJzID0gdGhpcy5fZmx1c2hBbmltYXRpb25zKGNsZWFudXBGbnMsIG1pY3JvdGFza0lkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBjbGVhbnVwRm5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cEZuc1tpXSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTGVhdmVOb2RlKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudG90YWxRdWV1ZWRQbGF5ZXJzID0gMDtcclxuICAgICAgICB0aGlzLmNvbGxlY3RlZEVudGVyRWxlbWVudHMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLmNvbGxlY3RlZExlYXZlRWxlbWVudHMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl9mbHVzaEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XHJcbiAgICAgICAgdGhpcy5fZmx1c2hGbnMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5fd2hlblF1aWV0Rm5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyB3ZSBtb3ZlIHRoZXNlIG92ZXIgdG8gYSB2YXJpYWJsZSBzbyB0aGF0XHJcbiAgICAgICAgICAgIC8vIGlmIGFueSBuZXcgY2FsbGJhY2tzIGFyZSByZWdpc3RlcmVkIGluIGFub3RoZXJcclxuICAgICAgICAgICAgLy8gZmx1c2ggdGhleSBkbyBub3QgcG9wdWxhdGUgdGhlIGV4aXN0aW5nIHNldFxyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWlldEZuc18xID0gdGhpcy5fd2hlblF1aWV0Rm5zO1xyXG4gICAgICAgICAgICB0aGlzLl93aGVuUXVpZXRGbnMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKHBsYXllcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpbWl6ZUdyb3VwUGxheWVyKHBsYXllcnMpLm9uRG9uZShmdW5jdGlvbiAoKSB7IHF1aWV0Rm5zXzEuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHF1aWV0Rm5zXzEuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnJlcG9ydEVycm9yID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVycm9ycykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBwcm9jZXNzIGFuaW1hdGlvbnMgZHVlIHRvIHRoZSBmb2xsb3dpbmcgZmFpbGVkIHRyaWdnZXIgdHJhbnNpdGlvbnNcXG4gXCIgKyBlcnJvcnMuam9pbignXFxuJykpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBjbGVhbnVwRm5zXHJcbiAgICAgKiBAcGFyYW0gez99IG1pY3JvdGFza0lkXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fZmx1c2hBbmltYXRpb25zID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGNsZWFudXBGbnNcclxuICAgICAqIEBwYXJhbSB7P30gbWljcm90YXNrSWRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChjbGVhbnVwRm5zLCBtaWNyb3Rhc2tJZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ViVGltZWxpbmVzID0gbmV3IEVsZW1lbnRJbnN0cnVjdGlvbk1hcCgpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNraXBwZWRQbGF5ZXJzID0gW107XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2tpcHBlZFBsYXllcnNNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVldWVkSW5zdHJ1Y3Rpb25zID0gW107XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcmllZEVsZW1lbnRzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFByZVN0eWxlRWxlbWVudHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsUG9zdFN0eWxlRWxlbWVudHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlzYWJsZWRFbGVtZW50c1NldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLmRpc2FibGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBkaXNhYmxlZEVsZW1lbnRzU2V0LmFkZChub2RlKTtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXNUaGF0QXJlRGlzYWJsZWQgPSBfdGhpcy5kcml2ZXIucXVlcnkobm9kZSwgUVVFVUVEX1NFTEVDVE9SLCB0cnVlKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpXzEgPSAwOyBpXzEgPCBub2Rlc1RoYXRBcmVEaXNhYmxlZC5sZW5ndGg7IGlfMSsrKSB7XHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZEVsZW1lbnRzU2V0LmFkZChub2Rlc1RoYXRBcmVEaXNhYmxlZFtpXzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvZHlOb2RlID0gZ2V0Qm9keU5vZGUoKTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxUcmlnZ2VyRWxlbWVudHMgPSBBcnJheS5mcm9tKHRoaXMuc3RhdGVzQnlFbGVtZW50LmtleXMoKSk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50ZXJOb2RlTWFwID0gYnVpbGRSb290TWFwKGFsbFRyaWdnZXJFbGVtZW50cywgdGhpcy5jb2xsZWN0ZWRFbnRlckVsZW1lbnRzKTtcclxuICAgICAgICAvLyB0aGlzIG11c3Qgb2NjdXIgYmVmb3JlIHRoZSBpbnN0cnVjdGlvbnMgYXJlIGJ1aWx0IGJlbG93IHN1Y2ggdGhhdFxyXG4gICAgICAgIC8vIHRoZSA6ZW50ZXIgcXVlcmllcyBtYXRjaCB0aGUgZWxlbWVudHMgKHNpbmNlIHRoZSB0aW1lbGluZSBxdWVyaWVzXHJcbiAgICAgICAgLy8gYXJlIGZpcmVkIGR1cmluZyBpbnN0cnVjdGlvbiBidWlsZGluZykuXHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50ZXJOb2RlTWFwSWRzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwO1xyXG4gICAgICAgIGVudGVyTm9kZU1hcC5mb3JFYWNoKGZ1bmN0aW9uIChub2Rlcywgcm9vdCkge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc05hbWUgPSBFTlRFUl9DTEFTU05BTUUgKyBpKys7XHJcbiAgICAgICAgICAgIGVudGVyTm9kZU1hcElkcy5zZXQocm9vdCwgY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gYWRkQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsTGVhdmVOb2RlcyA9IFtdO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lcmdlZExlYXZlTm9kZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVhdmVOb2Rlc1dpdGhvdXRBbmltYXRpb25zID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaV8yID0gMDsgaV8yIDwgdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzLmxlbmd0aDsgaV8yKyspIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IHRoaXMuY29sbGVjdGVkTGVhdmVFbGVtZW50c1tpXzJdO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhaWxzID0gLyoqIEB0eXBlIHs/fSAqLyAoZWxlbWVudFtSRU1PVkFMX0ZMQUddKTtcclxuICAgICAgICAgICAgaWYgKGRldGFpbHMgJiYgZGV0YWlscy5zZXRGb3JSZW1vdmFsKSB7XHJcbiAgICAgICAgICAgICAgICBhbGxMZWF2ZU5vZGVzLnB1c2goZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBtZXJnZWRMZWF2ZU5vZGVzLmFkZChlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChkZXRhaWxzLmhhc0FuaW1hdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJpdmVyLnF1ZXJ5KGVsZW1lbnQsIFNUQVJfU0VMRUNUT1IsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGVsbSkgeyByZXR1cm4gbWVyZ2VkTGVhdmVOb2Rlcy5hZGQoZWxtKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWF2ZU5vZGVzV2l0aG91dEFuaW1hdGlvbnMuYWRkKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlYXZlTm9kZU1hcElkcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZWF2ZU5vZGVNYXAgPSBidWlsZFJvb3RNYXAoYWxsVHJpZ2dlckVsZW1lbnRzLCBBcnJheS5mcm9tKG1lcmdlZExlYXZlTm9kZXMpKTtcclxuICAgICAgICBsZWF2ZU5vZGVNYXAuZm9yRWFjaChmdW5jdGlvbiAobm9kZXMsIHJvb3QpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NOYW1lID0gTEVBVkVfQ0xBU1NOQU1FICsgaSsrO1xyXG4gICAgICAgICAgICBsZWF2ZU5vZGVNYXBJZHMuc2V0KHJvb3QsIGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGFkZENsYXNzKG5vZGUsIGNsYXNzTmFtZSk7IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNsZWFudXBGbnMucHVzaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGVudGVyTm9kZU1hcC5mb3JFYWNoKGZ1bmN0aW9uIChub2Rlcywgcm9vdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NOYW1lID0gLyoqIEB0eXBlIHs/fSAqLyAoKGVudGVyTm9kZU1hcElkcy5nZXQocm9vdCkpKTtcclxuICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHJlbW92ZUNsYXNzKG5vZGUsIGNsYXNzTmFtZSk7IH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGVhdmVOb2RlTWFwLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzLCByb290KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc05hbWUgPSAvKiogQHR5cGUgez99ICovICgobGVhdmVOb2RlTWFwSWRzLmdldChyb290KSkpO1xyXG4gICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gcmVtb3ZlQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTsgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBhbGxMZWF2ZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgX3RoaXMucHJvY2Vzc0xlYXZlTm9kZShlbGVtZW50KTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsUGxheWVycyA9IFtdO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9uZW91c1RyYW5zaXRpb25zID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpXzMgPSB0aGlzLl9uYW1lc3BhY2VMaXN0Lmxlbmd0aCAtIDE7IGlfMyA+PSAwOyBpXzMtLSkge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IHRoaXMuX25hbWVzcGFjZUxpc3RbaV8zXTtcclxuICAgICAgICAgICAgbnMuZHJhaW5RdWV1ZWRUcmFuc2l0aW9ucyhtaWNyb3Rhc2tJZCkuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IGVudHJ5LnBsYXllcjtcclxuICAgICAgICAgICAgICAgIGFsbFBsYXllcnMucHVzaChwbGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IGVudHJ5LmVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWJvZHlOb2RlIHx8ICFfdGhpcy5kcml2ZXIuY29udGFpbnNFbGVtZW50KGJvZHlOb2RlLCBlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVhdmVDbGFzc05hbWUgPSAvKiogQHR5cGUgez99ICovICgobGVhdmVOb2RlTWFwSWRzLmdldChlbGVtZW50KSkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50ZXJDbGFzc05hbWUgPSAvKiogQHR5cGUgez99ICovICgoZW50ZXJOb2RlTWFwSWRzLmdldChlbGVtZW50KSkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5zdHJ1Y3Rpb24gPSAvKiogQHR5cGUgez99ICovICgoX3RoaXMuX2J1aWxkSW5zdHJ1Y3Rpb24oZW50cnksIHN1YlRpbWVsaW5lcywgZW50ZXJDbGFzc05hbWUsIGxlYXZlQ2xhc3NOYW1lKSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLmVycm9ycyAmJiBpbnN0cnVjdGlvbi5lcnJvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb25lb3VzVHJhbnNpdGlvbnMucHVzaChpbnN0cnVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgYSB1bm1hdGNoZWQgdHJhbnNpdGlvbiBpcyBxdWV1ZWQgdG8gZ28gdGhlbiBpdCBTSE9VTEQgTk9UIHJlbmRlclxyXG4gICAgICAgICAgICAgICAgLy8gYW4gYW5pbWF0aW9uIGFuZCBjYW5jZWwgdGhlIHByZXZpb3VzbHkgcnVubmluZyBhbmltYXRpb25zLlxyXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzRmFsbGJhY2tUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLm9uU3RhcnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJhc2VTdHlsZXMoZWxlbWVudCwgaW5zdHJ1Y3Rpb24uZnJvbVN0eWxlcyk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5vbkRlc3Ryb3koZnVuY3Rpb24gKCkgeyByZXR1cm4gc2V0U3R5bGVzKGVsZW1lbnQsIGluc3RydWN0aW9uLnRvU3R5bGVzKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZFBsYXllcnMucHVzaChwbGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBpZiBhIHBhcmVudCBhbmltYXRpb24gdXNlcyB0aGlzIGFuaW1hdGlvbiBhcyBhIHN1YiB0cmlnZ2VyXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGl0IHdpbGwgaW5zdHJ1Y3QgdGhlIHRpbWVsaW5lIGJ1aWxkZXIgdG8gbm90IGFkZCBhIHBsYXllciBkZWxheSwgYnV0XHJcbiAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIHN0cmV0Y2ggdGhlIGZpcnN0IGtleWZyYW1lIGdhcCB1cCB1bnRpbCB0aGUgYW5pbWF0aW9uIHN0YXJ0cy4gVGhlXHJcbiAgICAgICAgICAgICAgICAvLyByZWFzb24gdGhpcyBpcyBpbXBvcnRhbnQgaXMgdG8gcHJldmVudCBleHRyYSBpbml0aWFsaXphdGlvbiBzdHlsZXMgZnJvbSBiZWluZ1xyXG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgYnkgdGhlIHVzZXIgaW4gdGhlIGFuaW1hdGlvbi5cclxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLnRpbWVsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uICh0bCkgeyByZXR1cm4gdGwuc3RyZXRjaFN0YXJ0aW5nS2V5ZnJhbWUgPSB0cnVlOyB9KTtcclxuICAgICAgICAgICAgICAgIHN1YlRpbWVsaW5lcy5hcHBlbmQoZWxlbWVudCwgaW5zdHJ1Y3Rpb24udGltZWxpbmVzKTtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR1cGxlID0geyBpbnN0cnVjdGlvbjogaW5zdHJ1Y3Rpb24sIHBsYXllcjogcGxheWVyLCBlbGVtZW50OiBlbGVtZW50IH07XHJcbiAgICAgICAgICAgICAgICBxdWV1ZWRJbnN0cnVjdGlvbnMucHVzaCh0dXBsZSk7XHJcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5xdWVyaWVkRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZ2V0T3JTZXRBc0luTWFwKHF1ZXJpZWRFbGVtZW50cywgZWxlbWVudCwgW10pLnB1c2gocGxheWVyKTsgfSk7XHJcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5wcmVTdHlsZVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHN0cmluZ01hcCwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3BzID0gT2JqZWN0LmtleXMoc3RyaW5nTWFwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNldFZhbF8xID0gLyoqIEB0eXBlIHs/fSAqLyAoKGFsbFByZVN0eWxlRWxlbWVudHMuZ2V0KGVsZW1lbnQpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2V0VmFsXzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbFByZVN0eWxlRWxlbWVudHMuc2V0KGVsZW1lbnQsIHNldFZhbF8xID0gbmV3IFNldCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBzZXRWYWxfMS5hZGQocHJvcCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24ucG9zdFN0eWxlUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoc3RyaW5nTWFwLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcHMgPSBPYmplY3Qua2V5cyhzdHJpbmdNYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNldFZhbCA9IC8qKiBAdHlwZSB7P30gKi8gKChhbGxQb3N0U3R5bGVFbGVtZW50cy5nZXQoZWxlbWVudCkpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldFZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxQb3N0U3R5bGVFbGVtZW50cy5zZXQoZWxlbWVudCwgc2V0VmFsID0gbmV3IFNldCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gc2V0VmFsLmFkZChwcm9wKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlcnJvbmVvdXNUcmFuc2l0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzXzEgPSBbXTtcclxuICAgICAgICAgICAgZXJyb25lb3VzVHJhbnNpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGVycm9yc18xLnB1c2goXCJAXCIgKyBpbnN0cnVjdGlvbi50cmlnZ2VyTmFtZSArIFwiIGhhcyBmYWlsZWQgZHVlIHRvOlxcblwiKTsgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICAgICAgKChpbnN0cnVjdGlvbi5lcnJvcnMpKS5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gZXJyb3JzXzEucHVzaChcIi0gXCIgKyBlcnJvciArIFwiXFxuXCIpOyB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGFsbFBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIuZGVzdHJveSgpOyB9KTtcclxuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihlcnJvcnNfMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFByZXZpb3VzUGxheWVyc01hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvLyB0aGlzIG1hcCB3b3JrcyB0byB0ZWxsIHdoaWNoIGVsZW1lbnQgaW4gdGhlIERPTSB0cmVlIGlzIGNvbnRhaW5lZCBieVxyXG4gICAgICAgIC8vIHdoaWNoIGFuaW1hdGlvbi4gRnVydGhlciBkb3duIGJlbG93IHRoaXMgbWFwIHdpbGwgZ2V0IHBvcHVsYXRlZCBvbmNlXHJcbiAgICAgICAgLy8gdGhlIHBsYXllcnMgYXJlIGJ1aWx0IGFuZCBpbiBkb2luZyBzbyBpdCBjYW4gZWZmaWNpZW50bHkgZmlndXJlIG91dFxyXG4gICAgICAgIC8vIGlmIGEgc3ViIHBsYXllciBpcyBza2lwcGVkIGR1ZSB0byBhIHBhcmVudCBwbGF5ZXIgaGF2aW5nIHByaW9yaXR5LlxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuaW1hdGlvbkVsZW1lbnRNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgcXVldWVkSW5zdHJ1Y3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSBlbnRyeS5lbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAoc3ViVGltZWxpbmVzLmhhcyhlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uRWxlbWVudE1hcC5zZXQoZWxlbWVudCwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fYmVmb3JlQW5pbWF0aW9uQnVpbGQoZW50cnkucGxheWVyLm5hbWVzcGFjZUlkLCBlbnRyeS5pbnN0cnVjdGlvbiwgYWxsUHJldmlvdXNQbGF5ZXJzTWFwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNraXBwZWRQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gcGxheWVyLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZpb3VzUGxheWVycyA9IF90aGlzLl9nZXRQcmV2aW91c1BsYXllcnMoZWxlbWVudCwgZmFsc2UsIHBsYXllci5uYW1lc3BhY2VJZCwgcGxheWVyLnRyaWdnZXJOYW1lLCBudWxsKTtcclxuICAgICAgICAgICAgcHJldmlvdXNQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHByZXZQbGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgIGdldE9yU2V0QXNJbk1hcChhbGxQcmV2aW91c1BsYXllcnNNYXAsIGVsZW1lbnQsIFtdKS5wdXNoKHByZXZQbGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgcHJldlBsYXllci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIHRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgZm9yIG5vZGVzIHRoYXQgd2lsbCBiZSByZW1vdmVkIChlaXRoZXIgYnkpXHJcbiAgICAgICAgLy8gaGF2aW5nIHRoZWlyIG93biBsZWF2ZSBhbmltYXRpb25zIG9yIGJ5IGJlaW5nIHF1ZXJpZWQgaW4gYSBjb250YWluZXJcclxuICAgICAgICAvLyB0aGF0IHdpbGwgYmUgcmVtb3ZlZCBvbmNlIGEgcGFyZW50IGFuaW1hdGlvbiBpcyBjb21wbGV0ZS4gVGhlIGlkZWFcclxuICAgICAgICAvLyBoZXJlIGlzIHRoYXQgKiBzdHlsZXMgbXVzdCBiZSBpZGVudGljYWwgdG8gISBzdHlsZXMgYmVjYXVzZSBvZlxyXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5ICgqIGlzIGFsc28gZmlsbGVkIGluIGJ5IGRlZmF1bHQgaW4gbWFueSBwbGFjZXMpLlxyXG4gICAgICAgIC8vIE90aGVyd2lzZSAqIHN0eWxlcyB3aWxsIHJldHVybiBhbiBlbXB0eSB2YWx1ZSBvciBhdXRvIHNpbmNlIHRoZSBlbGVtZW50XHJcbiAgICAgICAgLy8gdGhhdCBpcyBiZWluZyBnZXRDb21wdXRlZFN0eWxlJ2Qgd2lsbCBub3QgYmUgdmlzaWJsZSAoc2luY2UgKiA9IGRlc3RpbmF0aW9uKVxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcGxhY2VOb2RlcyA9IGFsbExlYXZlTm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlUG9zdFN0eWxlc0FzUHJlKG5vZGUsIGFsbFByZVN0eWxlRWxlbWVudHMsIGFsbFBvc3RTdHlsZUVsZW1lbnRzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBQT1NUIFNUQUdFOiBmaWxsIHRoZSAqIHN0eWxlc1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc3RTdHlsZXNNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsTGVhdmVRdWVyaWVkTm9kZXMgPSBjbG9ha0FuZENvbXB1dGVTdHlsZXMocG9zdFN0eWxlc01hcCwgdGhpcy5kcml2ZXIsIGxlYXZlTm9kZXNXaXRob3V0QW5pbWF0aW9ucywgYWxsUG9zdFN0eWxlRWxlbWVudHMsIF9hbmd1bGFyX2FuaW1hdGlvbnMuQVVUT19TVFlMRSk7XHJcbiAgICAgICAgYWxsTGVhdmVRdWVyaWVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAocmVwbGFjZVBvc3RTdHlsZXNBc1ByZShub2RlLCBhbGxQcmVTdHlsZUVsZW1lbnRzLCBhbGxQb3N0U3R5bGVFbGVtZW50cykpIHtcclxuICAgICAgICAgICAgICAgIHJlcGxhY2VOb2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gUFJFIFNUQUdFOiBmaWxsIHRoZSAhIHN0eWxlc1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVN0eWxlc01hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICBlbnRlck5vZGVNYXAuZm9yRWFjaChmdW5jdGlvbiAobm9kZXMsIHJvb3QpIHtcclxuICAgICAgICAgICAgY2xvYWtBbmRDb21wdXRlU3R5bGVzKHByZVN0eWxlc01hcCwgX3RoaXMuZHJpdmVyLCBuZXcgU2V0KG5vZGVzKSwgYWxsUHJlU3R5bGVFbGVtZW50cywgX2FuZ3VsYXJfYW5pbWF0aW9ucy7JtVBSRV9TVFlMRSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVwbGFjZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zdCA9IHBvc3RTdHlsZXNNYXAuZ2V0KG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmUgPSBwcmVTdHlsZXNNYXAuZ2V0KG5vZGUpO1xyXG4gICAgICAgICAgICBwb3N0U3R5bGVzTWFwLnNldChub2RlLCAvKiogQHR5cGUgez99ICovIChfX2Fzc2lnbih7fSwgcG9zdCwgcHJlKSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJvb3RQbGF5ZXJzID0gW107XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ViUGxheWVycyA9IFtdO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIE5PX1BBUkVOVF9BTklNQVRJT05fRUxFTUVOVF9ERVRFQ1RFRCA9IHt9O1xyXG4gICAgICAgIHF1ZXVlZEluc3RydWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGVudHJ5LmVsZW1lbnQsIHBsYXllciA9IGVudHJ5LnBsYXllciwgaW5zdHJ1Y3Rpb24gPSBlbnRyeS5pbnN0cnVjdGlvbjtcclxuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IGl0IHdhcyBuZXZlciBjb25zdW1lZCBieSBhIHBhcmVudCBhbmltYXRpb24gd2hpY2hcclxuICAgICAgICAgICAgLy8gbWVhbnMgdGhhdCBpdCBpcyBpbmRlcGVuZGVudCBhbmQgdGhlcmVmb3JlIHNob3VsZCBiZSBzZXQgZm9yIGFuaW1hdGlvblxyXG4gICAgICAgICAgICBpZiAoc3ViVGltZWxpbmVzLmhhcyhlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkRWxlbWVudHNTZXQuaGFzKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBzZXRTdHlsZXMoZWxlbWVudCwgaW5zdHJ1Y3Rpb24udG9TdHlsZXMpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBza2lwcGVkUGxheWVycy5wdXNoKHBsYXllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGZsb3cgdXAgdGhlIERPTSBhbmQgcXVlcnkgdGhlIG1hcCB0byBmaWd1cmUgb3V0XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBhIHBhcmVudCBhbmltYXRpb24gaGFzIHByaW9yaXR5IG92ZXIgaXQuIEluIHRoZSBzaXR1YXRpb25cclxuICAgICAgICAgICAgICAgIC8vIHRoYXQgYSBwYXJlbnQgaXMgZGV0ZWN0ZWQgdGhlbiBpdCB3aWxsIGNhbmNlbCB0aGUgbG9vcC4gSWZcclxuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgaXMgZGV0ZWN0ZWQsIG9yIGl0IHRha2VzIGEgZmV3IGhvcHMgdG8gZmluZCBhIHBhcmVudCxcclxuICAgICAgICAgICAgICAgIC8vIHRoZW4gaXQgd2lsbCBmaWxsIGluIHRoZSBtaXNzaW5nIG5vZGVzIGFuZCBzaWduYWwgdGhlbSBhcyBoYXZpbmdcclxuICAgICAgICAgICAgICAgIC8vIGEgZGV0ZWN0ZWQgcGFyZW50IChvciBhIE5PX1BBUkVOVCB2YWx1ZSB2aWEgYSBzcGVjaWFsIGNvbnN0YW50KS5cclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudFdpdGhBbmltYXRpb25fMSA9IE5PX1BBUkVOVF9BTklNQVRJT05fRUxFTUVOVF9ERVRFQ1RFRDtcclxuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25FbGVtZW50TWFwLnNpemUgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxtID0gZWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRzVG9BZGQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWxtID0gZWxtLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGV0ZWN0ZWRQYXJlbnQgPSBhbmltYXRpb25FbGVtZW50TWFwLmdldChlbG0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0ZWRQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFdpdGhBbmltYXRpb25fMSA9IGRldGVjdGVkUGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50c1RvQWRkLnB1c2goZWxtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50c1RvQWRkLmZvckVhY2goZnVuY3Rpb24gKHBhcmVudCkgeyByZXR1cm4gYW5pbWF0aW9uRWxlbWVudE1hcC5zZXQocGFyZW50LCBwYXJlbnRXaXRoQW5pbWF0aW9uXzEpOyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyUGxheWVyID0gX3RoaXMuX2J1aWxkQW5pbWF0aW9uKHBsYXllci5uYW1lc3BhY2VJZCwgaW5zdHJ1Y3Rpb24sIGFsbFByZXZpb3VzUGxheWVyc01hcCwgc2tpcHBlZFBsYXllcnNNYXAsIHByZVN0eWxlc01hcCwgcG9zdFN0eWxlc01hcCk7XHJcbiAgICAgICAgICAgICAgICBwbGF5ZXIuc2V0UmVhbFBsYXllcihpbm5lclBsYXllcik7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50V2l0aEFuaW1hdGlvbl8xID09PSBOT19QQVJFTlRfQU5JTUFUSU9OX0VMRU1FTlRfREVURUNURUQpIHtcclxuICAgICAgICAgICAgICAgICAgICByb290UGxheWVycy5wdXNoKHBsYXllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRQbGF5ZXJzID0gX3RoaXMucGxheWVyc0J5RWxlbWVudC5nZXQocGFyZW50V2l0aEFuaW1hdGlvbl8xKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50UGxheWVycyAmJiBwYXJlbnRQbGF5ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXIucGFyZW50UGxheWVyID0gb3B0aW1pemVHcm91cFBsYXllcihwYXJlbnRQbGF5ZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZFBsYXllcnMucHVzaChwbGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXJhc2VTdHlsZXMoZWxlbWVudCwgaW5zdHJ1Y3Rpb24uZnJvbVN0eWxlcyk7XHJcbiAgICAgICAgICAgICAgICBwbGF5ZXIub25EZXN0cm95KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldFN0eWxlcyhlbGVtZW50LCBpbnN0cnVjdGlvbi50b1N0eWxlcyk7IH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgc3RpbGwgbWlnaHQgYmUgYSBhbmNlc3RvciBwbGF5ZXIgYW5pbWF0aW5nIHRoaXNcclxuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgdGhlcmVmb3JlIHdlIHdpbGwgc3RpbGwgYWRkIGl0IGFzIGEgc3ViIHBsYXllclxyXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpZiBpdHMgYW5pbWF0aW9uIG1heSBiZSBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgc3ViUGxheWVycy5wdXNoKHBsYXllcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzYWJsZWRFbGVtZW50c1NldC5oYXMoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBza2lwcGVkUGxheWVycy5wdXNoKHBsYXllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBmaW5kIGFsbCBvZiB0aGUgc3ViIHBsYXllcnMnIGNvcnJlc3BvbmRpbmcgaW5uZXIgYW5pbWF0aW9uIHBsYXllclxyXG4gICAgICAgIHN1YlBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XHJcbiAgICAgICAgICAgIC8vIGV2ZW4gaWYgYW55IHBsYXllcnMgYXJlIG5vdCBmb3VuZCBmb3IgYSBzdWIgYW5pbWF0aW9uIHRoZW4gaXRcclxuICAgICAgICAgICAgLy8gd2lsbCBzdGlsbCBjb21wbGV0ZSBpdHNlbGYgYWZ0ZXIgdGhlIG5leHQgdGljayBzaW5jZSBpdCdzIE5vb3BcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyc0ZvckVsZW1lbnQgPSBza2lwcGVkUGxheWVyc01hcC5nZXQocGxheWVyLmVsZW1lbnQpO1xyXG4gICAgICAgICAgICBpZiAocGxheWVyc0ZvckVsZW1lbnQgJiYgcGxheWVyc0ZvckVsZW1lbnQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclBsYXllciA9IG9wdGltaXplR3JvdXBQbGF5ZXIocGxheWVyc0ZvckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcGxheWVyLnNldFJlYWxQbGF5ZXIoaW5uZXJQbGF5ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gdGhlIHJlYXNvbiB3aHkgd2UgZG9uJ3QgYWN0dWFsbHkgcGxheSB0aGUgYW5pbWF0aW9uIGlzXHJcbiAgICAgICAgLy8gYmVjYXVzZSBhbGwgdGhhdCBhIHNraXBwZWQgcGxheWVyIGlzIGRlc2lnbmVkIHRvIGRvIGlzIHRvXHJcbiAgICAgICAgLy8gZmlyZSB0aGUgc3RhcnQvZG9uZSB0cmFuc2l0aW9uIGNhbGxiYWNrIGV2ZW50c1xyXG4gICAgICAgIHNraXBwZWRQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xyXG4gICAgICAgICAgICBpZiAocGxheWVyLnBhcmVudFBsYXllcikge1xyXG4gICAgICAgICAgICAgICAgcGxheWVyLnN5bmNQbGF5ZXJFdmVudHMocGxheWVyLnBhcmVudFBsYXllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gcnVuIHRocm91Z2ggYWxsIG9mIHRoZSBxdWV1ZWQgcmVtb3ZhbHMgYW5kIHNlZSBpZiB0aGV5XHJcbiAgICAgICAgLy8gd2VyZSBwaWNrZWQgdXAgYnkgYSBxdWVyeS4gSWYgbm90IHRoZW4gcGVyZm9ybSB0aGUgcmVtb3ZhbFxyXG4gICAgICAgIC8vIG9wZXJhdGlvbiByaWdodCBhd2F5IHVubGVzcyBhIHBhcmVudCBhbmltYXRpb24gaXMgb25nb2luZy5cclxuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGlfNCA9IDA7IGlfNCA8IGFsbExlYXZlTm9kZXMubGVuZ3RoOyBpXzQrKykge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gYWxsTGVhdmVOb2Rlc1tpXzRdO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhaWxzID0gLyoqIEB0eXBlIHs/fSAqLyAoZWxlbWVudFtSRU1PVkFMX0ZMQUddKTtcclxuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgTEVBVkVfQ0xBU1NOQU1FKTtcclxuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGUgZWxlbWVudCBoYXMgYSByZW1vdmFsIGFuaW1hdGlvbiB0aGF0IGlzIGJlaW5nXHJcbiAgICAgICAgICAgIC8vIHRha2VuIGNhcmUgb2YgYW5kIHRoZXJlZm9yZSB0aGUgaW5uZXIgZWxlbWVudHMgd2lsbCBoYW5nIGFyb3VuZFxyXG4gICAgICAgICAgICAvLyB1bnRpbCB0aGF0IGFuaW1hdGlvbiBpcyBvdmVyIChvciB0aGUgcGFyZW50IHF1ZXJpZWQgYW5pbWF0aW9uKVxyXG4gICAgICAgICAgICBpZiAoZGV0YWlscyAmJiBkZXRhaWxzLmhhc0FuaW1hdGlvbilcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJzID0gW107XHJcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZWxlbWVudCBpcyBxdWVyaWVkIG9yIGlmIGl0IGNvbnRhaW5zIHF1ZXJpZWQgY2hpbGRyZW5cclxuICAgICAgICAgICAgLy8gdGhlbiB3ZSB3YW50IGZvciB0aGUgZWxlbWVudCBub3QgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBwYWdlXHJcbiAgICAgICAgICAgIC8vIHVudGlsIHRoZSBxdWVyaWVkIGFuaW1hdGlvbnMgaGF2ZSBmaW5pc2hlZFxyXG4gICAgICAgICAgICBpZiAocXVlcmllZEVsZW1lbnRzLnNpemUpIHtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZWRQbGF5ZXJSZXN1bHRzID0gcXVlcmllZEVsZW1lbnRzLmdldChlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChxdWVyaWVkUGxheWVyUmVzdWx0cyAmJiBxdWVyaWVkUGxheWVyUmVzdWx0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBwbGF5ZXJzLnB1c2guYXBwbHkocGxheWVycywgcXVlcmllZFBsYXllclJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcmllZElubmVyRWxlbWVudHMgPSB0aGlzLmRyaXZlci5xdWVyeShlbGVtZW50LCBOR19BTklNQVRJTkdfU0VMRUNUT1IsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBqID0gMDsgaiA8IHF1ZXJpZWRJbm5lckVsZW1lbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcmllZFBsYXllcnMgPSBxdWVyaWVkRWxlbWVudHMuZ2V0KHF1ZXJpZWRJbm5lckVsZW1lbnRzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocXVlcmllZFBsYXllcnMgJiYgcXVlcmllZFBsYXllcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllcnMucHVzaC5hcHBseShwbGF5ZXJzLCBxdWVyaWVkUGxheWVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFjdGl2ZVBsYXllcnMgPSBwbGF5ZXJzLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gIXAuZGVzdHJveWVkOyB9KTtcclxuICAgICAgICAgICAgaWYgKGFjdGl2ZVBsYXllcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVOb2Rlc0FmdGVyQW5pbWF0aW9uRG9uZSh0aGlzLCBlbGVtZW50LCBhY3RpdmVQbGF5ZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xlYXZlTm9kZShlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGlzIGlzIHJlcXVpcmVkIHNvIHRoZSBjbGVhbnVwIG1ldGhvZCBkb2Vzbid0IHJlbW92ZSB0aGVtXHJcbiAgICAgICAgYWxsTGVhdmVOb2Rlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHJvb3RQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xyXG4gICAgICAgICAgICBfdGhpcy5wbGF5ZXJzLnB1c2gocGxheWVyKTtcclxuICAgICAgICAgICAgcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBfdGhpcy5wbGF5ZXJzLmluZGV4T2YocGxheWVyKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnBsYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHBsYXllci5wbGF5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJvb3RQbGF5ZXJzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5lbGVtZW50Q29udGFpbnNEYXRhID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgZWxlbWVudCkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5zRGF0YSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRldGFpbHMgPSAvKiogQHR5cGUgez99ICovIChlbGVtZW50W1JFTU9WQUxfRkxBR10pO1xyXG4gICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMuc2V0Rm9yUmVtb3ZhbClcclxuICAgICAgICAgICAgY29udGFpbnNEYXRhID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5wbGF5ZXJzQnlFbGVtZW50LmhhcyhlbGVtZW50KSlcclxuICAgICAgICAgICAgY29udGFpbnNEYXRhID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudC5oYXMoZWxlbWVudCkpXHJcbiAgICAgICAgICAgIGNvbnRhaW5zRGF0YSA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVzQnlFbGVtZW50LmhhcyhlbGVtZW50KSlcclxuICAgICAgICAgICAgY29udGFpbnNEYXRhID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hOYW1lc3BhY2UobmFtZXNwYWNlSWQpLmVsZW1lbnRDb250YWluc0RhdGEoZWxlbWVudCkgfHwgY29udGFpbnNEYXRhO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuYWZ0ZXJGbHVzaCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHRoaXMuX2ZsdXNoRm5zLnB1c2goY2FsbGJhY2spOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5hZnRlckZsdXNoQW5pbWF0aW9uc0RvbmUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChjYWxsYmFjaykgeyB0aGlzLl93aGVuUXVpZXRGbnMucHVzaChjYWxsYmFjayk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBpc1F1ZXJpZWRFbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez89fSBuYW1lc3BhY2VJZFxyXG4gICAgICogQHBhcmFtIHs/PX0gdHJpZ2dlck5hbWVcclxuICAgICAqIEBwYXJhbSB7Pz19IHRvU3RhdGVWYWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuX2dldFByZXZpb3VzUGxheWVycyA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGlzUXVlcmllZEVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZUlkXHJcbiAgICAgKiBAcGFyYW0gez89fSB0cmlnZ2VyTmFtZVxyXG4gICAgICogQHBhcmFtIHs/PX0gdG9TdGF0ZVZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgaXNRdWVyaWVkRWxlbWVudCwgbmFtZXNwYWNlSWQsIHRyaWdnZXJOYW1lLCB0b1N0YXRlVmFsdWUpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJzID0gW107XHJcbiAgICAgICAgaWYgKGlzUXVlcmllZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcmllZEVsZW1lbnRQbGF5ZXJzID0gdGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudC5nZXQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIGlmIChxdWVyaWVkRWxlbWVudFBsYXllcnMpIHtcclxuICAgICAgICAgICAgICAgIHBsYXllcnMgPSBxdWVyaWVkRWxlbWVudFBsYXllcnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRQbGF5ZXJzID0gdGhpcy5wbGF5ZXJzQnlFbGVtZW50LmdldChlbGVtZW50KTtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnRQbGF5ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1JlbW92YWxBbmltYXRpb25fMSA9ICF0b1N0YXRlVmFsdWUgfHwgdG9TdGF0ZVZhbHVlID09IFZPSURfVkFMVUU7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50UGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGxheWVyLnF1ZXVlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZW1vdmFsQW5pbWF0aW9uXzEgJiYgcGxheWVyLnRyaWdnZXJOYW1lICE9IHRyaWdnZXJOYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgcGxheWVycy5wdXNoKHBsYXllcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmFtZXNwYWNlSWQgfHwgdHJpZ2dlck5hbWUpIHtcclxuICAgICAgICAgICAgcGxheWVycyA9IHBsYXllcnMuZmlsdGVyKGZ1bmN0aW9uIChwbGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lc3BhY2VJZCAmJiBuYW1lc3BhY2VJZCAhPSBwbGF5ZXIubmFtZXNwYWNlSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJOYW1lICYmIHRyaWdnZXJOYW1lICE9IHBsYXllci50cmlnZ2VyTmFtZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwbGF5ZXJzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxyXG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvblxyXG4gICAgICogQHBhcmFtIHs/fSBhbGxQcmV2aW91c1BsYXllcnNNYXBcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9iZWZvcmVBbmltYXRpb25CdWlsZCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxyXG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvblxyXG4gICAgICogQHBhcmFtIHs/fSBhbGxQcmV2aW91c1BsYXllcnNNYXBcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgaW5zdHJ1Y3Rpb24sIGFsbFByZXZpb3VzUGxheWVyc01hcCkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXJOYW1lID0gaW5zdHJ1Y3Rpb24udHJpZ2dlck5hbWU7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcm9vdEVsZW1lbnQgPSBpbnN0cnVjdGlvbi5lbGVtZW50O1xyXG4gICAgICAgIC8vIHdoZW4gYSByZW1vdmFsIGFuaW1hdGlvbiBvY2N1cnMsIEFMTCBwcmV2aW91cyBwbGF5ZXJzIGFyZSBjb2xsZWN0ZWRcclxuICAgICAgICAvLyBhbmQgZGVzdHJveWVkIChldmVuIGlmIHRoZXkgYXJlIG91dHNpZGUgb2YgdGhlIGN1cnJlbnQgbmFtZXNwYWNlKVxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhcmdldE5hbWVTcGFjZUlkID0gaW5zdHJ1Y3Rpb24uaXNSZW1vdmFsVHJhbnNpdGlvbiA/IHVuZGVmaW5lZCA6IG5hbWVzcGFjZUlkO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhcmdldFRyaWdnZXJOYW1lID0gaW5zdHJ1Y3Rpb24uaXNSZW1vdmFsVHJhbnNpdGlvbiA/IHVuZGVmaW5lZCA6IHRyaWdnZXJOYW1lO1xyXG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHRpbWVsaW5lSW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IHRpbWVsaW5lSW5zdHJ1Y3Rpb24uZWxlbWVudDtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNRdWVyaWVkRWxlbWVudCA9IGVsZW1lbnQgIT09IHJvb3RFbGVtZW50O1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJzID0gZ2V0T3JTZXRBc0luTWFwKGFsbFByZXZpb3VzUGxheWVyc01hcCwgZWxlbWVudCwgW10pO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2aW91c1BsYXllcnMgPSB0aGlzXzEuX2dldFByZXZpb3VzUGxheWVycyhlbGVtZW50LCBpc1F1ZXJpZWRFbGVtZW50LCB0YXJnZXROYW1lU3BhY2VJZCwgdGFyZ2V0VHJpZ2dlck5hbWUsIGluc3RydWN0aW9uLnRvU3RhdGUpO1xyXG4gICAgICAgICAgICBwcmV2aW91c1BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWFsUGxheWVyID0gLyoqIEB0eXBlIHs/fSAqLyAocGxheWVyLmdldFJlYWxQbGF5ZXIoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVhbFBsYXllci5iZWZvcmVEZXN0cm95KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhbFBsYXllci5iZWZvcmVEZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgcGxheWVycy5wdXNoKHBsYXllcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGluc3RydWN0aW9uLnRpbWVsaW5lczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHRpbWVsaW5lSW5zdHJ1Y3Rpb24gPSBfYVtfaV07XHJcbiAgICAgICAgICAgIF9sb29wXzEodGltZWxpbmVJbnN0cnVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRoaXMgbmVlZHMgdG8gYmUgZG9uZSBzbyB0aGF0IHRoZSBQUkUvUE9TVCBzdHlsZXMgY2FuIGJlXHJcbiAgICAgICAgLy8gY29tcHV0ZWQgcHJvcGVybHkgd2l0aG91dCBpbnRlcmZlcmluZyB3aXRoIHRoZSBwcmV2aW91cyBhbmltYXRpb25cclxuICAgICAgICBlcmFzZVN0eWxlcyhyb290RWxlbWVudCwgaW5zdHJ1Y3Rpb24uZnJvbVN0eWxlcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXHJcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gez99IGFsbFByZXZpb3VzUGxheWVyc01hcFxyXG4gICAgICogQHBhcmFtIHs/fSBza2lwcGVkUGxheWVyc01hcFxyXG4gICAgICogQHBhcmFtIHs/fSBwcmVTdHlsZXNNYXBcclxuICAgICAqIEBwYXJhbSB7P30gcG9zdFN0eWxlc01hcFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuX2J1aWxkQW5pbWF0aW9uID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXHJcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gez99IGFsbFByZXZpb3VzUGxheWVyc01hcFxyXG4gICAgICogQHBhcmFtIHs/fSBza2lwcGVkUGxheWVyc01hcFxyXG4gICAgICogQHBhcmFtIHs/fSBwcmVTdHlsZXNNYXBcclxuICAgICAqIEBwYXJhbSB7P30gcG9zdFN0eWxlc01hcFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBpbnN0cnVjdGlvbiwgYWxsUHJldmlvdXNQbGF5ZXJzTWFwLCBza2lwcGVkUGxheWVyc01hcCwgcHJlU3R5bGVzTWFwLCBwb3N0U3R5bGVzTWFwKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VyTmFtZSA9IGluc3RydWN0aW9uLnRyaWdnZXJOYW1lO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJvb3RFbGVtZW50ID0gaW5zdHJ1Y3Rpb24uZWxlbWVudDtcclxuICAgICAgICAvLyB3ZSBmaXJzdCBydW4gdGhpcyBzbyB0aGF0IHRoZSBwcmV2aW91cyBhbmltYXRpb24gcGxheWVyXHJcbiAgICAgICAgLy8gZGF0YSBjYW4gYmUgcGFzc2VkIGludG8gdGhlIHN1Y2Nlc3NpdmUgYW5pbWF0aW9uIHBsYXllcnNcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxRdWVyaWVkUGxheWVycyA9IFtdO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbENvbnN1bWVkRWxlbWVudHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsU3ViRWxlbWVudHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsTmV3UGxheWVycyA9IGluc3RydWN0aW9uLnRpbWVsaW5lcy5tYXAoZnVuY3Rpb24gKHRpbWVsaW5lSW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IHRpbWVsaW5lSW5zdHJ1Y3Rpb24uZWxlbWVudDtcclxuICAgICAgICAgICAgYWxsQ29uc3VtZWRFbGVtZW50cy5hZGQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIC8vIEZJWE1FIChtYXRza28pOiBtYWtlIHN1cmUgdG8tYmUtcmVtb3ZlZCBhbmltYXRpb25zIGFyZSByZW1vdmVkIHByb3Blcmx5XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRldGFpbHMgPSBlbGVtZW50W1JFTU9WQUxfRkxBR107XHJcbiAgICAgICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMucmVtb3ZlZEJlZm9yZVF1ZXJpZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2FuaW1hdGlvbnMuTm9vcEFuaW1hdGlvblBsYXllcigpO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1F1ZXJpZWRFbGVtZW50ID0gZWxlbWVudCAhPT0gcm9vdEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZpb3VzUGxheWVycyA9IGZsYXR0ZW5Hcm91cFBsYXllcnMoKGFsbFByZXZpb3VzUGxheWVyc01hcC5nZXQoZWxlbWVudCkgfHwgRU1QVFlfUExBWUVSX0FSUkFZKVxyXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5nZXRSZWFsUGxheWVyKCk7IH0pKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGBlbGVtZW50YCBpcyBub3QgYXBhcnQgb2YgdGhlIEFuaW1hdGlvblBsYXllciBkZWZpbml0aW9uLCBidXRcclxuICAgICAgICAgICAgICAgIC8vIE1vY2svV2ViQW5pbWF0aW9uc1xyXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBlbGVtZW50IHdpdGhpbiB0aGVpciBpbXBsZW1lbnRhdGlvbi4gVGhpcyB3aWxsIGJlIGFkZGVkIGluIEFuZ3VsYXI1IHRvXHJcbiAgICAgICAgICAgICAgICAvLyBBbmltYXRpb25QbGF5ZXJcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBwID0gLyoqIEB0eXBlIHs/fSAqLyAocCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHAuZWxlbWVudCA/IHBwLmVsZW1lbnQgPT09IGVsZW1lbnQgOiBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVN0eWxlcyA9IHByZVN0eWxlc01hcC5nZXQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc3RTdHlsZXMgPSBwb3N0U3R5bGVzTWFwLmdldChlbGVtZW50KTtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ZnJhbWVzID0gbm9ybWFsaXplS2V5ZnJhbWVzKF90aGlzLmRyaXZlciwgX3RoaXMuX25vcm1hbGl6ZXIsIGVsZW1lbnQsIHRpbWVsaW5lSW5zdHJ1Y3Rpb24ua2V5ZnJhbWVzLCBwcmVTdHlsZXMsIHBvc3RTdHlsZXMpO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSBfdGhpcy5fYnVpbGRQbGF5ZXIodGltZWxpbmVJbnN0cnVjdGlvbiwga2V5ZnJhbWVzLCBwcmV2aW91c1BsYXllcnMpO1xyXG4gICAgICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgdGhpcyBwYXJ0aWN1bGFyIHBsYXllciBiZWxvbmdzIHRvIGEgc3ViIHRyaWdnZXIuIEl0IGlzXHJcbiAgICAgICAgICAgIC8vIGltcG9ydGFudCB0aGF0IHdlIG1hdGNoIHRoaXMgcGxheWVyIHVwIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgKEB0cmlnZ2VyLmxpc3RlbmVyKVxyXG4gICAgICAgICAgICBpZiAodGltZWxpbmVJbnN0cnVjdGlvbi5zdWJUaW1lbGluZSAmJiBza2lwcGVkUGxheWVyc01hcCkge1xyXG4gICAgICAgICAgICAgICAgYWxsU3ViRWxlbWVudHMuYWRkKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1F1ZXJpZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3cmFwcGVkUGxheWVyID0gbmV3IFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIobmFtZXNwYWNlSWQsIHRyaWdnZXJOYW1lLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIHdyYXBwZWRQbGF5ZXIuc2V0UmVhbFBsYXllcihwbGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgYWxsUXVlcmllZFBsYXllcnMucHVzaCh3cmFwcGVkUGxheWVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGxheWVyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFsbFF1ZXJpZWRQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xyXG4gICAgICAgICAgICBnZXRPclNldEFzSW5NYXAoX3RoaXMucGxheWVyc0J5UXVlcmllZEVsZW1lbnQsIHBsYXllci5lbGVtZW50LCBbXSkucHVzaChwbGF5ZXIpO1xyXG4gICAgICAgICAgICBwbGF5ZXIub25Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlbGV0ZU9yVW5zZXRJbk1hcChfdGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudCwgcGxheWVyLmVsZW1lbnQsIHBsYXllcik7IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFsbENvbnN1bWVkRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gYWRkQ2xhc3MoZWxlbWVudCwgTkdfQU5JTUFUSU5HX0NMQVNTTkFNRSk7IH0pO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IG9wdGltaXplR3JvdXBQbGF5ZXIoYWxsTmV3UGxheWVycyk7XHJcbiAgICAgICAgcGxheWVyLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGFsbENvbnN1bWVkRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgTkdfQU5JTUFUSU5HX0NMQVNTTkFNRSk7IH0pO1xyXG4gICAgICAgICAgICBzZXRTdHlsZXMocm9vdEVsZW1lbnQsIGluc3RydWN0aW9uLnRvU3R5bGVzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyB0aGlzIGJhc2ljYWxseSBtYWtlcyBhbGwgb2YgdGhlIGNhbGxiYWNrcyBmb3Igc3ViIGVsZW1lbnQgYW5pbWF0aW9uc1xyXG4gICAgICAgIC8vIGJlIGRlcGVuZGVudCBvbiB0aGUgdXBwZXIgcGxheWVycyBmb3Igd2hlbiB0aGV5IGZpbmlzaFxyXG4gICAgICAgIGFsbFN1YkVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgZ2V0T3JTZXRBc0luTWFwKHNraXBwZWRQbGF5ZXJzTWFwLCBlbGVtZW50LCBbXSkucHVzaChwbGF5ZXIpOyB9KTtcclxuICAgICAgICByZXR1cm4gcGxheWVyO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvblxyXG4gICAgICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcclxuICAgICAqIEBwYXJhbSB7P30gcHJldmlvdXNQbGF5ZXJzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fYnVpbGRQbGF5ZXIgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gaW5zdHJ1Y3Rpb25cclxuICAgICAqIEBwYXJhbSB7P30ga2V5ZnJhbWVzXHJcbiAgICAgKiBAcGFyYW0gez99IHByZXZpb3VzUGxheWVyc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGluc3RydWN0aW9uLCBrZXlmcmFtZXMsIHByZXZpb3VzUGxheWVycykge1xyXG4gICAgICAgIGlmIChrZXlmcmFtZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcml2ZXIuYW5pbWF0ZShpbnN0cnVjdGlvbi5lbGVtZW50LCBrZXlmcmFtZXMsIGluc3RydWN0aW9uLmR1cmF0aW9uLCBpbnN0cnVjdGlvbi5kZWxheSwgaW5zdHJ1Y3Rpb24uZWFzaW5nLCBwcmV2aW91c1BsYXllcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHdoZW4gYW4gZW1wdHkgdHJhbnNpdGlvbnxkZWZpbml0aW9uIGlzIHByb3ZpZGVkXHJcbiAgICAgICAgLy8gLi4uIHRoZXJlIGlzIG5vIHBvaW50IGluIHJlbmRlcmluZyBhbiBlbXB0eSBhbmltYXRpb25cclxuICAgICAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2FuaW1hdGlvbnMuTm9vcEFuaW1hdGlvblBsYXllcigpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lO1xyXG59KCkpO1xyXG52YXIgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIobmFtZXNwYWNlSWQsIHRyaWdnZXJOYW1lLCBlbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VJZCA9IG5hbWVzcGFjZUlkO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlck5hbWUgPSB0cmlnZ2VyTmFtZTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIHRoaXMuX3BsYXllciA9IG5ldyBfYW5ndWxhcl9hbmltYXRpb25zLk5vb3BBbmltYXRpb25QbGF5ZXIoKTtcclxuICAgICAgICB0aGlzLl9jb250YWluc1JlYWxQbGF5ZXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9xdWV1ZWRDYWxsYmFja3MgPSB7fTtcclxuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubWFya2VkRm9yRGVzdHJveSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucXVldWVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBwbGF5ZXJcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnNldFJlYWxQbGF5ZXIgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcGxheWVyXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAocGxheWVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5fY29udGFpbnNSZWFsUGxheWVyKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5fcGxheWVyID0gcGxheWVyO1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3F1ZXVlZENhbGxiYWNrcykuZm9yRWFjaChmdW5jdGlvbiAocGhhc2UpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3F1ZXVlZENhbGxiYWNrc1twaGFzZV0uZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIGxpc3Rlbk9uUGxheWVyKHBsYXllciwgcGhhc2UsIHVuZGVmaW5lZCwgY2FsbGJhY2spOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9xdWV1ZWRDYWxsYmFja3MgPSB7fTtcclxuICAgICAgICB0aGlzLl9jb250YWluc1JlYWxQbGF5ZXIgPSB0cnVlO1xyXG4gICAgICAgICgvKiogQHR5cGUgez99ICovICh0aGlzKSkucXVldWVkID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5nZXRSZWFsUGxheWVyID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wbGF5ZXI7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcGxheWVyXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5zeW5jUGxheWVyRXZlbnRzID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHBsYXllclxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHBsYXllcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcCA9IC8qKiBAdHlwZSB7P30gKi8gKHRoaXMuX3BsYXllcik7XHJcbiAgICAgICAgaWYgKHAudHJpZ2dlckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHBsYXllci5vblN0YXJ0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHAudHJpZ2dlckNhbGxiYWNrKCdzdGFydCcpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5maW5pc2goKTsgfSk7XHJcbiAgICAgICAgcGxheWVyLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kZXN0cm95KCk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5fcXVldWVFdmVudCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcclxuICAgICAgICBnZXRPclNldEFzSW5NYXAodGhpcy5fcXVldWVkQ2FsbGJhY2tzLCBuYW1lLCBbXSkucHVzaChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGZuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZm5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9xdWV1ZUV2ZW50KCdkb25lJywgZm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wbGF5ZXIub25Eb25lKGZuKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZm5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uU3RhcnQgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZm5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9xdWV1ZUV2ZW50KCdzdGFydCcsIGZuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcGxheWVyLm9uU3RhcnQoZm4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBmblxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUub25EZXN0cm95ID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGZuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICBpZiAodGhpcy5xdWV1ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcXVldWVFdmVudCgnZGVzdHJveScsIGZuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcGxheWVyLm9uRGVzdHJveShmbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5pbml0ID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXllci5pbml0KCk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmhhc1N0YXJ0ZWQgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucXVldWVkID8gZmFsc2UgOiB0aGlzLl9wbGF5ZXIuaGFzU3RhcnRlZCgpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7ICF0aGlzLnF1ZXVlZCAmJiB0aGlzLl9wbGF5ZXIucGxheSgpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkgeyAhdGhpcy5xdWV1ZWQgJiYgdGhpcy5fcGxheWVyLnBhdXNlKCk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgIXRoaXMucXVldWVkICYmIHRoaXMuX3BsYXllci5yZXN0YXJ0KCk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmZpbmlzaCA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF5ZXIuZmluaXNoKCk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAodGhpcykpLmRlc3Ryb3llZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcGxheWVyLmRlc3Ryb3koKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7ICF0aGlzLnF1ZXVlZCAmJiB0aGlzLl9wbGF5ZXIucmVzZXQoKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBwXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBwXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIGlmICghdGhpcy5xdWV1ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGxheWVyLnNldFBvc2l0aW9uKHApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmdldFBvc2l0aW9uID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnF1ZXVlZCA/IDAgOiB0aGlzLl9wbGF5ZXIuZ2V0UG9zaXRpb24oKTsgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZSwgXCJ0b3RhbFRpbWVcIiwge1xyXG4gICAgICAgIGdldDogLyoqXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wbGF5ZXIudG90YWxUaW1lOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHBoYXNlTmFtZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUudHJpZ2dlckNhbGxiYWNrID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHBoYXNlTmFtZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHBoYXNlTmFtZSkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHAgPSAvKiogQHR5cGUgez99ICovICh0aGlzLl9wbGF5ZXIpO1xyXG4gICAgICAgIGlmIChwLnRyaWdnZXJDYWxsYmFjaykge1xyXG4gICAgICAgICAgICBwLnRyaWdnZXJDYWxsYmFjayhwaGFzZU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllcjtcclxufSgpKTtcclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gbWFwXHJcbiAqIEBwYXJhbSB7P30ga2V5XHJcbiAqIEBwYXJhbSB7P30gdmFsdWVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGRlbGV0ZU9yVW5zZXRJbk1hcChtYXAsIGtleSwgdmFsdWUpIHtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRWYWx1ZXM7XHJcbiAgICBpZiAobWFwIGluc3RhbmNlb2YgTWFwKSB7XHJcbiAgICAgICAgY3VycmVudFZhbHVlcyA9IG1hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoY3VycmVudFZhbHVlcykge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gY3VycmVudFZhbHVlcy5pbmRleE9mKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlcy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbWFwLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY3VycmVudFZhbHVlcyA9IG1hcFtrZXldO1xyXG4gICAgICAgIGlmIChjdXJyZW50VmFsdWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBjdXJyZW50VmFsdWVzLmluZGV4T2YodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWVzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFwW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3VycmVudFZhbHVlcztcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplVHJpZ2dlclZhbHVlKHZhbHVlKSB7XHJcbiAgICAvLyB3ZSB1c2UgYCE9IG51bGxgIGhlcmUgYmVjYXVzZSBpdCdzIHRoZSBtb3N0IHNpbXBsZVxyXG4gICAgLy8gd2F5IHRvIHRlc3QgYWdhaW5zdCBhIFwiZmFsc3lcIiB2YWx1ZSB3aXRob3V0IG1peGluZ1xyXG4gICAgLy8gaW4gZW1wdHkgc3RyaW5ncyBvciBhIHplcm8gdmFsdWUuIERPIE5PVCBPUFRJTUlaRS5cclxuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IG5vZGVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGlzRWxlbWVudE5vZGUobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZVsnbm9kZVR5cGUnXSA9PT0gMTtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSBldmVudE5hbWVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGlzVHJpZ2dlckV2ZW50VmFsaWQoZXZlbnROYW1lKSB7XHJcbiAgICByZXR1cm4gZXZlbnROYW1lID09ICdzdGFydCcgfHwgZXZlbnROYW1lID09ICdkb25lJztcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7Pz19IHZhbHVlXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBjbG9ha0VsZW1lbnQoZWxlbWVudCwgdmFsdWUpIHtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZFZhbHVlID0gZWxlbWVudC5zdHlsZS5kaXNwbGF5O1xyXG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogJ25vbmUnO1xyXG4gICAgcmV0dXJuIG9sZFZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHZhbHVlc01hcFxyXG4gKiBAcGFyYW0gez99IGRyaXZlclxyXG4gKiBAcGFyYW0gez99IGVsZW1lbnRzXHJcbiAqIEBwYXJhbSB7P30gZWxlbWVudFByb3BzTWFwXHJcbiAqIEBwYXJhbSB7P30gZGVmYXVsdFN0eWxlXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBjbG9ha0FuZENvbXB1dGVTdHlsZXModmFsdWVzTWFwLCBkcml2ZXIsIGVsZW1lbnRzLCBlbGVtZW50UHJvcHNNYXAsIGRlZmF1bHRTdHlsZSkge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvYWtWYWxzID0gW107XHJcbiAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBjbG9ha1ZhbHMucHVzaChjbG9ha0VsZW1lbnQoZWxlbWVudCkpOyB9KTtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZhaWxlZEVsZW1lbnRzID0gW107XHJcbiAgICBlbGVtZW50UHJvcHNNYXAuZm9yRWFjaChmdW5jdGlvbiAocHJvcHMsIGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSB7fTtcclxuICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gc3R5bGVzW3Byb3BdID0gZHJpdmVyLmNvbXB1dGVTdHlsZShlbGVtZW50LCBwcm9wLCBkZWZhdWx0U3R5bGUpO1xyXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBlYXN5IHdheSB0byBkZXRlY3QgdGhpcyBiZWNhdXNlIGEgc3ViIGVsZW1lbnQgY291bGQgYmUgcmVtb3ZlZFxyXG4gICAgICAgICAgICAvLyBieSBhIHBhcmVudCBhbmltYXRpb24gZWxlbWVudCBiZWluZyBkZXRhY2hlZC5cclxuICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudFtSRU1PVkFMX0ZMQUddID0gTlVMTF9SRU1PVkVEX1FVRVJJRURfU1RBVEU7XHJcbiAgICAgICAgICAgICAgICBmYWlsZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFsdWVzTWFwLnNldChlbGVtZW50LCBzdHlsZXMpO1xyXG4gICAgfSk7XHJcbiAgICAvLyB3ZSB1c2UgYSBpbmRleCB2YXJpYWJsZSBoZXJlIHNpbmNlIFNldC5mb3JFYWNoKGEsIGkpIGRvZXMgbm90IHJldHVyblxyXG4gICAgLy8gYW4gaW5kZXggdmFsdWUgZm9yIHRoZSBjbG9zdXJlIChidXQgaW5zdGVhZCBqdXN0IHRoZSB2YWx1ZSlcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwO1xyXG4gICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gY2xvYWtFbGVtZW50KGVsZW1lbnQsIGNsb2FrVmFsc1tpKytdKTsgfSk7XHJcbiAgICByZXR1cm4gZmFpbGVkRWxlbWVudHM7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gcm9vdHNcclxuICogQHBhcmFtIHs/fSBub2Rlc1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gYnVpbGRSb290TWFwKHJvb3RzLCBub2Rlcykge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcm9vdE1hcCA9IG5ldyBNYXAoKTtcclxuICAgIHJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHsgcmV0dXJuIHJvb3RNYXAuc2V0KHJvb3QsIFtdKTsgfSk7XHJcbiAgICBpZiAobm9kZXMubGVuZ3RoID09IDApXHJcbiAgICAgICAgcmV0dXJuIHJvb3RNYXA7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBOVUxMX05PREUgPSAxO1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZVNldCA9IG5ldyBTZXQobm9kZXMpO1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9jYWxSb290TWFwID0gbmV3IE1hcCgpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xyXG4gICAgICAgIGlmICghbm9kZSlcclxuICAgICAgICAgICAgcmV0dXJuIE5VTExfTk9ERTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByb290ID0gbG9jYWxSb290TWFwLmdldChub2RlKTtcclxuICAgICAgICBpZiAocm9vdClcclxuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xyXG4gICAgICAgIGlmIChyb290TWFwLmhhcyhwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgIC8vIG5nSWYgaW5zaWRlIEB0cmlnZ2VyXHJcbiAgICAgICAgICAgIHJvb3QgPSBwYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5vZGVTZXQuaGFzKHBhcmVudCkpIHtcclxuICAgICAgICAgICAgLy8gbmdJZiBpbnNpZGUgbmdJZlxyXG4gICAgICAgICAgICByb290ID0gTlVMTF9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcmVjdXJzZSB1cHdhcmRzXHJcbiAgICAgICAgICAgIHJvb3QgPSBnZXRSb290KHBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxvY2FsUm9vdE1hcC5zZXQobm9kZSwgcm9vdCk7XHJcbiAgICAgICAgcmV0dXJuIHJvb3Q7XHJcbiAgICB9XHJcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcm9vdCA9IGdldFJvb3Qobm9kZSk7XHJcbiAgICAgICAgaWYgKHJvb3QgIT09IE5VTExfTk9ERSkge1xyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovICgocm9vdE1hcC5nZXQocm9vdCkpKS5wdXNoKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJvb3RNYXA7XHJcbn1cclxudmFyIENMQVNTRVNfQ0FDSEVfS0VZID0gJyQkY2xhc3Nlcyc7XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICogQHBhcmFtIHs/fSBjbGFzc05hbWVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xyXG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XHJcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc2VzID0gZWxlbWVudFtDTEFTU0VTX0NBQ0hFX0tFWV07XHJcbiAgICAgICAgaWYgKCFjbGFzc2VzKSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMgPSBlbGVtZW50W0NMQVNTRVNfQ0FDSEVfS0VZXSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGFzc2VzW2NsYXNzTmFtZV0gPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICogQHBhcmFtIHs/fSBjbGFzc05hbWVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xyXG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XHJcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc2VzID0gZWxlbWVudFtDTEFTU0VTX0NBQ0hFX0tFWV07XHJcbiAgICAgICAgaWYgKGNsYXNzZXMpIHtcclxuICAgICAgICAgICAgZGVsZXRlIGNsYXNzZXNbY2xhc3NOYW1lXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gZW5naW5lXHJcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gKiBAcGFyYW0gez99IHBsYXllcnNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZU5vZGVzQWZ0ZXJBbmltYXRpb25Eb25lKGVuZ2luZSwgZWxlbWVudCwgcGxheWVycykge1xyXG4gICAgb3B0aW1pemVHcm91cFBsYXllcihwbGF5ZXJzKS5vbkRvbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5naW5lLnByb2Nlc3NMZWF2ZU5vZGUoZWxlbWVudCk7IH0pO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHBsYXllcnNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGZsYXR0ZW5Hcm91cFBsYXllcnMocGxheWVycykge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmluYWxQbGF5ZXJzID0gW107XHJcbiAgICBfZmxhdHRlbkdyb3VwUGxheWVyc1JlY3VyKHBsYXllcnMsIGZpbmFsUGxheWVycyk7XHJcbiAgICByZXR1cm4gZmluYWxQbGF5ZXJzO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHBsYXllcnNcclxuICogQHBhcmFtIHs/fSBmaW5hbFBsYXllcnNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIF9mbGF0dGVuR3JvdXBQbGF5ZXJzUmVjdXIocGxheWVycywgZmluYWxQbGF5ZXJzKSB7XHJcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgcGxheWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IHBsYXllcnNbaV07XHJcbiAgICAgICAgaWYgKHBsYXllciBpbnN0YW5jZW9mIF9hbmd1bGFyX2FuaW1hdGlvbnMuybVBbmltYXRpb25Hcm91cFBsYXllcikge1xyXG4gICAgICAgICAgICBfZmxhdHRlbkdyb3VwUGxheWVyc1JlY3VyKHBsYXllci5wbGF5ZXJzLCBmaW5hbFBsYXllcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZmluYWxQbGF5ZXJzLnB1c2goLyoqIEB0eXBlIHs/fSAqLyAocGxheWVyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IGFcclxuICogQHBhcmFtIHs/fSBiXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBvYmpFcXVhbHMoYSwgYikge1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gazEgPSBPYmplY3Qua2V5cyhhKTtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGsyID0gT2JqZWN0LmtleXMoYik7XHJcbiAgICBpZiAoazEubGVuZ3RoICE9IGsyLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgazEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wID0gazFbaV07XHJcbiAgICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KHByb3ApIHx8IGFbcHJvcF0gIT09IGJbcHJvcF0pXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICogQHBhcmFtIHs/fSBhbGxQcmVTdHlsZUVsZW1lbnRzXHJcbiAqIEBwYXJhbSB7P30gYWxsUG9zdFN0eWxlRWxlbWVudHNcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIHJlcGxhY2VQb3N0U3R5bGVzQXNQcmUoZWxlbWVudCwgYWxsUHJlU3R5bGVFbGVtZW50cywgYWxsUG9zdFN0eWxlRWxlbWVudHMpIHtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc3RFbnRyeSA9IGFsbFBvc3RTdHlsZUVsZW1lbnRzLmdldChlbGVtZW50KTtcclxuICAgIGlmICghcG9zdEVudHJ5KVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZUVudHJ5ID0gYWxsUHJlU3R5bGVFbGVtZW50cy5nZXQoZWxlbWVudCk7XHJcbiAgICBpZiAocHJlRW50cnkpIHtcclxuICAgICAgICBwb3N0RW50cnkuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gKChwcmVFbnRyeSkpLmFkZChkYXRhKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhbGxQcmVTdHlsZUVsZW1lbnRzLnNldChlbGVtZW50LCBwb3N0RW50cnkpO1xyXG4gICAgfVxyXG4gICAgYWxsUG9zdFN0eWxlRWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxudmFyIEFuaW1hdGlvbkVuZ2luZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkVuZ2luZShfZHJpdmVyLCBub3JtYWxpemVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9kcml2ZXIgPSBfZHJpdmVyO1xyXG4gICAgICAgIHRoaXMuX3RyaWdnZXJDYWNoZSA9IHt9O1xyXG4gICAgICAgIHRoaXMub25SZW1vdmFsQ29tcGxldGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkgeyB9O1xyXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUgPSBuZXcgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZShfZHJpdmVyLCBub3JtYWxpemVyKTtcclxuICAgICAgICB0aGlzLl90aW1lbGluZUVuZ2luZSA9IG5ldyBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZShfZHJpdmVyLCBub3JtYWxpemVyKTtcclxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLm9uUmVtb3ZhbENvbXBsZXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9uUmVtb3ZhbENvbXBsZXRlKGVsZW1lbnQsIGNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50SWRcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcclxuICAgICAqIEBwYXJhbSB7P30gaG9zdEVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5yZWdpc3RlclRyaWdnZXIgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50SWRcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcclxuICAgICAqIEBwYXJhbSB7P30gaG9zdEVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGNvbXBvbmVudElkLCBuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQsIG5hbWUsIG1ldGFkYXRhKSB7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FjaGVLZXkgPSBjb21wb25lbnRJZCArICctJyArIG5hbWU7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlciA9IHRoaXMuX3RyaWdnZXJDYWNoZVtjYWNoZUtleV07XHJcbiAgICAgICAgaWYgKCF0cmlnZ2VyKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSAvKiogQHR5cGUgez99ICovIChidWlsZEFuaW1hdGlvbkFzdCh0aGlzLl9kcml2ZXIsIC8qKiBAdHlwZSB7P30gKi8gKG1ldGFkYXRhKSwgZXJyb3JzKSk7XHJcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYW5pbWF0aW9uIHRyaWdnZXIgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBoYXMgZmFpbGVkIHRvIGJ1aWxkIGR1ZSB0byB0aGUgZm9sbG93aW5nIGVycm9yczpcXG4gLSBcIiArIGVycm9ycy5qb2luKFwiXFxuIC0gXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cmlnZ2VyID0gYnVpbGRUcmlnZ2VyKG5hbWUsIGFzdCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJDYWNoZVtjYWNoZUtleV0gPSB0cmlnZ2VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLnJlZ2lzdGVyVHJpZ2dlcihuYW1lc3BhY2VJZCwgbmFtZSwgdHJpZ2dlcik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXHJcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnJlZ2lzdGVyID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXHJcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5yZWdpc3RlcihuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmRlc3Ryb3kgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5kZXN0cm95KG5hbWVzcGFjZUlkLCBjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcclxuICAgICAqIEBwYXJhbSB7P30gaW5zZXJ0QmVmb3JlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLm9uSW5zZXJ0ID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGluc2VydEJlZm9yZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBwYXJlbnQsIGluc2VydEJlZm9yZSkge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUuaW5zZXJ0Tm9kZShuYW1lc3BhY2VJZCwgZWxlbWVudCwgcGFyZW50LCBpbnNlcnRCZWZvcmUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUub25SZW1vdmUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLnJlbW92ZU5vZGUobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGRpc2FibGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuZGlzYWJsZUFuaW1hdGlvbnMgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBkaXNhYmxlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgZGlzYWJsZSkge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUubWFya0VsZW1lbnRBc0Rpc2FibGVkKGVsZW1lbnQsIGRpc2FibGUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5XHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnByb2Nlc3MgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eVxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAocHJvcGVydHkuY2hhckF0KDApID09ICdAJykge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBwYXJzZVRpbWVsaW5lQ29tbWFuZChwcm9wZXJ0eSksIGlkID0gX2FbMF0sIGFjdGlvbiA9IF9hWzFdO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lbGluZUVuZ2luZS5jb21tYW5kKGlkLCBlbGVtZW50LCBhY3Rpb24sIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS50cmlnZ2VyKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcclxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRQaGFzZVxyXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5saXN0ZW4gPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcclxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRQaGFzZVxyXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBldmVudE5hbWUsIGV2ZW50UGhhc2UsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLy8gQEBsaXN0ZW5cclxuICAgICAgICBpZiAoZXZlbnROYW1lLmNoYXJBdCgwKSA9PSAnQCcpIHtcclxuICAgICAgICAgICAgdmFyIF9hID0gcGFyc2VUaW1lbGluZUNvbW1hbmQoZXZlbnROYW1lKSwgaWQgPSBfYVswXSwgYWN0aW9uID0gX2FbMV07XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lbGluZUVuZ2luZS5saXN0ZW4oaWQsIGVsZW1lbnQsIGFjdGlvbiwgY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5saXN0ZW4obmFtZXNwYWNlSWQsIGVsZW1lbnQsIGV2ZW50TmFtZSwgZXZlbnRQaGFzZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/PX0gbWljcm90YXNrSWRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuZmx1c2ggPSAvKipcclxuICAgICAqIEBwYXJhbSB7Pz19IG1pY3JvdGFza0lkXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobWljcm90YXNrSWQpIHtcclxuICAgICAgICBpZiAobWljcm90YXNrSWQgPT09IHZvaWQgMCkgeyBtaWNyb3Rhc2tJZCA9IC0xOyB9XHJcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5mbHVzaChtaWNyb3Rhc2tJZCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUsIFwicGxheWVyc1wiLCB7XHJcbiAgICAgICAgZ2V0OiAvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICgvKiogQHR5cGUgez99ICovICh0aGlzLl90cmFuc2l0aW9uRW5naW5lLnBsYXllcnMpKVxyXG4gICAgICAgICAgICAgICAgLmNvbmNhdCgvKiogQHR5cGUgez99ICovICh0aGlzLl90aW1lbGluZUVuZ2luZS5wbGF5ZXJzKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUud2hlblJlbmRlcmluZ0RvbmUgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUud2hlblJlbmRlcmluZ0RvbmUoKTsgfTtcclxuICAgIHJldHVybiBBbmltYXRpb25FbmdpbmU7XHJcbn0oKSk7XHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbnZhciBXZWJBbmltYXRpb25zUGxheWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gV2ViQW5pbWF0aW9uc1BsYXllcihlbGVtZW50LCBrZXlmcmFtZXMsIG9wdGlvbnMsIHByZXZpb3VzUGxheWVycykge1xyXG4gICAgICAgIGlmIChwcmV2aW91c1BsYXllcnMgPT09IHZvaWQgMCkgeyBwcmV2aW91c1BsYXllcnMgPSBbXTsgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICB0aGlzLmtleWZyYW1lcyA9IGtleWZyYW1lcztcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNQbGF5ZXJzID0gcHJldmlvdXNQbGF5ZXJzO1xyXG4gICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX29uU3RhcnRGbnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9vbkRlc3Ryb3lGbnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRQbGF5ZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNTdHlsZXMgPSB7fTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTbmFwc2hvdCA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9uc1snZHVyYXRpb24nXSk7XHJcbiAgICAgICAgdGhpcy5fZGVsYXkgPSAvKiogQHR5cGUgez99ICovIChvcHRpb25zWydkZWxheSddKSB8fCAwO1xyXG4gICAgICAgIHRoaXMudGltZSA9IHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fZGVsYXk7XHJcbiAgICAgICAgaWYgKGFsbG93UHJldmlvdXNQbGF5ZXJTdHlsZXNNZXJnZSh0aGlzLl9kdXJhdGlvbiwgdGhpcy5fZGVsYXkpKSB7XHJcbiAgICAgICAgICAgIHByZXZpb3VzUGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcyA9IHBsYXllci5jdXJyZW50U25hcHNob3Q7XHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIF90aGlzLnByZXZpb3VzU3R5bGVzW3Byb3BdID0gc3R5bGVzW3Byb3BdOyB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5fb25GaW5pc2ggPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcclxuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuaW5pdCA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2J1aWxkUGxheWVyKCk7XHJcbiAgICAgICAgdGhpcy5fcHJlcGFyZVBsYXllckJlZm9yZVN0YXJ0KCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5fYnVpbGRQbGF5ZXIgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKHN0eWxlcykgeyByZXR1cm4gY29weVN0eWxlcyhzdHlsZXMsIGZhbHNlKTsgfSk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNTdHlsZVByb3BzID0gT2JqZWN0LmtleXModGhpcy5wcmV2aW91c1N0eWxlcyk7XHJcbiAgICAgICAgaWYgKHByZXZpb3VzU3R5bGVQcm9wcy5sZW5ndGggJiYga2V5ZnJhbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydGluZ0tleWZyYW1lXzEgPSBrZXlmcmFtZXNbMF07XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1pc3NpbmdTdHlsZVByb3BzXzEgPSBbXTtcclxuICAgICAgICAgICAgcHJldmlvdXNTdHlsZVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICAgICAgICAgIGlmICghc3RhcnRpbmdLZXlmcmFtZV8xLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZ1N0eWxlUHJvcHNfMS5wdXNoKHByb3ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3RhcnRpbmdLZXlmcmFtZV8xW3Byb3BdID0gX3RoaXMucHJldmlvdXNTdHlsZXNbcHJvcF07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAobWlzc2luZ1N0eWxlUHJvcHNfMS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGZfMSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZiA9IGtleWZyYW1lc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nU3R5bGVQcm9wc18xLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2ZbcHJvcF0gPSBfY29tcHV0ZVN0eWxlKHNlbGZfMS5lbGVtZW50LCBwcm9wKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDE7IGkgPCBrZXlmcmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBfbG9vcF8xKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKHRoaXMpKS5kb21QbGF5ZXIgPVxyXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyV2ViQW5pbWF0aW9uKHRoaXMuZWxlbWVudCwga2V5ZnJhbWVzLCB0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX2ZpbmFsS2V5ZnJhbWUgPSBrZXlmcmFtZXMubGVuZ3RoID8ga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxXSA6IHt9O1xyXG4gICAgICAgIHRoaXMuZG9tUGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9vbkZpbmlzaCgpOyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLl9wcmVwYXJlUGxheWVyQmVmb3JlU3RhcnQgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyB0aGlzIGlzIHJlcXVpcmVkIHNvIHRoYXQgdGhlIHBsYXllciBkb2Vzbid0IHN0YXJ0IHRvIGFuaW1hdGUgcmlnaHQgYXdheVxyXG4gICAgICAgIGlmICh0aGlzLl9kZWxheSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNldERvbVBsYXllclN0YXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRvbVBsYXllci5wYXVzZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICAvKipcclxuICAgICAqIFxcQGludGVybmFsXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30ga2V5ZnJhbWVzXHJcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLl90cmlnZ2VyV2ViQW5pbWF0aW9uID0gLyoqXHJcbiAgICAgKiBcXEBpbnRlcm5hbFxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGtleWZyYW1lc1xyXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWxlbWVudCwga2V5ZnJhbWVzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgLy8ganNjb21waWxlciBkb2Vzbid0IHNlZW0gdG8ga25vdyBhbmltYXRlIGlzIGEgbmF0aXZlIHByb3BlcnR5IGJlY2F1c2UgaXQncyBub3QgZnVsbHlcclxuICAgICAgICAvLyBzdXBwb3J0ZWQgeWV0IGFjcm9zcyBjb21tb24gYnJvd3NlcnMgKHdlIHBvbHlmaWxsIGl0IGZvciBFZGdlL1NhZmFyaSkgW0NMICMxNDM2MzA5MjldXHJcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7P30gKi8gKGVsZW1lbnRbJ2FuaW1hdGUnXShrZXlmcmFtZXMsIG9wdGlvbnMpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZm5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLm9uU3RhcnQgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZm5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vblN0YXJ0Rm5zLnB1c2goZm4pOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGZuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZm5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkRvbmVGbnMucHVzaChmbik7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZm5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLm9uRGVzdHJveSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBmblxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uRGVzdHJveUZucy5wdXNoKGZuKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUucGxheSA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2J1aWxkUGxheWVyKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmhhc1N0YXJ0ZWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcclxuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kb21QbGF5ZXIucGxheSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUucGF1c2UgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgICAgICB0aGlzLmRvbVBsYXllci5wYXVzZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuZmluaXNoID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pbml0KCk7XHJcbiAgICAgICAgdGhpcy5fb25GaW5pc2goKTtcclxuICAgICAgICB0aGlzLmRvbVBsYXllci5maW5pc2goKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVzZXREb21QbGF5ZXJTdGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuX3Jlc2V0RG9tUGxheWVyU3RhdGUgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kb21QbGF5ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5kb21QbGF5ZXIuY2FuY2VsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUucmVzdGFydCA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB0aGlzLnBsYXkoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLmhhc1N0YXJ0ZWQgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7IH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNldERvbVBsYXllclN0YXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX29uRGVzdHJveUZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX29uRGVzdHJveUZucyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHApIHsgdGhpcy5kb21QbGF5ZXIuY3VycmVudFRpbWUgPSBwICogdGhpcy50aW1lOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kb21QbGF5ZXIuY3VycmVudFRpbWUgLyB0aGlzLnRpbWU7IH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUsIFwidG90YWxUaW1lXCIsIHtcclxuICAgICAgICBnZXQ6IC8qKlxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVsYXkgKyB0aGlzLl9kdXJhdGlvbjsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLmJlZm9yZURlc3Ryb3kgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcyA9IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1N0YXJ0ZWQoKSkge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9maW5hbEtleWZyYW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAhPSAnb2Zmc2V0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc1twcm9wXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9maW5pc2hlZCA/IF90aGlzLl9maW5hbEtleWZyYW1lW3Byb3BdIDogX2NvbXB1dGVTdHlsZShfdGhpcy5lbGVtZW50LCBwcm9wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3VycmVudFNuYXBzaG90ID0gc3R5bGVzO1xyXG4gICAgfTtcclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHBoYXNlTmFtZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUudHJpZ2dlckNhbGxiYWNrID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHBoYXNlTmFtZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHBoYXNlTmFtZSkge1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1ldGhvZHMgPSBwaGFzZU5hbWUgPT0gJ3N0YXJ0JyA/IHRoaXMuX29uU3RhcnRGbnMgOiB0aGlzLl9vbkRvbmVGbnM7XHJcbiAgICAgICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XHJcbiAgICAgICAgbWV0aG9kcy5sZW5ndGggPSAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBXZWJBbmltYXRpb25zUGxheWVyO1xyXG59KCkpO1xyXG4vKipcclxuICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7P30gcHJvcFxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gX2NvbXB1dGVTdHlsZShlbGVtZW50LCBwcm9wKSB7XHJcbiAgICByZXR1cm4gKC8qKiBAdHlwZSB7P30gKi8gKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpKSlbcHJvcF07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxudmFyIFdlYkFuaW1hdGlvbnNEcml2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBXZWJBbmltYXRpb25zRHJpdmVyKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHByb3BcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFdlYkFuaW1hdGlvbnNEcml2ZXIucHJvdG90eXBlLnZhbGlkYXRlU3R5bGVQcm9wZXJ0eSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBwcm9wXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gdmFsaWRhdGVTdHlsZVByb3BlcnR5KHByb3ApOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFdlYkFuaW1hdGlvbnNEcml2ZXIucHJvdG90eXBlLm1hdGNoZXNFbGVtZW50ID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiBtYXRjaGVzRWxlbWVudChlbGVtZW50LCBzZWxlY3Rvcik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsbTFcclxuICAgICAqIEBwYXJhbSB7P30gZWxtMlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgV2ViQW5pbWF0aW9uc0RyaXZlci5wcm90b3R5cGUuY29udGFpbnNFbGVtZW50ID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsbTFcclxuICAgICAqIEBwYXJhbSB7P30gZWxtMlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsbTEsIGVsbTIpIHsgcmV0dXJuIGNvbnRhaW5zRWxlbWVudChlbG0xLCBlbG0yKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXHJcbiAgICAgKiBAcGFyYW0gez99IG11bHRpXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBXZWJBbmltYXRpb25zRHJpdmVyLnByb3RvdHlwZS5xdWVyeSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXHJcbiAgICAgKiBAcGFyYW0gez99IG11bHRpXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IsIG11bHRpKSB7XHJcbiAgICAgICAgcmV0dXJuIGludm9rZVF1ZXJ5KGVsZW1lbnQsIHNlbGVjdG9yLCBtdWx0aSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gcHJvcFxyXG4gICAgICogQHBhcmFtIHs/PX0gZGVmYXVsdFZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBXZWJBbmltYXRpb25zRHJpdmVyLnByb3RvdHlwZS5jb21wdXRlU3R5bGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHs/fSBwcm9wXHJcbiAgICAgKiBAcGFyYW0gez89fSBkZWZhdWx0VmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHs/fSAqLyAoKC8qKiBAdHlwZSB7P30gKi8gKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpKSlbcHJvcF0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGtleWZyYW1lc1xyXG4gICAgICogQHBhcmFtIHs/fSBkdXJhdGlvblxyXG4gICAgICogQHBhcmFtIHs/fSBkZWxheVxyXG4gICAgICogQHBhcmFtIHs/fSBlYXNpbmdcclxuICAgICAqIEBwYXJhbSB7Pz19IHByZXZpb3VzUGxheWVyc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgV2ViQW5pbWF0aW9uc0RyaXZlci5wcm90b3R5cGUuYW5pbWF0ZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IGtleWZyYW1lc1xyXG4gICAgICogQHBhcmFtIHs/fSBkdXJhdGlvblxyXG4gICAgICogQHBhcmFtIHs/fSBkZWxheVxyXG4gICAgICogQHBhcmFtIHs/fSBlYXNpbmdcclxuICAgICAqIEBwYXJhbSB7Pz19IHByZXZpb3VzUGxheWVyc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIHByZXZpb3VzUGxheWVycykge1xyXG4gICAgICAgIGlmIChwcmV2aW91c1BsYXllcnMgPT09IHZvaWQgMCkgeyBwcmV2aW91c1BsYXllcnMgPSBbXTsgfVxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbGwgPSBkZWxheSA9PSAwID8gJ2JvdGgnIDogJ2ZvcndhcmRzJztcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJPcHRpb25zID0geyBkdXJhdGlvbjogZHVyYXRpb24sIGRlbGF5OiBkZWxheSwgZmlsbDogZmlsbCB9O1xyXG4gICAgICAgIC8vIHdlIGNoZWNrIGZvciB0aGlzIHRvIGF2b2lkIGhhdmluZyBhIG51bGx8dW5kZWZpbmVkIHZhbHVlIGJlIHByZXNlbnRcclxuICAgICAgICAvLyBmb3IgdGhlIGVhc2luZyAod2hpY2ggcmVzdWx0cyBpbiBhbiBlcnJvciBmb3IgY2VydGFpbiBicm93c2VycyAjOTc1MilcclxuICAgICAgICBpZiAoZWFzaW5nKSB7XHJcbiAgICAgICAgICAgIHBsYXllck9wdGlvbnNbJ2Vhc2luZyddID0gZWFzaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2aW91c1dlYkFuaW1hdGlvblBsYXllcnMgPSAvKiogQHR5cGUgez99ICovIChwcmV2aW91c1BsYXllcnMuZmlsdGVyKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllciBpbnN0YW5jZW9mIFdlYkFuaW1hdGlvbnNQbGF5ZXI7IH0pKTtcclxuICAgICAgICByZXR1cm4gbmV3IFdlYkFuaW1hdGlvbnNQbGF5ZXIoZWxlbWVudCwga2V5ZnJhbWVzLCBwbGF5ZXJPcHRpb25zLCBwcmV2aW91c1dlYkFuaW1hdGlvblBsYXllcnMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBXZWJBbmltYXRpb25zRHJpdmVyO1xyXG59KCkpO1xyXG4vKipcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIHN1cHBvcnRzV2ViQW5pbWF0aW9ucygpIHtcclxuICAgIHJldHVybiB0eXBlb2YgRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mICgvKiogQHR5cGUgez99ICovIChFbGVtZW50KSkucHJvdG90eXBlWydhbmltYXRlJ10gPT09ICdmdW5jdGlvbic7XHJcbn1cclxuXHJcbmV4cG9ydHMuQW5pbWF0aW9uRHJpdmVyID0gQW5pbWF0aW9uRHJpdmVyO1xyXG5leHBvcnRzLsm1QW5pbWF0aW9uID0gQW5pbWF0aW9uO1xyXG5leHBvcnRzLsm1QW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyID0gQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyO1xyXG5leHBvcnRzLsm1Tm9vcEFuaW1hdGlvblN0eWxlTm9ybWFsaXplciA9IE5vb3BBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXI7XHJcbmV4cG9ydHMuybVXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyID0gV2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplcjtcclxuZXhwb3J0cy7JtU5vb3BBbmltYXRpb25Ecml2ZXIgPSBOb29wQW5pbWF0aW9uRHJpdmVyO1xyXG5leHBvcnRzLsm1QW5pbWF0aW9uRW5naW5lID0gQW5pbWF0aW9uRW5naW5lO1xyXG5leHBvcnRzLsm1V2ViQW5pbWF0aW9uc0RyaXZlciA9IFdlYkFuaW1hdGlvbnNEcml2ZXI7XHJcbmV4cG9ydHMuybVzdXBwb3J0c1dlYkFuaW1hdGlvbnMgPSBzdXBwb3J0c1dlYkFuaW1hdGlvbnM7XHJcbmV4cG9ydHMuybVXZWJBbmltYXRpb25zUGxheWVyID0gV2ViQW5pbWF0aW9uc1BsYXllcjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XHJcblxyXG59KSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbmltYXRpb25zLWJyb3dzZXIudW1kLmpzLm1hcFxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGFuZ3VsYXIvYW5pbWF0aW9ucy9idW5kbGVzL2FuaW1hdGlvbnMtYnJvd3Nlci51bWQuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ2FwcCcsXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9hcHAuY29tcG9uZW50Lmh0bWwnKSxcclxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vYXBwLmNvbXBvbmVudC5jc3MnKV1cclxufSlcclxuZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2FwcC9hcHAuY29tcG9uZW50LnRzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gQ29tbWVudDtcclxuXHJcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XHJcbnZhciBDaGFyYWN0ZXJEYXRhID0gcmVxdWlyZSgnLi9DaGFyYWN0ZXJEYXRhJyk7XHJcblxyXG5mdW5jdGlvbiBDb21tZW50KGRvYywgZGF0YSkge1xyXG4gIHRoaXMubm9kZVR5cGUgPSBOb2RlLkNPTU1FTlRfTk9ERTtcclxuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBkb2M7XHJcbiAgdGhpcy5fZGF0YSA9IGRhdGE7XHJcbiAgdGhpcy5faW5kZXggPSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbnZhciBub2RlVmFsdWUgPSB7XHJcbiAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2RhdGE7IH0sXHJcbiAgc2V0OiBmdW5jdGlvbih2KSB7XHJcbiAgICB0aGlzLl9kYXRhID0gdjtcclxuICAgIGlmICh0aGlzLnJvb3RlZClcclxuICAgICAgdGhpcy5vd25lckRvY3VtZW50Lm11dGF0ZVZhbHVlKHRoaXMpO1xyXG4gIH1cclxufTtcclxuXHJcbkNvbW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDaGFyYWN0ZXJEYXRhLnByb3RvdHlwZSwge1xyXG4gIG5vZGVOYW1lOiB7IHZhbHVlOiAnI2NvbW1lbnQnIH0sXHJcbiAgbm9kZVZhbHVlOiBub2RlVmFsdWUsXHJcbiAgdGV4dENvbnRlbnQ6IG5vZGVWYWx1ZSxcclxuICBkYXRhOiBub2RlVmFsdWUsXHJcblxyXG4gIC8vIFV0aWxpdHkgbWV0aG9kc1xyXG4gIGNsb25lOiB7IHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcclxuICAgIHJldHVybiBuZXcgQ29tbWVudCh0aGlzLm93bmVyRG9jdW1lbnQsIHRoaXMuX2RhdGEpO1xyXG4gIH19LFxyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvQ29tbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gRE9NRXhjZXB0aW9uO1xyXG5cclxudmFyIElOREVYX1NJWkVfRVJSID0gMTtcclxudmFyIEhJRVJBUkNIWV9SRVFVRVNUX0VSUiA9IDM7XHJcbnZhciBXUk9OR19ET0NVTUVOVF9FUlIgPSA0O1xyXG52YXIgSU5WQUxJRF9DSEFSQUNURVJfRVJSID0gNTtcclxudmFyIE5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUiA9IDc7XHJcbnZhciBOT1RfRk9VTkRfRVJSID0gODtcclxudmFyIE5PVF9TVVBQT1JURURfRVJSID0gOTtcclxudmFyIElOVkFMSURfU1RBVEVfRVJSID0gMTE7XHJcbnZhciBTWU5UQVhfRVJSID0gMTI7XHJcbnZhciBJTlZBTElEX01PRElGSUNBVElPTl9FUlIgPSAxMztcclxudmFyIE5BTUVTUEFDRV9FUlIgPSAxNDtcclxudmFyIElOVkFMSURfQUNDRVNTX0VSUiA9IDE1O1xyXG52YXIgVFlQRV9NSVNNQVRDSF9FUlIgPSAxNztcclxudmFyIFNFQ1VSSVRZX0VSUiA9IDE4O1xyXG52YXIgTkVUV09SS19FUlIgPSAxOTtcclxudmFyIEFCT1JUX0VSUiA9IDIwO1xyXG52YXIgVVJMX01JU01BVENIX0VSUiA9IDIxO1xyXG52YXIgUVVPVEFfRVhDRUVERURfRVJSID0gMjI7XHJcbnZhciBUSU1FT1VUX0VSUiA9IDIzO1xyXG52YXIgSU5WQUxJRF9OT0RFX1RZUEVfRVJSID0gMjQ7XHJcbnZhciBEQVRBX0NMT05FX0VSUiA9IDI1O1xyXG5cclxuLy8gQ29kZSB0byBuYW1lXHJcbnZhciBuYW1lcyA9IFtcclxuICBudWxsLCAgLy8gTm8gZXJyb3Igd2l0aCBjb2RlIDBcclxuICAnSU5ERVhfU0laRV9FUlInLFxyXG4gIG51bGwsIC8vIGhpc3RvcmljYWxcclxuICAnSElFUkFSQ0hZX1JFUVVFU1RfRVJSJyxcclxuICAnV1JPTkdfRE9DVU1FTlRfRVJSJyxcclxuICAnSU5WQUxJRF9DSEFSQUNURVJfRVJSJyxcclxuICBudWxsLCAvLyBoaXN0b3JpY2FsXHJcbiAgJ05PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUicsXHJcbiAgJ05PVF9GT1VORF9FUlInLFxyXG4gICdOT1RfU1VQUE9SVEVEX0VSUicsXHJcbiAgbnVsbCwgLy8gaGlzdG9yaWNhbFxyXG4gICdJTlZBTElEX1NUQVRFX0VSUicsXHJcbiAgJ1NZTlRBWF9FUlInLFxyXG4gICdJTlZBTElEX01PRElGSUNBVElPTl9FUlInLFxyXG4gICdOQU1FU1BBQ0VfRVJSJyxcclxuICAnSU5WQUxJRF9BQ0NFU1NfRVJSJyxcclxuICBudWxsLCAvLyBoaXN0b3JpY2FsXHJcbiAgJ1RZUEVfTUlTTUFUQ0hfRVJSJyxcclxuICAnU0VDVVJJVFlfRVJSJyxcclxuICAnTkVUV09SS19FUlInLFxyXG4gICdBQk9SVF9FUlInLFxyXG4gICdVUkxfTUlTTUFUQ0hfRVJSJyxcclxuICAnUVVPVEFfRVhDRUVERURfRVJSJyxcclxuICAnVElNRU9VVF9FUlInLFxyXG4gICdJTlZBTElEX05PREVfVFlQRV9FUlInLFxyXG4gICdEQVRBX0NMT05FX0VSUicsXHJcbl07XHJcblxyXG4vLyBDb2RlIHRvIG1lc3NhZ2VcclxuLy8gVGhlc2Ugc3RyaW5ncyBhcmUgZnJvbSB0aGUgMTMgTWF5IDIwMTEgRWRpdG9yJ3MgRHJhZnQgb2YgRE9NIENvcmUuXHJcbi8vIGh0dHA6Ly9kdmNzLnczLm9yZy9oZy9kb21jb3JlL3Jhdy1maWxlL3RpcC9PdmVydmlldy5odG1sXHJcbi8vIENvcHlyaWdodCDCqSAyMDExIFczQ8KuIChNSVQsIEVSQ0lNLCBLZWlvKSwgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gVXNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIFczQyBEb2N1bWVudCBMaWNlbnNlOlxyXG4vLyBodHRwOi8vd3d3LnczLm9yZy9Db25zb3J0aXVtL0xlZ2FsLzIwMDIvY29weXJpZ2h0LWRvY3VtZW50cy0yMDAyMTIzMVxyXG52YXIgbWVzc2FnZXMgPSBbXHJcbiAgbnVsbCwgIC8vIE5vIGVycm9yIHdpdGggY29kZSAwXHJcbiAgJ0lOREVYX1NJWkVfRVJSICgxKTogdGhlIGluZGV4IGlzIG5vdCBpbiB0aGUgYWxsb3dlZCByYW5nZScsXHJcbiAgbnVsbCxcclxuICAnSElFUkFSQ0hZX1JFUVVFU1RfRVJSICgzKTogdGhlIG9wZXJhdGlvbiB3b3VsZCB5aWVsZCBhbiBpbmNvcnJlY3Qgbm9kZXMgbW9kZWwnLFxyXG4gICdXUk9OR19ET0NVTUVOVF9FUlIgKDQpOiB0aGUgb2JqZWN0IGlzIGluIHRoZSB3cm9uZyBEb2N1bWVudCwgYSBjYWxsIHRvIGltcG9ydE5vZGUgaXMgcmVxdWlyZWQnLFxyXG4gICdJTlZBTElEX0NIQVJBQ1RFUl9FUlIgKDUpOiB0aGUgc3RyaW5nIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycycsXHJcbiAgbnVsbCxcclxuICAnTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSICg3KTogdGhlIG9iamVjdCBjYW4gbm90IGJlIG1vZGlmaWVkJyxcclxuICAnTk9UX0ZPVU5EX0VSUiAoOCk6IHRoZSBvYmplY3QgY2FuIG5vdCBiZSBmb3VuZCBoZXJlJyxcclxuICAnTk9UX1NVUFBPUlRFRF9FUlIgKDkpOiB0aGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkJyxcclxuICBudWxsLFxyXG4gICdJTlZBTElEX1NUQVRFX0VSUiAoMTEpOiB0aGUgb2JqZWN0IGlzIGluIGFuIGludmFsaWQgc3RhdGUnLFxyXG4gICdTWU5UQVhfRVJSICgxMik6IHRoZSBzdHJpbmcgZGlkIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgcGF0dGVybicsXHJcbiAgJ0lOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUiAoMTMpOiB0aGUgb2JqZWN0IGNhbiBub3QgYmUgbW9kaWZpZWQgaW4gdGhpcyB3YXknLFxyXG4gICdOQU1FU1BBQ0VfRVJSICgxNCk6IHRoZSBvcGVyYXRpb24gaXMgbm90IGFsbG93ZWQgYnkgTmFtZXNwYWNlcyBpbiBYTUwnLFxyXG4gICdJTlZBTElEX0FDQ0VTU19FUlIgKDE1KTogdGhlIG9iamVjdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBvcGVyYXRpb24gb3IgYXJndW1lbnQnLFxyXG4gIG51bGwsXHJcbiAgJ1RZUEVfTUlTTUFUQ0hfRVJSICgxNyk6IHRoZSB0eXBlIG9mIHRoZSBvYmplY3QgZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIHR5cGUnLFxyXG4gICdTRUNVUklUWV9FUlIgKDE4KTogdGhlIG9wZXJhdGlvbiBpcyBpbnNlY3VyZScsXHJcbiAgJ05FVFdPUktfRVJSICgxOSk6IGEgbmV0d29yayBlcnJvciBvY2N1cnJlZCcsXHJcbiAgJ0FCT1JUX0VSUiAoMjApOiB0aGUgdXNlciBhYm9ydGVkIGFuIG9wZXJhdGlvbicsXHJcbiAgJ1VSTF9NSVNNQVRDSF9FUlIgKDIxKTogdGhlIGdpdmVuIFVSTCBkb2VzIG5vdCBtYXRjaCBhbm90aGVyIFVSTCcsXHJcbiAgJ1FVT1RBX0VYQ0VFREVEX0VSUiAoMjIpOiB0aGUgcXVvdGEgaGFzIGJlZW4gZXhjZWVkZWQnLFxyXG4gICdUSU1FT1VUX0VSUiAoMjMpOiBhIHRpbWVvdXQgb2NjdXJyZWQnLFxyXG4gICdJTlZBTElEX05PREVfVFlQRV9FUlIgKDI0KTogdGhlIHN1cHBsaWVkIG5vZGUgaXMgaW52YWxpZCBvciBoYXMgYW4gaW52YWxpZCBhbmNlc3RvciBmb3IgdGhpcyBvcGVyYXRpb24nLFxyXG4gICdEQVRBX0NMT05FX0VSUiAoMjUpOiB0aGUgb2JqZWN0IGNhbiBub3QgYmUgY2xvbmVkLidcclxuXTtcclxuXHJcbi8vIE5hbWUgdG8gY29kZVxyXG52YXIgY29uc3RhbnRzID0ge1xyXG4gIElOREVYX1NJWkVfRVJSOiBJTkRFWF9TSVpFX0VSUixcclxuICBET01TVFJJTkdfU0laRV9FUlI6IDIsIC8vIGhpc3RvcmljYWxcclxuICBISUVSQVJDSFlfUkVRVUVTVF9FUlI6IEhJRVJBUkNIWV9SRVFVRVNUX0VSUixcclxuICBXUk9OR19ET0NVTUVOVF9FUlI6IFdST05HX0RPQ1VNRU5UX0VSUixcclxuICBJTlZBTElEX0NIQVJBQ1RFUl9FUlI6IElOVkFMSURfQ0hBUkFDVEVSX0VSUixcclxuICBOT19EQVRBX0FMTE9XRURfRVJSOiA2LCAvLyBoaXN0b3JpY2FsXHJcbiAgTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSOiBOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlIsXHJcbiAgTk9UX0ZPVU5EX0VSUjogTk9UX0ZPVU5EX0VSUixcclxuICBOT1RfU1VQUE9SVEVEX0VSUjogTk9UX1NVUFBPUlRFRF9FUlIsXHJcbiAgSU5VU0VfQVRUUklCVVRFX0VSUjogMTAsIC8vIGhpc3RvcmljYWxcclxuICBJTlZBTElEX1NUQVRFX0VSUjogSU5WQUxJRF9TVEFURV9FUlIsXHJcbiAgU1lOVEFYX0VSUjogU1lOVEFYX0VSUixcclxuICBJTlZBTElEX01PRElGSUNBVElPTl9FUlI6IElOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUixcclxuICBOQU1FU1BBQ0VfRVJSOiBOQU1FU1BBQ0VfRVJSLFxyXG4gIElOVkFMSURfQUNDRVNTX0VSUjogSU5WQUxJRF9BQ0NFU1NfRVJSLFxyXG4gIFZBTElEQVRJT05fRVJSOiAxNiwgLy8gaGlzdG9yaWNhbFxyXG4gIFRZUEVfTUlTTUFUQ0hfRVJSOiBUWVBFX01JU01BVENIX0VSUixcclxuICBTRUNVUklUWV9FUlI6IFNFQ1VSSVRZX0VSUixcclxuICBORVRXT1JLX0VSUjogTkVUV09SS19FUlIsXHJcbiAgQUJPUlRfRVJSOiBBQk9SVF9FUlIsXHJcbiAgVVJMX01JU01BVENIX0VSUjogVVJMX01JU01BVENIX0VSUixcclxuICBRVU9UQV9FWENFRURFRF9FUlI6IFFVT1RBX0VYQ0VFREVEX0VSUixcclxuICBUSU1FT1VUX0VSUjogVElNRU9VVF9FUlIsXHJcbiAgSU5WQUxJRF9OT0RFX1RZUEVfRVJSOiBJTlZBTElEX05PREVfVFlQRV9FUlIsXHJcbiAgREFUQV9DTE9ORV9FUlI6IERBVEFfQ0xPTkVfRVJSXHJcbn07XHJcblxyXG5mdW5jdGlvbiBET01FeGNlcHRpb24oY29kZSkge1xyXG4gIEVycm9yLmNhbGwodGhpcyk7XHJcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XHJcbiAgdGhpcy5jb2RlID0gY29kZTtcclxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcclxuICB0aGlzLm5hbWUgPSBuYW1lc1tjb2RlXTtcclxufVxyXG5ET01FeGNlcHRpb24ucHJvdG90eXBlLl9fcHJvdG9fXyA9IEVycm9yLnByb3RvdHlwZTtcclxuXHJcbi8vIEluaXRpYWxpemUgdGhlIGNvbnN0YW50cyBvbiBET01FeGNlcHRpb24gYW5kIERPTUV4Y2VwdGlvbi5wcm90b3R5cGVcclxuZm9yKHZhciBjIGluIGNvbnN0YW50cykge1xyXG4gIHZhciB2ID0geyB2YWx1ZTogY29uc3RhbnRzW2NdIH07XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERPTUV4Y2VwdGlvbiwgYywgdik7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERPTUV4Y2VwdGlvbi5wcm90b3R5cGUsIGMsIHYpO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kb21pbm8vbGliL0RPTUV4Y2VwdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vIERPTVRva2VuTGlzdCBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vUmF5bm9zL0RPTS1zaGltXHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRE9NVG9rZW5MaXN0O1xyXG5cclxuZnVuY3Rpb24gRE9NVG9rZW5MaXN0KGdldHRlciwgc2V0dGVyKSB7XHJcbiAgdGhpcy5fZ2V0U3RyaW5nID0gZ2V0dGVyO1xyXG4gIHRoaXMuX3NldFN0cmluZyA9IHNldHRlcjtcclxuICBmaXhJbmRleCh0aGlzLCBnZXRMaXN0KHRoaXMpKTtcclxufVxyXG5cclxuRE9NVG9rZW5MaXN0LnByb3RvdHlwZSA9IHtcclxuICBpdGVtOiBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgaWYgKGluZGV4ID49IHRoaXMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2dldFN0cmluZygpLnNwbGl0KFwiIFwiKVtpbmRleF07XHJcbiAgfSxcclxuXHJcbiAgY29udGFpbnM6IGZ1bmN0aW9uKHRva2VuKSB7XHJcbiAgICB0b2tlbiA9IFN0cmluZyh0b2tlbik7XHJcbiAgICBoYW5kbGVFcnJvcnModG9rZW4pO1xyXG4gICAgdmFyIGxpc3QgPSBnZXRMaXN0KHRoaXMpO1xyXG4gICAgcmV0dXJuIGxpc3QuaW5kZXhPZih0b2tlbikgPiAtMTtcclxuICB9LFxyXG5cclxuICBhZGQ6IGZ1bmN0aW9uKHRva2VuKSB7XHJcbiAgICBoYW5kbGVFcnJvcnModG9rZW4pO1xyXG4gICAgdmFyIGxpc3QgPSBnZXRMaXN0KHRoaXMpO1xyXG4gICAgaWYgKGxpc3QuaW5kZXhPZih0b2tlbikgPiAtMSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsaXN0LnB1c2godG9rZW4pO1xyXG4gICAgdGhpcy5fc2V0U3RyaW5nKGxpc3Quam9pbihcIiBcIikudHJpbSgpKTtcclxuICAgIGZpeEluZGV4KHRoaXMsIGxpc3QpO1xyXG4gIH0sXHJcblxyXG4gIHJlbW92ZTogZnVuY3Rpb24odG9rZW4pIHtcclxuICAgIGhhbmRsZUVycm9ycyh0b2tlbik7XHJcbiAgICB2YXIgbGlzdCA9IGdldExpc3QodGhpcyk7XHJcbiAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YodG9rZW4pO1xyXG4gICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICB0aGlzLl9zZXRTdHJpbmcobGlzdC5qb2luKFwiIFwiKS50cmltKCkpO1xyXG4gICAgfVxyXG4gICAgZml4SW5kZXgodGhpcywgbGlzdCk7XHJcbiAgfSxcclxuXHJcbiAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUodG9rZW4pIHtcclxuICAgIGlmICh0aGlzLmNvbnRhaW5zKHRva2VuKSkge1xyXG4gICAgICB0aGlzLnJlbW92ZSh0b2tlbik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICB0aGlzLmFkZCh0b2tlbik7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9nZXRTdHJpbmcoKTtcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmaXhJbmRleChjbGlzdCwgbGlzdCkge1xyXG4gIGNsaXN0Lmxlbmd0aCA9IGxpc3QubGVuZ3RoO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgY2xpc3RbaV0gPSBsaXN0W2ldO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlRXJyb3JzKHRva2VuKSB7XHJcbiAgaWYgKHRva2VuID09PSBcIlwiIHx8IHRva2VuID09PSB1bmRlZmluZWQpIHtcclxuICAgIHV0aWxzLlN5bnRheEVycm9yKCk7XHJcbiAgfVxyXG4gIGlmICh0b2tlbi5pbmRleE9mKFwiIFwiKSA+IC0xKSB7XHJcbiAgICB1dGlscy5JbnZhbGlkQ2hhcmFjdGVyRXJyb3IoKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldExpc3QoY2xpc3QpIHtcclxuICB2YXIgc3RyID0gY2xpc3QuX2dldFN0cmluZygpO1xyXG4gIGlmIChzdHIgPT09IFwiXCIpIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICByZXR1cm4gc3RyLnNwbGl0KFwiIFwiKTtcclxuICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvRE9NVG9rZW5MaXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSAgRG9jdW1lbnRGcmFnbWVudDtcclxuXHJcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XHJcbnZhciBOb2RlTGlzdCA9IHJlcXVpcmUoJy4vTm9kZUxpc3QnKTtcclxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuL0VsZW1lbnQnKTtcclxudmFyIHNlbGVjdCA9IHJlcXVpcmUoJy4vc2VsZWN0Jyk7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxuXHJcbmZ1bmN0aW9uIERvY3VtZW50RnJhZ21lbnQoZG9jKSB7XHJcbiAgdGhpcy5ub2RlVHlwZSA9IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERTtcclxuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBkb2M7XHJcbiAgdGhpcy5jaGlsZE5vZGVzID0gW107XHJcbn1cclxuXHJcbkRvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlLnByb3RvdHlwZSwge1xyXG4gIG5vZGVOYW1lOiB7IHZhbHVlOiAnI2RvY3VtZW50LWZyYWdtZW50JyB9LFxyXG4gIG5vZGVWYWx1ZTogeyBcclxuICAgIGdldDogZnVuY3Rpb24oKSB7IFxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKCkge31cclxuICB9LFxyXG4gIC8vIENvcHkgdGhlIHRleHQgY29udGVudCBnZXR0ZXIvc2V0dGVyIGZyb20gRWxlbWVudFxyXG4gIHRleHRDb250ZW50OiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEVsZW1lbnQucHJvdG90eXBlLCAndGV4dENvbnRlbnQnKSxcclxuXHJcbiAgcXVlcnlTZWxlY3RvcjogeyB2YWx1ZTogZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICAgIC8vIGltcGxlbWVudCBpbiB0ZXJtcyBvZiBxdWVyeVNlbGVjdG9yQWxsXHJcbiAgICB2YXIgbm9kZXMgPSB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xyXG4gICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA/IG5vZGVzWzBdIDogbnVsbDtcclxuICB9fSxcclxuICBxdWVyeVNlbGVjdG9yQWxsOiB7IHZhbHVlOiBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgLy8gY3JlYXRlIGEgY29udGV4dFxyXG4gICAgdmFyIGNvbnRleHQgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xyXG4gICAgLy8gYWRkIHNvbWUgbWV0aG9kcyB0byB0aGUgY29udGV4dCBmb3IgemVzdCBpbXBsZW1lbnRhdGlvbiwgd2l0aG91dFxyXG4gICAgLy8gYWRkaW5nIHRoZW0gdG8gdGhlIHB1YmxpYyBEb2N1bWVudEZyYWdtZW50IEFQSVxyXG4gICAgY29udGV4dC5pc0hUTUwgPSB0cnVlOyAvLyBpbiBIVE1MIG5hbWVzcGFjZSAoY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaClcclxuICAgIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZTtcclxuICAgIGNvbnRleHQubmV4dEVsZW1lbnQgPVxyXG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEVsZW1lbnQucHJvdG90eXBlLCAnZmlyc3RFbGVtZW50Q2hpbGQnKS5cclxuICAgICAgZ2V0O1xyXG4gICAgLy8gaW52b2tlIHplc3RcclxuICAgIHZhciBub2RlcyA9IHNlbGVjdChzZWxlY3RvciwgY29udGV4dCk7XHJcbiAgICByZXR1cm4gbm9kZXMuaXRlbSA/IG5vZGVzIDogbmV3IE5vZGVMaXN0KG5vZGVzKTtcclxuICB9fSxcclxuXHJcbiAgLy8gVXRpbGl0eSBtZXRob2RzXHJcbiAgY2xvbmU6IHsgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xyXG4gICAgICByZXR1cm4gbmV3IERvY3VtZW50RnJhZ21lbnQodGhpcy5vd25lckRvY3VtZW50KTtcclxuICB9fSxcclxuICBpc0VxdWFsOiB7IHZhbHVlOiBmdW5jdGlvbiBpc0VxdWFsKG4pIHtcclxuICAgICAgLy8gQW55IHR3byBkb2N1bWVudCBmcmFnbWVudHMgYXJlIHNoYWxsb3dseSBlcXVhbC5cclxuICAgICAgLy8gTm9kZS5pc0VxdWFsTm9kZSgpIHdpbGwgdGVzdCB0aGVpciBjaGlsZHJlbiBmb3IgZXF1YWxpdHlcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgfX0sXHJcblxyXG4gIC8vIE5vbi1zdGFuZGFyZCwgYnV0IHVzZWZ1bCAoZ2l0aHViIGlzc3VlICM3MylcclxuICBpbm5lckhUTUw6IHtcclxuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpOyB9LFxyXG4gICAgc2V0OiB1dGlscy5ueWlcclxuICB9LFxyXG4gIG91dGVySFRNTDoge1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7IH0sXHJcbiAgICBzZXQ6IHV0aWxzLm55aVxyXG4gIH0sXHJcblxyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvRG9jdW1lbnRGcmFnbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4vRXZlbnQnKTtcclxudmFyIE1vdXNlRXZlbnQgPSByZXF1aXJlKCcuL01vdXNlRXZlbnQnKTtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcclxuXHJcbmZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge31cclxuXHJcbkV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IHtcclxuICAvLyBYWFhcclxuICAvLyBTZWUgV2ViSURMIMKnNC44IGZvciBkZXRhaWxzIG9uIG9iamVjdCBldmVudCBoYW5kbGVyc1xyXG4gIC8vIGFuZCBob3cgdGhleSBzaG91bGQgYmVoYXZlLiAgV2UgYWN0dWFsbHkgaGF2ZSB0byBhY2NlcHRcclxuICAvLyBhbnkgb2JqZWN0IHRvIGFkZEV2ZW50TGlzdGVuZXIuLi4gQ2FuJ3QgdHlwZSBjaGVjayBpdC5cclxuICAvLyBvbiByZWdpc3RyYXRpb24uXHJcblxyXG4gIC8vIFhYWDpcclxuICAvLyBDYXB0dXJpbmcgZXZlbnQgbGlzdGVuZXJzIGFyZSBzb3J0IG9mIHJhcmUuICBJIHRoaW5rIEkgY2FuIG9wdGltaXplXHJcbiAgLy8gdGhlbSBzbyB0aGF0IGRpc3BhdGNoRXZlbnQgY2FuIHNraXAgdGhlIGNhcHR1cmluZyBwaGFzZSAob3IgbXVjaCBvZlxyXG4gIC8vIGl0KS4gIEVhY2ggdGltZSBhIGNhcHR1cmluZyBsaXN0ZW5lciBpcyBhZGRlZCwgaW5jcmVtZW50IGEgZmxhZyBvblxyXG4gIC8vIHRoZSB0YXJnZXQgbm9kZSBhbmQgZWFjaCBvZiBpdHMgYW5jZXN0b3JzLiAgRGVjcmVtZW50IHdoZW4gcmVtb3ZlZC5cclxuICAvLyBBbmQgdXBkYXRlIHRoZSBjb3VudGVyIHdoZW4gbm9kZXMgYXJlIGFkZGVkIGFuZCByZW1vdmVkIGZyb20gdGhlXHJcbiAgLy8gdHJlZSBhcyB3ZWxsLiAgVGhlbiwgaW4gZGlzcGF0Y2ggZXZlbnQsIHRoZSBjYXB0dXJpbmcgcGhhc2UgY2FuXHJcbiAgLy8gYWJvcnQgaWYgaXQgc2VlcyBhbnkgbm9kZSB3aXRoIGEgemVybyBjb3VudC5cclxuICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XHJcbiAgICBpZiAoIWxpc3RlbmVyKSByZXR1cm47XHJcbiAgICBpZiAoY2FwdHVyZSA9PT0gdW5kZWZpbmVkKSBjYXB0dXJlID0gZmFsc2U7XHJcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVycykgdGhpcy5fbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGlmICghdGhpcy5fbGlzdGVuZXJzW3R5cGVdKSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSBbXTtcclxuICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xyXG5cclxuICAgIC8vIElmIHRoaXMgbGlzdGVuZXIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLCBqdXN0IHJldHVyblxyXG4gICAgZm9yKHZhciBpID0gMCwgbiA9IGxpc3QubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgIHZhciBsID0gbGlzdFtpXTtcclxuICAgICAgaWYgKGwubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmIGwuY2FwdHVyZSA9PT0gY2FwdHVyZSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIGFuIG9iamVjdCB0byB0aGUgbGlzdCBvZiBsaXN0ZW5lcnNcclxuICAgIHZhciBvYmogPSB7IGxpc3RlbmVyOiBsaXN0ZW5lciwgY2FwdHVyZTogY2FwdHVyZSB9O1xyXG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgb2JqLmYgPSBsaXN0ZW5lcjtcclxuICAgIGxpc3QucHVzaChvYmopO1xyXG4gIH0sXHJcblxyXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZSkge1xyXG4gICAgaWYgKGNhcHR1cmUgPT09IHVuZGVmaW5lZCkgY2FwdHVyZSA9IGZhbHNlO1xyXG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycykge1xyXG4gICAgICB2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcclxuICAgICAgaWYgKGxpc3QpIHtcclxuICAgICAgICAvLyBGaW5kIHRoZSBsaXN0ZW5lciBpbiB0aGUgbGlzdCBhbmQgcmVtb3ZlIGl0XHJcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbiA9IGxpc3QubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgbCA9IGxpc3RbaV07XHJcbiAgICAgICAgICBpZiAobC5saXN0ZW5lciA9PT0gbGlzdGVuZXIgJiYgbC5jYXB0dXJlID09PSBjYXB0dXJlKSB7XHJcbiAgICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gVGhpcyBpcyB0aGUgcHVibGljIEFQSSBmb3IgZGlzcGF0Y2hpbmcgdW50cnVzdGVkIHB1YmxpYyBldmVudHMuXHJcbiAgLy8gU2VlIF9kaXNwYXRjaEV2ZW50IGZvciB0aGUgaW1wbGVtZW50YXRpb25cclxuICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XHJcbiAgICAvLyBEaXNwYXRjaCBhbiB1bnRydXN0ZWQgZXZlbnRcclxuICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaEV2ZW50KGV2ZW50LCBmYWxzZSk7XHJcbiAgfSxcclxuXHJcbiAgLy9cclxuICAvLyBTZWUgRE9NQ29yZSDCpzQuNFxyXG4gIC8vIFhYWDogSSdsbCBwcm9iYWJseSBuZWVkIGFub3RoZXIgdmVyc2lvbiBvZiB0aGlzIG1ldGhvZCBmb3JcclxuICAvLyBpbnRlcm5hbCB1c2UsIG9uZSB0aGF0IGRvZXMgbm90IHNldCBpc1RydXN0ZWQgdG8gZmFsc2UuXHJcbiAgLy8gWFhYOiBzZWUgRG9jdW1lbnQuX2Rpc3BhdGNoRXZlbnQ6IHBlcmhhcHMgdGhhdCBhbmQgdGhpcyBjb3VsZFxyXG4gIC8vIGNhbGwgYSBjb21tb24gaW50ZXJuYWwgZnVuY3Rpb24gd2l0aCBkaWZmZXJlbnQgc2V0dGluZ3Mgb2ZcclxuICAvLyBhIHRydXN0ZWQgYm9vbGVhbiBhcmd1bWVudFxyXG4gIC8vXHJcbiAgLy8gWFhYOlxyXG4gIC8vIFRoZSBzcGVjIGhhcyBjaGFuZ2VkIGluIGhvdyB0byBkZWFsIHdpdGggaGFuZGxlcnMgcmVnaXN0ZXJlZFxyXG4gIC8vIG9uIGlkbCBvciBjb250ZW50IGF0dHJpYnV0ZXMgcmF0aGVyIHRoYW4gd2l0aCBhZGRFdmVudExpc3RlbmVyLlxyXG4gIC8vIFVzZWQgdG8gc2F5IHRoYXQgdGhleSBhbHdheXMgcmFuIGZpcnN0LiAgVGhhdCdzIGhvdyB3ZWJraXQgZG9lcyBpdFxyXG4gIC8vIFNwZWMgbm93IHNheXMgdGhhdCB0aGV5IHJ1biBpbiBhIHBvc2l0aW9uIGRldGVybWluZWQgYnlcclxuICAvLyB3aGVuIHRoZXkgd2VyZSBmaXJzdCBzZXQuICBGRiBkb2VzIGl0IHRoYXQgd2F5LiAgU2VlOlxyXG4gIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNldmVudC1oYW5kbGVyc1xyXG4gIC8vXHJcbiAgX2Rpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uIF9kaXNwYXRjaEV2ZW50KGV2ZW50LCB0cnVzdGVkKSB7XHJcbiAgICBpZiAodHlwZW9mIHRydXN0ZWQgIT09ICdib29sZWFuJykgdHJ1c3RlZCA9IGZhbHNlO1xyXG4gICAgZnVuY3Rpb24gaW52b2tlKHRhcmdldCwgZXZlbnQpIHtcclxuICAgICAgdmFyIHR5cGUgPSBldmVudC50eXBlLCBwaGFzZSA9IGV2ZW50LmV2ZW50UGhhc2U7XHJcbiAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XHJcblxyXG4gICAgICAvLyBJZiB0aGVyZSB3YXMgYW4gaW5kaXZpZHVhbCBoYW5kbGVyIGRlZmluZWQsIGludm9rZSBpdCBmaXJzdFxyXG4gICAgICAvLyBYWFg6IHNlZSBjb21tZW50IGFib3ZlOiB0aGlzIHNob3VsZG4ndCBhbHdheXMgYmUgZmlyc3QuXHJcbiAgICAgIGlmIChwaGFzZSAhPT0gRXZlbnQuQ0FQVFVSSU5HX1BIQVNFICYmXHJcbiAgICAgICAgdGFyZ2V0Ll9oYW5kbGVycyAmJiB0YXJnZXQuX2hhbmRsZXJzW3R5cGVdKVxyXG4gICAgICB7XHJcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0YXJnZXQuX2hhbmRsZXJzW3R5cGVdO1xyXG4gICAgICAgIHZhciBydjtcclxuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIHJ2PWhhbmRsZXIuY2FsbChldmVudC5jdXJyZW50VGFyZ2V0LCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgdmFyIGYgPSBoYW5kbGVyLmhhbmRsZUV2ZW50O1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBmICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoYW5kbGVFdmVudCBwcm9wZXJ0eSBvZiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZXZlbnQgaGFuZGxlciBvYmplY3QgaXMnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbm90IGEgZnVuY3Rpb24uJyk7XHJcbiAgICAgICAgICBydj1mLmNhbGwoaGFuZGxlciwgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3dpdGNoKGV2ZW50LnR5cGUpIHtcclxuICAgICAgICBjYXNlICdtb3VzZW92ZXInOlxyXG4gICAgICAgICAgaWYgKHJ2ID09PSB0cnVlKSAgLy8gSGlzdG9yaWNhbCBiYWdnYWdlXHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdiZWZvcmV1bmxvYWQnOlxyXG4gICAgICAgICAgLy8gWFhYOiBldmVudHVhbGx5IHdlIG5lZWQgYSBzcGVjaWFsIGNhc2UgaGVyZVxyXG4gICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBpZiAocnYgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBOb3cgaW52b2tlIGxpc3QgbGlzdCBvZiBsaXN0ZW5lcnMgZm9yIHRoaXMgdGFyZ2V0IGFuZCB0eXBlXHJcbiAgICAgIHZhciBsaXN0ID0gdGFyZ2V0Ll9saXN0ZW5lcnMgJiYgdGFyZ2V0Ll9saXN0ZW5lcnNbdHlwZV07XHJcbiAgICAgIGlmICghbGlzdCkgcmV0dXJuO1xyXG4gICAgICBsaXN0ID0gbGlzdC5zbGljZSgpO1xyXG4gICAgICBmb3IodmFyIGkgPSAwLCBuID0gbGlzdC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBpZiAoZXZlbnQuX2ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCkgcmV0dXJuO1xyXG4gICAgICAgIHZhciBsID0gbGlzdFtpXTtcclxuICAgICAgICBpZiAoKHBoYXNlID09PSBFdmVudC5DQVBUVVJJTkdfUEhBU0UgJiYgIWwuY2FwdHVyZSkgfHxcclxuICAgICAgICAgIChwaGFzZSA9PT0gRXZlbnQuQlVCQkxJTkdfUEhBU0UgJiYgbC5jYXB0dXJlKSlcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGlmIChsLmYpIHtcclxuICAgICAgICAgIGwuZi5jYWxsKGV2ZW50LmN1cnJlbnRUYXJnZXQsIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICB2YXIgZm4gPSBsLmxpc3RlbmVyLmhhbmRsZUV2ZW50O1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGFuZGxlRXZlbnQgcHJvcGVydHkgb2YgZXZlbnQgbGlzdGVuZXIgb2JqZWN0IGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgICAgZm4uY2FsbChsLmxpc3RlbmVyLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFldmVudC5faW5pdGlhbGl6ZWQgfHwgZXZlbnQuX2Rpc3BhdGNoaW5nKSB1dGlscy5JbnZhbGlkU3RhdGVFcnJvcigpO1xyXG4gICAgZXZlbnQuaXNUcnVzdGVkID0gdHJ1c3RlZDtcclxuXHJcbiAgICAvLyBCZWdpbiBkaXNwYXRjaGluZyB0aGUgZXZlbnQgbm93XHJcbiAgICBldmVudC5fZGlzcGF0Y2hpbmcgPSB0cnVlO1xyXG4gICAgZXZlbnQudGFyZ2V0ID0gdGhpcztcclxuXHJcbiAgICAvLyBCdWlsZCB0aGUgbGlzdCBvZiB0YXJnZXRzIGZvciB0aGUgY2FwdHVyaW5nIGFuZCBidWJibGluZyBwaGFzZXNcclxuICAgIC8vIFhYWDogd2UnbGwgZXZlbnR1YWxseSBoYXZlIHRvIGFkZCBXaW5kb3cgdG8gdGhpcyBsaXN0LlxyXG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xyXG4gICAgZm9yKHZhciBuID0gdGhpcy5wYXJlbnROb2RlOyBuOyBuID0gbi5wYXJlbnROb2RlKVxyXG4gICAgICBhbmNlc3RvcnMucHVzaChuKTtcclxuXHJcbiAgICAvLyBDYXB0dXJpbmcgcGhhc2VcclxuICAgIGV2ZW50LmV2ZW50UGhhc2UgPSBFdmVudC5DQVBUVVJJTkdfUEhBU0U7XHJcbiAgICBmb3IodmFyIGkgPSBhbmNlc3RvcnMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGludm9rZShhbmNlc3RvcnNbaV0sIGV2ZW50KTtcclxuICAgICAgaWYgKGV2ZW50Ll9wcm9wYWdhdGlvblN0b3BwZWQpIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEF0IHRhcmdldCBwaGFzZVxyXG4gICAgaWYgKCFldmVudC5fcHJvcGFnYXRpb25TdG9wcGVkKSB7XHJcbiAgICAgIGV2ZW50LmV2ZW50UGhhc2UgPSBFdmVudC5BVF9UQVJHRVQ7XHJcbiAgICAgIGludm9rZSh0aGlzLCBldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQnViYmxpbmcgcGhhc2VcclxuICAgIGlmIChldmVudC5idWJibGVzICYmICFldmVudC5fcHJvcGFnYXRpb25TdG9wcGVkKSB7XHJcbiAgICAgIGV2ZW50LmV2ZW50UGhhc2UgPSBFdmVudC5CVUJCTElOR19QSEFTRTtcclxuICAgICAgZm9yKHZhciBpaSA9IDAsIG5uID0gYW5jZXN0b3JzLmxlbmd0aDsgaWkgPCBubjsgaWkrKykge1xyXG4gICAgICAgIGludm9rZShhbmNlc3RvcnNbaWldLCBldmVudCk7XHJcbiAgICAgICAgaWYgKGV2ZW50Ll9wcm9wYWdhdGlvblN0b3BwZWQpIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZXZlbnQuX2Rpc3BhdGNoaW5nID0gZmFsc2U7XHJcbiAgICBldmVudC5ldmVudFBoYXNlID0gRXZlbnQuQVRfVEFSR0VUO1xyXG4gICAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XHJcblxyXG4gICAgLy8gRGVhbCB3aXRoIG1vdXNlIGV2ZW50cyBhbmQgZmlndXJlIG91dCB3aGVuXHJcbiAgICAvLyBhIGNsaWNrIGhhcyBoYXBwZW5lZFxyXG4gICAgaWYgKHRydXN0ZWQgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiYgZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XHJcbiAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XHJcbiAgICAgIGNhc2UgJ21vdXNlZG93bic6XHJcbiAgICAgICAgdGhpcy5fYXJtZWQgPSB7XHJcbiAgICAgICAgICB4OiBldmVudC5jbGllbnRYLFxyXG4gICAgICAgICAgeTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgICAgIHQ6IGV2ZW50LnRpbWVTdGFtcFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ21vdXNlb3V0JzpcclxuICAgICAgY2FzZSAnbW91c2VvdmVyJzpcclxuICAgICAgICB0aGlzLl9hcm1lZCA9IG51bGw7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ21vdXNldXAnOlxyXG4gICAgICAgIGlmICh0aGlzLl9pc0NsaWNrKGV2ZW50KSkgdGhpcy5fZG9DbGljayhldmVudCk7XHJcbiAgICAgICAgdGhpcy5fYXJtZWQgPSBudWxsO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XHJcbiAgfSxcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYSBjbGljayBvY2N1cnJlZFxyXG4gIC8vIFhYWCBXZSBkb24ndCBzdXBwb3J0IGRvdWJsZSBjbGlja3MgZm9yIG5vd1xyXG4gIF9pc0NsaWNrOiBmdW5jdGlvbihldmVudCkge1xyXG4gICAgcmV0dXJuICh0aGlzLl9hcm1lZCAhPT0gbnVsbCAmJlxyXG4gICAgICAgIGV2ZW50LnR5cGUgPT09ICdtb3VzZXVwJyAmJlxyXG4gICAgICAgIGV2ZW50LmlzVHJ1c3RlZCAmJlxyXG4gICAgICAgIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJlxyXG4gICAgICAgIGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMuX2FybWVkLnQgPCAxMDAwICYmXHJcbiAgICAgICAgTWF0aC5hYnMoZXZlbnQuY2xpZW50WCAtIHRoaXMuX2FybWVkLngpIDwgMTAgJiZcclxuICAgICAgICBNYXRoLmFicyhldmVudC5jbGllbnRZIC0gdGhpcy5fYXJtZWQuWSkgPCAxMCk7XHJcbiAgfSxcclxuXHJcbiAgLy8gQ2xpY2tzIGFyZSBoYW5kbGVkIGxpa2UgdGhpczpcclxuICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9lbGVtZW50cy5odG1sI2ludGVyYWN0aXZlLWNvbnRlbnQtMFxyXG4gIC8vXHJcbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIHNpbWlsYXIgdG8gdGhlIEhUTUxFbGVtZW50LmNsaWNrKCkgbWV0aG9kXHJcbiAgLy8gVGhlIGV2ZW50IGFyZ3VtZW50IG11c3QgYmUgdGhlIHRydXN0ZWQgbW91c2V1cCBldmVudFxyXG4gIF9kb0NsaWNrOiBmdW5jdGlvbihldmVudCkge1xyXG4gICAgaWYgKHRoaXMuX2NsaWNrX2luX3Byb2dyZXNzKSByZXR1cm47XHJcbiAgICB0aGlzLl9jbGlja19pbl9wcm9ncmVzcyA9IHRydWU7XHJcblxyXG4gICAgLy8gRmluZCB0aGUgbmVhcmVzdCBlbmNsb3NpbmcgZWxlbWVudCB0aGF0IGlzIGFjdGl2YXRhYmxlXHJcbiAgICAvLyBBbiBlbGVtZW50IGlzIGFjdGl2YXRhYmxlIGlmIGl0IGhhcyBhXHJcbiAgICAvLyBfcG9zdF9jbGlja19hY3RpdmF0aW9uX3N0ZXBzIGhvb2tcclxuICAgIHZhciBhY3RpdmF0ZWQgPSB0aGlzO1xyXG4gICAgd2hpbGUoYWN0aXZhdGVkICYmICFhY3RpdmF0ZWQuX3Bvc3RfY2xpY2tfYWN0aXZhdGlvbl9zdGVwcylcclxuICAgICAgYWN0aXZhdGVkID0gYWN0aXZhdGVkLnBhcmVudE5vZGU7XHJcblxyXG4gICAgaWYgKGFjdGl2YXRlZCAmJiBhY3RpdmF0ZWQuX3ByZV9jbGlja19hY3RpdmF0aW9uX3N0ZXBzKSB7XHJcbiAgICAgIGFjdGl2YXRlZC5fcHJlX2NsaWNrX2FjdGl2YXRpb25fc3RlcHMoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2xpY2sgPSB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnQnKTtcclxuICAgIGNsaWNrLmluaXRNb3VzZUV2ZW50KCdjbGljaycsIHRydWUsIHRydWUsXHJcbiAgICAgIHRoaXMub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldywgMSxcclxuICAgICAgZXZlbnQuc2NyZWVuWCwgZXZlbnQuc2NyZWVuWSxcclxuICAgICAgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSxcclxuICAgICAgZXZlbnQuY3RybEtleSwgZXZlbnQuYWx0S2V5LFxyXG4gICAgICBldmVudC5zaGlmdEtleSwgZXZlbnQubWV0YUtleSxcclxuICAgICAgZXZlbnQuYnV0dG9uLCBudWxsKTtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZGlzcGF0Y2hFdmVudChjbGljaywgdHJ1ZSk7XHJcblxyXG4gICAgaWYgKGFjdGl2YXRlZCkge1xyXG4gICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgLy8gVGhpcyBpcyB3aGVyZSBoeXBlcmxpbmtzIGdldCBmb2xsb3dlZCwgZm9yIGV4YW1wbGUuXHJcbiAgICAgICAgaWYgKGFjdGl2YXRlZC5fcG9zdF9jbGlja19hY3RpdmF0aW9uX3N0ZXBzKVxyXG4gICAgICAgICAgYWN0aXZhdGVkLl9wb3N0X2NsaWNrX2FjdGl2YXRpb25fc3RlcHMoY2xpY2spO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChhY3RpdmF0ZWQuX2NhbmNlbGxlZF9hY3RpdmF0aW9uX3N0ZXBzKVxyXG4gICAgICAgICAgYWN0aXZhdGVkLl9jYW5jZWxsZWRfYWN0aXZhdGlvbl9zdGVwcygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy9cclxuICAvLyBBbiBldmVudCBoYW5kbGVyIGlzIGxpa2UgYW4gZXZlbnQgbGlzdGVuZXIsIGJ1dCBpdCByZWdpc3RlcmVkXHJcbiAgLy8gYnkgc2V0dGluZyBhbiBJREwgb3IgY29udGVudCBhdHRyaWJ1dGUgbGlrZSBvbmxvYWQgb3Igb25jbGljay5cclxuICAvLyBUaGVyZSBjYW4gb25seSBiZSBvbmUgb2YgdGhlc2UgYXQgYSB0aW1lIGZvciBhbnkgZXZlbnQgdHlwZS5cclxuICAvLyBUaGlzIGlzIGFuIGludGVybmFsIG1ldGhvZCBmb3IgdGhlIGF0dHJpYnV0ZSBhY2Nlc3NvcnMgYW5kXHJcbiAgLy8gY29udGVudCBhdHRyaWJ1dGUgaGFuZGxlcnMgdGhhdCBuZWVkIHRvIHJlZ2lzdGVyIGV2ZW50cyBoYW5kbGVycy5cclxuICAvLyBUaGUgdHlwZSBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBpbiBhZGRFdmVudExpc3RlbmVyKCkuXHJcbiAgLy8gVGhlIGhhbmRsZXIgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgbGlzdGVuZXJzIGluIGFkZEV2ZW50TGlzdGVuZXI6XHJcbiAgLy8gaXQgY2FuIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0LiBQYXNzIG51bGwgdG8gcmVtb3ZlIGFueSBleGlzdGluZ1xyXG4gIC8vIGhhbmRsZXIuICBIYW5kbGVycyBhcmUgYWx3YXlzIGludm9rZWQgYmVmb3JlIGFueSBsaXN0ZW5lcnMgb2ZcclxuICAvLyB0aGUgc2FtZSB0eXBlLiAgVGhleSBhcmUgbm90IGludm9rZWQgZHVyaW5nIHRoZSBjYXB0dXJpbmcgcGhhc2VcclxuICAvLyBvZiBldmVudCBkaXNwYXRjaC5cclxuICAvL1xyXG4gIF9zZXRFdmVudEhhbmRsZXI6IGZ1bmN0aW9uIF9zZXRFdmVudEhhbmRsZXIodHlwZSwgaGFuZGxlcikge1xyXG4gICAgaWYgKCF0aGlzLl9oYW5kbGVycykgdGhpcy5faGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgdGhpcy5faGFuZGxlcnNbdHlwZV0gPSBoYW5kbGVyO1xyXG4gIH0sXHJcblxyXG4gIF9nZXRFdmVudEhhbmRsZXI6IGZ1bmN0aW9uIF9nZXRFdmVudEhhbmRsZXIodHlwZSkge1xyXG4gICAgcmV0dXJuICh0aGlzLl9oYW5kbGVycyAmJiB0aGlzLl9oYW5kbGVyc1t0eXBlXSkgfHwgbnVsbDtcclxuICB9XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZG9taW5vL2xpYi9FdmVudFRhcmdldC5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gTGVhZjtcclxuXHJcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxudmFyIEhpZXJhcmNoeVJlcXVlc3RFcnJvciA9IHV0aWxzLkhpZXJhcmNoeVJlcXVlc3RFcnJvcjtcclxudmFyIE5vdEZvdW5kRXJyb3IgPSB1dGlscy5Ob3RGb3VuZEVycm9yO1xyXG5cclxuLy8gVGhpcyBjbGFzcyBkZWZpbmVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciBub2RlIHN1YnR5cGVzIHRoYXRcclxuLy8gY2FuIG5ldmVyIGhhdmUgY2hpbGRyZW5cclxuZnVuY3Rpb24gTGVhZigpIHtcclxufVxyXG5cclxuTGVhZi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlLCB7XHJcbiAgaGFzQ2hpbGROb2RlczogeyB2YWx1ZTogZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfX0sXHJcbiAgZmlyc3RDaGlsZDogeyB2YWx1ZTogbnVsbCB9LFxyXG4gIGxhc3RDaGlsZDogeyB2YWx1ZTogbnVsbCB9LFxyXG4gIGluc2VydEJlZm9yZTogeyB2YWx1ZTogZnVuY3Rpb24obm9kZSwgY2hpbGQpIHtcclxuICAgIGlmICghbm9kZS5ub2RlVHlwZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgbm9kZScpO1xyXG4gICAgSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XHJcbiAgfX0sXHJcbiAgcmVwbGFjZUNoaWxkOiB7IHZhbHVlOiBmdW5jdGlvbihub2RlLCBjaGlsZCkge1xyXG4gICAgaWYgKCFub2RlLm5vZGVUeXBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBub2RlJyk7XHJcbiAgICBIaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcclxuICB9fSxcclxuICByZW1vdmVDaGlsZDogeyB2YWx1ZTogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgaWYgKCFub2RlLm5vZGVUeXBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBub2RlJyk7XHJcbiAgICBOb3RGb3VuZEVycm9yKCk7XHJcbiAgfX0sXHJcbiAgY2hpbGROb2RlczogeyBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCF0aGlzLl9jaGlsZE5vZGVzKSB0aGlzLl9jaGlsZE5vZGVzID0gW107XHJcbiAgICByZXR1cm4gdGhpcy5fY2hpbGROb2RlcztcclxuICB9fVxyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvTGVhZi5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBVSUV2ZW50ID0gcmVxdWlyZSgnLi9VSUV2ZW50Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vdXNlRXZlbnQ7XHJcblxyXG5mdW5jdGlvbiBNb3VzZUV2ZW50KCkge1xyXG4gIC8vIEp1c3QgdXNlIHRoZSBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yIHRvIGluaXRpYWxpemVcclxuICBVSUV2ZW50LmNhbGwodGhpcyk7XHJcblxyXG4gIHRoaXMuc2NyZWVuWCA9IHRoaXMuc2NyZWVuWSA9IHRoaXMuY2xpZW50WCA9IHRoaXMuY2xpZW50WSA9IDA7XHJcbiAgdGhpcy5jdHJsS2V5ID0gdGhpcy5hbHRLZXkgPSB0aGlzLnNoaWZ0S2V5ID0gdGhpcy5tZXRhS2V5ID0gZmFsc2U7XHJcbiAgdGhpcy5idXR0b24gPSAwO1xyXG4gIHRoaXMuYnV0dG9ucyA9IDE7XHJcbiAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gbnVsbDtcclxufVxyXG5Nb3VzZUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVUlFdmVudC5wcm90b3R5cGUsIHtcclxuICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogTW91c2VFdmVudCB9LFxyXG4gIGluaXRNb3VzZUV2ZW50OiB7IHZhbHVlOiBmdW5jdGlvbih0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlLFxyXG4gICAgdmlldywgZGV0YWlsLFxyXG4gICAgc2NyZWVuWCwgc2NyZWVuWSwgY2xpZW50WCwgY2xpZW50WSxcclxuICAgIGN0cmxLZXksIGFsdEtleSwgc2hpZnRLZXksIG1ldGFLZXksXHJcbiAgICBidXR0b24sIHJlbGF0ZWRUYXJnZXQpIHtcclxuXHJcbiAgICB0aGlzLmluaXRFdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlLCB2aWV3LCBkZXRhaWwpO1xyXG4gICAgdGhpcy5zY3JlZW5YID0gc2NyZWVuWDtcclxuICAgIHRoaXMuc2NyZWVuWSA9IHNjcmVlblk7XHJcbiAgICB0aGlzLmNsaWVudFggPSBjbGllbnRYO1xyXG4gICAgdGhpcy5jbGllbnRZID0gY2xpZW50WTtcclxuICAgIHRoaXMuY3RybEtleSA9IGN0cmxLZXk7XHJcbiAgICB0aGlzLmFsdEtleSA9IGFsdEtleTtcclxuICAgIHRoaXMuc2hpZnRLZXkgPSBzaGlmdEtleTtcclxuICAgIHRoaXMubWV0YUtleSA9IG1ldGFLZXk7XHJcbiAgICB0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcclxuICAgIHN3aXRjaChidXR0b24pIHtcclxuICAgIGNhc2UgMDogdGhpcy5idXR0b25zID0gMTsgYnJlYWs7XHJcbiAgICBjYXNlIDE6IHRoaXMuYnV0dG9ucyA9IDQ7IGJyZWFrO1xyXG4gICAgY2FzZSAyOiB0aGlzLmJ1dHRvbnMgPSAyOyBicmVhaztcclxuICAgIGRlZmF1bHQ6IHRoaXMuYnV0dG9ucyA9IDA7IGJyZWFrO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gcmVsYXRlZFRhcmdldDtcclxuICB9fSxcclxuXHJcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogeyB2YWx1ZTogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICBzd2l0Y2goa2V5KSB7XHJcbiAgICBjYXNlIFwiQWx0XCI6IHJldHVybiB0aGlzLmFsdEtleTtcclxuICAgIGNhc2UgXCJDb250cm9sXCI6IHJldHVybiB0aGlzLmN0cmxLZXk7XHJcbiAgICBjYXNlIFwiU2hpZnRcIjogcmV0dXJuIHRoaXMuc2hpZnRLZXk7XHJcbiAgICBjYXNlIFwiTWV0YVwiOiByZXR1cm4gdGhpcy5tZXRhS2V5O1xyXG4gICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH19XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZG9taW5vL2xpYi9Nb3VzZUV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuLyogZXhwb3J0ZWQgTm9kZVRyYXZlcnNhbCAqL1xyXG52YXIgTm9kZVRyYXZlcnNhbCA9IG1vZHVsZS5leHBvcnRzID0ge1xyXG4gIG5leHRTa2lwcGluZ0NoaWxkcmVuOiBuZXh0U2tpcHBpbmdDaGlsZHJlbixcclxuICBuZXh0QW5jZXN0b3JTaWJsaW5nOiBuZXh0QW5jZXN0b3JTaWJsaW5nLFxyXG4gIG5leHQ6IG5leHQsXHJcbiAgcHJldmlvdXM6IHByZXZpb3VzLFxyXG4gIGRlZXBMYXN0Q2hpbGQ6IGRlZXBMYXN0Q2hpbGRcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYmFzZWQgb24gV2ViS2l0J3MgTm9kZVRyYXZlcnNhbDo6bmV4dFNraXBwaW5nQ2hpbGRyZW5cclxuICogaHR0cHM6Ly90cmFjLndlYmtpdC5vcmcvYnJvd3Nlci90cnVuay9Tb3VyY2UvV2ViQ29yZS9kb20vTm9kZVRyYXZlcnNhbC5oP3Jldj0xNzkxNDMjTDEwOVxyXG4gKi9cclxuZnVuY3Rpb24gbmV4dFNraXBwaW5nQ2hpbGRyZW4obm9kZSwgc3RheVdpdGhpbikge1xyXG4gIGlmIChub2RlID09PSBzdGF5V2l0aGluKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgaWYgKG5vZGUubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcclxuICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xyXG4gIH1cclxuICByZXR1cm4gbmV4dEFuY2VzdG9yU2libGluZyhub2RlLCBzdGF5V2l0aGluKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBiYXNlZCBvbiBXZWJLaXQncyBOb2RlVHJhdmVyc2FsOjpuZXh0QW5jZXN0b3JTaWJsaW5nXHJcbiAqIGh0dHBzOi8vdHJhYy53ZWJraXQub3JnL2Jyb3dzZXIvdHJ1bmsvU291cmNlL1dlYkNvcmUvZG9tL05vZGVUcmF2ZXJzYWwuY3BwP3Jldj0xNzkxNDMjTDkzXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXh0QW5jZXN0b3JTaWJsaW5nKG5vZGUsIHN0YXlXaXRoaW4pIHtcclxuICBmb3IgKG5vZGUgPSBub2RlLnBhcmVudE5vZGU7IG5vZGUgIT09IG51bGw7IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpIHtcclxuICAgIGlmIChub2RlID09PSBzdGF5V2l0aGluKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogQGJhc2VkIG9uIFdlYktpdCdzIE5vZGVUcmF2ZXJzYWw6Om5leHRcclxuICogaHR0cHM6Ly90cmFjLndlYmtpdC5vcmcvYnJvd3Nlci90cnVuay9Tb3VyY2UvV2ViQ29yZS9kb20vTm9kZVRyYXZlcnNhbC5oP3Jldj0xNzkxNDMjTDk5XHJcbiAqL1xyXG5mdW5jdGlvbiBuZXh0KG5vZGUsIHN0YXlXaXRoaW4pIHtcclxuICB2YXIgbjtcclxuICBuID0gbm9kZS5maXJzdENoaWxkO1xyXG4gIGlmIChuICE9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gbjtcclxuICB9XHJcbiAgaWYgKG5vZGUgPT09IHN0YXlXaXRoaW4pIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICBuID0gbm9kZS5uZXh0U2libGluZztcclxuICBpZiAobiAhPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIG47XHJcbiAgfVxyXG4gIHJldHVybiBuZXh0QW5jZXN0b3JTaWJsaW5nKG5vZGUsIHN0YXlXaXRoaW4pO1xyXG59XHJcblxyXG4vKipcclxuICogQGJhc2VkIG9uIFdlYktpdCdzIE5vZGVUcmF2ZXJzYWw6OmRlZXBMYXN0Q2hpbGRcclxuICogaHR0cHM6Ly90cmFjLndlYmtpdC5vcmcvYnJvd3Nlci90cnVuay9Tb3VyY2UvV2ViQ29yZS9kb20vTm9kZVRyYXZlcnNhbC5jcHA/cmV2PTE3OTE0MyNMMTE2XHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwTGFzdENoaWxkKG5vZGUpIHtcclxuICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcclxuICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcclxuICB9XHJcbiAgcmV0dXJuIG5vZGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAYmFzZWQgb24gV2ViS2l0J3MgTm9kZVRyYXZlcnNhbDo6cHJldmlvdXNcclxuICogaHR0cHM6Ly90cmFjLndlYmtpdC5vcmcvYnJvd3Nlci90cnVuay9Tb3VyY2UvV2ViQ29yZS9kb20vTm9kZVRyYXZlcnNhbC5oP3Jldj0xNzkxNDMjTDEyMVxyXG4gKi9cclxuZnVuY3Rpb24gcHJldmlvdXMobm9kZSwgc3RheVdpdGhpbikge1xyXG4gIHZhciBwO1xyXG4gIHAgPSBub2RlLnByZXZpb3VzU2libGluZztcclxuICBpZiAocCAhPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIGRlZXBMYXN0Q2hpbGQocCk7XHJcbiAgfVxyXG4gIHAgPSBub2RlLnBhcmVudE5vZGU7XHJcbiAgaWYgKHAgPT09IHN0YXlXaXRoaW4pIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gcDtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZG9taW5vL2xpYi9Ob2RlVHJhdmVyc2FsLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcclxuXHJcbnZhciBOb25Eb2N1bWVudFR5cGVDaGlsZE5vZGUgPSB7XHJcblxyXG4gIG5leHRFbGVtZW50U2libGluZzogeyBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xyXG4gICAgICB2YXIgc2licyA9IHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzO1xyXG4gICAgICBmb3IodmFyIGkgPSB0aGlzLmluZGV4KzEsIG4gPSBzaWJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIGlmIChzaWJzW2ldLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkgcmV0dXJuIHNpYnNbaV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH19LFxyXG5cclxuICBwcmV2aW91c0VsZW1lbnRTaWJsaW5nOiB7IGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XHJcbiAgICAgIHZhciBzaWJzID0gdGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXM7XHJcbiAgICAgIGZvcih2YXIgaSA9IHRoaXMuaW5kZXgtMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBpZiAoc2lic1tpXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHJldHVybiBzaWJzW2ldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9fVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTm9uRG9jdW1lbnRUeXBlQ2hpbGROb2RlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZG9taW5vL2xpYi9Ob25Eb2N1bWVudFR5cGVDaGlsZE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFByb2Nlc3NpbmdJbnN0cnVjdGlvbjtcclxuXHJcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XHJcbnZhciBDaGFyYWN0ZXJEYXRhID0gcmVxdWlyZSgnLi9DaGFyYWN0ZXJEYXRhJyk7XHJcblxyXG5mdW5jdGlvbiBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oZG9jLCB0YXJnZXQsIGRhdGEpIHtcclxuICB0aGlzLm5vZGVUeXBlID0gTm9kZS5QUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREU7XHJcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gZG9jO1xyXG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gIHRoaXMuX2RhdGEgPSBkYXRhO1xyXG59XHJcblxyXG52YXIgbm9kZVZhbHVlID0ge1xyXG4gIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9kYXRhOyB9LFxyXG4gIHNldDogZnVuY3Rpb24odikge1xyXG4gICAgdGhpcy5fZGF0YSA9IHY7XHJcbiAgICBpZiAodGhpcy5yb290ZWQpIHRoaXMub3duZXJEb2N1bWVudC5tdXRhdGVWYWx1ZSh0aGlzKTtcclxuICB9XHJcbn07XHJcblxyXG5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDaGFyYWN0ZXJEYXRhLnByb3RvdHlwZSwge1xyXG4gIG5vZGVOYW1lOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRhcmdldDsgfX0sXHJcbiAgbm9kZVZhbHVlOiBub2RlVmFsdWUsXHJcbiAgdGV4dENvbnRlbnQ6IG5vZGVWYWx1ZSxcclxuICBkYXRhOiBub2RlVmFsdWUsXHJcblxyXG4gIC8vIFV0aWxpdHkgbWV0aG9kc1xyXG4gIGNsb25lOiB7IHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcclxuICAgICAgcmV0dXJuIG5ldyBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24odGhpcy5vd25lckRvY3VtZW50LCB0aGlzLnRhcmdldCwgdGhpcy5fZGF0YSk7XHJcbiAgfX0sXHJcbiAgaXNFcXVhbDogeyB2YWx1ZTogZnVuY3Rpb24gaXNFcXVhbChuKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRhcmdldCA9PT0gbi50YXJnZXQgJiYgdGhpcy5fZGF0YSA9PT0gbi5fZGF0YTtcclxuICB9fVxyXG5cclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kb21pbm8vbGliL1Byb2Nlc3NpbmdJbnN0cnVjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gVGV4dDtcclxuXHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcclxudmFyIENoYXJhY3RlckRhdGEgPSByZXF1aXJlKCcuL0NoYXJhY3RlckRhdGEnKTtcclxuXHJcbmZ1bmN0aW9uIFRleHQoZG9jLCBkYXRhKSB7XHJcbiAgdGhpcy5ub2RlVHlwZSA9IE5vZGUuVEVYVF9OT0RFO1xyXG4gIHRoaXMub3duZXJEb2N1bWVudCA9IGRvYztcclxuICB0aGlzLl9kYXRhID0gZGF0YTtcclxuICB0aGlzLl9pbmRleCA9IHVuZGVmaW5lZDtcclxufVxyXG5cclxudmFyIG5vZGVWYWx1ZSA9IHtcclxuICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fZGF0YTsgfSxcclxuICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgIGlmICh2ID09PSB0aGlzLl9kYXRhKSByZXR1cm47XHJcbiAgICB0aGlzLl9kYXRhID0gdjtcclxuICAgIGlmICh0aGlzLnJvb3RlZClcclxuICAgICAgdGhpcy5vd25lckRvY3VtZW50Lm11dGF0ZVZhbHVlKHRoaXMpO1xyXG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZSAmJlxyXG4gICAgICB0aGlzLnBhcmVudE5vZGUuX3RleHRjaGFuZ2Vob29rKVxyXG4gICAgICB0aGlzLnBhcmVudE5vZGUuX3RleHRjaGFuZ2Vob29rKHRoaXMpO1xyXG4gIH1cclxufTtcclxuXHJcblRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDaGFyYWN0ZXJEYXRhLnByb3RvdHlwZSwge1xyXG4gIG5vZGVOYW1lOiB7IHZhbHVlOiBcIiN0ZXh0XCIgfSxcclxuICAvLyBUaGVzZSB0aHJlZSBhdHRyaWJ1dGVzIGFyZSBhbGwgdGhlIHNhbWUuXHJcbiAgLy8gVGhlIGRhdGEgYXR0cmlidXRlIGhhcyBhIFtUcmVhdE51bGxBcz1FbXB0eVN0cmluZ10gYnV0IHdlJ2xsXHJcbiAgLy8gaW1wbGVtZW50IHRoYXQgYXQgdGhlIGludGVyZmFjZSBsZXZlbFxyXG4gIG5vZGVWYWx1ZTogbm9kZVZhbHVlLFxyXG4gIHRleHRDb250ZW50OiBub2RlVmFsdWUsXHJcbiAgZGF0YTogbm9kZVZhbHVlLFxyXG5cclxuICBzcGxpdFRleHQ6IHsgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0VGV4dChvZmZzZXQpIHtcclxuICAgIGlmIChvZmZzZXQgPiB0aGlzLl9kYXRhLmxlbmd0aCB8fCBvZmZzZXQgPCAwKSB1dGlscy5JbmRleFNpemVFcnJvcigpO1xyXG5cclxuICAgIHZhciBuZXdkYXRhID0gdGhpcy5fZGF0YS5zdWJzdHJpbmcob2Zmc2V0KSxcclxuICAgICAgbmV3bm9kZSA9IHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuZXdkYXRhKTtcclxuICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcclxuXHJcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xyXG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbClcclxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShuZXdub2RlLCB0aGlzLm5leHRTaWJsaW5nKTtcclxuXHJcbiAgICByZXR1cm4gbmV3bm9kZTtcclxuICB9fSxcclxuXHJcbiAgLy8gWFhYXHJcbiAgLy8gd2hvbGVUZXh0IGFuZCByZXBsYWNlV2hvbGVUZXh0KCkgYXJlIG5vdCBpbXBsZW1lbnRlZCB5ZXQgYmVjYXVzZVxyXG4gIC8vIHRoZSBET01Db3JlIHNwZWNpZmljYXRpb24gaXMgY29uc2lkZXJpbmcgcmVtb3Zpbmcgb3IgYWx0ZXJpbmcgdGhlbS5cclxuICB3aG9sZVRleHQ6IHtnZXQ6IHV0aWxzLm55aSB9LFxyXG4gIHJlcGxhY2VXaG9sZVRleHQ6IHsgdmFsdWU6IHV0aWxzLm55aSB9LFxyXG5cclxuICAvLyBVdGlsaXR5IG1ldGhvZHNcclxuICBjbG9uZTogeyB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XHJcbiAgICByZXR1cm4gbmV3IFRleHQodGhpcy5vd25lckRvY3VtZW50LCB0aGlzLl9kYXRhKTtcclxuICB9fSxcclxuXHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZG9taW5vL2xpYi9UZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9FdmVudCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVSUV2ZW50O1xyXG5cclxuZnVuY3Rpb24gVUlFdmVudCgpIHtcclxuICAvLyBKdXN0IHVzZSB0aGUgc3VwZXJjbGFzcyBjb25zdHJ1Y3RvciB0byBpbml0aWFsaXplXHJcbiAgRXZlbnQuY2FsbCh0aGlzKTtcclxuICB0aGlzLnZpZXcgPSBudWxsOyAvLyBGRiB1c2VzIHRoZSBjdXJyZW50IHdpbmRvd1xyXG4gIHRoaXMuZGV0YWlsID0gMDtcclxufVxyXG5VSUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlLCB7XHJcbiAgY29uc3RydWN0b3I6IHsgdmFsdWU6IFVJRXZlbnQgfSxcclxuICBpbml0VUlFdmVudDogeyB2YWx1ZTogZnVuY3Rpb24odHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgdmlldywgZGV0YWlsKSB7XHJcbiAgICB0aGlzLmluaXRFdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlKTtcclxuICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICB0aGlzLmRldGFpbCA9IGRldGFpbDtcclxuICB9fVxyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvVUlFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBVUkwgPSByZXF1aXJlKCcuL1VSTCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVUkxVdGlscztcclxuXHJcbi8vIFRoaXMgaXMgYW4gYWJzdHJhY3Qgc3VwZXJjbGFzcyBmb3IgTG9jYXRpb24sIEhUTUxBbmNob3JFbGVtZW50IGFuZFxyXG4vLyBvdGhlciB0eXBlcyB0aGF0IGhhdmUgdGhlIHN0YW5kYXJkIGNvbXBsZW1lbnQgb2YgXCJVUkwgZGVjb21wb3NpdGlvblxyXG4vLyBJREwgYXR0cmlidXRlc1wiLiAgVGhpcyBpcyBub3cgc3RhbmRhcmRpemVkIGFzIFVSTFV0aWxzLCBzZWU6XHJcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcclxuLy8gU3ViY2xhc3NlcyBtdXN0IGRlZmluZSBhIGdldHRlci9zZXR0ZXIgb24gaHJlZi5cclxuLy8gVGhlIGdldHRlciBhbmQgc2V0dGVyIG1ldGhvZHMgcGFyc2UgYW5kIHJlYnVpbGQgdGhlIFVSTCBvbiBlYWNoXHJcbi8vIGludm9jYXRpb247IHRoZXJlIGlzIG5vIGF0dGVtcHQgdG8gY2FjaGUgdGhlIHZhbHVlIGFuZCBiZSBtb3JlIGVmZmljaWVudFxyXG5mdW5jdGlvbiBVUkxVdGlscygpIHt9XHJcblVSTFV0aWxzLnByb3RvdHlwZSA9IHtcclxuICBjb25zdHJ1Y3RvcjogVVJMVXRpbHMsXHJcblxyXG4gIGdldCBwcm90b2NvbCgpIHtcclxuICAgIHZhciB1cmwgPSBuZXcgVVJMKHRoaXMuaHJlZik7XHJcbiAgICBpZiAodXJsLmlzQWJzb2x1dGUoKSkgcmV0dXJuIHVybC5zY2hlbWUgKyBcIjpcIjtcclxuICAgIGVsc2UgcmV0dXJuIFwiXCI7XHJcbiAgfSxcclxuXHJcbiAgZ2V0IGhvc3QoKSB7XHJcbiAgICB2YXIgdXJsID0gbmV3IFVSTCh0aGlzLmhyZWYpO1xyXG4gICAgaWYgKHVybC5pc0Fic29sdXRlKCkgJiYgdXJsLmlzQXV0aG9yaXR5QmFzZWQoKSlcclxuICAgICAgcmV0dXJuIHVybC5ob3N0ICsgKHVybC5wb3J0ID8gKFwiOlwiICsgdXJsLnBvcnQpIDogXCJcIik7XHJcbiAgICBlbHNlXHJcbiAgICAgIHJldHVybiBcIlwiO1xyXG4gIH0sXHJcblxyXG4gIGdldCBob3N0bmFtZSgpIHtcclxuICAgIHZhciB1cmwgPSBuZXcgVVJMKHRoaXMuaHJlZik7XHJcbiAgICBpZiAodXJsLmlzQWJzb2x1dGUoKSAmJiB1cmwuaXNBdXRob3JpdHlCYXNlZCgpKVxyXG4gICAgICByZXR1cm4gdXJsLmhvc3Q7XHJcbiAgICBlbHNlXHJcbiAgICAgIHJldHVybiBcIlwiO1xyXG4gIH0sXHJcblxyXG4gIGdldCBwb3J0KCkge1xyXG4gICAgdmFyIHVybCA9IG5ldyBVUkwodGhpcy5ocmVmKTtcclxuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpICYmIHVybC5pc0F1dGhvcml0eUJhc2VkKCkgJiYgdXJsLnBvcnQhPT11bmRlZmluZWQpXHJcbiAgICAgIHJldHVybiB1cmwucG9ydDtcclxuICAgIGVsc2VcclxuICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgfSxcclxuXHJcbiAgZ2V0IHBhdGhuYW1lKCkge1xyXG4gICAgdmFyIHVybCA9IG5ldyBVUkwodGhpcy5ocmVmKTtcclxuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpICYmIHVybC5pc0hpZXJhcmNoaWNhbCgpKVxyXG4gICAgICByZXR1cm4gdXJsLnBhdGg7XHJcbiAgICBlbHNlXHJcbiAgICAgIHJldHVybiBcIlwiO1xyXG4gIH0sXHJcblxyXG4gIGdldCBzZWFyY2goKSB7XHJcbiAgICB2YXIgdXJsID0gbmV3IFVSTCh0aGlzLmhyZWYpO1xyXG4gICAgaWYgKHVybC5pc0Fic29sdXRlKCkgJiYgdXJsLmlzSGllcmFyY2hpY2FsKCkgJiYgdXJsLnF1ZXJ5IT09dW5kZWZpbmVkKVxyXG4gICAgICByZXR1cm4gXCI/XCIgKyB1cmwucXVlcnk7XHJcbiAgICBlbHNlXHJcbiAgICAgIHJldHVybiBcIlwiO1xyXG4gIH0sXHJcblxyXG4gIGdldCBoYXNoKCkge1xyXG4gICAgdmFyIHVybCA9IG5ldyBVUkwodGhpcy5ocmVmKTtcclxuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpICYmIHVybC5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICByZXR1cm4gXCIjXCIgKyB1cmwuZnJhZ21lbnQ7XHJcbiAgICBlbHNlXHJcbiAgICAgIHJldHVybiBcIlwiO1xyXG4gIH0sXHJcblxyXG4gIGdldCB1c2VybmFtZSgpIHtcclxuICAgIHZhciB1cmwgPSBuZXcgVVJMKHRoaXMuaHJlZik7XHJcbiAgICByZXR1cm4gdXJsLnVzZXJuYW1lIHx8ICcnO1xyXG4gIH0sXHJcblxyXG4gIGdldCBwYXNzd29yZCgpIHtcclxuICAgIHZhciB1cmwgPSBuZXcgVVJMKHRoaXMuaHJlZik7XHJcbiAgICByZXR1cm4gdXJsLnBhc3N3b3JkIHx8ICcnO1xyXG4gIH0sXHJcblxyXG4gIGdldCBvcmlnaW4oKSB7XHJcbiAgICB2YXIgdXJsID0gbmV3IFVSTCh0aGlzLmhyZWYpO1xyXG4gICAgdmFyIG9yaWdpbkZvclBvcnQgPSBmdW5jdGlvbihkZWZhdWx0UG9ydCkge1xyXG4gICAgICB2YXIgb3JpZ2luID0gW3VybC5zY2hlbWUsIHVybC5ob3N0LCArdXJsLnBvcnQgfHwgZGVmYXVsdFBvcnRdO1xyXG4gICAgICAvLyBYWFggc2hvdWxkIGJlIFwidW5pY29kZSBzZXJpYWxpemF0aW9uXCJcclxuICAgICAgcmV0dXJuIG9yaWdpblswXSArICc6Ly8nICsgb3JpZ2luWzFdICtcclxuICAgICAgICAob3JpZ2luWzJdID09PSBkZWZhdWx0UG9ydCA/ICcnIDogKCc6JyArIG9yaWdpblsyXSkpO1xyXG4gICAgfTtcclxuICAgIHN3aXRjaCAodXJsLnNjaGVtZSkge1xyXG4gICAgY2FzZSAnZnRwJzpcclxuICAgICAgcmV0dXJuIG9yaWdpbkZvclBvcnQoMjEpO1xyXG4gICAgY2FzZSAnZ29waGVyJzpcclxuICAgICAgcmV0dXJuIG9yaWdpbkZvclBvcnQoNzApO1xyXG4gICAgY2FzZSAnaHR0cCc6XHJcbiAgICBjYXNlICd3cyc6XHJcbiAgICAgIHJldHVybiBvcmlnaW5Gb3JQb3J0KDgwKTtcclxuICAgIGNhc2UgJ2h0dHBzJzpcclxuICAgIGNhc2UgJ3dzcyc6XHJcbiAgICAgIHJldHVybiBvcmlnaW5Gb3JQb3J0KDQ0Myk7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICAvLyB0aGlzIGlzIHdoYXQgY2hyb21lIGRvZXNcclxuICAgICAgcmV0dXJuIHVybC5zY2hlbWUgKyAnOi8vJztcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKlxyXG4gIGdldCBzZWFyY2hQYXJhbXMoKSB7XHJcbiAgICB2YXIgdXJsID0gbmV3IFVSTCh0aGlzLmhyZWYpO1xyXG4gICAgLy8gWFhYXHJcbiAgfSxcclxuICAqL1xyXG5cclxuICBzZXQgcHJvdG9jb2wodikge1xyXG4gICAgdmFyIG91dHB1dCA9IHRoaXMuaHJlZjtcclxuICAgIHZhciB1cmwgPSBuZXcgVVJMKG91dHB1dCk7XHJcbiAgICBpZiAodXJsLmlzQWJzb2x1dGUoKSkge1xyXG4gICAgICB2ID0gdi5yZXBsYWNlKC86KyQvLCBcIlwiKTtcclxuICAgICAgdiA9IHYucmVwbGFjZSgvW14tK1xcLmEtekEtWjAtOV0vZywgVVJMLnBlcmNlbnRFbmNvZGUpO1xyXG4gICAgICBpZiAodi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdXJsLnNjaGVtZSA9IHY7XHJcbiAgICAgICAgb3V0cHV0ID0gdXJsLnRvU3RyaW5nKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuaHJlZiA9IG91dHB1dDtcclxuICB9LFxyXG5cclxuICBzZXQgaG9zdCh2KSB7XHJcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5ocmVmO1xyXG4gICAgdmFyIHVybCA9IG5ldyBVUkwob3V0cHV0KTtcclxuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpICYmIHVybC5pc0F1dGhvcml0eUJhc2VkKCkpIHtcclxuICAgICAgdiA9IHYucmVwbGFjZSgvW14tK1xcLl9+ISQmJygpKiw7Oj1hLXpBLVowLTldL2csIFVSTC5wZXJjZW50RW5jb2RlKTtcclxuICAgICAgaWYgKHYubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHVybC5ob3N0ID0gdjtcclxuICAgICAgICBkZWxldGUgdXJsLnBvcnQ7XHJcbiAgICAgICAgb3V0cHV0ID0gdXJsLnRvU3RyaW5nKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuaHJlZiA9IG91dHB1dDtcclxuICB9LFxyXG5cclxuICBzZXQgaG9zdG5hbWUodikge1xyXG4gICAgdmFyIG91dHB1dCA9IHRoaXMuaHJlZjtcclxuICAgIHZhciB1cmwgPSBuZXcgVVJMKG91dHB1dCk7XHJcbiAgICBpZiAodXJsLmlzQWJzb2x1dGUoKSAmJiB1cmwuaXNBdXRob3JpdHlCYXNlZCgpKSB7XHJcbiAgICAgIHYgPSB2LnJlcGxhY2UoL15cXC8rLywgXCJcIik7XHJcbiAgICAgIHYgPSB2LnJlcGxhY2UoL1teLStcXC5ffiEkJicoKSosOzo9YS16QS1aMC05XS9nLCBVUkwucGVyY2VudEVuY29kZSk7XHJcbiAgICAgIGlmICh2Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICB1cmwuaG9zdCA9IHY7XHJcbiAgICAgICAgb3V0cHV0ID0gdXJsLnRvU3RyaW5nKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuaHJlZiA9IG91dHB1dDtcclxuICB9LFxyXG5cclxuICBzZXQgcG9ydCh2KSB7XHJcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5ocmVmO1xyXG4gICAgdmFyIHVybCA9IG5ldyBVUkwob3V0cHV0KTtcclxuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpICYmIHVybC5pc0F1dGhvcml0eUJhc2VkKCkpIHtcclxuICAgICAgdiA9ICcnICsgdjtcclxuICAgICAgdiA9IHYucmVwbGFjZSgvW14wLTldLiokLywgXCJcIik7XHJcbiAgICAgIHYgPSB2LnJlcGxhY2UoL14wKy8sIFwiXCIpO1xyXG4gICAgICBpZiAodi5sZW5ndGggPT09IDApIHYgPSBcIjBcIjtcclxuICAgICAgaWYgKHBhcnNlSW50KHYsIDEwKSA8PSA2NTUzNSkge1xyXG4gICAgICAgIHVybC5wb3J0ID0gdjtcclxuICAgICAgICBvdXRwdXQgPSB1cmwudG9TdHJpbmcoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5ocmVmID0gb3V0cHV0O1xyXG4gIH0sXHJcblxyXG4gIHNldCBwYXRobmFtZSh2KSB7XHJcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5ocmVmO1xyXG4gICAgdmFyIHVybCA9IG5ldyBVUkwob3V0cHV0KTtcclxuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpICYmIHVybC5pc0hpZXJhcmNoaWNhbCgpKSB7XHJcbiAgICAgIGlmICh2LmNoYXJBdCgwKSAhPT0gXCIvXCIpXHJcbiAgICAgICAgdiA9IFwiL1wiICsgdjtcclxuICAgICAgdiA9IHYucmVwbGFjZSgvW14tK1xcLl9+ISQmJygpKiw7Oj1AXFwvYS16QS1aMC05XS9nLCBVUkwucGVyY2VudEVuY29kZSk7XHJcbiAgICAgIHVybC5wYXRoID0gdjtcclxuICAgICAgb3V0cHV0ID0gdXJsLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmhyZWYgPSBvdXRwdXQ7XHJcbiAgfSxcclxuXHJcbiAgc2V0IHNlYXJjaCh2KSB7XHJcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5ocmVmO1xyXG4gICAgdmFyIHVybCA9IG5ldyBVUkwob3V0cHV0KTtcclxuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpICYmIHVybC5pc0hpZXJhcmNoaWNhbCgpKSB7XHJcbiAgICAgIGlmICh2LmNoYXJBdCgwKSA9PT0gXCI/XCIpIHYgPSB2LnN1YnN0cmluZygxKTtcclxuICAgICAgdiA9IHYucmVwbGFjZSgvW14tK1xcLl9+ISQmJygpKiw7Oj1AXFwvP2EtekEtWjAtOV0vZywgVVJMLnBlcmNlbnRFbmNvZGUpO1xyXG4gICAgICB1cmwucXVlcnkgPSB2O1xyXG4gICAgICBvdXRwdXQgPSB1cmwudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIHRoaXMuaHJlZiA9IG91dHB1dDtcclxuICB9LFxyXG5cclxuICBzZXQgaGFzaCh2KSB7XHJcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5ocmVmO1xyXG4gICAgdmFyIHVybCA9IG5ldyBVUkwob3V0cHV0KTtcclxuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpKSB7XHJcbiAgICAgIGlmICh2LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHYgPSB2LnN1YnN0cmluZygxKTtcclxuICAgICAgdiA9IHYucmVwbGFjZSgvW14tK1xcLl9+ISQmJygpKiw7Oj1AXFwvP2EtekEtWjAtOV0vZywgVVJMLnBlcmNlbnRFbmNvZGUpO1xyXG4gICAgICB1cmwuZnJhZ21lbnQgPSB2O1xyXG4gICAgICBvdXRwdXQgPSB1cmwudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIHRoaXMuaHJlZiA9IG91dHB1dDtcclxuICB9LFxyXG5cclxuICBzZXQgdXNlcm5hbWUodikge1xyXG4gICAgdmFyIG91dHB1dCA9IHRoaXMuaHJlZjtcclxuICAgIHZhciB1cmwgPSBuZXcgVVJMKG91dHB1dCk7XHJcbiAgICBpZiAodXJsLmlzQWJzb2x1dGUoKSkge1xyXG4gICAgICB2ID0gdi5yZXBsYWNlKC9bXFx4MDAtXFx4MUZcXHg3Ri1cXHVGRkZGIFwiIzw+P2BcXC9AXFxcXDpdL2csIFVSTC5wZXJjZW50RW5jb2RlKTtcclxuICAgICAgdXJsLnVzZXJuYW1lID0gdjtcclxuICAgICAgb3V0cHV0ID0gdXJsLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmhyZWYgPSBvdXRwdXQ7XHJcbiAgfSxcclxuXHJcbiAgc2V0IHBhc3N3b3JkKHYpIHtcclxuICAgIHZhciBvdXRwdXQgPSB0aGlzLmhyZWY7XHJcbiAgICB2YXIgdXJsID0gbmV3IFVSTChvdXRwdXQpO1xyXG4gICAgaWYgKHVybC5pc0Fic29sdXRlKCkpIHtcclxuICAgICAgaWYgKHY9PT0nJykge1xyXG4gICAgICAgIHVybC5wYXNzd29yZCA9IG51bGw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdiA9IHYucmVwbGFjZSgvW1xceDAwLVxceDFGXFx4N0YtXFx1RkZGRiBcIiM8Pj9gXFwvQFxcXFxdL2csIFVSTC5wZXJjZW50RW5jb2RlKTtcclxuICAgICAgICB1cmwucGFzc3dvcmQgPSB2O1xyXG4gICAgICB9XHJcbiAgICAgIG91dHB1dCA9IHVybC50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ocmVmID0gb3V0cHV0O1xyXG4gIH0vKixcclxuXHJcbiAgc2V0IHNlYXJjaFBhcmFtcyh2KSB7XHJcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5ocmVmO1xyXG4gICAgdmFyIHVybCA9IG5ldyBVUkwob3V0cHV0KTtcclxuICAgIC8vIFhYWFxyXG4gICAgdGhpcy5ocmVmID0gb3V0cHV0O1xyXG4gIH1cclxuICAqL1xyXG59O1xyXG5cclxuVVJMVXRpbHMuX2luaGVyaXQgPSBmdW5jdGlvbihwcm90bykge1xyXG4gIC8vIGNvcHkgZ2V0dGVycy9zZXR0ZXJzIGZyb20gVVJMVXRpbHMgdG8gby5cclxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhVUkxVdGlscy5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24ocCkge1xyXG4gICAgaWYgKHA9PT0nY29uc3RydWN0b3InIHx8IHA9PT0naHJlZicpIHsgcmV0dXJuOyB9XHJcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoVVJMVXRpbHMucHJvdG90eXBlLCBwKTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgcCwgZGVzYyk7XHJcbiAgfSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kb21pbm8vbGliL1VSTFV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG5cclxuZXhwb3J0cy5wcm9wZXJ0eSA9IGZ1bmN0aW9uKGF0dHIpIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShhdHRyLnR5cGUpKSB7XHJcbiAgICB2YXIgdmFsaWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgYXR0ci50eXBlLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgIHZhbGlkW3ZhbC52YWx1ZSB8fCB2YWxdID0gdmFsLmFsaWFzIHx8IHZhbDtcclxuICAgIH0pO1xyXG4gICAgdmFyIG1pc3NpbmdWYWx1ZURlZmF1bHQgPSBhdHRyLm1pc3Npbmc7XHJcbiAgICBpZiAobWlzc2luZ1ZhbHVlRGVmYXVsdD09PXVuZGVmaW5lZCkgeyBtaXNzaW5nVmFsdWVEZWZhdWx0ID0gbnVsbDsgfVxyXG4gICAgdmFyIGludmFsaWRWYWx1ZURlZmF1bHQgPSBhdHRyLmludmFsaWQ7XHJcbiAgICBpZiAoaW52YWxpZFZhbHVlRGVmYXVsdD09PXVuZGVmaW5lZCkgeyBpbnZhbGlkVmFsdWVEZWZhdWx0ID0gbWlzc2luZ1ZhbHVlRGVmYXVsdDsgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuX2dldGF0dHIoYXR0ci5uYW1lKTtcclxuICAgICAgICBpZiAodiA9PT0gbnVsbCkgcmV0dXJuIG1pc3NpbmdWYWx1ZURlZmF1bHQ7XHJcblxyXG4gICAgICAgIHYgPSB2YWxpZFt2LnRvTG93ZXJDYXNlKCldO1xyXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHJldHVybiB2O1xyXG4gICAgICAgIGlmIChpbnZhbGlkVmFsdWVEZWZhdWx0ICE9PSBudWxsKSByZXR1cm4gaW52YWxpZFZhbHVlRGVmYXVsdDtcclxuICAgICAgICByZXR1cm4gdjtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgdGhpcy5fc2V0YXR0cihhdHRyLm5hbWUsIHYpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuICBlbHNlIGlmIChhdHRyLnR5cGUgPT09IEJvb2xlYW4pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKGF0dHIubmFtZSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xyXG4gICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICB0aGlzLl9zZXRhdHRyKGF0dHIubmFtZSwgJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKGF0dHIubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuICBlbHNlIGlmIChhdHRyLnR5cGUgPT09IE51bWJlciB8fFxyXG4gICAgICAgICAgIGF0dHIudHlwZSA9PT0gXCJsb25nXCIgfHxcclxuICAgICAgICAgICBhdHRyLnR5cGUgPT09IFwidW5zaWduZWQgbG9uZ1wiIHx8XHJcbiAgICAgICAgICAgYXR0ci50eXBlID09PSBcImxpbWl0ZWQgdW5zaWduZWQgbG9uZyB3aXRoIGZhbGxiYWNrXCIpIHtcclxuICAgIHJldHVybiBudW1iZXJQcm9wRGVzYyhhdHRyKTtcclxuICB9XHJcbiAgZWxzZSBpZiAoIWF0dHIudHlwZSB8fCBhdHRyLnR5cGUgPT09IFN0cmluZykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2dldGF0dHIoYXR0ci5uYW1lKSB8fCAnJzsgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgaWYgKGF0dHIudHJlYXROdWxsQXNFbXB0eVN0cmluZyAmJiB2ID09PSBudWxsKSB7IHYgPSAnJzsgfVxyXG4gICAgICAgIHRoaXMuX3NldGF0dHIoYXR0ci5uYW1lLCB2KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbiAgZWxzZSBpZiAodHlwZW9mIGF0dHIudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuIGF0dHIudHlwZShhdHRyLm5hbWUsIGF0dHIpO1xyXG4gIH1cclxuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGRlZmluaXRpb24nKTtcclxufTtcclxuXHJcbi8vIFNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrLyNyZWZsZWN0XHJcbi8vXHJcbi8vIGRlZnZhbCBpcyB0aGUgZGVmYXVsdCB2YWx1ZS4gSWYgaXQgaXMgYSBmdW5jdGlvbiwgdGhlbiB0aGF0IGZ1bmN0aW9uXHJcbi8vIHdpbGwgYmUgaW52b2tlZCBhcyBhIG1ldGhvZCBvZiB0aGUgZWxlbWVudCB0byBvYnRhaW4gdGhlIGRlZmF1bHQuXHJcbi8vIElmIG5vIGRlZmF1bHQgaXMgc3BlY2lmaWVkIGZvciBhIGdpdmVuIGF0dHJpYnV0ZSwgdGhlbiB0aGUgZGVmYXVsdFxyXG4vLyBkZXBlbmRzIG9uIHRoZSB0eXBlIG9mIHRoZSBhdHRyaWJ1dGUsIGJ1dCBzaW5jZSB0aGlzIGZ1bmN0aW9uIGhhbmRsZXNcclxuLy8gNCBpbnRlZ2VyIGNhc2VzLCB5b3UgbXVzdCBzcGVjaWZ5IHRoZSBkZWZhdWx0IHZhbHVlIGluIGVhY2ggY2FsbFxyXG4vL1xyXG4vLyBtaW4gYW5kIG1heCBkZWZpbmUgYSB2YWxpZCByYW5nZSBmb3IgZ2V0dGluZyB0aGUgYXR0cmlidXRlLlxyXG4vL1xyXG4vLyBzZXRtaW4gZGVmaW5lcyBhIG1pbmltdW0gdmFsdWUgd2hlbiBzZXR0aW5nLiAgSWYgdGhlIHZhbHVlIGlzIGxlc3NcclxuLy8gdGhhbiB0aGF0LCB0aGVuIHRocm93IElOREVYX1NJWkVfRVJSLlxyXG4vL1xyXG4vLyBDb252ZW5pZW50bHksIEphdmFTY3JpcHQncyBwYXJzZUludCBmdW5jdGlvbiBhcHBlYXJzIHRvIGJlXHJcbi8vIGNvbXBhdGlibGUgd2l0aCBIVE1MJ3MgJ3J1bGVzIGZvciBwYXJzaW5nIGludGVnZXJzJ1xyXG5mdW5jdGlvbiBudW1iZXJQcm9wRGVzYyhhKSB7XHJcbiAgdmFyIGRlZjtcclxuICBpZih0eXBlb2YgYS5kZWZhdWx0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBkZWYgPSBhLmRlZmF1bHQ7XHJcbiAgfVxyXG4gIGVsc2UgaWYodHlwZW9mIGEuZGVmYXVsdCA9PT0gJ251bWJlcicpIHtcclxuICAgIGRlZiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYS5kZWZhdWx0OyB9O1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIGRlZiA9IGZ1bmN0aW9uKCkgeyB1dGlscy5hc3NlcnQoZmFsc2UsIHR5cGVvZiBhLmRlZmF1bHQpOyB9O1xyXG4gIH1cclxuICB2YXIgdW5zaWduZWRfbG9uZyA9IChhLnR5cGUgPT09ICd1bnNpZ25lZCBsb25nJyk7XHJcbiAgdmFyIHNpZ25lZF9sb25nID0gKGEudHlwZSA9PT0gJ2xvbmcnKTtcclxuICB2YXIgdW5zaWduZWRfZmFsbGJhY2sgPSAoYS50eXBlID09PSAnbGltaXRlZCB1bnNpZ25lZCBsb25nIHdpdGggZmFsbGJhY2snKTtcclxuICB2YXIgbWluID0gYS5taW4sIG1heCA9IGEubWF4LCBzZXRtaW4gPSBhLnNldG1pbjtcclxuICBpZiAobWluID09PSB1bmRlZmluZWQpIHtcclxuICAgIGlmICh1bnNpZ25lZF9sb25nKSBtaW4gPSAwO1xyXG4gICAgaWYgKHNpZ25lZF9sb25nKSBtaW4gPSAtMHg4MDAwMDAwMDtcclxuICAgIGlmICh1bnNpZ25lZF9mYWxsYmFjaykgbWluID0gMTtcclxuICB9XHJcbiAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAodW5zaWduZWRfbG9uZyB8fCBzaWduZWRfbG9uZyB8fCB1bnNpZ25lZF9mYWxsYmFjaykgbWF4ID0gMHg3RkZGRkZGRjtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgdiA9IHRoaXMuX2dldGF0dHIoYS5uYW1lKTtcclxuICAgICAgdmFyIG4gPSBhLmZsb2F0ID8gcGFyc2VGbG9hdCh2KSA6IHBhcnNlSW50KHYsIDEwKTtcclxuICAgICAgaWYgKHYgPT09IG51bGwgfHwgIWlzRmluaXRlKG4pIHx8IChtaW4gIT09IHVuZGVmaW5lZCAmJiBuIDwgbWluKSB8fCAobWF4ICE9PSB1bmRlZmluZWQgJiYgbiA+IG1heCkpIHtcclxuICAgICAgICByZXR1cm4gZGVmLmNhbGwodGhpcyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHVuc2lnbmVkX2xvbmcgfHwgc2lnbmVkX2xvbmcgfHwgdW5zaWduZWRfZmFsbGJhY2spIHtcclxuICAgICAgICBpZiAoIS9eWyBcXHRcXG5cXGZcXHJdKlstK10/WzAtOV0vLnRlc3QodikpIHsgcmV0dXJuIGRlZi5jYWxsKHRoaXMpOyB9XHJcbiAgICAgICAgbiA9IG58MDsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XHJcbiAgICAgIGlmICghYS5mbG9hdCkgeyB2ID0gTWF0aC5mbG9vcih2KTsgfVxyXG4gICAgICBpZiAoc2V0bWluICE9PSB1bmRlZmluZWQgJiYgdiA8IHNldG1pbikge1xyXG4gICAgICAgIHV0aWxzLkluZGV4U2l6ZUVycm9yKGEubmFtZSArICcgc2V0IHRvICcgKyB2KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodW5zaWduZWRfbG9uZykge1xyXG4gICAgICAgIHYgPSAodiA8IDAgfHwgdiA+IDB4N0ZGRkZGRkYpID8gZGVmLmNhbGwodGhpcykgOlxyXG4gICAgICAgICAgKHZ8MCk7ICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgICAgfSBlbHNlIGlmICh1bnNpZ25lZF9mYWxsYmFjaykge1xyXG4gICAgICAgIHYgPSAodiA8IDEgfHwgdiA+IDB4N0ZGRkZGRkYpID8gZGVmLmNhbGwodGhpcykgOlxyXG4gICAgICAgICAgKHZ8MCk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICB9IGVsc2UgaWYgKHNpZ25lZF9sb25nKSB7XHJcbiAgICAgICAgdiA9ICh2IDwgLTB4ODAwMDAwMDAgfHwgdiA+IDB4N0ZGRkZGRkYpID8gZGVmLmNhbGwodGhpcykgOlxyXG4gICAgICAgICAgKHZ8MCk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX3NldGF0dHIoYS5uYW1lLCBTdHJpbmcodikpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbi8vIFRoaXMgaXMgYSB1dGlsaXR5IGZ1bmN0aW9uIGZvciBzZXR0aW5nIHVwIGNoYW5nZSBoYW5kbGVyIGZ1bmN0aW9uc1xyXG4vLyBmb3IgYXR0cmlidXRlcyBsaWtlICdpZCcgdGhhdCByZXF1aXJlIHNwZWNpYWwgaGFuZGxpbmcgd2hlbiB0aGV5IGNoYW5nZS5cclxuZXhwb3J0cy5yZWdpc3RlckNoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbihjLCBuYW1lLCBoYW5kbGVyKSB7XHJcbiAgdmFyIHAgPSBjLnByb3RvdHlwZTtcclxuXHJcbiAgLy8gSWYgcCBkb2VzIG5vdCBhbHJlYWR5IGhhdmUgaXRzIG93biBfYXR0cmlidXRlQ2hhbmdlSGFuZGxlcnNcclxuICAvLyB0aGVuIGNyZWF0ZSBvbmUgZm9yIGl0LCBpbmhlcml0aW5nIGZyb20gdGhlIGluaGVyaXRlZFxyXG4gIC8vIF9hdHRyaWJ1dGVDaGFuZ2VIYW5kbGVycy4gQXQgdGhlIHRvcCAoZm9yIHRoZSBFbGVtZW50IGNsYXNzKSB0aGVcclxuICAvLyBfYXR0cmlidXRlQ2hhbmdlSGFuZGxlcnMgb2JqZWN0IHdpbGwgYmUgY3JlYXRlZCB3aXRoIGEgbnVsbCBwcm90b3R5cGUuXHJcbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocCwgJ19hdHRyaWJ1dGVDaGFuZ2VIYW5kbGVycycpKSB7XHJcbiAgICBwLl9hdHRyaWJ1dGVDaGFuZ2VIYW5kbGVycyA9XHJcbiAgICAgIE9iamVjdC5jcmVhdGUocC5fYXR0cmlidXRlQ2hhbmdlSGFuZGxlcnMgfHwgbnVsbCk7XHJcbiAgfVxyXG5cclxuICBwLl9hdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyc1tuYW1lXSA9IGhhbmRsZXI7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kb21pbm8vbGliL2F0dHJpYnV0ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcbiAqIFRoaXMgZmlsZSBkZWZpbmVzIERvbWlubyBiZWhhdmlvdXIgdGhhdCBjYW4gYmUgZXh0ZXJuYWxseSBjb25maWd1cmVkLlxyXG4gKiBUbyBjaGFuZ2UgdGhlc2Ugc2V0dGluZ3MsIHNldCB0aGUgcmVsZXZhbnQgZ2xvYmFsIHByb3BlcnR5ICpiZWZvcmUqXHJcbiAqIHlvdSBjYWxsIGByZXF1aXJlKFwiZG9taW5vXCIpYC5cclxuICovXHJcblxyXG5leHBvcnRzLmlzQXBpV3JpdGFibGUgPSAhZ2xvYmFsLl9fZG9taW5vX2Zyb3plbl9fO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZG9taW5vL2xpYi9jb25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKTtcclxudmFyIHNsb3BweSA9IHJlcXVpcmUoJy4vc2xvcHB5Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNwZWMsIGRlZmF1bHRDb25zdHJ1Y3RvciwgdGFnTGlzdCwgdGFnTmFtZVRvSW1wbCkge1xyXG4gIHZhciBjID0gc3BlYy5jdG9yO1xyXG4gIGlmIChjKSB7XHJcbiAgICB2YXIgcHJvcHMgPSBzcGVjLnByb3BzIHx8IHt9O1xyXG5cclxuICAgIGlmIChzcGVjLmF0dHJpYnV0ZXMpIHtcclxuICAgICAgZm9yICh2YXIgbiBpbiBzcGVjLmF0dHJpYnV0ZXMpIHtcclxuICAgICAgICB2YXIgYXR0ciA9IHNwZWMuYXR0cmlidXRlc1tuXTtcclxuICAgICAgICBpZiAodHlwZW9mIGF0dHIgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkoYXR0cikpIGF0dHIgPSB7dHlwZTogYXR0cn07XHJcbiAgICAgICAgaWYgKCFhdHRyLm5hbWUpIGF0dHIubmFtZSA9IG4udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBwcm9wc1tuXSA9IGF0dHJpYnV0ZXMucHJvcGVydHkoYXR0cik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm9wcy5jb25zdHJ1Y3RvciA9IHsgdmFsdWUgOiBjIH07XHJcbiAgICBjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoKHNwZWMuc3VwZXJjbGFzcyB8fCBkZWZhdWx0Q29uc3RydWN0b3IpLnByb3RvdHlwZSwgcHJvcHMpO1xyXG4gICAgaWYgKHNwZWMuZXZlbnRzKSB7XHJcbiAgICAgIGFkZEV2ZW50SGFuZGxlcnMoYywgc3BlYy5ldmVudHMpO1xyXG4gICAgfVxyXG4gICAgdGFnTGlzdFtjLm5hbWVdID0gYztcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICBjID0gZGVmYXVsdENvbnN0cnVjdG9yO1xyXG4gIH1cclxuXHJcbiAgKHNwZWMudGFncyB8fCBzcGVjLnRhZyAmJiBbc3BlYy50YWddIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHRhZykge1xyXG4gICAgdGFnTmFtZVRvSW1wbFt0YWddID0gYztcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGM7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBFdmVudEhhbmRsZXJCdWlsZGVyKGJvZHksIGRvY3VtZW50LCBmb3JtLCBlbGVtZW50KSB7XHJcbiAgdGhpcy5ib2R5ID0gYm9keTtcclxuICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XHJcbiAgdGhpcy5mb3JtID0gZm9ybTtcclxuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG59XHJcblxyXG5FdmVudEhhbmRsZXJCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IHNsb3BweS5FdmVudEhhbmRsZXJCdWlsZGVyX2J1aWxkO1xyXG5cclxuZnVuY3Rpb24gRXZlbnRIYW5kbGVyQ2hhbmdlSGFuZGxlcihlbHQsIG5hbWUsIG9sZHZhbCwgbmV3dmFsKSB7XHJcbiAgdmFyIGRvYyA9IGVsdC5vd25lckRvY3VtZW50IHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgdmFyIGZvcm0gPSBlbHQuZm9ybSB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIGVsdFtuYW1lXSA9IG5ldyBFdmVudEhhbmRsZXJCdWlsZGVyKG5ld3ZhbCwgZG9jLCBmb3JtLCBlbHQpLmJ1aWxkKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZEV2ZW50SGFuZGxlcnMoYywgZXZlbnRIYW5kbGVyVHlwZXMpIHtcclxuICB2YXIgcCA9IGMucHJvdG90eXBlO1xyXG4gIGV2ZW50SGFuZGxlclR5cGVzLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xyXG4gICAgLy8gRGVmaW5lIHRoZSBldmVudCBoYW5kbGVyIHJlZ2lzdHJhdGlvbiBJREwgYXR0cmlidXRlIGZvciB0aGlzIHR5cGVcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcIm9uXCIgKyB0eXBlLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEV2ZW50SGFuZGxlcih0eXBlKTtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgdGhpcy5fc2V0RXZlbnRIYW5kbGVyKHR5cGUsIHYpO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gRGVmaW5lIHNwZWNpYWwgYmVoYXZpb3IgZm9yIHRoZSBjb250ZW50IGF0dHJpYnV0ZSBhcyB3ZWxsXHJcbiAgICBhdHRyaWJ1dGVzLnJlZ2lzdGVyQ2hhbmdlSGFuZGxlcihjLCBcIm9uXCIgKyB0eXBlLCBFdmVudEhhbmRsZXJDaGFuZ2VIYW5kbGVyKTtcclxuICB9KTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZG9taW5vL2xpYi9kZWZpbmVFbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgRXZlbnQ6IHJlcXVpcmUoJy4vRXZlbnQnKSxcclxuICBVSUV2ZW50OiByZXF1aXJlKCcuL1VJRXZlbnQnKSxcclxuICBNb3VzZUV2ZW50OiByZXF1aXJlKCcuL01vdXNlRXZlbnQnKSxcclxuICBDdXN0b21FdmVudDogcmVxdWlyZSgnLi9DdXN0b21FdmVudCcpXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kb21pbm8vbGliL2V2ZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxuXHJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiByZXF1aXJlKCcuL0NTU1N0eWxlRGVjbGFyYXRpb24nKSxcclxuICBDaGFyYWN0ZXJEYXRhOiByZXF1aXJlKCcuL0NoYXJhY3RlckRhdGEnKSxcclxuICBDb21tZW50OiByZXF1aXJlKCcuL0NvbW1lbnQnKSxcclxuICBET01FeGNlcHRpb246IHJlcXVpcmUoJy4vRE9NRXhjZXB0aW9uJyksXHJcbiAgRE9NSW1wbGVtZW50YXRpb246IHJlcXVpcmUoJy4vRE9NSW1wbGVtZW50YXRpb24nKSxcclxuICBET01Ub2tlbkxpc3Q6IHJlcXVpcmUoJy4vRE9NVG9rZW5MaXN0JyksXHJcbiAgRG9jdW1lbnQ6IHJlcXVpcmUoJy4vRG9jdW1lbnQnKSxcclxuICBEb2N1bWVudEZyYWdtZW50OiByZXF1aXJlKCcuL0RvY3VtZW50RnJhZ21lbnQnKSxcclxuICBEb2N1bWVudFR5cGU6IHJlcXVpcmUoJy4vRG9jdW1lbnRUeXBlJyksXHJcbiAgRWxlbWVudDogcmVxdWlyZSgnLi9FbGVtZW50JyksXHJcbiAgSFRNTFBhcnNlcjogcmVxdWlyZSgnLi9IVE1MUGFyc2VyJyksXHJcbiAgTm9kZTogcmVxdWlyZSgnLi9Ob2RlJyksXHJcbiAgTm9kZUxpc3Q6IHJlcXVpcmUoJy4vTm9kZUxpc3QnKSxcclxuICBOb2RlRmlsdGVyOiByZXF1aXJlKCcuL05vZGVGaWx0ZXInKSxcclxuICBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb246IHJlcXVpcmUoJy4vUHJvY2Vzc2luZ0luc3RydWN0aW9uJyksXHJcbiAgVGV4dDogcmVxdWlyZSgnLi9UZXh0JyksXHJcbiAgV2luZG93OiByZXF1aXJlKCcuL1dpbmRvdycpXHJcbn07XHJcblxyXG51dGlscy5tZXJnZShleHBvcnRzLCByZXF1aXJlKCcuL2V2ZW50cycpKTtcclxudXRpbHMubWVyZ2UoZXhwb3J0cywgcmVxdWlyZSgnLi9odG1sZWx0cycpLmVsZW1lbnRzKTtcclxudXRpbHMubWVyZ2UoZXhwb3J0cywgcmVxdWlyZSgnLi9zdmcnKS5lbGVtZW50cyk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kb21pbm8vbGliL2ltcGwuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIERvbWlubyB1c2VzIHNsb3BweS1tb2RlIGZlYXR1cmVzIChpbiBwYXJ0aWN1bGFyLCBgd2l0aGApIGZvciBhIGZld1xyXG4gKiBtaW5vciB0aGluZ3MuICBUaGlzIGZpbGUgZW5jYXBzdWxhdGVzIGFsbCB0aGUgc2xvcHBpbmVzczsgZXZlcnlcclxuICogb3RoZXIgbW9kdWxlIHNob3VsZCBiZSBzdHJpY3QuICovXHJcbi8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovXHJcbi8qIGpzaGludCBldmlsOiB0cnVlICovXHJcbi8qIGpzaGludCAtVzA4NSAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBXaW5kb3dfcnVuOiBmdW5jdGlvbiBfcnVuKGNvZGUsIGZpbGUpIHtcclxuICAgIGlmIChmaWxlKSBjb2RlICs9ICdcXG4vL0Agc291cmNlVVJMPScgKyBmaWxlO1xyXG4gICAgd2l0aCh0aGlzKSBldmFsKGNvZGUpO1xyXG4gIH0sXHJcbiAgRXZlbnRIYW5kbGVyQnVpbGRlcl9idWlsZDogZnVuY3Rpb24gYnVpbGQoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICB3aXRoKHRoaXMuZG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSlcclxuICAgICAgICB3aXRoKHRoaXMuZG9jdW1lbnQpXHJcbiAgICAgICAgICB3aXRoKHRoaXMuZm9ybSlcclxuICAgICAgICAgICAgd2l0aCh0aGlzLmVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgcmV0dXJuIGV2YWwoXCIoZnVuY3Rpb24oZXZlbnQpe1wiICsgdGhpcy5ib2R5ICsgXCJ9KVwiKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyB0aHJvdyBlcnI7IH07XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZG9taW5vL2xpYi9zbG9wcHkuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4vRWxlbWVudCcpO1xyXG52YXIgZGVmaW5lRWxlbWVudCA9IHJlcXVpcmUoJy4vZGVmaW5lRWxlbWVudCcpO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbnZhciBDU1NTdHlsZURlY2xhcmF0aW9uID0gcmVxdWlyZSgnLi9DU1NTdHlsZURlY2xhcmF0aW9uJyk7XHJcblxyXG52YXIgc3ZnRWxlbWVudHMgPSBleHBvcnRzLmVsZW1lbnRzID0ge307XHJcbnZhciBzdmdOYW1lVG9JbXBsID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHJcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICB2YXIgaW1wbCA9IHN2Z05hbWVUb0ltcGxbbG9jYWxOYW1lXSB8fCBTVkdFbGVtZW50O1xyXG4gIHJldHVybiBuZXcgaW1wbChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGRlZmluZShzcGVjKSB7XHJcbiAgcmV0dXJuIGRlZmluZUVsZW1lbnQoc3BlYywgU1ZHRWxlbWVudCwgc3ZnRWxlbWVudHMsIHN2Z05hbWVUb0ltcGwpO1xyXG59XHJcblxyXG52YXIgU1ZHRWxlbWVudCA9IGRlZmluZSh7XHJcbiAgc3VwZXJjbGFzczogRWxlbWVudCxcclxuICBjdG9yOiBmdW5jdGlvbiBTVkdFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcclxuICAgIEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgdXRpbHMuTkFNRVNQQUNFLlNWRywgcHJlZml4KTtcclxuICB9LFxyXG4gIHByb3BzOiB7XHJcbiAgICBzdHlsZTogeyBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoIXRoaXMuX3N0eWxlKVxyXG4gICAgICAgIHRoaXMuX3N0eWxlID0gbmV3IENTU1N0eWxlRGVjbGFyYXRpb24odGhpcyk7XHJcbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZTtcclxuICAgIH19XHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgY3RvcjogZnVuY3Rpb24gU1ZHU1ZHRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XHJcbiAgICBTVkdFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XHJcbiAgfSxcclxuICB0YWc6ICdzdmcnLFxyXG4gIHByb3BzOiB7XHJcbiAgICBjcmVhdGVTVkdSZWN0OiB7IHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBleHBvcnRzLmNyZWF0ZUVsZW1lbnQodGhpcy5vd25lckRvY3VtZW50LCAncmVjdCcsIG51bGwpO1xyXG4gICAgfSB9XHJcbiAgfVxyXG59KTtcclxuXHJcbmRlZmluZSh7XHJcbiAgdGFnczogW1xyXG4gICAgJ2EnLCAnYWx0R2x5cGgnLCAnYWx0R2x5cGhEZWYnLCAnYWx0R2x5cGhJdGVtJywgJ2FuaW1hdGUnLCAnYW5pbWF0ZUNvbG9yJywgJ2FuaW1hdGVNb3Rpb24nLCAnYW5pbWF0ZVRyYW5zZm9ybScsXHJcbiAgICAnY2lyY2xlJywgJ2NsaXBQYXRoJywgJ2NvbG9yLXByb2ZpbGUnLCAnY3Vyc29yJywgJ2RlZnMnLCAnZGVzYycsICdlbGxpcHNlJywgJ2ZlQmxlbmQnLCAnZmVDb2xvck1hdHJpeCcsXHJcbiAgICAnZmVDb21wb25lbnRUcmFuc2ZlcicsICdmZUNvbXBvc2l0ZScsICdmZUNvbnZvbHZlTWF0cml4JywgJ2ZlRGlmZnVzZUxpZ2h0aW5nJywgJ2ZlRGlzcGxhY2VtZW50TWFwJywgJ2ZlRGlzdGFudExpZ2h0JyxcclxuICAgICdmZUZsb29kJywgJ2ZlRnVuY0EnLCAnZmVGdW5jQicsICdmZUZ1bmNHJywgJ2ZlRnVuY1InLCAnZmVHYXVzc2lhbkJsdXInLCAnZmVJbWFnZScsICdmZU1lcmdlJywgJ2ZlTWVyZ2VOb2RlJyxcclxuICAgICdmZU1vcnBob2xvZ3knLCAnZmVPZmZzZXQnLCAnZmVQb2ludExpZ2h0JywgJ2ZlU3BlY3VsYXJMaWdodGluZycsICdmZVNwb3RMaWdodCcsICdmZVRpbGUnLCAnZmVUdXJidWxlbmNlJywgJ2ZpbHRlcicsXHJcbiAgICAnZm9udCcsICdmb250LWZhY2UnLCAnZm9udC1mYWNlLWZvcm1hdCcsICdmb250LWZhY2UtbmFtZScsICdmb250LWZhY2Utc3JjJywgJ2ZvbnQtZmFjZS11cmknLCAnZm9yZWlnbk9iamVjdCcsICdnJyxcclxuICAgICdnbHlwaCcsICdnbHlwaFJlZicsICdoa2VybicsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hcmtlcicsICdtYXNrJywgJ21ldGFkYXRhJywgJ21pc3NpbmctZ2x5cGgnLFxyXG4gICAgJ21wYXRoJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbEdyYWRpZW50JywgJ3JlY3QnLCAnc2NyaXB0JywgJ3NldCcsICdzdG9wJywgICdzdHlsZScsXHJcbiAgICAnc3dpdGNoJywgJ3N5bWJvbCcsICd0ZXh0JywgJ3RleHRQYXRoJywgJ3RpdGxlJywgJ3RyZWYnLCAndHNwYW4nLCAndXNlJywgJ3ZpZXcnLCAndmtlcm4nXHJcbiAgXVxyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvc3ZnLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSgxMSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYnVuZGxlcy9wbGF0Zm9ybS1icm93c2VyLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDEzMyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZmlyc3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1cmxcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ1cmxcIlxuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgU2VydmVyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tc2VydmVyJztcclxuaW1wb3J0IHsgQXBwTW9kdWxlU2hhcmVkIH0gZnJvbSAnLi9hcHAuc2hhcmVkLm1vZHVsZSc7XHJcbmltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9hcHAvYXBwLmNvbXBvbmVudCc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gICAgYm9vdHN0cmFwOiBbIEFwcENvbXBvbmVudCBdLFxyXG4gICAgaW1wb3J0czogW1xyXG4gICAgICAgIFNlcnZlck1vZHVsZSxcclxuICAgICAgICBBcHBNb2R1bGVTaGFyZWRcclxuICAgIF1cclxufSlcclxuZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9hcHAuc2VydmVyLm1vZHVsZS50cyIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKEMpIE1pY3Jvc29mdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbnZhciBSZWZsZWN0O1xyXG4oZnVuY3Rpb24gKFJlZmxlY3QpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbiAgICAvLyBmZWF0dXJlIHRlc3QgZm9yIFN5bWJvbCBzdXBwb3J0XHJcbiAgICB2YXIgc3VwcG9ydHNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCI7XHJcbiAgICB2YXIgdG9QcmltaXRpdmVTeW1ib2wgPSBzdXBwb3J0c1N5bWJvbCAmJiB0eXBlb2YgU3ltYm9sLnRvUHJpbWl0aXZlICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sLnRvUHJpbWl0aXZlIDogXCJAQHRvUHJpbWl0aXZlXCI7XHJcbiAgICB2YXIgaXRlcmF0b3JTeW1ib2wgPSBzdXBwb3J0c1N5bWJvbCAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sLml0ZXJhdG9yIDogXCJAQGl0ZXJhdG9yXCI7XHJcbiAgICB2YXIgSGFzaE1hcDtcclxuICAgIChmdW5jdGlvbiAoSGFzaE1hcCkge1xyXG4gICAgICAgIHZhciBzdXBwb3J0c0NyZWF0ZSA9IHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCI7IC8vIGZlYXR1cmUgdGVzdCBmb3IgT2JqZWN0LmNyZWF0ZSBzdXBwb3J0XHJcbiAgICAgICAgdmFyIHN1cHBvcnRzUHJvdG8gPSB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5OyAvLyBmZWF0dXJlIHRlc3QgZm9yIF9fcHJvdG9fXyBzdXBwb3J0XHJcbiAgICAgICAgdmFyIGRvd25MZXZlbCA9ICFzdXBwb3J0c0NyZWF0ZSAmJiAhc3VwcG9ydHNQcm90bztcclxuICAgICAgICAvLyBjcmVhdGUgYW4gb2JqZWN0IGluIGRpY3Rpb25hcnkgbW9kZSAoYS5rLmEuIFwic2xvd1wiIG1vZGUgaW4gdjgpXHJcbiAgICAgICAgSGFzaE1hcC5jcmVhdGUgPSBzdXBwb3J0c0NyZWF0ZVxyXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1ha2VEaWN0aW9uYXJ5KE9iamVjdC5jcmVhdGUobnVsbCkpOyB9XHJcbiAgICAgICAgICAgIDogc3VwcG9ydHNQcm90b1xyXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWtlRGljdGlvbmFyeSh7IF9fcHJvdG9fXzogbnVsbCB9KTsgfVxyXG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWtlRGljdGlvbmFyeSh7fSk7IH07XHJcbiAgICAgICAgSGFzaE1hcC5oYXMgPSBkb3duTGV2ZWxcclxuICAgICAgICAgICAgPyBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIGhhc093bi5jYWxsKG1hcCwga2V5KTsgfVxyXG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChtYXAsIGtleSkgeyByZXR1cm4ga2V5IGluIG1hcDsgfTtcclxuICAgICAgICBIYXNoTWFwLmdldCA9IGRvd25MZXZlbFxyXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChtYXAsIGtleSkgeyByZXR1cm4gaGFzT3duLmNhbGwobWFwLCBrZXkpID8gbWFwW2tleV0gOiB1bmRlZmluZWQ7IH1cclxuICAgICAgICAgICAgOiBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIG1hcFtrZXldOyB9O1xyXG4gICAgfSkoSGFzaE1hcCB8fCAoSGFzaE1hcCA9IHt9KSk7XHJcbiAgICAvLyBMb2FkIGdsb2JhbCBvciBzaGltIHZlcnNpb25zIG9mIE1hcCwgU2V0LCBhbmQgV2Vha01hcFxyXG4gICAgdmFyIGZ1bmN0aW9uUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKEZ1bmN0aW9uKTtcclxuICAgIHZhciB1c2VQb2x5ZmlsbCA9IHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52W1wiUkVGTEVDVF9NRVRBREFUQV9VU0VfTUFQX1BPTFlGSUxMXCJdID09PSBcInRydWVcIjtcclxuICAgIHZhciBfTWFwID0gIXVzZVBvbHlmaWxsICYmIHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgTWFwLnByb3RvdHlwZS5lbnRyaWVzID09PSBcImZ1bmN0aW9uXCIgPyBNYXAgOiBDcmVhdGVNYXBQb2x5ZmlsbCgpO1xyXG4gICAgdmFyIF9TZXQgPSAhdXNlUG9seWZpbGwgJiYgdHlwZW9mIFNldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTZXQucHJvdG90eXBlLmVudHJpZXMgPT09IFwiZnVuY3Rpb25cIiA/IFNldCA6IENyZWF0ZVNldFBvbHlmaWxsKCk7XHJcbiAgICB2YXIgX1dlYWtNYXAgPSAhdXNlUG9seWZpbGwgJiYgdHlwZW9mIFdlYWtNYXAgPT09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBDcmVhdGVXZWFrTWFwUG9seWZpbGwoKTtcclxuICAgIC8vIFtbTWV0YWRhdGFdXSBpbnRlcm5hbCBzbG90XHJcbiAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeS1vYmplY3QtaW50ZXJuYWwtbWV0aG9kcy1hbmQtaW50ZXJuYWwtc2xvdHNcclxuICAgIHZhciBNZXRhZGF0YSA9IG5ldyBfV2Vha01hcCgpO1xyXG4gICAgLyoqXHJcbiAgICAgICogQXBwbGllcyBhIHNldCBvZiBkZWNvcmF0b3JzIHRvIGEgcHJvcGVydHkgb2YgYSB0YXJnZXQgb2JqZWN0LlxyXG4gICAgICAqIEBwYXJhbSBkZWNvcmF0b3JzIEFuIGFycmF5IG9mIGRlY29yYXRvcnMuXHJcbiAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdC5cclxuICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IHRvIGRlY29yYXRlLlxyXG4gICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIHRoZSB0YXJnZXQga2V5LlxyXG4gICAgICAqIEByZW1hcmtzIERlY29yYXRvcnMgYXJlIGFwcGxpZWQgaW4gcmV2ZXJzZSBvcmRlci5cclxuICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgfVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICogICAgIEV4YW1wbGUgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnNBcnJheSwgRXhhbXBsZSk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnNBcnJheSwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnNBcnJheSwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIsXHJcbiAgICAgICogICAgICAgICBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnNBcnJheSwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIixcclxuICAgICAgKiAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpKSk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIixcclxuICAgICAgKiAgICAgICAgIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIixcclxuICAgICAgKiAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKSkpO1xyXG4gICAgICAqXHJcbiAgICAgICovXHJcbiAgICBmdW5jdGlvbiBkZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpIHtcclxuICAgICAgICAgICAgaWYgKCFJc0FycmF5KGRlY29yYXRvcnMpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QoYXR0cmlidXRlcykgJiYgIUlzVW5kZWZpbmVkKGF0dHJpYnV0ZXMpICYmICFJc051bGwoYXR0cmlidXRlcykpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIGlmIChJc051bGwoYXR0cmlidXRlcykpXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGVQcm9wZXJ0eShkZWNvcmF0b3JzLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghSXNBcnJheShkZWNvcmF0b3JzKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc0NvbnN0cnVjdG9yKHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0ZUNvbnN0cnVjdG9yKGRlY29yYXRvcnMsIHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgUmVmbGVjdC5kZWNvcmF0ZSA9IGRlY29yYXRlO1xyXG4gICAgLy8gNC4xLjIgUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSlcclxuICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI3JlZmxlY3QubWV0YWRhdGFcclxuICAgIC8qKlxyXG4gICAgICAqIEEgZGVmYXVsdCBtZXRhZGF0YSBkZWNvcmF0b3IgZmFjdG9yeSB0aGF0IGNhbiBiZSB1c2VkIG9uIGEgY2xhc3MsIGNsYXNzIG1lbWJlciwgb3IgcGFyYW1ldGVyLlxyXG4gICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBUaGUga2V5IGZvciB0aGUgbWV0YWRhdGEgZW50cnkuXHJcbiAgICAgICogQHBhcmFtIG1ldGFkYXRhVmFsdWUgVGhlIHZhbHVlIGZvciB0aGUgbWV0YWRhdGEgZW50cnkuXHJcbiAgICAgICogQHJldHVybnMgQSBkZWNvcmF0b3IgZnVuY3Rpb24uXHJcbiAgICAgICogQHJlbWFya3NcclxuICAgICAgKiBJZiBgbWV0YWRhdGFLZXlgIGlzIGFscmVhZHkgZGVmaW5lZCBmb3IgdGhlIHRhcmdldCBhbmQgdGFyZ2V0IGtleSwgdGhlXHJcbiAgICAgICogbWV0YWRhdGFWYWx1ZSBmb3IgdGhhdCBrZXkgd2lsbCBiZSBvdmVyd3JpdHRlbi5cclxuICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICogICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICB9XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yLCBUeXBlU2NyaXB0IG9ubHkpXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcclxuICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgKiAgICAgfVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUsIFR5cGVTY3JpcHQgb25seSlcclxuICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICogICAgICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxyXG4gICAgICAqICAgICAgICAgcHJvcGVydHk7XHJcbiAgICAgICogICAgIH1cclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgKiAgICAgICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXHJcbiAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKCkgeyB9XHJcbiAgICAgICogICAgIH1cclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICogICAgICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxyXG4gICAgICAqICAgICAgICAgbWV0aG9kKCkgeyB9XHJcbiAgICAgICogICAgIH1cclxuICAgICAgKlxyXG4gICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgICAgICBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpICYmICFJc1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWNvcmF0b3I7XHJcbiAgICB9XHJcbiAgICBSZWZsZWN0Lm1ldGFkYXRhID0gbWV0YWRhdGE7XHJcbiAgICAvKipcclxuICAgICAgKiBEZWZpbmUgYSB1bmlxdWUgbWV0YWRhdGEgZW50cnkgb24gdGhlIHRhcmdldC5cclxuICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICogQHBhcmFtIG1ldGFkYXRhVmFsdWUgQSB2YWx1ZSB0aGF0IGNvbnRhaW5zIGF0dGFjaGVkIG1ldGFkYXRhLlxyXG4gICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdG8gZGVmaW5lIG1ldGFkYXRhLlxyXG4gICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICogQGV4YW1wbGVcclxuICAgICAgKlxyXG4gICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAqXHJcbiAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgIH1cclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAqICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgb3B0aW9ucywgRXhhbXBsZSk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgb3B0aW9ucywgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgb3B0aW9ucywgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgb3B0aW9ucywgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIGRlY29yYXRvciBmYWN0b3J5IGFzIG1ldGFkYXRhLXByb2R1Y2luZyBhbm5vdGF0aW9uLlxyXG4gICAgICAqICAgICBmdW5jdGlvbiBNeUFubm90YXRpb24ob3B0aW9ucyk6IERlY29yYXRvciB7XHJcbiAgICAgICogICAgICAgICByZXR1cm4gKHRhcmdldCwga2V5PykgPT4gUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIHRhcmdldCwga2V5KTtcclxuICAgICAgKiAgICAgfVxyXG4gICAgICAqXHJcbiAgICAgICovXHJcbiAgICBmdW5jdGlvbiBkZWZpbmVNZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgIHJldHVybiBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcclxuICAgIH1cclxuICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEgPSBkZWZpbmVNZXRhZGF0YTtcclxuICAgIC8qKlxyXG4gICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbiBoYXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBkZWZpbmVkLlxyXG4gICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cclxuICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXRhZGF0YSBrZXkgd2FzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbjsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxyXG4gICAgICAqIEBleGFtcGxlXHJcbiAgICAgICpcclxuICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAqICAgICB9XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgKlxyXG4gICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcclxuICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICByZXR1cm4gT3JkaW5hcnlIYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICB9XHJcbiAgICBSZWZsZWN0Lmhhc01ldGFkYXRhID0gaGFzTWV0YWRhdGE7XHJcbiAgICAvKipcclxuICAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB0YXJnZXQgb2JqZWN0IGhhcyB0aGUgcHJvdmlkZWQgbWV0YWRhdGEga2V5IGRlZmluZWQuXHJcbiAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxyXG4gICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXHJcbiAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cclxuICAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG1ldGFkYXRhIGtleSB3YXMgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdDsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxyXG4gICAgICAqIEBleGFtcGxlXHJcbiAgICAgICpcclxuICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAqICAgICB9XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgKlxyXG4gICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcclxuICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICByZXR1cm4gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICB9XHJcbiAgICBSZWZsZWN0Lmhhc093bk1ldGFkYXRhID0gaGFzT3duTWV0YWRhdGE7XHJcbiAgICAvKipcclxuICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBvbiB0aGUgdGFyZ2V0IG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluLlxyXG4gICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cclxuICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICogQHJldHVybnMgVGhlIG1ldGFkYXRhIHZhbHVlIGZvciB0aGUgbWV0YWRhdGEga2V5IGlmIGZvdW5kOyBvdGhlcndpc2UsIGB1bmRlZmluZWRgLlxyXG4gICAgICAqIEBleGFtcGxlXHJcbiAgICAgICpcclxuICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAqICAgICB9XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgKlxyXG4gICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcclxuICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICB9XHJcbiAgICBSZWZsZWN0LmdldE1ldGFkYXRhID0gZ2V0TWV0YWRhdGE7XHJcbiAgICAvKipcclxuICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBvbiB0aGUgdGFyZ2V0IG9iamVjdC5cclxuICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cclxuICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAqIEByZXR1cm5zIFRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGtleSBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cclxuICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgfVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgfVxyXG4gICAgUmVmbGVjdC5nZXRPd25NZXRhZGF0YSA9IGdldE93bk1ldGFkYXRhO1xyXG4gICAgLyoqXHJcbiAgICAgICogR2V0cyB0aGUgbWV0YWRhdGEga2V5cyBkZWZpbmVkIG9uIHRoZSB0YXJnZXQgb2JqZWN0IG9yIGl0cyBwcm90b3R5cGUgY2hhaW4uXHJcbiAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cclxuICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHVuaXF1ZSBtZXRhZGF0YSBrZXlzLlxyXG4gICAgICAqIEBleGFtcGxlXHJcbiAgICAgICpcclxuICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAqICAgICB9XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZSk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldE1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgcmV0dXJuIE9yZGluYXJ5TWV0YWRhdGFLZXlzKHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgfVxyXG4gICAgUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMgPSBnZXRNZXRhZGF0YUtleXM7XHJcbiAgICAvKipcclxuICAgICAgKiBHZXRzIHRoZSB1bmlxdWUgbWV0YWRhdGEga2V5cyBkZWZpbmVkIG9uIHRoZSB0YXJnZXQgb2JqZWN0LlxyXG4gICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXHJcbiAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cclxuICAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB1bmlxdWUgbWV0YWRhdGEga2V5cy5cclxuICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgfVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xyXG4gICAgICAqXHJcbiAgICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgIHJldHVybiBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KTtcclxuICAgIH1cclxuICAgIFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzID0gZ2V0T3duTWV0YWRhdGFLZXlzO1xyXG4gICAgLyoqXHJcbiAgICAgICogRGVsZXRlcyB0aGUgbWV0YWRhdGEgZW50cnkgZnJvbSB0aGUgdGFyZ2V0IG9iamVjdCB3aXRoIHRoZSBwcm92aWRlZCBrZXkuXHJcbiAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxyXG4gICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXHJcbiAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cclxuICAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG1ldGFkYXRhIGVudHJ5IHdhcyBmb3VuZCBhbmQgZGVsZXRlZDsgb3RoZXJ3aXNlLCBmYWxzZS5cclxuICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgfVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRlbGV0ZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcCh0YXJnZXQsIHByb3BlcnR5S2V5LCAvKkNyZWF0ZSovIGZhbHNlKTtcclxuICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKCFtZXRhZGF0YU1hcC5kZWxldGUobWV0YWRhdGFLZXkpKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKG1ldGFkYXRhTWFwLnNpemUgPiAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBNZXRhZGF0YS5nZXQodGFyZ2V0KTtcclxuICAgICAgICB0YXJnZXRNZXRhZGF0YS5kZWxldGUocHJvcGVydHlLZXkpO1xyXG4gICAgICAgIGlmICh0YXJnZXRNZXRhZGF0YS5zaXplID4gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgTWV0YWRhdGEuZGVsZXRlKHRhcmdldCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhID0gZGVsZXRlTWV0YWRhdGE7XHJcbiAgICBmdW5jdGlvbiBEZWNvcmF0ZUNvbnN0cnVjdG9yKGRlY29yYXRvcnMsIHRhcmdldCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWNvcmF0b3IgPSBkZWNvcmF0b3JzW2ldO1xyXG4gICAgICAgICAgICB2YXIgZGVjb3JhdGVkID0gZGVjb3JhdG9yKHRhcmdldCk7XHJcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQoZGVjb3JhdGVkKSAmJiAhSXNOdWxsKGRlY29yYXRlZCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghSXNDb25zdHJ1Y3RvcihkZWNvcmF0ZWQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IGRlY29yYXRlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gRGVjb3JhdGVQcm9wZXJ0eShkZWNvcmF0b3JzLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgdmFyIGRlY29yYXRvciA9IGRlY29yYXRvcnNbaV07XHJcbiAgICAgICAgICAgIHZhciBkZWNvcmF0ZWQgPSBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcik7XHJcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQoZGVjb3JhdGVkKSAmJiAhSXNOdWxsKGRlY29yYXRlZCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QoZGVjb3JhdGVkKSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0gZGVjb3JhdGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBDcmVhdGUpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBNZXRhZGF0YS5nZXQoTyk7XHJcbiAgICAgICAgaWYgKElzVW5kZWZpbmVkKHRhcmdldE1ldGFkYXRhKSkge1xyXG4gICAgICAgICAgICBpZiAoIUNyZWF0ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRhcmdldE1ldGFkYXRhID0gbmV3IF9NYXAoKTtcclxuICAgICAgICAgICAgTWV0YWRhdGEuc2V0KE8sIHRhcmdldE1ldGFkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gdGFyZ2V0TWV0YWRhdGEuZ2V0KFApO1xyXG4gICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpIHtcclxuICAgICAgICAgICAgaWYgKCFDcmVhdGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBtZXRhZGF0YU1hcCA9IG5ldyBfTWFwKCk7XHJcbiAgICAgICAgICAgIHRhcmdldE1ldGFkYXRhLnNldChQLCBtZXRhZGF0YU1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXRhZGF0YU1hcDtcclxuICAgIH1cclxuICAgIC8vIDMuMS4xLjEgT3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcclxuICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5aGFzbWV0YWRhdGFcclxuICAgIGZ1bmN0aW9uIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcclxuICAgICAgICB2YXIgaGFzT3duID0gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XHJcbiAgICAgICAgaWYgKGhhc093bilcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTyk7XHJcbiAgICAgICAgaWYgKCFJc051bGwocGFyZW50KSlcclxuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gMy4xLjIuMSBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxyXG4gICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnloYXNvd25tZXRhZGF0YVxyXG4gICAgZnVuY3Rpb24gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xyXG4gICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLypDcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBUb0Jvb2xlYW4obWV0YWRhdGFNYXAuaGFzKE1ldGFkYXRhS2V5KSk7XHJcbiAgICB9XHJcbiAgICAvLyAzLjEuMy4xIE9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXHJcbiAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWdldG1ldGFkYXRhXHJcbiAgICBmdW5jdGlvbiBPcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSB7XHJcbiAgICAgICAgdmFyIGhhc093biA9IE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xyXG4gICAgICAgIGlmIChoYXNPd24pXHJcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcclxuICAgICAgICB2YXIgcGFyZW50ID0gT3JkaW5hcnlHZXRQcm90b3R5cGVPZihPKTtcclxuICAgICAgICBpZiAoIUlzTnVsbChwYXJlbnQpKVxyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLy8gMy4xLjQuMSBPcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxyXG4gICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnlnZXRvd25tZXRhZGF0YVxyXG4gICAgZnVuY3Rpb24gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xyXG4gICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLypDcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSlcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICByZXR1cm4gbWV0YWRhdGFNYXAuZ2V0KE1ldGFkYXRhS2V5KTtcclxuICAgIH1cclxuICAgIC8vIDMuMS41LjEgT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUClcclxuICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5ZGVmaW5lb3dubWV0YWRhdGFcclxuICAgIGZ1bmN0aW9uIE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApIHtcclxuICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gdHJ1ZSk7XHJcbiAgICAgICAgbWV0YWRhdGFNYXAuc2V0KE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlKTtcclxuICAgIH1cclxuICAgIC8vIDMuMS42LjEgT3JkaW5hcnlNZXRhZGF0YUtleXMoTywgUClcclxuICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5bWV0YWRhdGFrZXlzXHJcbiAgICBmdW5jdGlvbiBPcmRpbmFyeU1ldGFkYXRhS2V5cyhPLCBQKSB7XHJcbiAgICAgICAgdmFyIG93bktleXMgPSBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKTtcclxuICAgICAgICB2YXIgcGFyZW50ID0gT3JkaW5hcnlHZXRQcm90b3R5cGVPZihPKTtcclxuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gb3duS2V5cztcclxuICAgICAgICB2YXIgcGFyZW50S2V5cyA9IE9yZGluYXJ5TWV0YWRhdGFLZXlzKHBhcmVudCwgUCk7XHJcbiAgICAgICAgaWYgKHBhcmVudEtleXMubGVuZ3RoIDw9IDApXHJcbiAgICAgICAgICAgIHJldHVybiBvd25LZXlzO1xyXG4gICAgICAgIGlmIChvd25LZXlzLmxlbmd0aCA8PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50S2V5cztcclxuICAgICAgICB2YXIgc2V0ID0gbmV3IF9TZXQoKTtcclxuICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgb3duS2V5c18xID0gb3duS2V5czsgX2kgPCBvd25LZXlzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBvd25LZXlzXzFbX2ldO1xyXG4gICAgICAgICAgICB2YXIgaGFzS2V5ID0gc2V0LmhhcyhrZXkpO1xyXG4gICAgICAgICAgICBpZiAoIWhhc0tleSkge1xyXG4gICAgICAgICAgICAgICAgc2V0LmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBwYXJlbnRLZXlzXzEgPSBwYXJlbnRLZXlzOyBfYSA8IHBhcmVudEtleXNfMS5sZW5ndGg7IF9hKyspIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IHBhcmVudEtleXNfMVtfYV07XHJcbiAgICAgICAgICAgIHZhciBoYXNLZXkgPSBzZXQuaGFzKGtleSk7XHJcbiAgICAgICAgICAgIGlmICghaGFzS2V5KSB7XHJcbiAgICAgICAgICAgICAgICBzZXQuYWRkKGtleSk7XHJcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ga2V5cztcclxuICAgIH1cclxuICAgIC8vIDMuMS43LjEgT3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUClcclxuICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5b3dubWV0YWRhdGFrZXlzXHJcbiAgICBmdW5jdGlvbiBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKSB7XHJcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpXHJcbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgICAgIHZhciBrZXlzT2JqID0gbWV0YWRhdGFNYXAua2V5cygpO1xyXG4gICAgICAgIHZhciBpdGVyYXRvciA9IEdldEl0ZXJhdG9yKGtleXNPYmopO1xyXG4gICAgICAgIHZhciBrID0gMDtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICB2YXIgbmV4dCA9IEl0ZXJhdG9yU3RlcChpdGVyYXRvcik7XHJcbiAgICAgICAgICAgIGlmICghbmV4dCkge1xyXG4gICAgICAgICAgICAgICAga2V5cy5sZW5ndGggPSBrO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IEl0ZXJhdG9yVmFsdWUobmV4dCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBrZXlzW2tdID0gbmV4dFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBrKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gNiBFQ01BU2NyaXB0IERhdGEgVHlwMGVzIGFuZCBWYWx1ZXNcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtZGF0YS10eXBlcy1hbmQtdmFsdWVzXHJcbiAgICBmdW5jdGlvbiBUeXBlKHgpIHtcclxuICAgICAgICBpZiAoeCA9PT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIDEgLyogTnVsbCAqLztcclxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB4KSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjogcmV0dXJuIDAgLyogVW5kZWZpbmVkICovO1xyXG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOiByZXR1cm4gMiAvKiBCb29sZWFuICovO1xyXG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHJldHVybiAzIC8qIFN0cmluZyAqLztcclxuICAgICAgICAgICAgY2FzZSBcInN5bWJvbFwiOiByZXR1cm4gNCAvKiBTeW1ib2wgKi87XHJcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjogcmV0dXJuIDUgLyogTnVtYmVyICovO1xyXG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHJldHVybiB4ID09PSBudWxsID8gMSAvKiBOdWxsICovIDogNiAvKiBPYmplY3QgKi87XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiA2IC8qIE9iamVjdCAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyA2LjEuMSBUaGUgVW5kZWZpbmVkIFR5cGVcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMtdW5kZWZpbmVkLXR5cGVcclxuICAgIGZ1bmN0aW9uIElzVW5kZWZpbmVkKHgpIHtcclxuICAgICAgICByZXR1cm4geCA9PT0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLy8gNi4xLjIgVGhlIE51bGwgVHlwZVxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcy1udWxsLXR5cGVcclxuICAgIGZ1bmN0aW9uIElzTnVsbCh4KSB7XHJcbiAgICAgICAgcmV0dXJuIHggPT09IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyA2LjEuNSBUaGUgU3ltYm9sIFR5cGVcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMtc3ltYm9sLXR5cGVcclxuICAgIGZ1bmN0aW9uIElzU3ltYm9sKHgpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCI7XHJcbiAgICB9XHJcbiAgICAvLyA2LjEuNyBUaGUgT2JqZWN0IFR5cGVcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC10eXBlXHJcbiAgICBmdW5jdGlvbiBJc09iamVjdCh4KSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiID8geCAhPT0gbnVsbCA6IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XHJcbiAgICB9XHJcbiAgICAvLyA3LjEgVHlwZSBDb252ZXJzaW9uXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlLWNvbnZlcnNpb25cclxuICAgIC8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcclxuICAgIGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0LCBQcmVmZXJyZWRUeXBlKSB7XHJcbiAgICAgICAgc3dpdGNoIChUeXBlKGlucHV0KSkge1xyXG4gICAgICAgICAgICBjYXNlIDAgLyogVW5kZWZpbmVkICovOiByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgICAgIGNhc2UgMSAvKiBOdWxsICovOiByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgICAgIGNhc2UgMiAvKiBCb29sZWFuICovOiByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgICAgIGNhc2UgMyAvKiBTdHJpbmcgKi86IHJldHVybiBpbnB1dDtcclxuICAgICAgICAgICAgY2FzZSA0IC8qIFN5bWJvbCAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICBjYXNlIDUgLyogTnVtYmVyICovOiByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoaW50ID0gUHJlZmVycmVkVHlwZSA9PT0gMyAvKiBTdHJpbmcgKi8gPyBcInN0cmluZ1wiIDogUHJlZmVycmVkVHlwZSA9PT0gNSAvKiBOdW1iZXIgKi8gPyBcIm51bWJlclwiIDogXCJkZWZhdWx0XCI7XHJcbiAgICAgICAgdmFyIGV4b3RpY1RvUHJpbSA9IEdldE1ldGhvZChpbnB1dCwgdG9QcmltaXRpdmVTeW1ib2wpO1xyXG4gICAgICAgIGlmIChleG90aWNUb1ByaW0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZXhvdGljVG9QcmltLmNhbGwoaW5wdXQsIGhpbnQpO1xyXG4gICAgICAgICAgICBpZiAoSXNPYmplY3QocmVzdWx0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIGhpbnQgPT09IFwiZGVmYXVsdFwiID8gXCJudW1iZXJcIiA6IGhpbnQpO1xyXG4gICAgfVxyXG4gICAgLy8gNy4xLjEuMSBPcmRpbmFyeVRvUHJpbWl0aXZlKE8sIGhpbnQpXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXHJcbiAgICBmdW5jdGlvbiBPcmRpbmFyeVRvUHJpbWl0aXZlKE8sIGhpbnQpIHtcclxuICAgICAgICBpZiAoaGludCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB2YXIgdG9TdHJpbmdfMSA9IE8udG9TdHJpbmc7XHJcbiAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHRvU3RyaW5nXzEpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdG9TdHJpbmdfMS5jYWxsKE8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhbHVlT2YgPSBPLnZhbHVlT2Y7XHJcbiAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHZhbHVlT2YpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdmFsdWVPZi5jYWxsKE8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZU9mID0gTy52YWx1ZU9mO1xyXG4gICAgICAgICAgICBpZiAoSXNDYWxsYWJsZSh2YWx1ZU9mKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlT2YuY2FsbChPKTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QocmVzdWx0KSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0b1N0cmluZ18yID0gTy50b1N0cmluZztcclxuICAgICAgICAgICAgaWYgKElzQ2FsbGFibGUodG9TdHJpbmdfMikpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0b1N0cmluZ18yLmNhbGwoTyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICB9XHJcbiAgICAvLyA3LjEuMiBUb0Jvb2xlYW4oYXJndW1lbnQpXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvMjAxNi8jc2VjLXRvYm9vbGVhblxyXG4gICAgZnVuY3Rpb24gVG9Cb29sZWFuKGFyZ3VtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuICEhYXJndW1lbnQ7XHJcbiAgICB9XHJcbiAgICAvLyA3LjEuMTIgVG9TdHJpbmcoYXJndW1lbnQpXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3N0cmluZ1xyXG4gICAgZnVuY3Rpb24gVG9TdHJpbmcoYXJndW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gXCJcIiArIGFyZ3VtZW50O1xyXG4gICAgfVxyXG4gICAgLy8gNy4xLjE0IFRvUHJvcGVydHlLZXkoYXJndW1lbnQpXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XHJcbiAgICBmdW5jdGlvbiBUb1Byb3BlcnR5S2V5KGFyZ3VtZW50KSB7XHJcbiAgICAgICAgdmFyIGtleSA9IFRvUHJpbWl0aXZlKGFyZ3VtZW50LCAzIC8qIFN0cmluZyAqLyk7XHJcbiAgICAgICAgaWYgKElzU3ltYm9sKGtleSkpXHJcbiAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgcmV0dXJuIFRvU3RyaW5nKGtleSk7XHJcbiAgICB9XHJcbiAgICAvLyA3LjIgVGVzdGluZyBhbmQgQ29tcGFyaXNvbiBPcGVyYXRpb25zXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10ZXN0aW5nLWFuZC1jb21wYXJpc29uLW9wZXJhdGlvbnNcclxuICAgIC8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2FycmF5XHJcbiAgICBmdW5jdGlvbiBJc0FycmF5KGFyZ3VtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXlcclxuICAgICAgICAgICAgPyBBcnJheS5pc0FycmF5KGFyZ3VtZW50KVxyXG4gICAgICAgICAgICA6IGFyZ3VtZW50IGluc3RhbmNlb2YgT2JqZWN0XHJcbiAgICAgICAgICAgICAgICA/IGFyZ3VtZW50IGluc3RhbmNlb2YgQXJyYXlcclxuICAgICAgICAgICAgICAgIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xyXG4gICAgfVxyXG4gICAgLy8gNy4yLjMgSXNDYWxsYWJsZShhcmd1bWVudClcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcclxuICAgIGZ1bmN0aW9uIElzQ2FsbGFibGUoYXJndW1lbnQpIHtcclxuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGFuIGFwcHJveGltYXRpb24gYXMgd2UgY2Fubm90IGNoZWNrIGZvciBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2QuXHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PT0gXCJmdW5jdGlvblwiO1xyXG4gICAgfVxyXG4gICAgLy8gNy4yLjQgSXNDb25zdHJ1Y3Rvcihhcmd1bWVudClcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzY29uc3RydWN0b3JcclxuICAgIGZ1bmN0aW9uIElzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcclxuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGFuIGFwcHJveGltYXRpb24gYXMgd2UgY2Fubm90IGNoZWNrIGZvciBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZC5cclxuICAgICAgICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09PSBcImZ1bmN0aW9uXCI7XHJcbiAgICB9XHJcbiAgICAvLyA3LjIuNyBJc1Byb3BlcnR5S2V5KGFyZ3VtZW50KVxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNwcm9wZXJ0eWtleVxyXG4gICAgZnVuY3Rpb24gSXNQcm9wZXJ0eUtleShhcmd1bWVudCkge1xyXG4gICAgICAgIHN3aXRjaCAoVHlwZShhcmd1bWVudCkpIHtcclxuICAgICAgICAgICAgY2FzZSAzIC8qIFN0cmluZyAqLzogcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGNhc2UgNCAvKiBTeW1ib2wgKi86IHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gNy4zIE9wZXJhdGlvbnMgb24gT2JqZWN0c1xyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3BlcmF0aW9ucy1vbi1vYmplY3RzXHJcbiAgICAvLyA3LjMuOSBHZXRNZXRob2QoViwgUClcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxyXG4gICAgZnVuY3Rpb24gR2V0TWV0aG9kKFYsIFApIHtcclxuICAgICAgICB2YXIgZnVuYyA9IFZbUF07XHJcbiAgICAgICAgaWYgKGZ1bmMgPT09IHVuZGVmaW5lZCB8fCBmdW5jID09PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmICghSXNDYWxsYWJsZShmdW5jKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIHJldHVybiBmdW5jO1xyXG4gICAgfVxyXG4gICAgLy8gNy40IE9wZXJhdGlvbnMgb24gSXRlcmF0b3IgT2JqZWN0c1xyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3BlcmF0aW9ucy1vbi1pdGVyYXRvci1vYmplY3RzXHJcbiAgICBmdW5jdGlvbiBHZXRJdGVyYXRvcihvYmopIHtcclxuICAgICAgICB2YXIgbWV0aG9kID0gR2V0TWV0aG9kKG9iaiwgaXRlcmF0b3JTeW1ib2wpO1xyXG4gICAgICAgIGlmICghSXNDYWxsYWJsZShtZXRob2QpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IC8vIGZyb20gQ2FsbFxyXG4gICAgICAgIHZhciBpdGVyYXRvciA9IG1ldGhvZC5jYWxsKG9iaik7XHJcbiAgICAgICAgaWYgKCFJc09iamVjdChpdGVyYXRvcikpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgICB9XHJcbiAgICAvLyA3LjQuNCBJdGVyYXRvclZhbHVlKGl0ZXJSZXN1bHQpXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvMjAxNi8jc2VjLWl0ZXJhdG9ydmFsdWVcclxuICAgIGZ1bmN0aW9uIEl0ZXJhdG9yVmFsdWUoaXRlclJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiBpdGVyUmVzdWx0LnZhbHVlO1xyXG4gICAgfVxyXG4gICAgLy8gNy40LjUgSXRlcmF0b3JTdGVwKGl0ZXJhdG9yKVxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXRlcmF0b3JzdGVwXHJcbiAgICBmdW5jdGlvbiBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IGZhbHNlIDogcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yY2xvc2VcclxuICAgIGZ1bmN0aW9uIEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpIHtcclxuICAgICAgICB2YXIgZiA9IGl0ZXJhdG9yW1wicmV0dXJuXCJdO1xyXG4gICAgICAgIGlmIChmKVxyXG4gICAgICAgICAgICBmLmNhbGwoaXRlcmF0b3IpO1xyXG4gICAgfVxyXG4gICAgLy8gOS4xIE9yZGluYXJ5IE9iamVjdCBJbnRlcm5hbCBNZXRob2RzIGFuZCBJbnRlcm5hbCBTbG90c1xyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnktb2JqZWN0LWludGVybmFsLW1ldGhvZHMtYW5kLWludGVybmFsLXNsb3RzXHJcbiAgICAvLyA5LjEuMS4xIE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTylcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9yZGluYXJ5Z2V0cHJvdG90eXBlb2ZcclxuICAgIGZ1bmN0aW9uIE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTykge1xyXG4gICAgICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKTtcclxuICAgICAgICBpZiAodHlwZW9mIE8gIT09IFwiZnVuY3Rpb25cIiB8fCBPID09PSBmdW5jdGlvblByb3RvdHlwZSlcclxuICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgIC8vIFR5cGVTY3JpcHQgZG9lc24ndCBzZXQgX19wcm90b19fIGluIEVTNSwgYXMgaXQncyBub24tc3RhbmRhcmQuXHJcbiAgICAgICAgLy8gVHJ5IHRvIGRldGVybWluZSB0aGUgc3VwZXJjbGFzcyBjb25zdHJ1Y3Rvci4gQ29tcGF0aWJsZSBpbXBsZW1lbnRhdGlvbnNcclxuICAgICAgICAvLyBtdXN0IGVpdGhlciBzZXQgX19wcm90b19fIG9uIGEgc3ViY2xhc3MgY29uc3RydWN0b3IgdG8gdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3IsXHJcbiAgICAgICAgLy8gb3IgZW5zdXJlIGVhY2ggY2xhc3MgaGFzIGEgdmFsaWQgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBvbiBpdHMgcHJvdG90eXBlIHRoYXRcclxuICAgICAgICAvLyBwb2ludHMgYmFjayB0byB0aGUgY29uc3RydWN0b3IuXHJcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgRnVuY3Rpb24uW1tQcm90b3R5cGVdXSwgdGhlbiB0aGlzIGlzIGRlZmluYXRlbHkgaW5oZXJpdGVkLlxyXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGNhc2Ugd2hlbiBpbiBFUzYgb3Igd2hlbiB1c2luZyBfX3Byb3RvX18gaW4gYSBjb21wYXRpYmxlIGJyb3dzZXIuXHJcbiAgICAgICAgaWYgKHByb3RvICE9PSBmdW5jdGlvblByb3RvdHlwZSlcclxuICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgIC8vIElmIHRoZSBzdXBlciBwcm90b3R5cGUgaXMgT2JqZWN0LnByb3RvdHlwZSwgbnVsbCwgb3IgdW5kZWZpbmVkLCB0aGVuIHdlIGNhbm5vdCBkZXRlcm1pbmUgdGhlIGhlcml0YWdlLlxyXG4gICAgICAgIHZhciBwcm90b3R5cGUgPSBPLnByb3RvdHlwZTtcclxuICAgICAgICB2YXIgcHJvdG90eXBlUHJvdG8gPSBwcm90b3R5cGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSk7XHJcbiAgICAgICAgaWYgKHByb3RvdHlwZVByb3RvID09IG51bGwgfHwgcHJvdG90eXBlUHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUpXHJcbiAgICAgICAgICAgIHJldHVybiBwcm90bztcclxuICAgICAgICAvLyBJZiB0aGUgY29uc3RydWN0b3Igd2FzIG5vdCBhIGZ1bmN0aW9uLCB0aGVuIHdlIGNhbm5vdCBkZXRlcm1pbmUgdGhlIGhlcml0YWdlLlxyXG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHByb3RvdHlwZVByb3RvLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29uc3RydWN0b3IgIT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgIC8vIElmIHdlIGhhdmUgc29tZSBraW5kIG9mIHNlbGYtcmVmZXJlbmNlLCB0aGVuIHdlIGNhbm5vdCBkZXRlcm1pbmUgdGhlIGhlcml0YWdlLlxyXG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gTylcclxuICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgIC8vIHdlIGhhdmUgYSBwcmV0dHkgZ29vZCBndWVzcyBhdCB0aGUgaGVyaXRhZ2UuXHJcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xyXG4gICAgfVxyXG4gICAgLy8gbmFpdmUgTWFwIHNoaW1cclxuICAgIGZ1bmN0aW9uIENyZWF0ZU1hcFBvbHlmaWxsKCkge1xyXG4gICAgICAgIHZhciBjYWNoZVNlbnRpbmVsID0ge307XHJcbiAgICAgICAgdmFyIGFycmF5U2VudGluZWwgPSBbXTtcclxuICAgICAgICB2YXIgTWFwSXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBNYXBJdGVyYXRvcihrZXlzLCB2YWx1ZXMsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0ga2V5cztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlW1wiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XHJcbiAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xyXG4gICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2luZGV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9rZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9zZWxlY3Rvcih0aGlzLl9rZXlzW2luZGV4XSwgdGhpcy5fdmFsdWVzW2luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICsgMSA+PSB0aGlzLl9rZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gYXJyYXlTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gYXJyYXlTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiByZXN1bHQsIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS50aHJvdyA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBhcnJheVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IGFycmF5U2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLnJldHVybiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBhcnJheVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IGFycmF5U2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIE1hcEl0ZXJhdG9yO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIE1hcCgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXkgPSBjYWNoZVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IC0yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXAucHJvdG90eXBlLCBcInNpemVcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9rZXlzLmxlbmd0aDsgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gZmFsc2UpID49IDA7IH07XHJcbiAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyB0aGlzLl92YWx1ZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmQoa2V5LCAvKmluc2VydCovIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLl9rZXlzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXggKyAxOyBpIDwgc2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXNbaSAtIDFdID0gdGhpcy5fa2V5c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzW2kgLSAxXSA9IHRoaXMuX3ZhbHVlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cy5sZW5ndGgtLTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoLS07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gdGhpcy5fY2FjaGVLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXkgPSBjYWNoZVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gLTI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5cy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUtleSA9IGNhY2hlU2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gLTI7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1hcC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMsIGdldEtleSk7IH07XHJcbiAgICAgICAgICAgIE1hcC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMuX2tleXMsIHRoaXMuX3ZhbHVlcywgZ2V0VmFsdWUpOyB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRFbnRyeSk7IH07XHJcbiAgICAgICAgICAgIE1hcC5wcm90b3R5cGVbXCJAQGl0ZXJhdG9yXCJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzKCk7IH07XHJcbiAgICAgICAgICAgIE1hcC5wcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzKCk7IH07XHJcbiAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuX2ZpbmQgPSBmdW5jdGlvbiAoa2V5LCBpbnNlcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZUtleSAhPT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IHRoaXMuX2tleXMuaW5kZXhPZih0aGlzLl9jYWNoZUtleSA9IGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVJbmRleCA8IDAgJiYgaW5zZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IHRoaXMuX2tleXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVJbmRleDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIE1hcDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldEtleShrZXksIF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0VmFsdWUoXywgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBnZXRFbnRyeShrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBba2V5LCB2YWx1ZV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gbmFpdmUgU2V0IHNoaW1cclxuICAgIGZ1bmN0aW9uIENyZWF0ZVNldFBvbHlmaWxsKCkge1xyXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTZXQoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAgPSBuZXcgX01hcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXQucHJvdG90eXBlLCBcInNpemVcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAuc2l6ZTsgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0aGlzLl9tYXAuaGFzKHZhbHVlKTsgfTtcclxuICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuX21hcC5zZXQodmFsdWUsIHZhbHVlKSwgdGhpczsgfTtcclxuICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuX21hcC5kZWxldGUodmFsdWUpOyB9O1xyXG4gICAgICAgICAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9tYXAuY2xlYXIoKTsgfTtcclxuICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTsgfTtcclxuICAgICAgICAgICAgU2V0LnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAudmFsdWVzKCk7IH07XHJcbiAgICAgICAgICAgIFNldC5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcC5lbnRyaWVzKCk7IH07XHJcbiAgICAgICAgICAgIFNldC5wcm90b3R5cGVbXCJAQGl0ZXJhdG9yXCJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5rZXlzKCk7IH07XHJcbiAgICAgICAgICAgIFNldC5wcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5rZXlzKCk7IH07XHJcbiAgICAgICAgICAgIHJldHVybiBTZXQ7XHJcbiAgICAgICAgfSgpKTtcclxuICAgIH1cclxuICAgIC8vIG5haXZlIFdlYWtNYXAgc2hpbVxyXG4gICAgZnVuY3Rpb24gQ3JlYXRlV2Vha01hcFBvbHlmaWxsKCkge1xyXG4gICAgICAgIHZhciBVVUlEX1NJWkUgPSAxNjtcclxuICAgICAgICB2YXIga2V5cyA9IEhhc2hNYXAuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIHJvb3RLZXkgPSBDcmVhdGVVbmlxdWVLZXkoKTtcclxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gV2Vha01hcCgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tleSA9IENyZWF0ZVVuaXF1ZUtleSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUgIT09IHVuZGVmaW5lZCA/IEhhc2hNYXAuaGFzKHRhYmxlLCB0aGlzLl9rZXkpIDogZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUgIT09IHVuZGVmaW5lZCA/IEhhc2hNYXAuZ2V0KHRhYmxlLCB0aGlzLl9rZXkpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCAvKmNyZWF0ZSovIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGFibGVbdGhpcy5fa2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUgIT09IHVuZGVmaW5lZCA/IGRlbGV0ZSB0YWJsZVt0aGlzLl9rZXldIDogZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTk9URTogbm90IGEgcmVhbCBjbGVhciwganVzdCBtYWtlcyB0aGUgcHJldmlvdXMgZGF0YSB1bnJlYWNoYWJsZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5ID0gQ3JlYXRlVW5pcXVlS2V5KCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBXZWFrTWFwO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgZnVuY3Rpb24gQ3JlYXRlVW5pcXVlS2V5KCkge1xyXG4gICAgICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgICAgICBkb1xyXG4gICAgICAgICAgICAgICAga2V5ID0gXCJAQFdlYWtNYXBAQFwiICsgQ3JlYXRlVVVJRCgpO1xyXG4gICAgICAgICAgICB3aGlsZSAoSGFzaE1hcC5oYXMoa2V5cywga2V5KSk7XHJcbiAgICAgICAgICAgIGtleXNba2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgY3JlYXRlKSB7XHJcbiAgICAgICAgICAgIGlmICghaGFzT3duLmNhbGwodGFyZ2V0LCByb290S2V5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjcmVhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHJvb3RLZXksIHsgdmFsdWU6IEhhc2hNYXAuY3JlYXRlKCkgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtyb290S2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gRmlsbFJhbmRvbUJ5dGVzKGJ1ZmZlciwgc2l6ZSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSlcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpXSA9IE1hdGgucmFuZG9tKCkgKiAweGZmIHwgMDtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gR2VuUmFuZG9tQnl0ZXMoc2l6ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtc0NyeXB0byAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHNpemUpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBGaWxsUmFuZG9tQnl0ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSksIHNpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBGaWxsUmFuZG9tQnl0ZXMobmV3IEFycmF5KHNpemUpLCBzaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gQ3JlYXRlVVVJRCgpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBHZW5SYW5kb21CeXRlcyhVVUlEX1NJWkUpO1xyXG4gICAgICAgICAgICAvLyBtYXJrIGFzIHJhbmRvbSAtIFJGQyA0MTIyIMKnIDQuNFxyXG4gICAgICAgICAgICBkYXRhWzZdID0gZGF0YVs2XSAmIDB4NGYgfCAweDQwO1xyXG4gICAgICAgICAgICBkYXRhWzhdID0gZGF0YVs4XSAmIDB4YmYgfCAweDgwO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgVVVJRF9TSVpFOyArK29mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJ5dGUgPSBkYXRhW29mZnNldF07XHJcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09PSA0IHx8IG9mZnNldCA9PT0gNiB8fCBvZmZzZXQgPT09IDgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiLVwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ5dGUgPCAxNilcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIwXCI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gYnl0ZS50b1N0cmluZygxNikudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHVzZXMgYSBoZXVyaXN0aWMgdXNlZCBieSB2OCBhbmQgY2hha3JhIHRvIGZvcmNlIGFuIG9iamVjdCBpbnRvIGRpY3Rpb25hcnkgbW9kZS5cclxuICAgIGZ1bmN0aW9uIE1ha2VEaWN0aW9uYXJ5KG9iaikge1xyXG4gICAgICAgIG9iai5fXyA9IHVuZGVmaW5lZDtcclxuICAgICAgICBkZWxldGUgb2JqLl9fO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbiAgICAvLyBwYXRjaCBnbG9iYWwgUmVmbGVjdFxyXG4gICAgKGZ1bmN0aW9uIChfX2dsb2JhbCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgX19nbG9iYWwuUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICBpZiAoX19nbG9iYWwuUmVmbGVjdCAhPT0gUmVmbGVjdCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBSZWZsZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKFJlZmxlY3QsIHApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZ2xvYmFsLlJlZmxlY3RbcF0gPSBSZWZsZWN0W3BdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX19nbG9iYWwuUmVmbGVjdCA9IFJlZmxlY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgfSkodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6XHJcbiAgICAgICAgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDpcclxuICAgICAgICAgICAgRnVuY3Rpb24oXCJyZXR1cm4gdGhpcztcIikoKSk7XHJcbn0pKFJlZmxlY3QgfHwgKFJlZmxlY3QgPSB7fSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWZsZWN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWZsZWN0LW1ldGFkYXRhL1JlZmxlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xyXG52YXIgZmlyc3RfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2ZpcnN0Jyk7XHJcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5maXJzdCA9IGZpcnN0XzEuZmlyc3Q7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpcnN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9maXJzdC5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoNzcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9hc3BuZXQtcHJlcmVuZGVyaW5nL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoODQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy96b25lLmpzL2Rpc3Qvem9uZS1ub2RlLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjUuMi4yXHJcbiAqIChjKSAyMDEwLTIwMTggR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cclxuICogTGljZW5zZTogTUlUXHJcbiAqL1xyXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpLCByZXF1aXJlKCdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvYW5pbWF0aW9ucy9icm93c2VyJykpIDpcclxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucycsIFsnZXhwb3J0cycsICdAYW5ndWxhci9jb3JlJywgJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInLCAnQGFuZ3VsYXIvYW5pbWF0aW9ucycsICdAYW5ndWxhci9hbmltYXRpb25zL2Jyb3dzZXInXSwgZmFjdG9yeSkgOlxyXG5cdChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5wbGF0Zm9ybUJyb3dzZXIgPSBnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyIHx8IHt9LCBnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyLmFuaW1hdGlvbnMgPSB7fSksZ2xvYmFsLm5nLmNvcmUsZ2xvYmFsLm5nLnBsYXRmb3JtQnJvd3NlcixnbG9iYWwubmcuYW5pbWF0aW9ucyxnbG9iYWwubmcuYW5pbWF0aW9ucy5icm93c2VyKSk7XHJcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvcmUsX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLF9hbmd1bGFyX2FuaW1hdGlvbnMsX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyKSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG4vKipcclxuICogQGxpY2Vuc2UgQW5ndWxhciB2NS4yLjJcclxuICogKGMpIDIwMTAtMjAxOCBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xyXG4gKiBMaWNlbnNlOiBNSVRcclxuICovXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxudmFyIEJyb3dzZXJBbmltYXRpb25CdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJyb3dzZXJBbmltYXRpb25CdWlsZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXIocm9vdFJlbmRlcmVyLCBkb2MpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl9uZXh0QW5pbWF0aW9uSWQgPSAwO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGVEYXRhID0gLyoqIEB0eXBlIHs/fSAqLyAoe1xyXG4gICAgICAgICAgICBpZDogJzAnLFxyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgIHN0eWxlczogW10sXHJcbiAgICAgICAgICAgIGRhdGE6IHsgYW5pbWF0aW9uOiBbXSB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgX3RoaXMuX3JlbmRlcmVyID0gLyoqIEB0eXBlIHs/fSAqLyAocm9vdFJlbmRlcmVyLmNyZWF0ZVJlbmRlcmVyKGRvYy5ib2R5LCB0eXBlRGF0YSkpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBhbmltYXRpb25cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJBbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBhbmltYXRpb25cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChhbmltYXRpb24pIHtcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9IHRoaXMuX25leHRBbmltYXRpb25JZC50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuX25leHRBbmltYXRpb25JZCsrO1xyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5ID0gQXJyYXkuaXNBcnJheShhbmltYXRpb24pID8gX2FuZ3VsYXJfYW5pbWF0aW9ucy5zZXF1ZW5jZShhbmltYXRpb24pIDogYW5pbWF0aW9uO1xyXG4gICAgICAgIGlzc3VlQW5pbWF0aW9uQ29tbWFuZCh0aGlzLl9yZW5kZXJlciwgbnVsbCwgaWQsICdyZWdpc3RlcicsIFtlbnRyeV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgQnJvd3NlckFuaW1hdGlvbkZhY3RvcnkoaWQsIHRoaXMuX3JlbmRlcmVyKTtcclxuICAgIH07XHJcbiAgICBCcm93c2VyQW5pbWF0aW9uQnVpbGRlci5kZWNvcmF0b3JzID0gW1xyXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXHJcbiAgICBdO1xyXG4gICAgLyoqIEBub2NvbGxhcHNlICovXHJcbiAgICBCcm93c2VyQW5pbWF0aW9uQnVpbGRlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcclxuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJGYWN0b3J5MiwgfSxcclxuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuRE9DVU1FTlQsXSB9LF0gfSxcclxuICAgIF07IH07XHJcbiAgICByZXR1cm4gQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXI7XHJcbn0oX2FuZ3VsYXJfYW5pbWF0aW9ucy5BbmltYXRpb25CdWlsZGVyKSk7XHJcbnZhciBCcm93c2VyQW5pbWF0aW9uRmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhCcm93c2VyQW5pbWF0aW9uRmFjdG9yeSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJyb3dzZXJBbmltYXRpb25GYWN0b3J5KF9pZCwgX3JlbmRlcmVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5faWQgPSBfaWQ7XHJcbiAgICAgICAgX3RoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCcm93c2VyQW5pbWF0aW9uRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJlckFuaW1hdGlvblBsYXllcih0aGlzLl9pZCwgZWxlbWVudCwgb3B0aW9ucyB8fCB7fSwgdGhpcy5fcmVuZGVyZXIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCcm93c2VyQW5pbWF0aW9uRmFjdG9yeTtcclxufShfYW5ndWxhcl9hbmltYXRpb25zLkFuaW1hdGlvbkZhY3RvcnkpKTtcclxudmFyIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIoaWQsIGVsZW1lbnQsIG9wdGlvbnMsIF9yZW5kZXJlcikge1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xyXG4gICAgICAgIHRoaXMucGFyZW50UGxheWVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50b3RhbFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2NvbW1hbmQoJ2NyZWF0ZScsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50TmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLl9saXN0ZW4gPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZXZlbnROYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5saXN0ZW4odGhpcy5lbGVtZW50LCBcIkBAXCIgKyB0aGlzLmlkICsgXCI6XCIgKyBldmVudE5hbWUsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gY29tbWFuZFxyXG4gICAgICogQHBhcmFtIHsuLi4/fSBhcmdzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuX2NvbW1hbmQgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gY29tbWFuZFxyXG4gICAgICogQHBhcmFtIHsuLi4/fSBhcmdzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoY29tbWFuZCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzc3VlQW5pbWF0aW9uQ29tbWFuZCh0aGlzLl9yZW5kZXJlciwgdGhpcy5lbGVtZW50LCB0aGlzLmlkLCBjb21tYW5kLCBhcmdzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZm5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZm5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChmbikgeyB0aGlzLl9saXN0ZW4oJ2RvbmUnLCBmbik7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZm5cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5vblN0YXJ0ID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGZuXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fbGlzdGVuKCdzdGFydCcsIGZuKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBmblxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uRGVzdHJveSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBmblxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGZuKSB7IHRoaXMuX2xpc3RlbignZGVzdHJveScsIGZuKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmluaXQgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5fY29tbWFuZCgnaW5pdCcpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhcnRlZDsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnBsYXkgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9jb21tYW5kKCdwbGF5Jyk7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucGF1c2UgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5fY29tbWFuZCgncGF1c2UnKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5fY29tbWFuZCgncmVzdGFydCcpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZmluaXNoID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IHRoaXMuX2NvbW1hbmQoJ2ZpbmlzaCcpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZGVzdHJveSA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkgeyB0aGlzLl9jb21tYW5kKCdkZXN0cm95Jyk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5yZXNldCA9IC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKCkgeyB0aGlzLl9jb21tYW5kKCdyZXNldCcpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHBcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBwXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAocCkgeyB0aGlzLl9jb21tYW5kKCdzZXRQb3NpdGlvbicsIHApOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH07XHJcbiAgICByZXR1cm4gUmVuZGVyZXJBbmltYXRpb25QbGF5ZXI7XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHJlbmRlcmVyXHJcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxyXG4gKiBAcGFyYW0gez99IGlkXHJcbiAqIEBwYXJhbSB7P30gY29tbWFuZFxyXG4gKiBAcGFyYW0gez99IGFyZ3NcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGlzc3VlQW5pbWF0aW9uQ29tbWFuZChyZW5kZXJlciwgZWxlbWVudCwgaWQsIGNvbW1hbmQsIGFyZ3MpIHtcclxuICAgIHJldHVybiByZW5kZXJlci5zZXRQcm9wZXJ0eShlbGVtZW50LCBcIkBAXCIgKyBpZCArIFwiOlwiICsgY29tbWFuZCwgYXJncyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxudmFyIEFOSU1BVElPTl9QUkVGSVggPSAnQCc7XHJcbnZhciBESVNBQkxFX0FOSU1BVElPTlNfRkxBRyA9ICdALmRpc2FibGVkJztcclxudmFyIEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeShkZWxlZ2F0ZSwgZW5naW5lLCBfem9uZSkge1xyXG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcclxuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudElkID0gMDtcclxuICAgICAgICB0aGlzLl9taWNyb3Rhc2tJZCA9IDE7XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ2FsbGJhY2tzQnVmZmVyID0gW107XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXJDYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9jZFJlY3VyRGVwdGggPSAwO1xyXG4gICAgICAgIGVuZ2luZS5vblJlbW92YWxDb21wbGV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBkZWxlZ2F0ZSkge1xyXG4gICAgICAgICAgICAvLyBOb3RlOiBpZiBhbiBjb21wb25lbnQgZWxlbWVudCBoYXMgYSBsZWF2ZSBhbmltYXRpb24sIGFuZCB0aGUgY29tcG9uZW50XHJcbiAgICAgICAgICAgIC8vIGEgaG9zdCBsZWF2ZSBhbmltYXRpb24sIHRoZSB2aWV3IGVuZ2luZSB3aWxsIGNhbGwgYHJlbW92ZUNoaWxkYCBmb3IgdGhlIHBhcmVudFxyXG4gICAgICAgICAgICAvLyBjb21wb25lbnQgcmVuZGVyZXIgYXMgd2VsbCBhcyBmb3IgdGhlIGNoaWxkIGNvbXBvbmVudCByZW5kZXJlci5cclxuICAgICAgICAgICAgLy8gVGhlcmVmb3JlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGFscmVhZHkgcmVtb3ZlZCB0aGUgZWxlbWVudC5cclxuICAgICAgICAgICAgaWYgKGRlbGVnYXRlICYmIGRlbGVnYXRlLnBhcmVudE5vZGUoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIGRlbGVnYXRlLnJlbW92ZUNoaWxkKGVsZW1lbnQucGFyZW50Tm9kZSwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlUmVuZGVyZXIgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gaG9zdEVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGhvc3RFbGVtZW50LCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBFTVBUWV9OQU1FU1BBQ0VfSUQgPSAnJztcclxuICAgICAgICAvLyBjYWNoZSB0aGUgZGVsZWdhdGVzIHRvIGZpbmQgb3V0IHdoaWNoIGNhY2hlZCBkZWxlZ2F0ZSBjYW5cclxuICAgICAgICAvLyBiZSB1c2VkIGJ5IHdoaWNoIGNhY2hlZCByZW5kZXJlclxyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlbGVnYXRlID0gdGhpcy5kZWxlZ2F0ZS5jcmVhdGVSZW5kZXJlcihob3N0RWxlbWVudCwgdHlwZSk7XHJcbiAgICAgICAgaWYgKCFob3N0RWxlbWVudCB8fCAhdHlwZSB8fCAhdHlwZS5kYXRhIHx8ICF0eXBlLmRhdGFbJ2FuaW1hdGlvbiddKSB7XHJcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJDYWNoZS5nZXQoZGVsZWdhdGUpO1xyXG4gICAgICAgICAgICBpZiAoIXJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlciA9IG5ldyBCYXNlQW5pbWF0aW9uUmVuZGVyZXIoRU1QVFlfTkFNRVNQQUNFX0lELCBkZWxlZ2F0ZSwgdGhpcy5lbmdpbmUpO1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSBjYWNoZSB0aGlzIHJlc3VsdCB3aGVuIHRoZSBiYXNlIHJlbmRlcmVyIGlzIHVzZWRcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyQ2FjaGUuc2V0KGRlbGVnYXRlLCByZW5kZXJlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRJZCA9IHR5cGUuaWQ7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZXNwYWNlSWQgPSB0eXBlLmlkICsgJy0nICsgdGhpcy5fY3VycmVudElkO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRJZCsrO1xyXG4gICAgICAgIHRoaXMuZW5naW5lLnJlZ2lzdGVyKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCk7XHJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5pbWF0aW9uVHJpZ2dlcnMgPSAvKiogQHR5cGUgez99ICovICh0eXBlLmRhdGFbJ2FuaW1hdGlvbiddKTtcclxuICAgICAgICBhbmltYXRpb25UcmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0cmlnZ2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbmdpbmUucmVnaXN0ZXJUcmlnZ2VyKGNvbXBvbmVudElkLCBuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQsIHRyaWdnZXIubmFtZSwgdHJpZ2dlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25SZW5kZXJlcih0aGlzLCBuYW1lc3BhY2VJZCwgZGVsZWdhdGUsIHRoaXMuZW5naW5lKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeS5wcm90b3R5cGUuYmVnaW4gPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9jZFJlY3VyRGVwdGgrKztcclxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5iZWdpbikge1xyXG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmJlZ2luKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5LnByb3RvdHlwZS5fc2NoZWR1bGVDb3VudFRhc2sgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIFpvbmUuY3VycmVudC5zY2hlZHVsZU1pY3JvVGFzaygnaW5jcmVtZW5ldCB0aGUgYW5pbWF0aW9uIG1pY3JvdGFzaycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9taWNyb3Rhc2tJZCsrOyB9KTtcclxuICAgIH07XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBjb3VudFxyXG4gICAgICogQHBhcmFtIHs/fSBmblxyXG4gICAgICogQHBhcmFtIHs/fSBkYXRhXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkucHJvdG90eXBlLnNjaGVkdWxlTGlzdGVuZXJDYWxsYmFjayA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBjb3VudFxyXG4gICAgICogQHBhcmFtIHs/fSBmblxyXG4gICAgICogQHBhcmFtIHs/fSBkYXRhXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoY291bnQsIGZuLCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoY291bnQgPj0gMCAmJiBjb3VudCA8IHRoaXMuX21pY3JvdGFza0lkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZuKGRhdGEpOyB9KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fYW5pbWF0aW9uQ2FsbGJhY2tzQnVmZmVyLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShudWxsKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FuaW1hdGlvbkNhbGxiYWNrc0J1ZmZlci5mb3JFYWNoKGZ1bmN0aW9uICh0dXBsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSB0dXBsZVswXSwgZGF0YSA9IHR1cGxlWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbihkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYW5pbWF0aW9uQ2FsbGJhY2tzQnVmZmVyID0gW107XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbkNhbGxiYWNrc0J1ZmZlci5wdXNoKFtmbiwgZGF0YV0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5LnByb3RvdHlwZS5lbmQgPSAvKipcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX2NkUmVjdXJEZXB0aC0tO1xyXG4gICAgICAgIC8vIHRoaXMgaXMgdG8gcHJldmVudCBhbmltYXRpb25zIGZyb20gcnVubmluZyB0d2ljZSB3aGVuIGFuIGlubmVyXHJcbiAgICAgICAgLy8gY29tcG9uZW50IGRvZXMgQ0Qgd2hlbiBhIHBhcmVudCBjb21wb25lbnQgaW5zdGVkIGhhcyBpbnNlcnRlZCBpdFxyXG4gICAgICAgIGlmICh0aGlzLl9jZFJlY3VyRGVwdGggPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9zY2hlZHVsZUNvdW50VGFzaygpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZW5naW5lLmZsdXNoKF90aGlzLl9taWNyb3Rhc2tJZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbmQpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkucHJvdG90eXBlLndoZW5SZW5kZXJpbmdEb25lID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmVuZ2luZS53aGVuUmVuZGVyaW5nRG9uZSgpOyB9O1xyXG4gICAgQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5LmRlY29yYXRvcnMgPSBbXHJcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcclxuICAgIF07XHJcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cclxuICAgIEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcclxuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJGYWN0b3J5MiwgfSxcclxuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci7JtUFuaW1hdGlvbkVuZ2luZSwgfSxcclxuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdab25lLCB9LFxyXG4gICAgXTsgfTtcclxuICAgIHJldHVybiBBbmltYXRpb25SZW5kZXJlckZhY3Rvcnk7XHJcbn0oKSk7XHJcbnZhciBCYXNlQW5pbWF0aW9uUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCYXNlQW5pbWF0aW9uUmVuZGVyZXIobmFtZXNwYWNlSWQsIGRlbGVnYXRlLCBlbmdpbmUpIHtcclxuICAgICAgICB0aGlzLm5hbWVzcGFjZUlkID0gbmFtZXNwYWNlSWQ7XHJcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xyXG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgIHRoaXMuZGVzdHJveU5vZGUgPSB0aGlzLmRlbGVnYXRlLmRlc3Ryb3lOb2RlID8gZnVuY3Rpb24gKG4pIHsgcmV0dXJuICgoZGVsZWdhdGUuZGVzdHJveU5vZGUpKShuKTsgfSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZSwgXCJkYXRhXCIsIHtcclxuICAgICAgICBnZXQ6IC8qKlxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5kYXRhOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUuZGVzdHJveSh0aGlzLm5hbWVzcGFjZUlkLCB0aGlzLmRlbGVnYXRlKTtcclxuICAgICAgICB0aGlzLmRlbGVnYXRlLmRlc3Ryb3koKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobmFtZSwgbmFtZXNwYWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuY3JlYXRlRWxlbWVudChuYW1lLCBuYW1lc3BhY2UpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDb21tZW50ID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUuY3JlYXRlQ29tbWVudCh2YWx1ZSk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlLmNyZWF0ZVRleHQodmFsdWUpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxyXG4gICAgICogQHBhcmFtIHs/fSBuZXdDaGlsZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcclxuICAgICAqIEBwYXJhbSB7P30gbmV3Q2hpbGRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChwYXJlbnQsIG5ld0NoaWxkKSB7XHJcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5hcHBlbmRDaGlsZChwYXJlbnQsIG5ld0NoaWxkKTtcclxuICAgICAgICB0aGlzLmVuZ2luZS5vbkluc2VydCh0aGlzLm5hbWVzcGFjZUlkLCBuZXdDaGlsZCwgcGFyZW50LCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxyXG4gICAgICogQHBhcmFtIHs/fSBuZXdDaGlsZFxyXG4gICAgICogQHBhcmFtIHs/fSByZWZDaGlsZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XHJcbiAgICAgKiBAcGFyYW0gez99IG5ld0NoaWxkXHJcbiAgICAgKiBAcGFyYW0gez99IHJlZkNoaWxkXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAocGFyZW50LCBuZXdDaGlsZCwgcmVmQ2hpbGQpIHtcclxuICAgICAgICB0aGlzLmRlbGVnYXRlLmluc2VydEJlZm9yZShwYXJlbnQsIG5ld0NoaWxkLCByZWZDaGlsZCk7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUub25JbnNlcnQodGhpcy5uYW1lc3BhY2VJZCwgbmV3Q2hpbGQsIHBhcmVudCwgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxyXG4gICAgICogQHBhcmFtIHs/fSBvbGRDaGlsZFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcclxuICAgICAqIEBwYXJhbSB7P30gb2xkQ2hpbGRcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChwYXJlbnQsIG9sZENoaWxkKSB7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUub25SZW1vdmUodGhpcy5uYW1lc3BhY2VJZCwgb2xkQ2hpbGQsIHRoaXMuZGVsZWdhdGUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3Rvck9yTm9kZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5zZWxlY3RSb290RWxlbWVudCA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3Rvck9yTm9kZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHNlbGVjdG9yT3JOb2RlKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlLnNlbGVjdFJvb3RFbGVtZW50KHNlbGVjdG9yT3JOb2RlKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBub2RlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLnBhcmVudE5vZGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUucGFyZW50Tm9kZShub2RlKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBub2RlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLm5leHRTaWJsaW5nID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlLm5leHRTaWJsaW5nKG5vZGUpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2UpIHtcclxuICAgICAgICB0aGlzLmRlbGVnYXRlLnNldEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUsIG5hbWVzcGFjZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxcclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxyXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUsIG5hbWVzcGFjZSkge1xyXG4gICAgICAgIHRoaXMuZGVsZWdhdGUucmVtb3ZlQXR0cmlidXRlKGVsLCBuYW1lLCBuYW1lc3BhY2UpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbFxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmFkZENsYXNzID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbCwgbmFtZSkgeyB0aGlzLmRlbGVnYXRlLmFkZENsYXNzKGVsLCBuYW1lKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbFxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbCwgbmFtZSkgeyB0aGlzLmRlbGVnYXRlLnJlbW92ZUNsYXNzKGVsLCBuYW1lKTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbFxyXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHs/PX0gZmxhZ3NcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuc2V0U3R5bGUgPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxcclxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Pz19IGZsYWdzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWwsIHN0eWxlLCB2YWx1ZSwgZmxhZ3MpIHtcclxuICAgICAgICB0aGlzLmRlbGVnYXRlLnNldFN0eWxlKGVsLCBzdHlsZSwgdmFsdWUsIGZsYWdzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gZWxcclxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVcclxuICAgICAqIEBwYXJhbSB7Pz19IGZsYWdzXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZVN0eWxlID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsXHJcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXHJcbiAgICAgKiBAcGFyYW0gez89fSBmbGFnc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKGVsLCBzdHlsZSwgZmxhZ3MpIHtcclxuICAgICAgICB0aGlzLmRlbGVnYXRlLnJlbW92ZVN0eWxlKGVsLCBzdHlsZSwgZmxhZ3MpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbFxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLnNldFByb3BlcnR5ID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT0gQU5JTUFUSU9OX1BSRUZJWCAmJiBuYW1lID09IERJU0FCTEVfQU5JTUFUSU9OU19GTEFHKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUFuaW1hdGlvbnMoZWwsICEhdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRQcm9wZXJ0eShlbCwgbmFtZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5zZXRWYWx1ZSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBub2RlXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAobm9kZSwgdmFsdWUpIHsgdGhpcy5kZWxlZ2F0ZS5zZXRWYWx1ZShub2RlLCB2YWx1ZSk7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50TmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5saXN0ZW4gPSAvKipcclxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50TmFtZVxyXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmxpc3Rlbih0YXJnZXQsIGV2ZW50TmFtZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmRpc2FibGVBbmltYXRpb25zID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuZW5naW5lLmRpc2FibGVBbmltYXRpb25zKGVsZW1lbnQsIHZhbHVlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQmFzZUFuaW1hdGlvblJlbmRlcmVyO1xyXG59KCkpO1xyXG52YXIgQW5pbWF0aW9uUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQW5pbWF0aW9uUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBbmltYXRpb25SZW5kZXJlcihmYWN0b3J5LCBuYW1lc3BhY2VJZCwgZGVsZWdhdGUsIGVuZ2luZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWVzcGFjZUlkLCBkZWxlZ2F0ZSwgZW5naW5lKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xyXG4gICAgICAgIF90aGlzLm5hbWVzcGFjZUlkID0gbmFtZXNwYWNlSWQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGVsXHJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBlbFxyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09IEFOSU1BVElPTl9QUkVGSVgpIHtcclxuICAgICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDEpID09ICcuJyAmJiBuYW1lID09IERJU0FCTEVfQU5JTUFUSU9OU19GTEFHKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSB1bmRlZmluZWQgPyB0cnVlIDogISF2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZUFuaW1hdGlvbnMoZWwsIC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5wcm9jZXNzKHRoaXMubmFtZXNwYWNlSWQsIGVsLCBuYW1lLnN1YnN0cigxKSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnNldFByb3BlcnR5KGVsLCBuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSB7P30gZXZlbnROYW1lXHJcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUubGlzdGVuID0gLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFxyXG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcclxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChldmVudE5hbWUuY2hhckF0KDApID09IEFOSU1BVElPTl9QUkVGSVgpIHtcclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IHJlc29sdmVFbGVtZW50RnJvbVRhcmdldCh0YXJnZXQpO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lXzEgPSBldmVudE5hbWUuc3Vic3RyKDEpO1xyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaGFzZSA9ICcnO1xyXG4gICAgICAgICAgICAvLyBAbGlzdGVuZXIucGhhc2UgaXMgZm9yIHRyaWdnZXIgYW5pbWF0aW9uIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICAvLyBAQGxpc3RlbmVyIGlzIGZvciBhbmltYXRpb24gYnVpbGRlciBjYWxsYmFja3NcclxuICAgICAgICAgICAgaWYgKG5hbWVfMS5jaGFyQXQoMCkgIT0gQU5JTUFUSU9OX1BSRUZJWCkge1xyXG4gICAgICAgICAgICAgICAgX2EgPSBwYXJzZVRyaWdnZXJDYWxsYmFja05hbWUobmFtZV8xKSwgbmFtZV8xID0gX2FbMF0sIHBoYXNlID0gX2FbMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5naW5lLmxpc3Rlbih0aGlzLm5hbWVzcGFjZUlkLCBlbGVtZW50LCBuYW1lXzEsIHBoYXNlLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvdW50SWQgPSAoLyoqIEB0eXBlIHs/fSAqLyAoZXZlbnQpKVsnX2RhdGEnXSB8fCAtMTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmZhY3Rvcnkuc2NoZWR1bGVMaXN0ZW5lckNhbGxiYWNrKGNvdW50SWQsIGNhbGxiYWNrLCBldmVudCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5saXN0ZW4odGFyZ2V0LCBldmVudE5hbWUsIGNhbGxiYWNrKTtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFuaW1hdGlvblJlbmRlcmVyO1xyXG59KEJhc2VBbmltYXRpb25SZW5kZXJlcikpO1xyXG4vKipcclxuICogQHBhcmFtIHs/fSB0YXJnZXRcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVFbGVtZW50RnJvbVRhcmdldCh0YXJnZXQpIHtcclxuICAgIHN3aXRjaCAodGFyZ2V0KSB7XHJcbiAgICAgICAgY2FzZSAnYm9keSc6XHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xyXG4gICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcclxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xyXG4gICAgICAgIGNhc2UgJ3dpbmRvdyc6XHJcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSB0cmlnZ2VyTmFtZVxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VUcmlnZ2VyQ2FsbGJhY2tOYW1lKHRyaWdnZXJOYW1lKSB7XHJcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkb3RJbmRleCA9IHRyaWdnZXJOYW1lLmluZGV4T2YoJy4nKTtcclxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXIgPSB0cmlnZ2VyTmFtZS5zdWJzdHJpbmcoMCwgZG90SW5kZXgpO1xyXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGhhc2UgPSB0cmlnZ2VyTmFtZS5zdWJzdHIoZG90SW5kZXggKyAxKTtcclxuICAgIHJldHVybiBbdHJpZ2dlciwgcGhhc2VdO1xyXG59XHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxudmFyIEluamVjdGFibGVBbmltYXRpb25FbmdpbmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEluamVjdGFibGVBbmltYXRpb25FbmdpbmUoZHJpdmVyLCBub3JtYWxpemVyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGRyaXZlciwgbm9ybWFsaXplcikgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEluamVjdGFibGVBbmltYXRpb25FbmdpbmUuZGVjb3JhdG9ycyA9IFtcclxuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxyXG4gICAgXTtcclxuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xyXG4gICAgSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcclxuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci5BbmltYXRpb25Ecml2ZXIsIH0sXHJcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIuybVBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIsIH0sXHJcbiAgICBdOyB9O1xyXG4gICAgcmV0dXJuIEluamVjdGFibGVBbmltYXRpb25FbmdpbmU7XHJcbn0oX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1QW5pbWF0aW9uRW5naW5lKSk7XHJcbi8qKlxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gaW5zdGFudGlhdGVTdXBwb3J0ZWRBbmltYXRpb25Ecml2ZXIoKSB7XHJcbiAgICBpZiAoX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1c3VwcG9ydHNXZWJBbmltYXRpb25zKCkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci7JtVdlYkFuaW1hdGlvbnNEcml2ZXIoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1Tm9vcEFuaW1hdGlvbkRyaXZlcigpO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gaW5zdGFudGlhdGVEZWZhdWx0U3R5bGVOb3JtYWxpemVyKCkge1xyXG4gICAgcmV0dXJuIG5ldyBfYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIuybVXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyKCk7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gcmVuZGVyZXJcclxuICogQHBhcmFtIHs/fSBlbmdpbmVcclxuICogQHBhcmFtIHs/fSB6b25lXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVJlbmRlcmVyRmFjdG9yeShyZW5kZXJlciwgZW5naW5lLCB6b25lKSB7XHJcbiAgICByZXR1cm4gbmV3IEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeShyZW5kZXJlciwgZW5naW5lLCB6b25lKTtcclxufVxyXG52YXIgU0hBUkVEX0FOSU1BVElPTl9QUk9WSURFUlMgPSBbXHJcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2FuaW1hdGlvbnMuQW5pbWF0aW9uQnVpbGRlciwgdXNlQ2xhc3M6IEJyb3dzZXJBbmltYXRpb25CdWlsZGVyIH0sXHJcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci7JtUFuaW1hdGlvblN0eWxlTm9ybWFsaXplciwgdXNlRmFjdG9yeTogaW5zdGFudGlhdGVEZWZhdWx0U3R5bGVOb3JtYWxpemVyIH0sXHJcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci7JtUFuaW1hdGlvbkVuZ2luZSwgdXNlQ2xhc3M6IEluamVjdGFibGVBbmltYXRpb25FbmdpbmUgfSwge1xyXG4gICAgICAgIHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJGYWN0b3J5MixcclxuICAgICAgICB1c2VGYWN0b3J5OiBpbnN0YW50aWF0ZVJlbmRlcmVyRmFjdG9yeSxcclxuICAgICAgICBkZXBzOiBbX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1RG9tUmVuZGVyZXJGYWN0b3J5MiwgX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1QW5pbWF0aW9uRW5naW5lLCBfYW5ndWxhcl9jb3JlLk5nWm9uZV1cclxuICAgIH1cclxuXTtcclxuLyoqXHJcbiAqIFNlcGFyYXRlIHByb3ZpZGVycyBmcm9tIHRoZSBhY3R1YWwgbW9kdWxlIHNvIHRoYXQgd2UgY2FuIGRvIGEgbG9jYWwgbW9kaWZpY2F0aW9uIGluIEdvb2dsZTMgdG9cclxuICogaW5jbHVkZSB0aGVtIGluIHRoZSBCcm93c2VyTW9kdWxlLlxyXG4gKi9cclxudmFyIEJST1dTRVJfQU5JTUFUSU9OU19QUk9WSURFUlMgPSBbXHJcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci5BbmltYXRpb25Ecml2ZXIsIHVzZUZhY3Rvcnk6IGluc3RhbnRpYXRlU3VwcG9ydGVkQW5pbWF0aW9uRHJpdmVyIH1cclxuXS5jb25jYXQoU0hBUkVEX0FOSU1BVElPTl9QUk9WSURFUlMpO1xyXG4vKipcclxuICogU2VwYXJhdGUgcHJvdmlkZXJzIGZyb20gdGhlIGFjdHVhbCBtb2R1bGUgc28gdGhhdCB3ZSBjYW4gZG8gYSBsb2NhbCBtb2RpZmljYXRpb24gaW4gR29vZ2xlMyB0b1xyXG4gKiBpbmNsdWRlIHRoZW0gaW4gdGhlIEJyb3dzZXJUZXN0aW5nTW9kdWxlLlxyXG4gKi9cclxudmFyIEJST1dTRVJfTk9PUF9BTklNQVRJT05TX1BST1ZJREVSUyA9IFt7IHByb3ZpZGU6IF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci5BbmltYXRpb25Ecml2ZXIsIHVzZUNsYXNzOiBfYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIuybVOb29wQW5pbWF0aW9uRHJpdmVyIH1dLmNvbmNhdChTSEFSRURfQU5JTUFUSU9OX1BST1ZJREVSUyk7XHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbi8qKlxyXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxyXG4gKi9cclxudmFyIEJyb3dzZXJBbmltYXRpb25zTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBCcm93c2VyQW5pbWF0aW9uc01vZHVsZS5kZWNvcmF0b3JzID0gW1xyXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcclxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkJyb3dzZXJNb2R1bGVdLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogQlJPV1NFUl9BTklNQVRJT05TX1BST1ZJREVSUyxcclxuICAgICAgICAgICAgICAgIH0sXSB9LFxyXG4gICAgXTtcclxuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xyXG4gICAgQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcclxuICAgIHJldHVybiBCcm93c2VyQW5pbWF0aW9uc01vZHVsZTtcclxufSgpKTtcclxuLyoqXHJcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXHJcbiAqL1xyXG52YXIgTm9vcEFuaW1hdGlvbnNNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb29wQW5pbWF0aW9uc01vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIE5vb3BBbmltYXRpb25zTW9kdWxlLmRlY29yYXRvcnMgPSBbXHJcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuQnJvd3Nlck1vZHVsZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBCUk9XU0VSX05PT1BfQU5JTUFUSU9OU19QUk9WSURFUlMsXHJcbiAgICAgICAgICAgICAgICB9LF0gfSxcclxuICAgIF07XHJcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cclxuICAgIE5vb3BBbmltYXRpb25zTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XHJcbiAgICByZXR1cm4gTm9vcEFuaW1hdGlvbnNNb2R1bGU7XHJcbn0oKSk7XHJcblxyXG5leHBvcnRzLkJyb3dzZXJBbmltYXRpb25zTW9kdWxlID0gQnJvd3NlckFuaW1hdGlvbnNNb2R1bGU7XHJcbmV4cG9ydHMuTm9vcEFuaW1hdGlvbnNNb2R1bGUgPSBOb29wQW5pbWF0aW9uc01vZHVsZTtcclxuZXhwb3J0cy7JtUJyb3dzZXJBbmltYXRpb25CdWlsZGVyID0gQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXI7XHJcbmV4cG9ydHMuybVCcm93c2VyQW5pbWF0aW9uRmFjdG9yeSA9IEJyb3dzZXJBbmltYXRpb25GYWN0b3J5O1xyXG5leHBvcnRzLsm1QW5pbWF0aW9uUmVuZGVyZXIgPSBBbmltYXRpb25SZW5kZXJlcjtcclxuZXhwb3J0cy7JtUFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeSA9IEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeTtcclxuZXhwb3J0cy7JtWEgPSBCYXNlQW5pbWF0aW9uUmVuZGVyZXI7XHJcbmV4cG9ydHMuybVmID0gQlJPV1NFUl9BTklNQVRJT05TX1BST1ZJREVSUztcclxuZXhwb3J0cy7JtWcgPSBCUk9XU0VSX05PT1BfQU5JTUFUSU9OU19QUk9WSURFUlM7XHJcbmV4cG9ydHMuybViID0gSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZTtcclxuZXhwb3J0cy7JtWQgPSBpbnN0YW50aWF0ZURlZmF1bHRTdHlsZU5vcm1hbGl6ZXI7XHJcbmV4cG9ydHMuybVlID0gaW5zdGFudGlhdGVSZW5kZXJlckZhY3Rvcnk7XHJcbmV4cG9ydHMuybVjID0gaW5zdGFudGlhdGVTdXBwb3J0ZWRBbmltYXRpb25Ecml2ZXI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cclxufSkpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGxhdGZvcm0tYnJvd3Nlci1hbmltYXRpb25zLnVtZC5qcy5tYXBcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYnVuZGxlcy9wbGF0Zm9ybS1icm93c2VyLWFuaW1hdGlvbnMudW1kLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmltcG9ydCB7IEh0dHBNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9odHRwJztcclxuaW1wb3J0IHsgUm91dGVyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuXHJcbmltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9hcHAvYXBwLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IE5hdk1lbnVDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvbmF2bWVudS9uYXZtZW51LmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IEhvbWVDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvaG9tZS9ob21lLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IEZldGNoRGF0YUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9mZXRjaGRhdGEvZmV0Y2hkYXRhLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IENvdW50ZXJDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvY291bnRlci9jb3VudGVyLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IFZlaGljbGVGb3JtQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3ZlaGljbGUtZm9ybS92ZWhpY2xlLWZvcm0uY29tcG9uZW50J1xyXG5cclxuLy8gaW1wb3J0ICdoYW1tZXJqcyc7XHJcbmltcG9ydCB7IE1hdEJ1dHRvbk1vZHVsZSwgTWF0U2xpZGVUb2dnbGVNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XHJcblxyXG5cclxuQE5nTW9kdWxlKHtcclxuICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgICAgIEFwcENvbXBvbmVudCxcclxuICAgICAgICBOYXZNZW51Q29tcG9uZW50LFxyXG4gICAgICAgIENvdW50ZXJDb21wb25lbnQsXHJcbiAgICAgICAgRmV0Y2hEYXRhQ29tcG9uZW50LFxyXG4gICAgICAgIEhvbWVDb21wb25lbnQsXHJcbiAgICAgICAgVmVoaWNsZUZvcm1Db21wb25lbnRcclxuICAgIF0sXHJcbiAgICBpbXBvcnRzOiBbXHJcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxyXG4gICAgICAgIEh0dHBNb2R1bGUsXHJcbiAgICAgICAgRm9ybXNNb2R1bGUsXHJcbiAgICAgICAgTWF0QnV0dG9uTW9kdWxlLFxyXG4gICAgICAgIE1hdFNsaWRlVG9nZ2xlTW9kdWxlLFxyXG4gICAgICAgIFJvdXRlck1vZHVsZS5mb3JSb290KFtcclxuICAgICAgICAgICAgeyBwYXRoOiAnJywgcmVkaXJlY3RUbzogJ2hvbWUnLCBwYXRoTWF0Y2g6ICdmdWxsJyB9LFxyXG4gICAgICAgICAgICB7IHBhdGg6ICd2ZWhpY2xlcy9uZXcnLCBjb21wb25lbnQ6IFZlaGljbGVGb3JtQ29tcG9uZW50IH0sXHJcbiAgICAgICAgICAgIHsgcGF0aDogJ2hvbWUnLCBjb21wb25lbnQ6IEhvbWVDb21wb25lbnQgfSxcclxuICAgICAgICAgICAgeyBwYXRoOiAnY291bnRlcicsIGNvbXBvbmVudDogQ291bnRlckNvbXBvbmVudCB9LFxyXG4gICAgICAgICAgICB7IHBhdGg6ICdmZXRjaC1kYXRhJywgY29tcG9uZW50OiBGZXRjaERhdGFDb21wb25lbnQgfSxcclxuICAgICAgICAgICAgeyBwYXRoOiAnKionLCByZWRpcmVjdFRvOiAnaG9tZScgfVxyXG4gICAgICAgIF0pXHJcbiAgICBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBBcHBNb2R1bGVTaGFyZWQge1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvYXBwLnNoYXJlZC5tb2R1bGUudHMiLCJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgdHJpZ2dlciwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCBhbmltYXRlIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnY291bnRlcicsXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9jb3VudGVyLmNvbXBvbmVudC5odG1sJyksXHJcbiAgICBzdHlsZXM6IFtgXHJcbiAgICAgICAgLm15QnV0dG9uIHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcHVycGxlO1xyXG4gICAgICAgICAgICBjb2xvcjogd2hpdGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAubXlCdXR0b246aG92ZXIge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBvcmFuZ2U7XHJcbiAgICAgICAgICAgIGNvbG9yOiB3aGl0ZTtcclxuICAgICAgICB9XHJcbiAgICBgXSxcclxuICAgIGFuaW1hdGlvbnM6IFtcclxuICAgICAgICB0cmlnZ2VyKCdob3ZlckFuaW1hdGlvbicsIFtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbignOmVudGVyJywgWyAgIC8vIDplbnRlciBpcyBhbGlhcyB0byAndm9pZCA9PiAqJ1xyXG4gICAgICAgICAgICAgICAgc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxyXG4gICAgICAgICAgICAgICAgYW5pbWF0ZSgyNTAsIHN0eWxlKHsgb3BhY2l0eTogMSB9KSlcclxuICAgICAgICAgICAgXSksXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFsgICAvLyA6bGVhdmUgaXMgYWxpYXMgdG8gJyogPT4gdm9pZCdcclxuICAgICAgICAgICAgICAgIGFuaW1hdGUoMTAwLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgXSlcclxuICAgIF1cclxufSlcclxuZXhwb3J0IGNsYXNzIENvdW50ZXJDb21wb25lbnQge1xyXG4gICAgcHVibGljIGN1cnJlbnRDb3VudCA9IDA7XHJcblxyXG4gICAgcHVibGljIGluY3JlbWVudENvdW50ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q291bnQrKztcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9jb3VudGVyL2NvdW50ZXIuY29tcG9uZW50LnRzIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgSHR0cCB9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ2ZldGNoZGF0YScsXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9mZXRjaGRhdGEuY29tcG9uZW50Lmh0bWwnKVxyXG59KVxyXG5leHBvcnQgY2xhc3MgRmV0Y2hEYXRhQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBmb3JlY2FzdHM6IFdlYXRoZXJGb3JlY2FzdFtdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGh0dHA6IEh0dHAsIEBJbmplY3QoJ0JBU0VfVVJMJykgYmFzZVVybDogc3RyaW5nKSB7XHJcbiAgICAgICAgaHR0cC5nZXQoYmFzZVVybCArICdhcGkvU2FtcGxlRGF0YS9XZWF0aGVyRm9yZWNhc3RzJykuc3Vic2NyaWJlKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yZWNhc3RzID0gcmVzdWx0Lmpzb24oKSBhcyBXZWF0aGVyRm9yZWNhc3RbXTtcclxuICAgICAgICB9LCBlcnJvciA9PiBjb25zb2xlLmVycm9yKGVycm9yKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmludGVyZmFjZSBXZWF0aGVyRm9yZWNhc3Qge1xyXG4gICAgZGF0ZUZvcm1hdHRlZDogc3RyaW5nO1xyXG4gICAgdGVtcGVyYXR1cmVDOiBudW1iZXI7XHJcbiAgICB0ZW1wZXJhdHVyZUY6IG51bWJlcjtcclxuICAgIHN1bW1hcnk6IHN0cmluZztcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvZmV0Y2hkYXRhL2ZldGNoZGF0YS5jb21wb25lbnQudHMiLCJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdob21lJyxcclxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2hvbWUuY29tcG9uZW50Lmh0bWwnKVxyXG59KVxyXG5leHBvcnQgY2xhc3MgSG9tZUNvbXBvbmVudCB7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2hvbWUvaG9tZS5jb21wb25lbnQudHMiLCJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICduYXYtbWVudScsXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9uYXZtZW51LmNvbXBvbmVudC5odG1sJyksXHJcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL25hdm1lbnUuY29tcG9uZW50LmNzcycpXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmF2TWVudUNvbXBvbmVudCB7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL25hdm1lbnUvbmF2bWVudS5jb21wb25lbnQudHMiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdhcHAtdmVoaWNsZS1mb3JtJyxcclxuICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi92ZWhpY2xlLWZvcm0uY29tcG9uZW50Lmh0bWwnKSxcclxuICBzdHlsZXM6IFtyZXF1aXJlKCcuL3ZlaGljbGUtZm9ybS5jb21wb25lbnQuY3NzJyldXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBWZWhpY2xlRm9ybUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkgeyB9XHJcblxyXG4gIG5nT25Jbml0KCkge1xyXG4gIH1cclxuXHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL3ZlaGljbGUtZm9ybS92ZWhpY2xlLWZvcm0uY29tcG9uZW50LnRzIiwiaW1wb3J0ICdyZWZsZWN0LW1ldGFkYXRhJztcclxuaW1wb3J0ICd6b25lLmpzJztcclxuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9maXJzdCc7XHJcbmltcG9ydCB7IEFQUF9CQVNFX0hSRUYgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBlbmFibGVQcm9kTW9kZSwgQXBwbGljYXRpb25SZWYsIE5nWm9uZSwgVmFsdWVQcm92aWRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBwbGF0Zm9ybUR5bmFtaWNTZXJ2ZXIsIFBsYXRmb3JtU3RhdGUsIElOSVRJQUxfQ09ORklHIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tc2VydmVyJztcclxuaW1wb3J0IHsgY3JlYXRlU2VydmVyUmVuZGVyZXIsIFJlbmRlclJlc3VsdCB9IGZyb20gJ2FzcG5ldC1wcmVyZW5kZXJpbmcnO1xyXG5pbXBvcnQgeyBBcHBNb2R1bGUgfSBmcm9tICcuL2FwcC9hcHAuc2VydmVyLm1vZHVsZSc7XHJcblxyXG5lbmFibGVQcm9kTW9kZSgpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlU2VydmVyUmVuZGVyZXIocGFyYW1zID0+IHtcclxuICAgIGNvbnN0IHByb3ZpZGVycyA9IFtcclxuICAgICAgICB7IHByb3ZpZGU6IElOSVRJQUxfQ09ORklHLCB1c2VWYWx1ZTogeyBkb2N1bWVudDogJzxhcHA+PC9hcHA+JywgdXJsOiBwYXJhbXMudXJsIH0gfSxcclxuICAgICAgICB7IHByb3ZpZGU6IEFQUF9CQVNFX0hSRUYsIHVzZVZhbHVlOiBwYXJhbXMuYmFzZVVybCB9LFxyXG4gICAgICAgIHsgcHJvdmlkZTogJ0JBU0VfVVJMJywgdXNlVmFsdWU6IHBhcmFtcy5vcmlnaW4gKyBwYXJhbXMuYmFzZVVybCB9LFxyXG4gICAgXTtcclxuXHJcbiAgICByZXR1cm4gcGxhdGZvcm1EeW5hbWljU2VydmVyKHByb3ZpZGVycykuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSkudGhlbihtb2R1bGVSZWYgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFwcFJlZjogQXBwbGljYXRpb25SZWYgPSBtb2R1bGVSZWYuaW5qZWN0b3IuZ2V0KEFwcGxpY2F0aW9uUmVmKTtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IG1vZHVsZVJlZi5pbmplY3Rvci5nZXQoUGxhdGZvcm1TdGF0ZSk7XHJcbiAgICAgICAgY29uc3Qgem9uZSA9IG1vZHVsZVJlZi5pbmplY3Rvci5nZXQoTmdab25lKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPFJlbmRlclJlc3VsdD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB6b25lLm9uRXJyb3Iuc3Vic2NyaWJlKChlcnJvckluZm86IGFueSkgPT4gcmVqZWN0KGVycm9ySW5mbykpO1xyXG4gICAgICAgICAgICBhcHBSZWYuaXNTdGFibGUuZmlyc3QoaXNTdGFibGUgPT4gaXNTdGFibGUpLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlICdvblN0YWJsZScgZmlyZXMgYmVmb3JlICdvbkVycm9yJywgd2UgaGF2ZSB0byBkZWxheSBzbGlnaHRseSBiZWZvcmVcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRpbmcgdGhlIHJlcXVlc3QgaW4gY2FzZSB0aGVyZSdzIGFuIGVycm9yIHRvIHJlcG9ydFxyXG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDogc3RhdGUucmVuZGVyVG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZVJlZi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9ib290LnNlcnZlci50cyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBtZWRpYSAobWF4LXdpZHRoOiA3NjdweCkge1xcclxcbiAgICAvKiBPbiBzbWFsbCBzY3JlZW5zLCB0aGUgbmF2IG1lbnUgc3BhbnMgdGhlIGZ1bGwgd2lkdGggb2YgdGhlIHNjcmVlbi4gTGVhdmUgYSBzcGFjZSBmb3IgaXQuICovXFxyXFxuICAgIC5ib2R5LWNvbnRlbnQge1xcclxcbiAgICAgICAgcGFkZGluZy10b3A6IDUwcHg7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvYXBwL2FwcC5jb21wb25lbnQuY3NzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJsaSAuZ2x5cGhpY29uIHtcXHJcXG4gICAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4vKiBIaWdobGlnaHRpbmcgcnVsZXMgZm9yIG5hdiBtZW51IGl0ZW1zICovXFxyXFxubGkubGluay1hY3RpdmUgYSxcXHJcXG5saS5saW5rLWFjdGl2ZSBhOmhvdmVyLFxcclxcbmxpLmxpbmstYWN0aXZlIGE6Zm9jdXMge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDE4OUM3O1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxufVxcclxcblxcclxcbi8qIEtlZXAgdGhlIG5hdiBtZW51IGluZGVwZW5kZW50IG9mIHNjcm9sbGluZyBhbmQgb24gdG9wIG9mIG90aGVyIGl0ZW1zICovXFxyXFxuLm1haW4tbmF2IHtcXHJcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcclxcbiAgICB0b3A6IDA7XFxyXFxuICAgIGxlZnQ6IDA7XFxyXFxuICAgIHJpZ2h0OiAwO1xcclxcbiAgICB6LWluZGV4OiAxO1xcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcXHJcXG4gICAgLyogT24gc21hbGwgc2NyZWVucywgY29udmVydCB0aGUgbmF2IG1lbnUgdG8gYSB2ZXJ0aWNhbCBzaWRlYmFyICovXFxyXFxuICAgIC5tYWluLW5hdiB7XFxyXFxuICAgICAgICBoZWlnaHQ6IDEwMCU7XFxyXFxuICAgICAgICB3aWR0aDogY2FsYygyNSUgLSAyMHB4KTtcXHJcXG4gICAgfVxcclxcbiAgICAubmF2YmFyIHtcXHJcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDBweDtcXHJcXG4gICAgICAgIGJvcmRlci13aWR0aDogMHB4O1xcclxcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgICB9XFxyXFxuICAgIC5uYXZiYXItaGVhZGVyIHtcXHJcXG4gICAgICAgIGZsb2F0OiBub25lO1xcclxcbiAgICB9XFxyXFxuICAgIC5uYXZiYXItY29sbGFwc2Uge1xcclxcbiAgICAgICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICM0NDQ7XFxyXFxuICAgICAgICBwYWRkaW5nOiAwcHg7XFxyXFxuICAgIH1cXHJcXG4gICAgLm5hdmJhciB1bCB7XFxyXFxuICAgICAgICBmbG9hdDogbm9uZTtcXHJcXG4gICAgfVxcclxcbiAgICAubmF2YmFyIGxpIHtcXHJcXG4gICAgICAgIGZsb2F0OiBub25lO1xcclxcbiAgICAgICAgZm9udC1zaXplOiAxNXB4O1xcclxcbiAgICAgICAgbWFyZ2luOiA2cHg7XFxyXFxuICAgIH1cXHJcXG4gICAgLm5hdmJhciBsaSBhIHtcXHJcXG4gICAgICAgIHBhZGRpbmc6IDEwcHggMTZweDtcXHJcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcXHJcXG4gICAgfVxcclxcbiAgICAubmF2YmFyIGEge1xcclxcbiAgICAgICAgLyogSWYgYSBtZW51IGl0ZW0ncyB0ZXh0IGlzIHRvbyBsb25nLCB0cnVuY2F0ZSBpdCAqL1xcclxcbiAgICAgICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcclxcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG4gICAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcclxcbiAgICB9XFxyXFxufVxcclxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL25hdm1lbnUvbmF2bWVudS5jb21wb25lbnQuY3NzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy92ZWhpY2xlLWZvcm0vdmVoaWNsZS1mb3JtLmNvbXBvbmVudC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEN1c3RvbUV2ZW50O1xyXG5cclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9FdmVudCcpO1xyXG5cclxuZnVuY3Rpb24gQ3VzdG9tRXZlbnQodHlwZSwgZGljdGlvbmFyeSkge1xyXG4gIC8vIEp1c3QgdXNlIHRoZSBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yIHRvIGluaXRpYWxpemVcclxuICBFdmVudC5jYWxsKHRoaXMsIHR5cGUsIGRpY3Rpb25hcnkpO1xyXG59XHJcbkN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlLCB7XHJcbiAgY29uc3RydWN0b3I6IHsgdmFsdWU6IEN1c3RvbUV2ZW50IH1cclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kb21pbm8vbGliL0N1c3RvbUV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXJlZEVsZW1lbnRMaXN0O1xyXG5cclxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcclxuXHJcbi8vXHJcbi8vIFRoaXMgZmlsZSBkZWZpbmVzIG5vZGUgbGlzdCBpbXBsZW1lbnRhdGlvbiB0aGF0IGxhemlseSB0cmF2ZXJzZXNcclxuLy8gdGhlIGRvY3VtZW50IHRyZWUgKG9yIGEgc3VidHJlZSByb290ZWQgYXQgYW55IGVsZW1lbnQpIGFuZCBpbmNsdWRlc1xyXG4vLyBvbmx5IHRob3NlIGVsZW1lbnRzIGZvciB3aGljaCBhIHNwZWNpZmllZCBmaWx0ZXIgZnVuY3Rpb24gcmV0dXJucyB0cnVlLlxyXG4vLyBJdCBpcyB1c2VkIHRvIGltcGxlbWVudCB0aGVcclxuLy8ge0RvY3VtZW50LEVsZW1lbnR9LmdldEVsZW1lbnRzQnl7VGFnTmFtZSxDbGFzc05hbWV9eyxOU30gbWV0aG9kcy5cclxuLy9cclxuXHJcbmZ1bmN0aW9uIEZpbHRlcmVkRWxlbWVudExpc3Qocm9vdCwgZmlsdGVyKSB7XHJcbiAgdGhpcy5yb290ID0gcm9vdDtcclxuICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcclxuICB0aGlzLmxhc3RNb2RUaW1lID0gcm9vdC5sYXN0TW9kVGltZTtcclxuICB0aGlzLmRvbmUgPSBmYWxzZTtcclxuICB0aGlzLmNhY2hlID0gW107XHJcbiAgdGhpcy50cmF2ZXJzZSgpO1xyXG59XHJcblxyXG5GaWx0ZXJlZEVsZW1lbnRMaXN0LnByb3RvdHlwZSA9IHtcclxuICBnZXQgbGVuZ3RoKCkge1xyXG4gICAgdGhpcy5jaGVja2NhY2hlKCk7XHJcbiAgICBpZiAoIXRoaXMuZG9uZSkgdGhpcy50cmF2ZXJzZSgpO1xyXG4gICAgcmV0dXJuIHRoaXMuY2FjaGUubGVuZ3RoO1xyXG4gIH0sXHJcblxyXG4gIGl0ZW06IGZ1bmN0aW9uKG4pIHtcclxuICAgIHRoaXMuY2hlY2tjYWNoZSgpO1xyXG4gICAgaWYgKCF0aGlzLmRvbmUgJiYgbiA+PSB0aGlzLmNhY2hlLmxlbmd0aCkgdGhpcy50cmF2ZXJzZShuKTtcclxuICAgIHJldHVybiB0aGlzLmNhY2hlW25dO1xyXG4gIH0sXHJcblxyXG4gIGNoZWNrY2FjaGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMubGFzdE1vZFRpbWUgIT09IHRoaXMucm9vdC5sYXN0TW9kVGltZSkge1xyXG4gICAgICAvLyBzdWJ0cmVlIGhhcyBjaGFuZ2VkLCBzbyBpbnZhbGlkYXRlIGNhY2hlXHJcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNhY2hlLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcclxuICAgICAgICB0aGlzW2ldID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY2FjaGUubGVuZ3RoID0gMDtcclxuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XHJcbiAgICAgIHRoaXMubGFzdE1vZFRpbWUgPSB0aGlzLnJvb3QubGFzdE1vZFRpbWU7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gSWYgbiBpcyBzcGVjaWZpZWQsIHRoZW4gdHJhdmVyc2UgdGhlIHRyZWUgdW50aWwgd2UndmUgZm91bmQgdGhlIG50aFxyXG4gIC8vIGl0ZW0gKG9yIHVudGlsIHdlJ3ZlIGZvdW5kIGFsbCBpdGVtcykuICBJZiBuIGlzIG5vdCBzcGVjaWZpZWQsXHJcbiAgLy8gdHJhdmVyc2UgdW50aWwgd2UndmUgZm91bmQgYWxsIGl0ZW1zLlxyXG4gIHRyYXZlcnNlOiBmdW5jdGlvbihuKSB7XHJcbiAgICAvLyBpbmNyZW1lbnQgbiBzbyB3ZSBjYW4gY29tcGFyZSB0byBsZW5ndGgsIGFuZCBzbyBpdCBpcyBuZXZlciBmYWxzeVxyXG4gICAgaWYgKG4gIT09IHVuZGVmaW5lZCkgbisrO1xyXG5cclxuICAgIHZhciBlbHQ7XHJcbiAgICB3aGlsZSAoKGVsdCA9IHRoaXMubmV4dCgpKSAhPT0gbnVsbCkge1xyXG4gICAgICB0aGlzW3RoaXMuY2FjaGUubGVuZ3RoXSA9IGVsdDsgLy9YWFggVXNlIHByb3h5IGluc3RlYWRcclxuICAgICAgdGhpcy5jYWNoZS5wdXNoKGVsdCk7XHJcbiAgICAgIGlmIChuICYmIHRoaXMuY2FjaGUubGVuZ3RoID09PSBuKSByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbm8gbmV4dCBlbGVtZW50LCBzbyB3ZSd2ZSBmb3VuZCBldmVyeXRoaW5nXHJcbiAgICB0aGlzLmRvbmUgPSB0cnVlO1xyXG4gIH0sXHJcblxyXG4gIC8vIFJldHVybiB0aGUgbmV4dCBlbGVtZW50IHVuZGVyIHJvb3QgdGhhdCBtYXRjaGVzIGZpbHRlclxyXG4gIG5leHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gKHRoaXMuY2FjaGUubGVuZ3RoID09PSAwKSA/IHRoaXMucm9vdCAvLyBTdGFydCBhdCB0aGUgcm9vdCBvciBhdFxyXG4gICAgICA6IHRoaXMuY2FjaGVbdGhpcy5jYWNoZS5sZW5ndGgtMV07IC8vIHRoZSBsYXN0IGVsZW1lbnQgd2UgZm91bmRcclxuXHJcbiAgICB2YXIgZWx0O1xyXG4gICAgaWYgKHN0YXJ0Lm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUpXHJcbiAgICAgIGVsdCA9IHN0YXJ0LmRvY3VtZW50RWxlbWVudDtcclxuICAgIGVsc2VcclxuICAgICAgZWx0ID0gc3RhcnQubmV4dEVsZW1lbnQodGhpcy5yb290KTtcclxuXHJcbiAgICB3aGlsZShlbHQpIHtcclxuICAgICAgaWYgKHRoaXMuZmlsdGVyKGVsdCkpIHtcclxuICAgICAgICByZXR1cm4gZWx0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlbHQgPSBlbHQubmV4dEVsZW1lbnQodGhpcy5yb290KTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvRmlsdGVyZWRFbGVtZW50TGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBVUkwgPSByZXF1aXJlKCcuL1VSTCcpO1xyXG52YXIgVVJMVXRpbHMgPSByZXF1aXJlKCcuL1VSTFV0aWxzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExvY2F0aW9uO1xyXG5cclxuZnVuY3Rpb24gTG9jYXRpb24od2luZG93LCBocmVmKSB7XHJcbiAgdGhpcy5fd2luZG93ID0gd2luZG93O1xyXG4gIHRoaXMuX2hyZWYgPSBocmVmO1xyXG59XHJcblxyXG5Mb2NhdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFVSTFV0aWxzLnByb3RvdHlwZSwge1xyXG4gIGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBMb2NhdGlvbiB9LFxyXG5cclxuICAvLyBTcGVjaWFsIGJlaGF2aW9yIHdoZW4gaHJlZiBpcyBzZXRcclxuICBocmVmOiB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5faHJlZjsgfSxcclxuICAgIHNldDogZnVuY3Rpb24odikgeyB0aGlzLmFzc2lnbih2KTsgfVxyXG4gIH0sXHJcblxyXG4gIGFzc2lnbjogeyB2YWx1ZTogZnVuY3Rpb24odXJsKSB7XHJcbiAgICAvLyBSZXNvbHZlIHRoZSBuZXcgdXJsIGFnYWluc3QgdGhlIGN1cnJlbnQgb25lXHJcbiAgICAvLyBYWFg6XHJcbiAgICAvLyBUaGlzIGlzIG5vdCBhY3R1YWxseSBjb3JyZWN0LiBJdCBzaG91bGQgYmUgcmVzb2x2ZWQgYWdhaW5zdFxyXG4gICAgLy8gdGhlIFVSTCBvZiB0aGUgZG9jdW1lbnQgb2YgdGhlIHNjcmlwdC4gRm9yIG5vdywgdGhvdWdoLCBJIG9ubHlcclxuICAgIC8vIHN1cHBvcnQgYSBzaW5nbGUgd2luZG93IGFuZCB0aGVyZSBpcyBvbmx5IG9uZSBiYXNlIHVybC5cclxuICAgIC8vIFNvIHRoaXMgaXMgZ29vZCBlbm91Z2ggZm9yIG5vdy5cclxuICAgIHZhciBjdXJyZW50ID0gbmV3IFVSTCh0aGlzLl9ocmVmKTtcclxuICAgIHZhciBuZXd1cmwgPSBjdXJyZW50LnJlc29sdmUodXJsKTtcclxuXHJcbiAgICAvLyBTYXZlIHRoZSBuZXcgdXJsXHJcbiAgICB0aGlzLl9ocmVmID0gbmV3dXJsO1xyXG5cclxuICAgIC8vIFN0YXJ0IGxvYWRpbmcgdGhlIG5ldyBkb2N1bWVudCFcclxuICAgIC8vIFhYWFxyXG4gICAgLy8gVGhpcyBpcyBqdXN0IHNvbWV0aGluZyBoYWNrZWQgdG9nZXRoZXIuXHJcbiAgICAvLyBUaGUgcmVhbCBhbGdvcml0aG0gaXM6IGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2hpc3RvcnkuaHRtbCNuYXZpZ2F0ZVxyXG4gIH19LFxyXG5cclxuICByZXBsYWNlOiB7IHZhbHVlOiBmdW5jdGlvbih1cmwpIHtcclxuICAgIC8vIFhYWFxyXG4gICAgLy8gU2luY2Ugd2UgYXJlbid0IHRyYWNraW5nIGhpc3RvcnkgeWV0LCByZXBsYWNlIGlzIHRoZSBzYW1lIGFzIGFzc2lnblxyXG4gICAgdGhpcy5hc3NpZ24odXJsKTtcclxuICB9fSxcclxuXHJcbiAgcmVsb2FkOiB7IHZhbHVlOiBmdW5jdGlvbigpIHtcclxuICAgIC8vIFhYWDpcclxuICAgIC8vIEFjdHVhbGx5LCB0aGUgc3BlYyBpcyBhIGxvdCBtb3JlIGNvbXBsaWNhdGVkIHRoYW4gdGhpc1xyXG4gICAgdGhpcy5hc3NpZ24odGhpcy5ocmVmKTtcclxuICB9fSxcclxuXHJcbiAgdG9TdHJpbmc6IHsgdmFsdWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaHJlZjtcclxuICB9fVxyXG5cclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kb21pbm8vbGliL0xvY2F0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgVkFMVUU6IDEsIC8vIFRoZSB2YWx1ZSBvZiBhIFRleHQsIENvbW1lbnQgb3IgUEkgbm9kZSBjaGFuZ2VkXHJcbiAgQVRUUjogMiwgLy8gQSBuZXcgYXR0cmlidXRlIHdhcyBhZGRlZCBvciBhbiBhdHRyaWJ1dGUgdmFsdWUgYW5kL29yIHByZWZpeCBjaGFuZ2VkXHJcbiAgUkVNT1ZFX0FUVFI6IDMsIC8vIEFuIGF0dHJpYnV0ZSB3YXMgcmVtb3ZlZFxyXG4gIFJFTU9WRTogNCwgLy8gQSBub2RlIHdhcyByZW1vdmVkXHJcbiAgTU9WRTogNSwgLy8gQSBub2RlIHdhcyBtb3ZlZFxyXG4gIElOU0VSVDogNiAvLyBBIG5vZGUgKG9yIGEgc3VidHJlZSBvZiBub2Rlcykgd2FzIGluc2VydGVkXHJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvTXV0YXRpb25Db25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI25hdmlnYXRvcmlkXHJcbnZhciBOYXZpZ2F0b3JJRCA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gIGFwcENvZGVOYW1lOiB7IHZhbHVlOiBcIk1vemlsbGFcIiB9LFxyXG4gIGFwcE5hbWU6IHsgdmFsdWU6IFwiTmV0c2NhcGVcIiB9LFxyXG4gIGFwcFZlcnNpb246IHsgdmFsdWU6IFwiNC4wXCIgfSxcclxuICBwbGF0Zm9ybTogeyB2YWx1ZTogXCJcIiB9LFxyXG4gIHByb2R1Y3Q6IHsgdmFsdWU6IFwiR2Vja29cIiB9LFxyXG4gIHByb2R1Y3RTdWI6IHsgdmFsdWU6IFwiMjAxMDAxMDFcIiB9LFxyXG4gIHVzZXJBZ2VudDogeyB2YWx1ZTogXCJcIiB9LFxyXG4gIHZlbmRvcjogeyB2YWx1ZTogXCJcIiB9LFxyXG4gIHZlbmRvclN1YjogeyB2YWx1ZTogXCJcIiB9LFxyXG4gIHRhaW50RW5hYmxlZDogeyB2YWx1ZTogZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOYXZpZ2F0b3JJRDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvTmF2aWdhdG9ySUQuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVJdGVyYXRvcjtcclxuXHJcbnZhciBOb2RlRmlsdGVyID0gcmVxdWlyZSgnLi9Ob2RlRmlsdGVyJyk7XHJcbnZhciBOb2RlVHJhdmVyc2FsID0gcmVxdWlyZSgnLi9Ob2RlVHJhdmVyc2FsJyk7XHJcblxyXG4vKiBQcml2YXRlIG1ldGhvZHMgYW5kIGhlbHBlcnMgKi9cclxuXHJcbi8qKlxyXG4gKiBAYmFzZWQgb24gV2ViS2l0J3MgTm9kZUl0ZXJhdG9yOjptb3ZlVG9OZXh0IGFuZCBOb2RlSXRlcmF0b3I6Om1vdmVUb1ByZXZpb3VzXHJcbiAqIGh0dHBzOi8vdHJhYy53ZWJraXQub3JnL2Jyb3dzZXIvdHJ1bmsvU291cmNlL1dlYkNvcmUvZG9tL05vZGVJdGVyYXRvci5jcHA/cmV2PTE4NjI3OSNMNTFcclxuICovXHJcbmZ1bmN0aW9uIG1vdmUobm9kZSwgc3RheVdpdGhpbiwgZGlyZWN0aW9uSXNOZXh0KSB7XHJcbiAgaWYgKGRpcmVjdGlvbklzTmV4dCkge1xyXG4gICAgcmV0dXJuIE5vZGVUcmF2ZXJzYWwubmV4dChub2RlLCBzdGF5V2l0aGluKTtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKG5vZGUgPT09IHN0YXlXaXRoaW4pIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTm9kZVRyYXZlcnNhbC5wcmV2aW91cyhub2RlLCBudWxsKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAc3BlYyBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2NvbmNlcHQtbm9kZWl0ZXJhdG9yLXRyYXZlcnNlXHJcbiAqIEBtZXRob2RcclxuICogQGFjY2VzcyBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Tm9kZUl0ZXJhdG9yfSBuaVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIE9uZSBvZiAnbmV4dCcgb3IgJ3ByZXZpb3VzJy5cclxuICogQHJldHVybiB7Tm9kZXxudWxsfVxyXG4gKi9cclxuZnVuY3Rpb24gdHJhdmVyc2UobmksIGRpcmVjdGlvbklzTmV4dCkge1xyXG4gIHZhciBub2RlLCBiZWZvcmVOb2RlO1xyXG4gIG5vZGUgPSBuaS5yZWZlcmVuY2VOb2RlO1xyXG4gIGJlZm9yZU5vZGUgPSBuaS5wb2ludGVyQmVmb3JlUmVmZXJlbmNlTm9kZTtcclxuICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgaWYgKGJlZm9yZU5vZGUgPT09IGRpcmVjdGlvbklzTmV4dCkge1xyXG4gICAgICBiZWZvcmVOb2RlID0gIWJlZm9yZU5vZGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBub2RlID0gbW92ZShub2RlLCBuaS5yb290LCBkaXJlY3Rpb25Jc05leHQpO1xyXG4gICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgcmVzdWx0ID0gbmkuZmlsdGVyLmFjY2VwdE5vZGUobm9kZSk7XHJcbiAgICBpZiAocmVzdWx0ID09PSBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQpIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIG5pLnJlZmVyZW5jZU5vZGUgPSBub2RlO1xyXG4gIG5pLnBvaW50ZXJCZWZvcmVSZWZlcmVuY2VOb2RlID0gYmVmb3JlTm9kZTtcclxuICByZXR1cm4gbm9kZTtcclxufVxyXG5cclxuLyogUHVibGljIEFQSSAqL1xyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudGVkIHZlcnNpb246IGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTUvV0QtZG9tLTIwMTUwNjE4LyNub2RlaXRlcmF0b3JcclxuICogTGF0ZXN0IHZlcnNpb246IGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jbm9kZWl0ZXJhdG9yXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge05vZGV9IHJvb3RcclxuICogQHBhcmFtIHtudW1iZXJ9IHdoYXRUb1Nob3cgW29wdGlvbmFsXVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE5vZGVGaWx0ZXJ9IGZpbHRlciBbb3B0aW9uYWxdXHJcbiAqIEB0aHJvd3MgRXJyb3JcclxuICovXHJcbmZ1bmN0aW9uIE5vZGVJdGVyYXRvcihyb290LCB3aGF0VG9TaG93LCBmaWx0ZXIpIHtcclxuICB2YXIgbmkgPSB0aGlzLCBhY3RpdmUgPSBmYWxzZTtcclxuXHJcbiAgaWYgKCFyb290IHx8ICFyb290Lm5vZGVUeXBlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RPTUV4Y2VwdGlvbjogTk9UX1NVUFBPUlRFRF9FUlInKTtcclxuICB9XHJcblxyXG4gIG5pLnJvb3QgPSBuaS5yZWZlcmVuY2VOb2RlID0gcm9vdDtcclxuICBuaS5wb2ludGVyQmVmb3JlUmVmZXJlbmNlTm9kZSA9IHRydWU7XHJcbiAgbmkud2hhdFRvU2hvdyA9IE51bWJlcih3aGF0VG9TaG93KSB8fCAwO1xyXG5cclxuICBpZiAodHlwZW9mIGZpbHRlciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgZmlsdGVyID0gbnVsbDtcclxuICB9XHJcblxyXG4gIG5pLmZpbHRlciA9IE9iamVjdC5jcmVhdGUoTm9kZUZpbHRlci5wcm90b3R5cGUpO1xyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICogQHJldHVybiB7TnVtYmVyfSBDb25zdGFudCBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQsXHJcbiAgICogIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVCBvciBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQLlxyXG4gICAqL1xyXG4gIG5pLmZpbHRlci5hY2NlcHROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIGlmIChhY3RpdmUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdET01FeGNlcHRpb246IElOVkFMSURfU1RBVEVfRVJSJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFwcyBub2RlVHlwZSB0byB3aGF0VG9TaG93XHJcbiAgICBpZiAoISgoKDEgPDwgKG5vZGUubm9kZVR5cGUgLSAxKSkgJiBuaS53aGF0VG9TaG93KSkpIHtcclxuICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZpbHRlciA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xyXG4gICAgfVxyXG5cclxuICAgIGFjdGl2ZSA9IHRydWU7XHJcbiAgICByZXN1bHQgPSBmaWx0ZXIobm9kZSk7XHJcbiAgICBhY3RpdmUgPSBmYWxzZTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcbn1cclxuXHJcbk5vZGVJdGVyYXRvci5wcm90b3R5cGUgPSB7XHJcbiAgY29uc3RydWN0b3I6IE5vZGVJdGVyYXRvcixcclxuXHJcbiAgLyoqXHJcbiAgICogQHNwZWMgaHR0cDovL3d3dy53My5vcmcvVFIvZG9tLyNkb20tbm9kZWl0ZXJhdG9yLW5leHRub2RlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cclxuICAgKi9cclxuICBuZXh0Tm9kZTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRyYXZlcnNlKHRoaXMsIHRydWUpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBzcGVjIGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jZG9tLW5vZGVpdGVyYXRvci1wcmV2aW91c25vZGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxyXG4gICAqL1xyXG4gIHByZXZpb3VzTm9kZTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRyYXZlcnNlKHRoaXMsIGZhbHNlKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAc3BlYyBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2RvbS1ub2RlaXRlcmF0b3ItZGV0YWNoXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEByZXR1cm4gdm9pZFxyXG4gICAqL1xyXG4gIGRldGFjaDogZnVuY3Rpb24oKSB7XHJcbiAgICAvKiBcIlRoZSBkZXRhY2goKSBtZXRob2QgbXVzdCBkbyBub3RoaW5nLlxyXG4gICAgICogSXRzIGZ1bmN0aW9uYWxpdHkgKGRpc2FibGluZyBhIE5vZGVJdGVyYXRvciBvYmplY3QpIHdhcyByZW1vdmVkLFxyXG4gICAgICogYnV0IHRoZSBtZXRob2QgaXRzZWxmIGlzIHByZXNlcnZlZCBmb3IgY29tcGF0aWJpbGl0eS5cclxuICAgICAqL1xyXG4gIH1cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvTm9kZUl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBUcmVlV2Fsa2VyO1xyXG5cclxudmFyIE5vZGVGaWx0ZXIgPSByZXF1aXJlKCcuL05vZGVGaWx0ZXInKTtcclxudmFyIE5vZGVUcmF2ZXJzYWwgPSByZXF1aXJlKCcuL05vZGVUcmF2ZXJzYWwnKTtcclxuXHJcbnZhciBtYXBDaGlsZCA9IHtcclxuICBmaXJzdDogJ2ZpcnN0Q2hpbGQnLFxyXG4gIGxhc3Q6ICdsYXN0Q2hpbGQnLFxyXG4gIG5leHQ6ICdmaXJzdENoaWxkJyxcclxuICBwcmV2aW91czogJ2xhc3RDaGlsZCdcclxufTtcclxuXHJcbnZhciBtYXBTaWJsaW5nID0ge1xyXG4gIGZpcnN0OiAnbmV4dFNpYmxpbmcnLFxyXG4gIGxhc3Q6ICdwcmV2aW91c1NpYmxpbmcnLFxyXG4gIG5leHQ6ICduZXh0U2libGluZycsXHJcbiAgcHJldmlvdXM6ICdwcmV2aW91c1NpYmxpbmcnXHJcbn07XHJcblxyXG4vKiBQcml2YXRlIG1ldGhvZHMgYW5kIGhlbHBlcnMgKi9cclxuXHJcbi8qKlxyXG4gKiBAc3BlYyBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2NvbmNlcHQtdHJhdmVyc2UtY2hpbGRyZW5cclxuICogQG1ldGhvZFxyXG4gKiBAYWNjZXNzIHByaXZhdGVcclxuICogQHBhcmFtIHtUcmVlV2Fsa2VyfSB0d1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBPbmUgb2YgJ2ZpcnN0JyBvciAnbGFzdCcuXHJcbiAqIEByZXR1cm4ge05vZGV8bnVsbH1cclxuICovXHJcbmZ1bmN0aW9uIHRyYXZlcnNlQ2hpbGRyZW4odHcsIHR5cGUpIHtcclxuICB2YXIgY2hpbGQsIG5vZGUsIHBhcmVudCwgcmVzdWx0LCBzaWJsaW5nO1xyXG4gIG5vZGUgPSB0dy5jdXJyZW50Tm9kZVttYXBDaGlsZFt0eXBlXV07XHJcbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcclxuICAgIHJlc3VsdCA9IHR3LmZpbHRlci5hY2NlcHROb2RlKG5vZGUpO1xyXG4gICAgaWYgKHJlc3VsdCA9PT0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUKSB7XHJcbiAgICAgIHR3LmN1cnJlbnROb2RlID0gbm9kZTtcclxuICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcbiAgICBpZiAocmVzdWx0ID09PSBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQKSB7XHJcbiAgICAgIGNoaWxkID0gbm9kZVttYXBDaGlsZFt0eXBlXV07XHJcbiAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xyXG4gICAgICAgIG5vZGUgPSBjaGlsZDtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcclxuICAgICAgc2libGluZyA9IG5vZGVbbWFwU2libGluZ1t0eXBlXV07XHJcbiAgICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XHJcbiAgICAgICAgbm9kZSA9IHNpYmxpbmc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xyXG4gICAgICBpZiAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdHcucm9vdCB8fCBwYXJlbnQgPT09IHR3LmN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgbm9kZSA9IHBhcmVudDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBzcGVjIGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jY29uY2VwdC10cmF2ZXJzZS1zaWJsaW5nc1xyXG4gKiBAbWV0aG9kXHJcbiAqIEBhY2Nlc3MgcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge1RyZWVXYWxrZXJ9IHR3XHJcbiAqIEBwYXJhbSB7VHJlZVdhbGtlcn0gdHlwZSBPbmUgb2YgJ25leHQnIG9yICdwcmV2aW91cycuXHJcbiAqIEByZXR1cm4ge05vZGV8bnVsfVxyXG4gKi9cclxuZnVuY3Rpb24gdHJhdmVyc2VTaWJsaW5ncyh0dywgdHlwZSkge1xyXG4gIHZhciBub2RlLCByZXN1bHQsIHNpYmxpbmc7XHJcbiAgbm9kZSA9IHR3LmN1cnJlbnROb2RlO1xyXG4gIGlmIChub2RlID09PSB0dy5yb290KSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgd2hpbGUgKHRydWUpIHtcclxuICAgIHNpYmxpbmcgPSBub2RlW21hcFNpYmxpbmdbdHlwZV1dO1xyXG4gICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcclxuICAgICAgbm9kZSA9IHNpYmxpbmc7XHJcbiAgICAgIHJlc3VsdCA9IHR3LmZpbHRlci5hY2NlcHROb2RlKG5vZGUpO1xyXG4gICAgICBpZiAocmVzdWx0ID09PSBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQpIHtcclxuICAgICAgICB0dy5jdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgIH1cclxuICAgICAgc2libGluZyA9IG5vZGVbbWFwQ2hpbGRbdHlwZV1dO1xyXG4gICAgICBpZiAocmVzdWx0ID09PSBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1QgfHwgc2libGluZyA9PT0gbnVsbCkge1xyXG4gICAgICAgIHNpYmxpbmcgPSBub2RlW21hcFNpYmxpbmdbdHlwZV1dO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xyXG4gICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdHcucm9vdCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmICh0dy5maWx0ZXIuYWNjZXB0Tm9kZShub2RlKSA9PT0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuXHJcbi8qIFB1YmxpYyBBUEkgKi9cclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRlZCB2ZXJzaW9uOiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDE1L1dELWRvbS0yMDE1MDYxOC8jaW50ZXJmYWNlLXRyZWV3YWxrZXJcclxuICogTGF0ZXN0IHZlcnNpb246IGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jaW50ZXJmYWNlLXRyZWV3YWxrZXJcclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7Tm9kZX0gcm9vdFxyXG4gKiBAcGFyYW0ge251bWJlcn0gd2hhdFRvU2hvdyBbb3B0aW9uYWxdXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb258Tm9kZUZpbHRlcn0gZmlsdGVyIFtvcHRpb25hbF1cclxuICogQHRocm93cyBFcnJvclxyXG4gKi9cclxuZnVuY3Rpb24gVHJlZVdhbGtlcihyb290LCB3aGF0VG9TaG93LCBmaWx0ZXIpIHtcclxuICB2YXIgdHcgPSB0aGlzLCBhY3RpdmUgPSBmYWxzZTtcclxuXHJcbiAgaWYgKCFyb290IHx8ICFyb290Lm5vZGVUeXBlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RPTUV4Y2VwdGlvbjogTk9UX1NVUFBPUlRFRF9FUlInKTtcclxuICB9XHJcblxyXG4gIHR3LnJvb3QgPSByb290O1xyXG4gIHR3LndoYXRUb1Nob3cgPSBOdW1iZXIod2hhdFRvU2hvdykgfHwgMDtcclxuXHJcbiAgdHcuY3VycmVudE5vZGUgPSByb290O1xyXG5cclxuICBpZiAodHlwZW9mIGZpbHRlciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgZmlsdGVyID0gbnVsbDtcclxuICB9XHJcblxyXG4gIHR3LmZpbHRlciA9IE9iamVjdC5jcmVhdGUoTm9kZUZpbHRlci5wcm90b3R5cGUpO1xyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICogQHJldHVybiB7TnVtYmVyfSBDb25zdGFudCBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQsXHJcbiAgICogIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVCBvciBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQLlxyXG4gICAqL1xyXG4gIHR3LmZpbHRlci5hY2NlcHROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIGlmIChhY3RpdmUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdET01FeGNlcHRpb246IElOVkFMSURfU1RBVEVfRVJSJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFwcyBub2RlVHlwZSB0byB3aGF0VG9TaG93XHJcbiAgICBpZiAoISgoKDEgPDwgKG5vZGUubm9kZVR5cGUgLSAxKSkgJiB0dy53aGF0VG9TaG93KSkpIHtcclxuICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZpbHRlciA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xyXG4gICAgfVxyXG5cclxuICAgIGFjdGl2ZSA9IHRydWU7XHJcbiAgICByZXN1bHQgPSBmaWx0ZXIobm9kZSk7XHJcbiAgICBhY3RpdmUgPSBmYWxzZTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcbn1cclxuXHJcblRyZWVXYWxrZXIucHJvdG90eXBlID0ge1xyXG5cclxuICBjb25zdHJ1Y3RvcjogVHJlZVdhbGtlcixcclxuXHJcbiAgLyoqXHJcbiAgICogQHNwZWMgaHR0cDovL3d3dy53My5vcmcvVFIvZG9tLyNkb20tdHJlZXdhbGtlci1wYXJlbnRub2RlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cclxuICAgKi9cclxuICBwYXJlbnROb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XHJcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiBub2RlICE9PSB0aGlzLnJvb3QpIHtcclxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcclxuICAgICAgaWYgKG5vZGUgIT09IG51bGwgJiYgdGhpcy5maWx0ZXIuYWNjZXB0Tm9kZShub2RlKSA9PT0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBzcGVjIGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jZG9tLXRyZWV3YWxrZXItZmlyc3RjaGlsZFxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XHJcbiAgICovXHJcbiAgZmlyc3RDaGlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRyYXZlcnNlQ2hpbGRyZW4odGhpcywgJ2ZpcnN0Jyk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHNwZWMgaHR0cDovL3d3dy53My5vcmcvVFIvZG9tLyNkb20tdHJlZXdhbGtlci1sYXN0Y2hpbGRcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxyXG4gICAqL1xyXG4gIGxhc3RDaGlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRyYXZlcnNlQ2hpbGRyZW4odGhpcywgJ2xhc3QnKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAc3BlYyBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2RvbS10cmVld2Fsa2VyLXByZXZpb3Vzc2libGluZ1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XHJcbiAgICovXHJcbiAgcHJldmlvdXNTaWJsaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdHJhdmVyc2VTaWJsaW5ncyh0aGlzLCAncHJldmlvdXMnKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAc3BlYyBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2RvbS10cmVld2Fsa2VyLW5leHRzaWJsaW5nXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cclxuICAgKi9cclxuICBuZXh0U2libGluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRyYXZlcnNlU2libGluZ3ModGhpcywgJ25leHQnKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAc3BlYyBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2RvbS10cmVld2Fsa2VyLXByZXZpb3Vzbm9kZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XHJcbiAgICovXHJcbiAgcHJldmlvdXNOb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbm9kZSwgcmVzdWx0LCBzaWJsaW5nO1xyXG4gICAgbm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XHJcbiAgICB3aGlsZSAobm9kZSAhPT0gdGhpcy5yb290KSB7XHJcbiAgICAgIHNpYmxpbmcgPSBub2RlLnByZXZpb3VzU2libGluZztcclxuICAgICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcclxuICAgICAgICBub2RlID0gc2libGluZztcclxuICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlci5hY2NlcHROb2RlKG5vZGUpO1xyXG4gICAgICAgIHdoaWxlIChyZXN1bHQgIT09IE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVCAmJiBub2RlLmxhc3RDaGlsZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xyXG4gICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXIuYWNjZXB0Tm9kZShub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUKSB7XHJcbiAgICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gbm9kZTtcclxuICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5vZGUgPT09IHRoaXMucm9vdCB8fCBub2RlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xyXG4gICAgICBpZiAodGhpcy5maWx0ZXIuYWNjZXB0Tm9kZShub2RlKSA9PT0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBzcGVjIGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jZG9tLXRyZWV3YWxrZXItbmV4dG5vZGVcclxuICAgKiBAYmFzZWQgb24gV2ViS2l0J3MgVHJlZVdhbGtlcjo6bmV4dE5vZGVcclxuICAgKiBodHRwczovL3RyYWMud2Via2l0Lm9yZy9icm93c2VyL3RydW5rL1NvdXJjZS9XZWJDb3JlL2RvbS9UcmVlV2Fsa2VyLmNwcD9yZXY9MTc5MTQzI0wyNTJcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxyXG4gICAqL1xyXG4gIG5leHROb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbm9kZSwgcmVzdWx0LCBmb2xsb3dpbmc7XHJcbiAgICBub2RlID0gdGhpcy5jdXJyZW50Tm9kZTtcclxuICAgIHJlc3VsdCA9IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcclxuXHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICB3aGlsZSAocmVzdWx0ICE9PSBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1QgJiYgbm9kZS5maXJzdENoaWxkICE9PSBudWxsKSB7XHJcbiAgICAgICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcclxuICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlci5hY2NlcHROb2RlKG5vZGUpO1xyXG4gICAgICAgIGlmIChyZXN1bHQgPT09IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCkge1xyXG4gICAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZm9sbG93aW5nID0gTm9kZVRyYXZlcnNhbC5uZXh0U2tpcHBpbmdDaGlsZHJlbihub2RlLCB0aGlzLnJvb3QpO1xyXG4gICAgICBpZiAoZm9sbG93aW5nICE9PSBudWxsKSB7XHJcbiAgICAgICAgbm9kZSA9IGZvbGxvd2luZztcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICByZXN1bHQgPSB0aGlzLmZpbHRlci5hY2NlcHROb2RlKG5vZGUpO1xyXG4gICAgICBpZiAocmVzdWx0ID09PSBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gbm9kZTtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RvbWluby9saWIvVHJlZVdhbGtlci5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjd2luZG93dGltZXJzXHJcbnZhciBXaW5kb3dUaW1lcnMgPSB7XHJcbiAgc2V0VGltZW91dDogc2V0VGltZW91dCxcclxuICBjbGVhclRpbWVvdXQ6IGNsZWFyVGltZW91dCxcclxuICBzZXRJbnRlcnZhbDogc2V0SW50ZXJ2YWwsXHJcbiAgY2xlYXJJbnRlcnZhbDogY2xlYXJJbnRlcnZhbFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXaW5kb3dUaW1lcnM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kb21pbm8vbGliL1dpbmRvd1RpbWVycy5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoganNoaW50IG5vZGU6dHJ1ZSwgbGF0ZWRlZjpmYWxzZSAqL1xyXG5cInVzZSBzdHJpY3RcIjsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbi8qIVxyXG5QYXJzZXItTGliXHJcbkNvcHlyaWdodCAoYykgMjAwOS0yMDExIE5pY2hvbGFzIEMuIFpha2FzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5cclxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG5USEUgU09GVFdBUkUuXHJcblxyXG4qL1xyXG4vKiBWZXJzaW9uIHYwLjIuNStkb21pbm8xLCBCdWlsZCB0aW1lOiAzMC1KYW51YXJ5LTIwMTYgMDU6MTM6MDMgKi9cclxudmFyIHBhcnNlcmxpYiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbihmdW5jdGlvbigpe1xyXG5cclxuLyoqXHJcbiAqIEEgZ2VuZXJpYyBiYXNlIHRvIGluaGVyaXQgZnJvbSBmb3IgYW55IG9iamVjdFxyXG4gKiB0aGF0IG5lZWRzIGV2ZW50IGhhbmRsaW5nLlxyXG4gKiBAY2xhc3MgRXZlbnRUYXJnZXRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpe1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFycmF5IG9mIGxpc3RlbmVycyBmb3IgdmFyaW91cyBldmVudHMuXHJcbiAgICAgKiBAdHlwZSBPYmplY3RcclxuICAgICAqIEBwcm9wZXJ0eSBfbGlzdGVuZXJzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG59XHJcblxyXG5FdmVudFRhcmdldC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLy9yZXN0b3JlIGNvbnN0cnVjdG9yXHJcbiAgICBjb25zdHJ1Y3RvcjogRXZlbnRUYXJnZXQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQgdHlwZS5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHRvIGFkZCBhIGxpc3RlbmVyIGZvci5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cclxuICAgICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICAgKiBAbWV0aG9kIGFkZExpc3RlbmVyXHJcbiAgICAgKi9cclxuICAgIGFkZExpc3RlbmVyOiBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcil7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9saXN0ZW5lcnNbdHlwZV0pe1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlcyBhbiBldmVudCBiYXNlZCBvbiB0aGUgcGFzc2VkLWluIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZXZlbnQgQW4gb2JqZWN0IHdpdGggYXQgbGVhc3QgYSAndHlwZScgYXR0cmlidXRlXHJcbiAgICAgKiAgICAgIG9yIGEgc3RyaW5nIGluZGljYXRpbmcgdGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAgICogQG1ldGhvZCBmaXJlXHJcbiAgICAgKi9cclxuICAgIGZpcmU6IGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiKXtcclxuICAgICAgICAgICAgZXZlbnQgPSB7IHR5cGU6IGV2ZW50IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQudGFyZ2V0ICE9PSBcInVuZGVmaW5lZFwiKXtcclxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQudHlwZSA9PT0gXCJ1bmRlZmluZWRcIil7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IG9iamVjdCBtaXNzaW5nICd0eXBlJyBwcm9wZXJ0eS5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzW2V2ZW50LnR5cGVdKXtcclxuXHJcbiAgICAgICAgICAgIC8vY3JlYXRlIGEgY29weSBvZiB0aGUgYXJyYXkgYW5kIHVzZSB0aGF0IHNvIGxpc3RlbmVycyBjYW4ndCBjaGFuZVxyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50LnR5cGVdLmNvbmNhdCgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGxlbj1saXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmNhbGwodGhpcywgZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudCB0eXBlLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gcmVtb3ZlIGEgbGlzdGVuZXIgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBmdW5jdGlvbiB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAgICogQG1ldGhvZCByZW1vdmVMaXN0ZW5lclxyXG4gICAgICovXHJcbiAgICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpe1xyXG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbdHlwZV0pe1xyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGxlbj1saXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gbGlzdGVuZXIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIENvbnZlbmllbnQgd2F5IHRvIHJlYWQgdGhyb3VnaCBzdHJpbmdzLlxyXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi51dGlsXHJcbiAqIEBjbGFzcyBTdHJpbmdSZWFkZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHJlYWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBTdHJpbmdSZWFkZXIodGV4dCl7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5wdXQgdGV4dCB3aXRoIGxpbmUgZW5kaW5ncyBub3JtYWxpemVkLlxyXG4gICAgICogQHByb3BlcnR5IF9pbnB1dFxyXG4gICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9pbnB1dCA9IHRleHQucmVwbGFjZSgvKFxccnxcXG4pezEsMn0vZywgXCJcXG5cIik7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJvdyBmb3IgdGhlIGNoYXJhY3RlciB0byBiZSByZWFkIG5leHQuXHJcbiAgICAgKiBAcHJvcGVydHkgX2xpbmVcclxuICAgICAqIEB0eXBlIGludFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fbGluZSA9IDE7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3RlciB0byBiZSByZWFkIG5leHQuXHJcbiAgICAgKiBAcHJvcGVydHkgX2NvbFxyXG4gICAgICogQHR5cGUgaW50XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9jb2wgPSAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgaW4gdGhlIGlucHV0IHRvIGJlIHJlYWQgbmV4dC5cclxuICAgICAqIEBwcm9wZXJ0eSBfY3Vyc29yXHJcbiAgICAgKiBAdHlwZSBpbnRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2N1cnNvciA9IDA7XHJcbn1cclxuXHJcblN0cmluZ1JlYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLy9yZXN0b3JlIGNvbnN0cnVjdG9yXHJcbiAgICBjb25zdHJ1Y3RvcjogU3RyaW5nUmVhZGVyLFxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gUG9zaXRpb24gaW5mb1xyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjb2x1bW4gb2YgdGhlIGNoYXJhY3RlciB0byBiZSByZWFkIG5leHQuXHJcbiAgICAgKiBAcmV0dXJuIHtpbnR9IFRoZSBjb2x1bW4gb2YgdGhlIGNoYXJhY3RlciB0byBiZSByZWFkIG5leHQuXHJcbiAgICAgKiBAbWV0aG9kIGdldENvbFxyXG4gICAgICovXHJcbiAgICBnZXRDb2w6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByb3cgb2YgdGhlIGNoYXJhY3RlciB0byBiZSByZWFkIG5leHQuXHJcbiAgICAgKiBAcmV0dXJuIHtpbnR9IFRoZSByb3cgb2YgdGhlIGNoYXJhY3RlciB0byBiZSByZWFkIG5leHQuXHJcbiAgICAgKiBAbWV0aG9kIGdldExpbmVcclxuICAgICAqL1xyXG4gICAgZ2V0TGluZTogZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZSA7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBpZiB5b3UncmUgYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZXJlJ3Mgbm8gbW9yZSBpbnB1dCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICogQG1ldGhvZCBlb2ZcclxuICAgICAqL1xyXG4gICAgZW9mOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiAodGhpcy5fY3Vyc29yID09PSB0aGlzLl9pbnB1dC5sZW5ndGgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIEJhc2ljIHJlYWRpbmdcclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgdGhlIG5leHQgY2hhcmFjdGVyIHdpdGhvdXQgYWR2YW5jaW5nIHRoZSBjdXJzb3IuXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gY291bnQgSG93IG1hbnkgY2hhcmFjdGVycyB0byBsb29rIGFoZWFkIChkZWZhdWx0IGlzIDEpLlxyXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgbmV4dCBjaGFyYWN0ZXIgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBuZXh0IGNoYXJhY3Rlci5cclxuICAgICAqIEBtZXRob2QgcGVla1xyXG4gICAgICovXHJcbiAgICBwZWVrOiBmdW5jdGlvbihjb3VudCl7XHJcbiAgICAgICAgdmFyIGMgPSBudWxsO1xyXG4gICAgICAgIGNvdW50ID0gKHR5cGVvZiBjb3VudCA9PT0gXCJ1bmRlZmluZWRcIiA/IDEgOiBjb3VudCk7XHJcblxyXG4gICAgICAgIC8vaWYgd2UncmUgbm90IGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0Li4uXHJcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvciA8IHRoaXMuX2lucHV0Lmxlbmd0aCl7XHJcblxyXG4gICAgICAgICAgICAvL2dldCBjaGFyYWN0ZXIgYW5kIGluY3JlbWVudCBjdXJzb3IgYW5kIGNvbHVtblxyXG4gICAgICAgICAgICBjID0gdGhpcy5faW5wdXQuY2hhckF0KHRoaXMuX2N1cnNvciArIGNvdW50IC0gMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyB0aGUgbmV4dCBjaGFyYWN0ZXIgZnJvbSB0aGUgaW5wdXQgYW5kIGFkanVzdHMgdGhlIHJvdyBhbmQgY29sdW1uXHJcbiAgICAgKiBhY2NvcmRpbmdseS5cclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIG5leHQgY2hhcmFjdGVyIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gbmV4dCBjaGFyYWN0ZXIuXHJcbiAgICAgKiBAbWV0aG9kIHJlYWRcclxuICAgICAqL1xyXG4gICAgcmVhZDogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgYyA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vaWYgd2UncmUgbm90IGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0Li4uXHJcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvciA8IHRoaXMuX2lucHV0Lmxlbmd0aCl7XHJcblxyXG4gICAgICAgICAgICAvL2lmIHRoZSBsYXN0IGNoYXJhY3RlciB3YXMgYSBuZXdsaW5lLCBpbmNyZW1lbnQgcm93IGNvdW50XHJcbiAgICAgICAgICAgIC8vYW5kIHJlc2V0IGNvbHVtbiBjb3VudFxyXG4gICAgICAgICAgICBpZiAodGhpcy5faW5wdXQuY2hhckF0KHRoaXMuX2N1cnNvcikgPT09IFwiXFxuXCIpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZSsrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sPTE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2wrKztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9nZXQgY2hhcmFjdGVyIGFuZCBpbmNyZW1lbnQgY3Vyc29yIGFuZCBjb2x1bW5cclxuICAgICAgICAgICAgYyA9IHRoaXMuX2lucHV0LmNoYXJBdCh0aGlzLl9jdXJzb3IrKyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH0sXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBNaXNjXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNhdmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIHNvIGl0IGNhbiBiZSByZXR1cm5lZCB0byBsYXRlci5cclxuICAgICAqIEBtZXRob2QgbWFya1xyXG4gICAgICogQHJldHVybiB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgbWFyazogZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLl9ib29rbWFyayA9IHtcclxuICAgICAgICAgICAgY3Vyc29yOiB0aGlzLl9jdXJzb3IsXHJcbiAgICAgICAgICAgIGxpbmU6ICAgdGhpcy5fbGluZSxcclxuICAgICAgICAgICAgY29sOiAgICB0aGlzLl9jb2xcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24oKXtcclxuICAgICAgICBpZiAodGhpcy5fYm9va21hcmspe1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSB0aGlzLl9ib29rbWFyay5jdXJzb3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSB0aGlzLl9ib29rbWFyay5saW5lO1xyXG4gICAgICAgICAgICB0aGlzLl9jb2wgPSB0aGlzLl9ib29rbWFyay5jb2w7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ib29rbWFyaztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gQWR2YW5jZWQgcmVhZGluZ1xyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyB1cCB0byBhbmQgaW5jbHVkaW5nIHRoZSBnaXZlbiBzdHJpbmcuIFRocm93cyBhbiBlcnJvciBpZiB0aGF0XHJcbiAgICAgKiBzdHJpbmcgaXMgbm90IGZvdW5kLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gVGhlIHN0cmluZyB0byByZWFkLlxyXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgc3RyaW5nIHdoZW4gaXQgaXMgZm91bmQuXHJcbiAgICAgKiBAdGhyb3dzIEVycm9yIHdoZW4gdGhlIHN0cmluZyBwYXR0ZXJuIGlzIG5vdCBmb3VuZC5cclxuICAgICAqIEBtZXRob2QgcmVhZFRvXHJcbiAgICAgKi9cclxuICAgIHJlYWRUbzogZnVuY3Rpb24ocGF0dGVybil7XHJcblxyXG4gICAgICAgIHZhciBidWZmZXIgPSBcIlwiLFxyXG4gICAgICAgICAgICBjO1xyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIEZpcnN0LCBidWZmZXIgbXVzdCBiZSB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIHBhdHRlcm4uXHJcbiAgICAgICAgICogVGhlbiwgYnVmZmVyIG11c3QgZW5kIHdpdGggdGhlIHBhdHRlcm4gb3IgZWxzZSByZWFjaCB0aGVcclxuICAgICAgICAgKiBlbmQgb2YgdGhlIGlucHV0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHdoaWxlIChidWZmZXIubGVuZ3RoIDwgcGF0dGVybi5sZW5ndGggfHwgYnVmZmVyLmxhc3RJbmRleE9mKHBhdHRlcm4pICE9PSBidWZmZXIubGVuZ3RoIC0gcGF0dGVybi5sZW5ndGgpe1xyXG4gICAgICAgICAgICBjID0gdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgICAgIGlmIChjKXtcclxuICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBjO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgcGF0dGVybiArIFwiXFxcIiBhdCBsaW5lIFwiICsgdGhpcy5fbGluZSAgKyBcIiwgY29sIFwiICsgdGhpcy5fY29sICsgXCIuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYnVmZmVyO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBjaGFyYWN0ZXJzIHdoaWxlIGVhY2ggY2hhcmFjdGVyIGNhdXNlcyB0aGUgZ2l2ZW5cclxuICAgICAqIGZpbHRlciBmdW5jdGlvbiB0byByZXR1cm4gdHJ1ZS4gVGhlIGZ1bmN0aW9uIGlzIHBhc3NlZFxyXG4gICAgICogaW4gZWFjaCBjaGFyYWN0ZXIgYW5kIGVpdGhlciByZXR1cm5zIHRydWUgdG8gY29udGludWVcclxuICAgICAqIHJlYWRpbmcgb3IgZmFsc2UgdG8gc3RvcC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbHRlciBUaGUgZnVuY3Rpb24gdG8gcmVhZCBvbiBlYWNoIGNoYXJhY3Rlci5cclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHN0cmluZyBtYWRlIHVwIG9mIGFsbCBjaGFyYWN0ZXJzIHRoYXQgcGFzc2VkIHRoZVxyXG4gICAgICogICAgICBmaWx0ZXIgY2hlY2suXHJcbiAgICAgKiBAbWV0aG9kIHJlYWRXaGlsZVxyXG4gICAgICovXHJcbiAgICByZWFkV2hpbGU6IGZ1bmN0aW9uKGZpbHRlcil7XHJcblxyXG4gICAgICAgIHZhciBidWZmZXIgPSBcIlwiLFxyXG4gICAgICAgICAgICBjID0gdGhpcy5yZWFkKCk7XHJcblxyXG4gICAgICAgIHdoaWxlKGMgIT09IG51bGwgJiYgZmlsdGVyKGMpKXtcclxuICAgICAgICAgICAgYnVmZmVyICs9IGM7XHJcbiAgICAgICAgICAgIGMgPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBidWZmZXI7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGNoYXJhY3RlcnMgdGhhdCBtYXRjaCBlaXRoZXIgdGV4dCBvciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbmRcclxuICAgICAqIHJldHVybnMgdGhvc2UgY2hhcmFjdGVycy4gSWYgYSBtYXRjaCBpcyBmb3VuZCwgdGhlIHJvdyBhbmQgY29sdW1uXHJcbiAgICAgKiBhcmUgYWRqdXN0ZWQ7IGlmIG5vIG1hdGNoIGlzIGZvdW5kLCB0aGUgcmVhZGVyJ3Mgc3RhdGUgaXMgdW5jaGFuZ2VkLlxyXG4gICAgICogcmVhZGluZyBvciBmYWxzZSB0byBzdG9wLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBtYXRjaHRlciBJZiBhIHN0cmluZywgdGhlbiB0aGUgbGl0ZXJhbCBzdHJpbmdcclxuICAgICAqICAgICAgdmFsdWUgaXMgc2VhcmNoZWQgZm9yLiBJZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgdGhlbiBhbnkgc3RyaW5nXHJcbiAgICAgKiAgICAgIG1hdGNoaW5nIHRoZSBwYXR0ZXJuIGlzIHNlYXJjaCBmb3IuXHJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBzdHJpbmcgbWFkZSB1cCBvZiBhbGwgY2hhcmFjdGVycyB0aGF0IG1hdGNoZWQgb3JcclxuICAgICAqICAgICAgbnVsbCBpZiB0aGVyZSB3YXMgbm8gbWF0Y2guXHJcbiAgICAgKiBAbWV0aG9kIHJlYWRNYXRjaFxyXG4gICAgICovXHJcbiAgICByZWFkTWF0Y2g6IGZ1bmN0aW9uKG1hdGNoZXIpe1xyXG5cclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX2N1cnNvciksXHJcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy9pZiBpdCdzIGEgc3RyaW5nLCBqdXN0IGRvIGEgc3RyYWlnaHQgbWF0Y2hcclxuICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXIgPT09IFwic3RyaW5nXCIpe1xyXG4gICAgICAgICAgICBpZiAoc291cmNlLmluZGV4T2YobWF0Y2hlcikgPT09IDApe1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJlYWRDb3VudChtYXRjaGVyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZXIgaW5zdGFuY2VvZiBSZWdFeHApe1xyXG4gICAgICAgICAgICBpZiAobWF0Y2hlci50ZXN0KHNvdXJjZSkpe1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJlYWRDb3VudChSZWdFeHAubGFzdE1hdGNoLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSBnaXZlbiBudW1iZXIgb2YgY2hhcmFjdGVycy4gSWYgdGhlIGVuZCBvZiB0aGUgaW5wdXQgaXMgcmVhY2hlZCxcclxuICAgICAqIGl0IHJlYWRzIG9ubHkgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXJzIGFuZCBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvci5cclxuICAgICAqIEBwYXJhbSB7aW50fSBjb3VudCBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gcmVhZC5cclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHN0cmluZyBtYWRlIHVwIHRoZSByZWFkIGNoYXJhY3RlcnMuXHJcbiAgICAgKiBAbWV0aG9kIHJlYWRDb3VudFxyXG4gICAgICovXHJcbiAgICByZWFkQ291bnQ6IGZ1bmN0aW9uKGNvdW50KXtcclxuICAgICAgICB2YXIgYnVmZmVyID0gXCJcIjtcclxuXHJcbiAgICAgICAgd2hpbGUoY291bnQtLSl7XHJcbiAgICAgICAgICAgIGJ1ZmZlciArPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICB9XHJcblxyXG59O1xyXG4vKipcclxuICogVHlwZSB0byB1c2Ugd2hlbiBhIHN5bnRheCBlcnJvciBvY2N1cnMuXHJcbiAqIEBjbGFzcyBTeW50YXhFcnJvclxyXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi51dGlsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cclxuICogQHBhcmFtIHtpbnR9IGxpbmUgVGhlIGxpbmUgYXQgd2hpY2ggdGhlIGVycm9yIG9jY3VycmVkLlxyXG4gKiBAcGFyYW0ge2ludH0gY29sIFRoZSBjb2x1bW4gYXQgd2hpY2ggdGhlIGVycm9yIG9jY3VycmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gU3ludGF4RXJyb3IobWVzc2FnZSwgbGluZSwgY29sKXtcclxuICAgIEVycm9yLmNhbGwodGhpcyk7XHJcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29sdW1uIGF0IHdoaWNoIHRoZSBlcnJvciBvY2N1cnJlZC5cclxuICAgICAqIEB0eXBlIGludFxyXG4gICAgICogQHByb3BlcnR5IGNvbFxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbCA9IGNvbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsaW5lIGF0IHdoaWNoIHRoZSBlcnJvciBvY2N1cnJlZC5cclxuICAgICAqIEB0eXBlIGludFxyXG4gICAgICogQHByb3BlcnR5IGxpbmVcclxuICAgICAqL1xyXG4gICAgdGhpcy5saW5lID0gbGluZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bml0LlxyXG4gICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgKiBAcHJvcGVydHkgdGV4dFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG5cclxufVxyXG5cclxuLy9pbmhlcml0IGZyb20gRXJyb3JcclxuU3ludGF4RXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuU3ludGF4RXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ludGF4RXJyb3I7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4vKipcclxuICogQmFzZSB0eXBlIHRvIHJlcHJlc2VudCBhIHNpbmdsZSBzeW50YWN0aWMgdW5pdC5cclxuICogQGNsYXNzIFN5bnRheFVuaXRcclxuICogQG5hbWVzcGFjZSBwYXJzZXJsaWIudXRpbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgb2YgdGhlIHVuaXQuXHJcbiAqIEBwYXJhbSB7aW50fSBsaW5lIFRoZSBsaW5lIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cclxuICogQHBhcmFtIHtpbnR9IGNvbCBUaGUgY29sdW1uIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cclxuICovXHJcbmZ1bmN0aW9uIFN5bnRheFVuaXQodGV4dCwgbGluZSwgY29sLCB0eXBlKXtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29sdW1uIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cclxuICAgICAqIEB0eXBlIGludFxyXG4gICAgICogQHByb3BlcnR5IGNvbFxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbCA9IGNvbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsaW5lIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cclxuICAgICAqIEB0eXBlIGludFxyXG4gICAgICogQHByb3BlcnR5IGxpbmVcclxuICAgICAqL1xyXG4gICAgdGhpcy5saW5lID0gbGluZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bml0LlxyXG4gICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgKiBAcHJvcGVydHkgdGV4dFxyXG4gICAgICovXHJcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHR5cGUgb2Ygc3ludGF4IHVuaXQuXHJcbiAgICAgKiBAdHlwZSBpbnRcclxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXHJcbiAgICAgKi9cclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgc3ludGF4IHVuaXQgYmFzZWQgc29sZWx5IG9uIHRoZSBnaXZlbiB0b2tlbi5cclxuICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIG5ldyBzeW50YXggdW5pdCB3aGVuXHJcbiAqIGl0IHJlcHJlc2VudHMgYSBzaW5nbGUgdG9rZW4gaW5zdGVhZCBvZiBtdWx0aXBsZS5cclxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuIFRoZSB0b2tlbiBvYmplY3QgdG8gcmVwcmVzZW50LlxyXG4gKiBAcmV0dXJuIHtwYXJzZXJsaWIudXRpbC5TeW50YXhVbml0fSBUaGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdG9rZW4uXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBmcm9tVG9rZW5cclxuICovXHJcblN5bnRheFVuaXQuZnJvbVRva2VuID0gZnVuY3Rpb24odG9rZW4pe1xyXG4gICAgcmV0dXJuIG5ldyBTeW50YXhVbml0KHRva2VuLnZhbHVlLCB0b2tlbi5zdGFydExpbmUsIHRva2VuLnN0YXJ0Q29sKTtcclxufTtcclxuXHJcblN5bnRheFVuaXQucHJvdG90eXBlID0ge1xyXG5cclxuICAgIC8vcmVzdG9yZSBjb25zdHJ1Y3RvclxyXG4gICAgY29uc3RydWN0b3I6IFN5bnRheFVuaXQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bml0LlxyXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5pdC5cclxuICAgICAqIEBtZXRob2QgdmFsdWVPZlxyXG4gICAgICovXHJcbiAgICB2YWx1ZU9mOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5pdC5cclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuaXQuXHJcbiAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyaWMgVG9rZW5TdHJlYW0gcHJvdmlkaW5nIGJhc2UgZnVuY3Rpb25hbGl0eS5cclxuICogQGNsYXNzIFRva2VuU3RyZWFtQmFzZVxyXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi51dGlsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdSZWFkZXJ9IGlucHV0IFRoZSB0ZXh0IHRvIHRva2VuaXplIG9yIGEgcmVhZGVyIGZyb21cclxuICogICAgICB3aGljaCB0byByZWFkIHRoZSBpbnB1dC5cclxuICovXHJcbmZ1bmN0aW9uIFRva2VuU3RyZWFtQmFzZShpbnB1dCwgdG9rZW5EYXRhKXtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzdHJpbmcgcmVhZGVyIGZvciBlYXN5IGFjY2VzcyB0byB0aGUgdGV4dC5cclxuICAgICAqIEB0eXBlIFN0cmluZ1JlYWRlclxyXG4gICAgICogQHByb3BlcnR5IF9yZWFkZXJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3JlYWRlciA9IGlucHV0ID8gbmV3IFN0cmluZ1JlYWRlcihpbnB1dC50b1N0cmluZygpKSA6IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUb2tlbiBvYmplY3QgZm9yIHRoZSBsYXN0IGNvbnN1bWVkIHRva2VuLlxyXG4gICAgICogQHR5cGUgVG9rZW5cclxuICAgICAqIEBwcm9wZXJ0eSBfdG9rZW5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3Rva2VuID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhcnJheSBvZiB0b2tlbiBpbmZvcm1hdGlvbi5cclxuICAgICAqIEB0eXBlIEFycmF5XHJcbiAgICAgKiBAcHJvcGVydHkgX3Rva2VuRGF0YVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fdG9rZW5EYXRhID0gdG9rZW5EYXRhO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9va2FoZWFkIHRva2VuIGJ1ZmZlci5cclxuICAgICAqIEB0eXBlIEFycmF5XHJcbiAgICAgKiBAcHJvcGVydHkgX2x0XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9sdCA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9va2FoZWFkIHRva2VuIGJ1ZmZlciBpbmRleC5cclxuICAgICAqIEB0eXBlIGludFxyXG4gICAgICogQHByb3BlcnR5IF9sdEluZGV4XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9sdEluZGV4ID0gMDtcclxuXHJcbiAgICB0aGlzLl9sdEluZGV4Q2FjaGUgPSBbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFjY2VwdHMgYW4gYXJyYXkgb2YgdG9rZW4gaW5mb3JtYXRpb24gYW5kIG91dHB1dHNcclxuICogYW4gYXJyYXkgb2YgdG9rZW4gZGF0YSBjb250YWluaW5nIGtleS12YWx1ZSBtYXBwaW5nc1xyXG4gKiBhbmQgbWF0Y2hpbmcgZnVuY3Rpb25zIHRoYXQgdGhlIFRva2VuU3RyZWFtIG5lZWRzLlxyXG4gKiBAcGFyYW0ge0FycmF5fSB0b2tlbnMgQW4gYXJyYXkgb2YgdG9rZW4gZGVzY3JpcHRvcnMuXHJcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBwcm9jZXNzZWQgdG9rZW4gZGF0YS5cclxuICogQG1ldGhvZCBjcmVhdGVUb2tlbkRhdGFcclxuICogQHN0YXRpY1xyXG4gKi9cclxuVG9rZW5TdHJlYW1CYXNlLmNyZWF0ZVRva2VuRGF0YSA9IGZ1bmN0aW9uKHRva2Vucyl7XHJcblxyXG4gICAgdmFyIG5hbWVNYXAgICAgID0gW10sXHJcbiAgICAgICAgdHlwZU1hcCAgICAgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgICAgIHRva2VuRGF0YSAgICAgPSB0b2tlbnMuY29uY2F0KFtdKSxcclxuICAgICAgICBpICAgICAgICAgICAgPSAwLFxyXG4gICAgICAgIGxlbiAgICAgICAgICAgID0gdG9rZW5EYXRhLmxlbmd0aCsxO1xyXG5cclxuICAgIHRva2VuRGF0YS5VTktOT1dOID0gLTE7XHJcbiAgICB0b2tlbkRhdGEudW5zaGlmdCh7bmFtZTpcIkVPRlwifSk7XHJcblxyXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKyl7XHJcbiAgICAgICAgbmFtZU1hcC5wdXNoKHRva2VuRGF0YVtpXS5uYW1lKTtcclxuICAgICAgICB0b2tlbkRhdGFbdG9rZW5EYXRhW2ldLm5hbWVdID0gaTtcclxuICAgICAgICBpZiAodG9rZW5EYXRhW2ldLnRleHQpe1xyXG4gICAgICAgICAgICB0eXBlTWFwW3Rva2VuRGF0YVtpXS50ZXh0XSA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRva2VuRGF0YS5uYW1lID0gZnVuY3Rpb24odHQpe1xyXG4gICAgICAgIHJldHVybiBuYW1lTWFwW3R0XTtcclxuICAgIH07XHJcblxyXG4gICAgdG9rZW5EYXRhLnR5cGUgPSBmdW5jdGlvbihjKXtcclxuICAgICAgICByZXR1cm4gdHlwZU1hcFtjXTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHRva2VuRGF0YTtcclxufTtcclxuXHJcblRva2VuU3RyZWFtQmFzZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLy9yZXN0b3JlIGNvbnN0cnVjdG9yXHJcbiAgICBjb25zdHJ1Y3RvcjogVG9rZW5TdHJlYW1CYXNlLFxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gTWF0Y2hpbmcgbWV0aG9kc1xyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIGdpdmVuIHRva2VuIHR5cGUuXHJcbiAgICAgKiBJZiBzbywgdGhhdCB0b2tlbiBpcyBjb25zdW1lZDsgaWYgbm90LCB0aGUgdG9rZW4gaXMgcGxhY2VkXHJcbiAgICAgKiBiYWNrIG9udG8gdGhlIHRva2VuIHN0cmVhbS4gWW91IGNhbiBwYXNzIGluIGFueSBudW1iZXIgb2ZcclxuICAgICAqIHRva2VuIHR5cGVzIGFuZCB0aGlzIHdpbGwgcmV0dXJuIHRydWUgaWYgYW55IG9mIHRoZSB0b2tlblxyXG4gICAgICogdHlwZXMgaXMgZm91bmQuXHJcbiAgICAgKiBAcGFyYW0ge2ludHxpbnRbXX0gdG9rZW5UeXBlcyBFaXRoZXIgYSBzaW5nbGUgdG9rZW4gdHlwZSBvciBhbiBhcnJheSBvZlxyXG4gICAgICogICAgICB0b2tlbiB0eXBlcyB0aGF0IHRoZSBuZXh0IHRva2VuIG1pZ2h0IGJlLiBJZiBhbiBhcnJheSBpcyBwYXNzZWQsXHJcbiAgICAgKiAgICAgIGl0J3MgYXNzdW1lZCB0aGF0IHRoZSB0b2tlbiBjYW4gYmUgYW55IG9mIHRoZXNlLlxyXG4gICAgICogQHBhcmFtIHt2YXJpYW50fSBjaGFubmVsIChPcHRpb25hbCkgVGhlIGNoYW5uZWwgdG8gcmVhZCBmcm9tLiBJZiBub3RcclxuICAgICAqICAgICAgcHJvdmlkZWQsIHJlYWRzIGZyb20gdGhlIGRlZmF1bHQgKHVubmFtZWQpIGNoYW5uZWwuXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSB0b2tlbiB0eXBlIG1hdGNoZXMsIGZhbHNlIGlmIG5vdC5cclxuICAgICAqIEBtZXRob2QgbWF0Y2hcclxuICAgICAqL1xyXG4gICAgbWF0Y2g6IGZ1bmN0aW9uKHRva2VuVHlwZXMsIGNoYW5uZWwpe1xyXG5cclxuICAgICAgICAvL2Fsd2F5cyBjb252ZXJ0IHRvIGFuIGFycmF5LCBtYWtlcyB0aGluZ3MgZWFzaWVyXHJcbiAgICAgICAgaWYgKCEodG9rZW5UeXBlcyBpbnN0YW5jZW9mIEFycmF5KSl7XHJcbiAgICAgICAgICAgIHRva2VuVHlwZXMgPSBbdG9rZW5UeXBlc107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdHQgID0gdGhpcy5nZXQoY2hhbm5lbCksXHJcbiAgICAgICAgICAgIGkgICA9IDAsXHJcbiAgICAgICAgICAgIGxlbiA9IHRva2VuVHlwZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICB3aGlsZShpIDwgbGVuKXtcclxuICAgICAgICAgICAgaWYgKHR0ID09PSB0b2tlblR5cGVzW2krK10pe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vbm8gbWF0Y2ggZm91bmQsIHB1dCB0aGUgdG9rZW4gYmFja1xyXG4gICAgICAgIHRoaXMudW5nZXQoKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBnaXZlbiB0b2tlbiB0eXBlLlxyXG4gICAgICogSWYgc28sIHRoYXQgdG9rZW4gaXMgY29uc3VtZWQ7IGlmIG5vdCwgYW4gZXJyb3IgaXMgdGhyb3duLlxyXG4gICAgICogQHBhcmFtIHtpbnR8aW50W119IHRva2VuVHlwZXMgRWl0aGVyIGEgc2luZ2xlIHRva2VuIHR5cGUgb3IgYW4gYXJyYXkgb2ZcclxuICAgICAqICAgICAgdG9rZW4gdHlwZXMgdGhhdCB0aGUgbmV4dCB0b2tlbiBzaG91bGQgYmUuIElmIGFuIGFycmF5IGlzIHBhc3NlZCxcclxuICAgICAqICAgICAgaXQncyBhc3N1bWVkIHRoYXQgdGhlIHRva2VuIG11c3QgYmUgb25lIG9mIHRoZXNlLlxyXG4gICAgICogQHBhcmFtIHt2YXJpYW50fSBjaGFubmVsIChPcHRpb25hbCkgVGhlIGNoYW5uZWwgdG8gcmVhZCBmcm9tLiBJZiBub3RcclxuICAgICAqICAgICAgcHJvdmlkZWQsIHJlYWRzIGZyb20gdGhlIGRlZmF1bHQgKHVubmFtZWQpIGNoYW5uZWwuXHJcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAgICogQG1ldGhvZCBtdXN0TWF0Y2hcclxuICAgICAqL1xyXG4gICAgbXVzdE1hdGNoOiBmdW5jdGlvbih0b2tlblR5cGVzLCBjaGFubmVsKXtcclxuXHJcbiAgICAgICAgdmFyIHRva2VuO1xyXG5cclxuICAgICAgICAvL2Fsd2F5cyBjb252ZXJ0IHRvIGFuIGFycmF5LCBtYWtlcyB0aGluZ3MgZWFzaWVyXHJcbiAgICAgICAgaWYgKCEodG9rZW5UeXBlcyBpbnN0YW5jZW9mIEFycmF5KSl7XHJcbiAgICAgICAgICAgIHRva2VuVHlwZXMgPSBbdG9rZW5UeXBlc107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMubWF0Y2guYXBwbHkodGhpcywgYXJndW1lbnRzKSl7XHJcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5MVCgxKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiRXhwZWN0ZWQgXCIgKyB0aGlzLl90b2tlbkRhdGFbdG9rZW5UeXBlc1swXV0ubmFtZSArXHJcbiAgICAgICAgICAgICAgICBcIiBhdCBsaW5lIFwiICsgdG9rZW4uc3RhcnRMaW5lICsgXCIsIGNvbCBcIiArIHRva2VuLnN0YXJ0Q29sICsgXCIuXCIsIHRva2VuLnN0YXJ0TGluZSwgdG9rZW4uc3RhcnRDb2wpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBDb25zdW1pbmcgbWV0aG9kc1xyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBLZWVwcyByZWFkaW5nIGZyb20gdGhlIHRva2VuIHN0cmVhbSB1bnRpbCBlaXRoZXIgb25lIG9mIHRoZSBzcGVjaWZpZWRcclxuICAgICAqIHRva2VuIHR5cGVzIGlzIGZvdW5kIG9yIHVudGlsIHRoZSBlbmQgb2YgdGhlIGlucHV0IGlzIHJlYWNoZWQuXHJcbiAgICAgKiBAcGFyYW0ge2ludHxpbnRbXX0gdG9rZW5UeXBlcyBFaXRoZXIgYSBzaW5nbGUgdG9rZW4gdHlwZSBvciBhbiBhcnJheSBvZlxyXG4gICAgICogICAgICB0b2tlbiB0eXBlcyB0aGF0IHRoZSBuZXh0IHRva2VuIHNob3VsZCBiZS4gSWYgYW4gYXJyYXkgaXMgcGFzc2VkLFxyXG4gICAgICogICAgICBpdCdzIGFzc3VtZWQgdGhhdCB0aGUgdG9rZW4gbXVzdCBiZSBvbmUgb2YgdGhlc2UuXHJcbiAgICAgKiBAcGFyYW0ge3ZhcmlhbnR9IGNoYW5uZWwgKE9wdGlvbmFsKSBUaGUgY2hhbm5lbCB0byByZWFkIGZyb20uIElmIG5vdFxyXG4gICAgICogICAgICBwcm92aWRlZCwgcmVhZHMgZnJvbSB0aGUgZGVmYXVsdCAodW5uYW1lZCkgY2hhbm5lbC5cclxuICAgICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICAgKiBAbWV0aG9kIGFkdmFuY2VcclxuICAgICAqL1xyXG4gICAgYWR2YW5jZTogZnVuY3Rpb24odG9rZW5UeXBlcywgY2hhbm5lbCl7XHJcblxyXG4gICAgICAgIHdoaWxlKHRoaXMuTEEoMCkgIT09IDAgJiYgIXRoaXMubWF0Y2godG9rZW5UeXBlcywgY2hhbm5lbCkpe1xyXG4gICAgICAgICAgICB0aGlzLmdldCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuTEEoMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uc3VtZXMgdGhlIG5leHQgdG9rZW4gZnJvbSB0aGUgdG9rZW4gc3RyZWFtLlxyXG4gICAgICogQHJldHVybiB7aW50fSBUaGUgdG9rZW4gdHlwZSBvZiB0aGUgdG9rZW4gdGhhdCB3YXMganVzdCBjb25zdW1lZC5cclxuICAgICAqIEBtZXRob2QgZ2V0XHJcbiAgICAgKi9cclxuICAgIGdldDogZnVuY3Rpb24oY2hhbm5lbCl7XHJcblxyXG4gICAgICAgIHZhciB0b2tlbkluZm8gICA9IHRoaXMuX3Rva2VuRGF0YSxcclxuICAgICAgICAgICAgaSAgICAgICAgICAgPTAsXHJcbiAgICAgICAgICAgIHRva2VuLFxyXG4gICAgICAgICAgICBpbmZvO1xyXG5cclxuICAgICAgICAvL2NoZWNrIHRoZSBsb29rYWhlYWQgYnVmZmVyIGZpcnN0XHJcbiAgICAgICAgaWYgKHRoaXMuX2x0Lmxlbmd0aCAmJiB0aGlzLl9sdEluZGV4ID49IDAgJiYgdGhpcy5fbHRJbmRleCA8IHRoaXMuX2x0Lmxlbmd0aCl7XHJcblxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gdGhpcy5fbHRbdGhpcy5fbHRJbmRleCsrXTtcclxuICAgICAgICAgICAgaW5mbyA9IHRva2VuSW5mb1t0aGlzLl90b2tlbi50eXBlXTtcclxuXHJcbiAgICAgICAgICAgIC8vb2JleSBjaGFubmVscyBsb2dpY1xyXG4gICAgICAgICAgICB3aGlsZSgoaW5mby5jaGFubmVsICE9PSB1bmRlZmluZWQgJiYgY2hhbm5lbCAhPT0gaW5mby5jaGFubmVsKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2x0SW5kZXggPCB0aGlzLl9sdC5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSB0aGlzLl9sdFt0aGlzLl9sdEluZGV4KytdO1xyXG4gICAgICAgICAgICAgICAgaW5mbyA9IHRva2VuSW5mb1t0aGlzLl90b2tlbi50eXBlXTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9oZXJlIGJlIGRyYWdvbnNcclxuICAgICAgICAgICAgaWYgKChpbmZvLmNoYW5uZWwgPT09IHVuZGVmaW5lZCB8fCBjaGFubmVsID09PSBpbmZvLmNoYW5uZWwpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbHRJbmRleCA8PSB0aGlzLl9sdC5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbHRJbmRleENhY2hlLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW4udHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jYWxsIHRva2VuIHJldHJpZXZlciBtZXRob2RcclxuICAgICAgICB0b2tlbiA9IHRoaXMuX2dldFRva2VuKCk7XHJcblxyXG4gICAgICAgIC8vaWYgaXQgc2hvdWxkIGJlIGhpZGRlbiwgZG9uJ3Qgc2F2ZSBhIHRva2VuXHJcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPiAtMSAmJiAhdG9rZW5JbmZvW3Rva2VuLnR5cGVdLmhpZGUpe1xyXG5cclxuICAgICAgICAgICAgLy9hcHBseSB0b2tlbiBjaGFubmVsXHJcbiAgICAgICAgICAgIHRva2VuLmNoYW5uZWwgPSB0b2tlbkluZm9bdG9rZW4udHlwZV0uY2hhbm5lbDtcclxuXHJcbiAgICAgICAgICAgIC8vc2F2ZSBmb3IgbGF0ZXJcclxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSB0b2tlbjtcclxuICAgICAgICAgICAgdGhpcy5fbHQucHVzaCh0b2tlbik7XHJcblxyXG4gICAgICAgICAgICAvL3NhdmUgc3BhY2UgdGhhdCB3aWxsIGJlIG1vdmVkIChtdXN0IGJlIGRvbmUgYmVmb3JlIGFycmF5IGlzIHRydW5jYXRlZClcclxuICAgICAgICAgICAgdGhpcy5fbHRJbmRleENhY2hlLnB1c2godGhpcy5fbHQubGVuZ3RoIC0gdGhpcy5fbHRJbmRleCArIGkpO1xyXG5cclxuICAgICAgICAgICAgLy9rZWVwIHRoZSBidWZmZXIgdW5kZXIgNSBpdGVtc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbHQubGVuZ3RoID4gNSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sdC5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2Fsc28ga2VlcCB0aGUgc2hpZnQgYnVmZmVyIHVuZGVyIDUgaXRlbXNcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2x0SW5kZXhDYWNoZS5sZW5ndGggPiA1KXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2x0SW5kZXhDYWNoZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL3VwZGF0ZSBsb29rYWhlYWQgaW5kZXhcclxuICAgICAgICAgICAgdGhpcy5fbHRJbmRleCA9IHRoaXMuX2x0Lmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogU2tpcCB0byB0aGUgbmV4dCB0b2tlbiBpZjpcclxuICAgICAgICAgKiAxLiBUaGUgdG9rZW4gdHlwZSBpcyBtYXJrZWQgYXMgaGlkZGVuLlxyXG4gICAgICAgICAqIDIuIFRoZSB0b2tlbiB0eXBlIGhhcyBhIGNoYW5uZWwgc3BlY2lmaWVkIGFuZCBpdCBpc24ndCB0aGUgY3VycmVudCBjaGFubmVsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluZm8gPSB0b2tlbkluZm9bdG9rZW4udHlwZV07XHJcbiAgICAgICAgaWYgKGluZm8gJiZcclxuICAgICAgICAgICAgICAgIChpbmZvLmhpZGUgfHxcclxuICAgICAgICAgICAgICAgIChpbmZvLmNoYW5uZWwgIT09IHVuZGVmaW5lZCAmJiBjaGFubmVsICE9PSBpbmZvLmNoYW5uZWwpKSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChjaGFubmVsKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL3JldHVybiBqdXN0IHRoZSB0eXBlXHJcbiAgICAgICAgICAgIHJldHVybiB0b2tlbi50eXBlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb29rcyBhaGVhZCBhIGNlcnRhaW4gbnVtYmVyIG9mIHRva2VucyBhbmQgcmV0dXJucyB0aGUgdG9rZW4gdHlwZSBhdFxyXG4gICAgICogdGhhdCBwb3NpdGlvbi4gVGhpcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSBsb29rYWhlYWQgcGFzdCB0aGVcclxuICAgICAqIGVuZCBvZiBpbnB1dCwgcGFzdCB0aGUgc2l6ZSBvZiB0aGUgbG9va2FoZWFkIGJ1ZmZlciwgb3IgYmFjayBwYXN0XHJcbiAgICAgKiB0aGUgZmlyc3QgdG9rZW4gaW4gdGhlIGxvb2thaGVhZCBidWZmZXIuXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gVGhlIGluZGV4IG9mIHRoZSB0b2tlbiB0eXBlIHRvIHJldHJpZXZlLiAwIGZvciB0aGVcclxuICAgICAqICAgICAgY3VycmVudCB0b2tlbiwgMSBmb3IgdGhlIG5leHQsIC0xIGZvciB0aGUgcHJldmlvdXMsIGV0Yy5cclxuICAgICAqIEByZXR1cm4ge2ludH0gVGhlIHRva2VuIHR5cGUgb2YgdGhlIHRva2VuIGluIHRoZSBnaXZlbiBwb3NpdGlvbi5cclxuICAgICAqIEBtZXRob2QgTEFcclxuICAgICAqL1xyXG4gICAgTEE6IGZ1bmN0aW9uKGluZGV4KXtcclxuICAgICAgICB2YXIgdG90YWwgPSBpbmRleCxcclxuICAgICAgICAgICAgdHQ7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gMCl7XHJcbiAgICAgICAgICAgIC8vVE9ETzogU3RvcmUgNSBzb21ld2hlcmVcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gNSl7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbXVjaCBsb29rYWhlYWQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2dldCBhbGwgdGhvc2UgdG9rZW5zXHJcbiAgICAgICAgICAgIHdoaWxlKHRvdGFsKXtcclxuICAgICAgICAgICAgICAgIHR0ID0gdGhpcy5nZXQoKTtcclxuICAgICAgICAgICAgICAgIHRvdGFsLS07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vdW5nZXQgYWxsIHRob3NlIHRva2Vuc1xyXG4gICAgICAgICAgICB3aGlsZSh0b3RhbCA8IGluZGV4KXtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5nZXQoKTtcclxuICAgICAgICAgICAgICAgIHRvdGFsKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGluZGV4IDwgMCl7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLl9sdFt0aGlzLl9sdEluZGV4K2luZGV4XSl7XHJcbiAgICAgICAgICAgICAgICB0dCA9IHRoaXMuX2x0W3RoaXMuX2x0SW5kZXgraW5kZXhdLnR5cGU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbXVjaCBsb29rYmVoaW5kLlwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0dCA9IHRoaXMuX3Rva2VuLnR5cGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvb2tzIGFoZWFkIGEgY2VydGFpbiBudW1iZXIgb2YgdG9rZW5zIGFuZCByZXR1cm5zIHRoZSB0b2tlbiBhdFxyXG4gICAgICogdGhhdCBwb3NpdGlvbi4gVGhpcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSBsb29rYWhlYWQgcGFzdCB0aGVcclxuICAgICAqIGVuZCBvZiBpbnB1dCwgcGFzdCB0aGUgc2l6ZSBvZiB0aGUgbG9va2FoZWFkIGJ1ZmZlciwgb3IgYmFjayBwYXN0XHJcbiAgICAgKiB0aGUgZmlyc3QgdG9rZW4gaW4gdGhlIGxvb2thaGVhZCBidWZmZXIuXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gVGhlIGluZGV4IG9mIHRoZSB0b2tlbiB0eXBlIHRvIHJldHJpZXZlLiAwIGZvciB0aGVcclxuICAgICAqICAgICAgY3VycmVudCB0b2tlbiwgMSBmb3IgdGhlIG5leHQsIC0xIGZvciB0aGUgcHJldmlvdXMsIGV0Yy5cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIHRva2VuIG9mIHRoZSB0b2tlbiBpbiB0aGUgZ2l2ZW4gcG9zaXRpb24uXHJcbiAgICAgKiBAbWV0aG9kIExBXHJcbiAgICAgKi9cclxuICAgIExUOiBmdW5jdGlvbihpbmRleCl7XHJcblxyXG4gICAgICAgIC8vbG9va2FoZWFkIGZpcnN0IHRvIHByaW1lIHRoZSB0b2tlbiBidWZmZXJcclxuICAgICAgICB0aGlzLkxBKGluZGV4KTtcclxuXHJcbiAgICAgICAgLy9ub3cgZmluZCB0aGUgdG9rZW4sIHN1YnRyYWN0IG9uZSBiZWNhdXNlIF9sdEluZGV4IGlzIGFscmVhZHkgYXQgdGhlIG5leHQgaW5kZXhcclxuICAgICAgICByZXR1cm4gdGhpcy5fbHRbdGhpcy5fbHRJbmRleCtpbmRleC0xXTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0b2tlbiB0eXBlIGZvciB0aGUgbmV4dCB0b2tlbiBpbiB0aGUgc3RyZWFtIHdpdGhvdXRcclxuICAgICAqIGNvbnN1bWluZyBpdC5cclxuICAgICAqIEByZXR1cm4ge2ludH0gVGhlIHRva2VuIHR5cGUgb2YgdGhlIG5leHQgdG9rZW4gaW4gdGhlIHN0cmVhbS5cclxuICAgICAqIEBtZXRob2QgcGVla1xyXG4gICAgICovXHJcbiAgICBwZWVrOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLkxBKDEpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGFjdHVhbCB0b2tlbiBvYmplY3QgZm9yIHRoZSBsYXN0IGNvbnN1bWVkIHRva2VuLlxyXG4gICAgICogQHJldHVybiB7VG9rZW59IFRoZSB0b2tlbiBvYmplY3QgZm9yIHRoZSBsYXN0IGNvbnN1bWVkIHRva2VuLlxyXG4gICAgICogQG1ldGhvZCB0b2tlblxyXG4gICAgICovXHJcbiAgICB0b2tlbjogZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW47XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgdG9rZW4gZm9yIHRoZSBnaXZlbiB0b2tlbiB0eXBlLlxyXG4gICAgICogQHBhcmFtIHtpbnR9IHRva2VuVHlwZSBUaGUgdHlwZSBvZiB0b2tlbiB0byBnZXQgdGhlIG5hbWUgb2YuXHJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSB0b2tlbiBvciBcIlVOS05PV05fVE9LRU5cIiBmb3IgYW55XHJcbiAgICAgKiAgICAgIGludmFsaWQgdG9rZW4gdHlwZS5cclxuICAgICAqIEBtZXRob2QgdG9rZW5OYW1lXHJcbiAgICAgKi9cclxuICAgIHRva2VuTmFtZTogZnVuY3Rpb24odG9rZW5UeXBlKXtcclxuICAgICAgICBpZiAodG9rZW5UeXBlIDwgMCB8fCB0b2tlblR5cGUgPiB0aGlzLl90b2tlbkRhdGEubGVuZ3RoKXtcclxuICAgICAgICAgICAgcmV0dXJuIFwiVU5LTk9XTl9UT0tFTlwiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90b2tlbkRhdGFbdG9rZW5UeXBlXS5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0b2tlbiB0eXBlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gdG9rZW4gbmFtZS5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbk5hbWUgVGhlIG5hbWUgb2YgdGhlIHRva2VuIHdob3NlIHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZC5cclxuICAgICAqIEByZXR1cm4ge2ludH0gVGhlIHRva2VuIHR5cGUgdmFsdWUgZm9yIHRoZSBnaXZlbiB0b2tlbiBuYW1lIG9yIC0xXHJcbiAgICAgKiAgICAgIGZvciBhbiB1bmtub3duIHRva2VuLlxyXG4gICAgICogQG1ldGhvZCB0b2tlbk5hbWVcclxuICAgICAqL1xyXG4gICAgdG9rZW5UeXBlOiBmdW5jdGlvbih0b2tlbk5hbWUpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbkRhdGFbdG9rZW5OYW1lXSB8fCAtMTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXN0IGNvbnN1bWVkIHRva2VuIHRvIHRoZSB0b2tlbiBzdHJlYW0uXHJcbiAgICAgKiBAbWV0aG9kIHVuZ2V0XHJcbiAgICAgKi9cclxuICAgIHVuZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIC8vaWYgKHRoaXMuX2x0SW5kZXggPiAtMSl7XHJcbiAgICAgICAgaWYgKHRoaXMuX2x0SW5kZXhDYWNoZS5sZW5ndGgpe1xyXG4gICAgICAgICAgICB0aGlzLl9sdEluZGV4IC09IHRoaXMuX2x0SW5kZXhDYWNoZS5wb3AoKTsvLy0tO1xyXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IHRoaXMuX2x0W3RoaXMuX2x0SW5kZXggLSAxXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbXVjaCBsb29rYWhlYWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5cclxucGFyc2VybGliLnV0aWwgPSB7XHJcbl9fcHJvdG9fXyAgIDogbnVsbCxcclxuU3RyaW5nUmVhZGVyOiBTdHJpbmdSZWFkZXIsXHJcblN5bnRheEVycm9yIDogU3ludGF4RXJyb3IsXHJcblN5bnRheFVuaXQgIDogU3ludGF4VW5pdCxcclxuRXZlbnRUYXJnZXQgOiBFdmVudFRhcmdldCxcclxuVG9rZW5TdHJlYW1CYXNlIDogVG9rZW5TdHJlYW1CYXNlXHJcbn07XHJcbn0pKCk7XHJcbi8qXHJcblBhcnNlci1MaWJcclxuQ29weXJpZ2h0IChjKSAyMDA5LTIwMTEgTmljaG9sYXMgQy4gWmFrYXMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcblxyXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcblRIRSBTT0ZUV0FSRS5cclxuXHJcbiovXHJcbi8qIFZlcnNpb24gdjAuMi41K2RvbWlubzEsIEJ1aWxkIHRpbWU6IDMwLUphbnVhcnktMjAxNiAwNToxMzowMyAqL1xyXG4oZnVuY3Rpb24oKXtcclxudmFyIEV2ZW50VGFyZ2V0ID0gcGFyc2VybGliLnV0aWwuRXZlbnRUYXJnZXQsXHJcblRva2VuU3RyZWFtQmFzZSA9IHBhcnNlcmxpYi51dGlsLlRva2VuU3RyZWFtQmFzZSxcclxuU3RyaW5nUmVhZGVyID0gcGFyc2VybGliLnV0aWwuU3RyaW5nUmVhZGVyLCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuU3ludGF4RXJyb3IgPSBwYXJzZXJsaWIudXRpbC5TeW50YXhFcnJvcixcclxuU3ludGF4VW5pdCAgPSBwYXJzZXJsaWIudXRpbC5TeW50YXhVbml0O1xyXG5cclxudmFyIENvbG9ycyA9IHtcclxuICAgIF9fcHJvdG9fXyAgICAgICA6bnVsbCxcclxuICAgIGFsaWNlYmx1ZSAgICAgICA6XCIjZjBmOGZmXCIsXHJcbiAgICBhbnRpcXVld2hpdGUgICAgOlwiI2ZhZWJkN1wiLFxyXG4gICAgYXF1YSAgICAgICAgICAgIDpcIiMwMGZmZmZcIixcclxuICAgIGFxdWFtYXJpbmUgICAgICA6XCIjN2ZmZmQ0XCIsXHJcbiAgICBhenVyZSAgICAgICAgICAgOlwiI2YwZmZmZlwiLFxyXG4gICAgYmVpZ2UgICAgICAgICAgIDpcIiNmNWY1ZGNcIixcclxuICAgIGJpc3F1ZSAgICAgICAgICA6XCIjZmZlNGM0XCIsXHJcbiAgICBibGFjayAgICAgICAgICAgOlwiIzAwMDAwMFwiLFxyXG4gICAgYmxhbmNoZWRhbG1vbmQgIDpcIiNmZmViY2RcIixcclxuICAgIGJsdWUgICAgICAgICAgICA6XCIjMDAwMGZmXCIsXHJcbiAgICBibHVldmlvbGV0ICAgICAgOlwiIzhhMmJlMlwiLFxyXG4gICAgYnJvd24gICAgICAgICAgIDpcIiNhNTJhMmFcIixcclxuICAgIGJ1cmx5d29vZCAgICAgICA6XCIjZGViODg3XCIsXHJcbiAgICBjYWRldGJsdWUgICAgICAgOlwiIzVmOWVhMFwiLFxyXG4gICAgY2hhcnRyZXVzZSAgICAgIDpcIiM3ZmZmMDBcIixcclxuICAgIGNob2NvbGF0ZSAgICAgICA6XCIjZDI2OTFlXCIsXHJcbiAgICBjb3JhbCAgICAgICAgICAgOlwiI2ZmN2Y1MFwiLFxyXG4gICAgY29ybmZsb3dlcmJsdWUgIDpcIiM2NDk1ZWRcIixcclxuICAgIGNvcm5zaWxrICAgICAgICA6XCIjZmZmOGRjXCIsXHJcbiAgICBjcmltc29uICAgICAgICAgOlwiI2RjMTQzY1wiLFxyXG4gICAgY3lhbiAgICAgICAgICAgIDpcIiMwMGZmZmZcIixcclxuICAgIGRhcmtibHVlICAgICAgICA6XCIjMDAwMDhiXCIsXHJcbiAgICBkYXJrY3lhbiAgICAgICAgOlwiIzAwOGI4YlwiLFxyXG4gICAgZGFya2dvbGRlbnJvZCAgIDpcIiNiODg2MGJcIixcclxuICAgIGRhcmtncmF5ICAgICAgICA6XCIjYTlhOWE5XCIsXHJcbiAgICBkYXJrZ3JleSAgICAgICAgOlwiI2E5YTlhOVwiLFxyXG4gICAgZGFya2dyZWVuICAgICAgIDpcIiMwMDY0MDBcIixcclxuICAgIGRhcmtraGFraSAgICAgICA6XCIjYmRiNzZiXCIsXHJcbiAgICBkYXJrbWFnZW50YSAgICAgOlwiIzhiMDA4YlwiLFxyXG4gICAgZGFya29saXZlZ3JlZW4gIDpcIiM1NTZiMmZcIixcclxuICAgIGRhcmtvcmFuZ2UgICAgICA6XCIjZmY4YzAwXCIsXHJcbiAgICBkYXJrb3JjaGlkICAgICAgOlwiIzk5MzJjY1wiLFxyXG4gICAgZGFya3JlZCAgICAgICAgIDpcIiM4YjAwMDBcIixcclxuICAgIGRhcmtzYWxtb24gICAgICA6XCIjZTk5NjdhXCIsXHJcbiAgICBkYXJrc2VhZ3JlZW4gICAgOlwiIzhmYmM4ZlwiLFxyXG4gICAgZGFya3NsYXRlYmx1ZSAgIDpcIiM0ODNkOGJcIixcclxuICAgIGRhcmtzbGF0ZWdyYXkgICA6XCIjMmY0ZjRmXCIsXHJcbiAgICBkYXJrc2xhdGVncmV5ICAgOlwiIzJmNGY0ZlwiLFxyXG4gICAgZGFya3R1cnF1b2lzZSAgIDpcIiMwMGNlZDFcIixcclxuICAgIGRhcmt2aW9sZXQgICAgICA6XCIjOTQwMGQzXCIsXHJcbiAgICBkZWVwcGluayAgICAgICAgOlwiI2ZmMTQ5M1wiLFxyXG4gICAgZGVlcHNreWJsdWUgICAgIDpcIiMwMGJmZmZcIixcclxuICAgIGRpbWdyYXkgICAgICAgICA6XCIjNjk2OTY5XCIsXHJcbiAgICBkaW1ncmV5ICAgICAgICAgOlwiIzY5Njk2OVwiLFxyXG4gICAgZG9kZ2VyYmx1ZSAgICAgIDpcIiMxZTkwZmZcIixcclxuICAgIGZpcmVicmljayAgICAgICA6XCIjYjIyMjIyXCIsXHJcbiAgICBmbG9yYWx3aGl0ZSAgICAgOlwiI2ZmZmFmMFwiLFxyXG4gICAgZm9yZXN0Z3JlZW4gICAgIDpcIiMyMjhiMjJcIixcclxuICAgIGZ1Y2hzaWEgICAgICAgICA6XCIjZmYwMGZmXCIsXHJcbiAgICBnYWluc2Jvcm8gICAgICAgOlwiI2RjZGNkY1wiLFxyXG4gICAgZ2hvc3R3aGl0ZSAgICAgIDpcIiNmOGY4ZmZcIixcclxuICAgIGdvbGQgICAgICAgICAgICA6XCIjZmZkNzAwXCIsXHJcbiAgICBnb2xkZW5yb2QgICAgICAgOlwiI2RhYTUyMFwiLFxyXG4gICAgZ3JheSAgICAgICAgICAgIDpcIiM4MDgwODBcIixcclxuICAgIGdyZXkgICAgICAgICAgICA6XCIjODA4MDgwXCIsXHJcbiAgICBncmVlbiAgICAgICAgICAgOlwiIzAwODAwMFwiLFxyXG4gICAgZ3JlZW55ZWxsb3cgICAgIDpcIiNhZGZmMmZcIixcclxuICAgIGhvbmV5ZGV3ICAgICAgICA6XCIjZjBmZmYwXCIsXHJcbiAgICBob3RwaW5rICAgICAgICAgOlwiI2ZmNjliNFwiLFxyXG4gICAgaW5kaWFucmVkICAgICAgIDpcIiNjZDVjNWNcIixcclxuICAgIGluZGlnbyAgICAgICAgICA6XCIjNGIwMDgyXCIsXHJcbiAgICBpdm9yeSAgICAgICAgICAgOlwiI2ZmZmZmMFwiLFxyXG4gICAga2hha2kgICAgICAgICAgIDpcIiNmMGU2OGNcIixcclxuICAgIGxhdmVuZGVyICAgICAgICA6XCIjZTZlNmZhXCIsXHJcbiAgICBsYXZlbmRlcmJsdXNoICAgOlwiI2ZmZjBmNVwiLFxyXG4gICAgbGF3bmdyZWVuICAgICAgIDpcIiM3Y2ZjMDBcIixcclxuICAgIGxlbW9uY2hpZmZvbiAgICA6XCIjZmZmYWNkXCIsXHJcbiAgICBsaWdodGJsdWUgICAgICAgOlwiI2FkZDhlNlwiLFxyXG4gICAgbGlnaHRjb3JhbCAgICAgIDpcIiNmMDgwODBcIixcclxuICAgIGxpZ2h0Y3lhbiAgICAgICA6XCIjZTBmZmZmXCIsXHJcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdyAgOlwiI2ZhZmFkMlwiLFxyXG4gICAgbGlnaHRncmF5ICAgICAgIDpcIiNkM2QzZDNcIixcclxuICAgIGxpZ2h0Z3JleSAgICAgICA6XCIjZDNkM2QzXCIsXHJcbiAgICBsaWdodGdyZWVuICAgICAgOlwiIzkwZWU5MFwiLFxyXG4gICAgbGlnaHRwaW5rICAgICAgIDpcIiNmZmI2YzFcIixcclxuICAgIGxpZ2h0c2FsbW9uICAgICA6XCIjZmZhMDdhXCIsXHJcbiAgICBsaWdodHNlYWdyZWVuICAgOlwiIzIwYjJhYVwiLFxyXG4gICAgbGlnaHRza3libHVlICAgIDpcIiM4N2NlZmFcIixcclxuICAgIGxpZ2h0c2xhdGVncmF5ICA6XCIjNzc4ODk5XCIsXHJcbiAgICBsaWdodHNsYXRlZ3JleSAgOlwiIzc3ODg5OVwiLFxyXG4gICAgbGlnaHRzdGVlbGJsdWUgIDpcIiNiMGM0ZGVcIixcclxuICAgIGxpZ2h0eWVsbG93ICAgICA6XCIjZmZmZmUwXCIsXHJcbiAgICBsaW1lICAgICAgICAgICAgOlwiIzAwZmYwMFwiLFxyXG4gICAgbGltZWdyZWVuICAgICAgIDpcIiMzMmNkMzJcIixcclxuICAgIGxpbmVuICAgICAgICAgICA6XCIjZmFmMGU2XCIsXHJcbiAgICBtYWdlbnRhICAgICAgICAgOlwiI2ZmMDBmZlwiLFxyXG4gICAgbWFyb29uICAgICAgICAgIDpcIiM4MDAwMDBcIixcclxuICAgIG1lZGl1bWFxdWFtYXJpbmU6XCIjNjZjZGFhXCIsXHJcbiAgICBtZWRpdW1ibHVlICAgICAgOlwiIzAwMDBjZFwiLFxyXG4gICAgbWVkaXVtb3JjaGlkICAgIDpcIiNiYTU1ZDNcIixcclxuICAgIG1lZGl1bXB1cnBsZSAgICA6XCIjOTM3MGQ4XCIsXHJcbiAgICBtZWRpdW1zZWFncmVlbiAgOlwiIzNjYjM3MVwiLFxyXG4gICAgbWVkaXVtc2xhdGVibHVlIDpcIiM3YjY4ZWVcIixcclxuICAgIG1lZGl1bXNwcmluZ2dyZWVuICAgOlwiIzAwZmE5YVwiLFxyXG4gICAgbWVkaXVtdHVycXVvaXNlIDpcIiM0OGQxY2NcIixcclxuICAgIG1lZGl1bXZpb2xldHJlZCA6XCIjYzcxNTg1XCIsXHJcbiAgICBtaWRuaWdodGJsdWUgICAgOlwiIzE5MTk3MFwiLFxyXG4gICAgbWludGNyZWFtICAgICAgIDpcIiNmNWZmZmFcIixcclxuICAgIG1pc3R5cm9zZSAgICAgICA6XCIjZmZlNGUxXCIsXHJcbiAgICBtb2NjYXNpbiAgICAgICAgOlwiI2ZmZTRiNVwiLFxyXG4gICAgbmF2YWpvd2hpdGUgICAgIDpcIiNmZmRlYWRcIixcclxuICAgIG5hdnkgICAgICAgICAgICA6XCIjMDAwMDgwXCIsXHJcbiAgICBvbGRsYWNlICAgICAgICAgOlwiI2ZkZjVlNlwiLFxyXG4gICAgb2xpdmUgICAgICAgICAgIDpcIiM4MDgwMDBcIixcclxuICAgIG9saXZlZHJhYiAgICAgICA6XCIjNmI4ZTIzXCIsXHJcbiAgICBvcmFuZ2UgICAgICAgICAgOlwiI2ZmYTUwMFwiLFxyXG4gICAgb3JhbmdlcmVkICAgICAgIDpcIiNmZjQ1MDBcIixcclxuICAgIG9yY2hpZCAgICAgICAgICA6XCIjZGE3MGQ2XCIsXHJcbiAgICBwYWxlZ29sZGVucm9kICAgOlwiI2VlZThhYVwiLFxyXG4gICAgcGFsZWdyZWVuICAgICAgIDpcIiM5OGZiOThcIixcclxuICAgIHBhbGV0dXJxdW9pc2UgICA6XCIjYWZlZWVlXCIsXHJcbiAgICBwYWxldmlvbGV0cmVkICAgOlwiI2Q4NzA5M1wiLFxyXG4gICAgcGFwYXlhd2hpcCAgICAgIDpcIiNmZmVmZDVcIixcclxuICAgIHBlYWNocHVmZiAgICAgICA6XCIjZmZkYWI5XCIsXHJcbiAgICBwZXJ1ICAgICAgICAgICAgOlwiI2NkODUzZlwiLFxyXG4gICAgcGluayAgICAgICAgICAgIDpcIiNmZmMwY2JcIixcclxuICAgIHBsdW0gICAgICAgICAgICA6XCIjZGRhMGRkXCIsXHJcbiAgICBwb3dkZXJibHVlICAgICAgOlwiI2IwZTBlNlwiLFxyXG4gICAgcHVycGxlICAgICAgICAgIDpcIiM4MDAwODBcIixcclxuICAgIHJlZCAgICAgICAgICAgICA6XCIjZmYwMDAwXCIsXHJcbiAgICByb3N5YnJvd24gICAgICAgOlwiI2JjOGY4ZlwiLFxyXG4gICAgcm95YWxibHVlICAgICAgIDpcIiM0MTY5ZTFcIixcclxuICAgIHNhZGRsZWJyb3duICAgICA6XCIjOGI0NTEzXCIsXHJcbiAgICBzYWxtb24gICAgICAgICAgOlwiI2ZhODA3MlwiLFxyXG4gICAgc2FuZHlicm93biAgICAgIDpcIiNmNGE0NjBcIixcclxuICAgIHNlYWdyZWVuICAgICAgICA6XCIjMmU4YjU3XCIsXHJcbiAgICBzZWFzaGVsbCAgICAgICAgOlwiI2ZmZjVlZVwiLFxyXG4gICAgc2llbm5hICAgICAgICAgIDpcIiNhMDUyMmRcIixcclxuICAgIHNpbHZlciAgICAgICAgICA6XCIjYzBjMGMwXCIsXHJcbiAgICBza3libHVlICAgICAgICAgOlwiIzg3Y2VlYlwiLFxyXG4gICAgc2xhdGVibHVlICAgICAgIDpcIiM2YTVhY2RcIixcclxuICAgIHNsYXRlZ3JheSAgICAgICA6XCIjNzA4MDkwXCIsXHJcbiAgICBzbGF0ZWdyZXkgICAgICAgOlwiIzcwODA5MFwiLFxyXG4gICAgc25vdyAgICAgICAgICAgIDpcIiNmZmZhZmFcIixcclxuICAgIHNwcmluZ2dyZWVuICAgICA6XCIjMDBmZjdmXCIsXHJcbiAgICBzdGVlbGJsdWUgICAgICAgOlwiIzQ2ODJiNFwiLFxyXG4gICAgdGFuICAgICAgICAgICAgIDpcIiNkMmI0OGNcIixcclxuICAgIHRlYWwgICAgICAgICAgICA6XCIjMDA4MDgwXCIsXHJcbiAgICB0aGlzdGxlICAgICAgICAgOlwiI2Q4YmZkOFwiLFxyXG4gICAgdG9tYXRvICAgICAgICAgIDpcIiNmZjYzNDdcIixcclxuICAgIHR1cnF1b2lzZSAgICAgICA6XCIjNDBlMGQwXCIsXHJcbiAgICB2aW9sZXQgICAgICAgICAgOlwiI2VlODJlZVwiLFxyXG4gICAgd2hlYXQgICAgICAgICAgIDpcIiNmNWRlYjNcIixcclxuICAgIHdoaXRlICAgICAgICAgICA6XCIjZmZmZmZmXCIsXHJcbiAgICB3aGl0ZXNtb2tlICAgICAgOlwiI2Y1ZjVmNVwiLFxyXG4gICAgeWVsbG93ICAgICAgICAgIDpcIiNmZmZmMDBcIixcclxuICAgIHllbGxvd2dyZWVuICAgICA6XCIjOWFjZDMyXCIsXHJcbiAgICAvLydjdXJyZW50Q29sb3InIGNvbG9yIGtleXdvcmQgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jY3VycmVudGNvbG9yXHJcbiAgICBjdXJyZW50Q29sb3IgICAgICAgIDpcIlRoZSB2YWx1ZSBvZiB0aGUgJ2NvbG9yJyBwcm9wZXJ0eS5cIixcclxuICAgIC8vQ1NTMiBzeXN0ZW0gY29sb3JzIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvI2NzczItc3lzdGVtXHJcbiAgICBhY3RpdmVCb3JkZXIgICAgICAgIDpcIkFjdGl2ZSB3aW5kb3cgYm9yZGVyLlwiLFxyXG4gICAgYWN0aXZlY2FwdGlvbiAgICAgICA6XCJBY3RpdmUgd2luZG93IGNhcHRpb24uXCIsXHJcbiAgICBhcHB3b3Jrc3BhY2UgICAgICAgIDpcIkJhY2tncm91bmQgY29sb3Igb2YgbXVsdGlwbGUgZG9jdW1lbnQgaW50ZXJmYWNlLlwiLFxyXG4gICAgYmFja2dyb3VuZCAgICAgICAgICA6XCJEZXNrdG9wIGJhY2tncm91bmQuXCIsXHJcbiAgICBidXR0b25mYWNlICAgICAgICAgIDpcIlRoZSBmYWNlIGJhY2tncm91bmQgY29sb3IgZm9yIDMtRCBlbGVtZW50cyB0aGF0IGFwcGVhciAzLUQgZHVlIHRvIG9uZSBsYXllciBvZiBzdXJyb3VuZGluZyBib3JkZXIuXCIsXHJcbiAgICBidXR0b25oaWdobGlnaHQgICAgIDpcIlRoZSBjb2xvciBvZiB0aGUgYm9yZGVyIGZhY2luZyB0aGUgbGlnaHQgc291cmNlIGZvciAzLUQgZWxlbWVudHMgdGhhdCBhcHBlYXIgMy1EIGR1ZSB0byBvbmUgbGF5ZXIgb2Ygc3Vycm91bmRpbmcgYm9yZGVyLlwiLFxyXG4gICAgYnV0dG9uc2hhZG93ICAgICAgICA6XCJUaGUgY29sb3Igb2YgdGhlIGJvcmRlciBhd2F5IGZyb20gdGhlIGxpZ2h0IHNvdXJjZSBmb3IgMy1EIGVsZW1lbnRzIHRoYXQgYXBwZWFyIDMtRCBkdWUgdG8gb25lIGxheWVyIG9mIHN1cnJvdW5kaW5nIGJvcmRlci5cIixcclxuICAgIGJ1dHRvbnRleHQgICAgICAgICAgOlwiVGV4dCBvbiBwdXNoIGJ1dHRvbnMuXCIsXHJcbiAgICBjYXB0aW9udGV4dCAgICAgICAgIDpcIlRleHQgaW4gY2FwdGlvbiwgc2l6ZSBib3gsIGFuZCBzY3JvbGxiYXIgYXJyb3cgYm94LlwiLFxyXG4gICAgZ3JheXRleHQgICAgICAgICAgICA6XCJHcmF5ZWQgKGRpc2FibGVkKSB0ZXh0LiBUaGlzIGNvbG9yIGlzIHNldCB0byAjMDAwIGlmIHRoZSBjdXJyZW50IGRpc3BsYXkgZHJpdmVyIGRvZXMgbm90IHN1cHBvcnQgYSBzb2xpZCBncmF5IGNvbG9yLlwiLFxyXG4gICAgZ3JleXRleHQgICAgICAgICAgICA6XCJHcmV5ZWQgKGRpc2FibGVkKSB0ZXh0LiBUaGlzIGNvbG9yIGlzIHNldCB0byAjMDAwIGlmIHRoZSBjdXJyZW50IGRpc3BsYXkgZHJpdmVyIGRvZXMgbm90IHN1cHBvcnQgYSBzb2xpZCBncmV5IGNvbG9yLlwiLFxyXG4gICAgaGlnaGxpZ2h0ICAgICAgICAgICA6XCJJdGVtKHMpIHNlbGVjdGVkIGluIGEgY29udHJvbC5cIixcclxuICAgIGhpZ2hsaWdodHRleHQgICAgICAgOlwiVGV4dCBvZiBpdGVtKHMpIHNlbGVjdGVkIGluIGEgY29udHJvbC5cIixcclxuICAgIGluYWN0aXZlYm9yZGVyICAgICAgOlwiSW5hY3RpdmUgd2luZG93IGJvcmRlci5cIixcclxuICAgIGluYWN0aXZlY2FwdGlvbiAgICAgOlwiSW5hY3RpdmUgd2luZG93IGNhcHRpb24uXCIsXHJcbiAgICBpbmFjdGl2ZWNhcHRpb250ZXh0IDpcIkNvbG9yIG9mIHRleHQgaW4gYW4gaW5hY3RpdmUgY2FwdGlvbi5cIixcclxuICAgIGluZm9iYWNrZ3JvdW5kICAgICAgOlwiQmFja2dyb3VuZCBjb2xvciBmb3IgdG9vbHRpcCBjb250cm9scy5cIixcclxuICAgIGluZm90ZXh0ICAgICAgICAgICAgOlwiVGV4dCBjb2xvciBmb3IgdG9vbHRpcCBjb250cm9scy5cIixcclxuICAgIG1lbnUgICAgICAgICAgICAgICAgOlwiTWVudSBiYWNrZ3JvdW5kLlwiLFxyXG4gICAgbWVudXRleHQgICAgICAgICAgICA6XCJUZXh0IGluIG1lbnVzLlwiLFxyXG4gICAgc2Nyb2xsYmFyICAgICAgICAgICA6XCJTY3JvbGwgYmFyIGdyYXkgYXJlYS5cIixcclxuICAgIHRocmVlZGRhcmtzaGFkb3cgICAgOlwiVGhlIGNvbG9yIG9mIHRoZSBkYXJrZXIgKGdlbmVyYWxseSBvdXRlcikgb2YgdGhlIHR3byBib3JkZXJzIGF3YXkgZnJvbSB0aGUgbGlnaHQgc291cmNlIGZvciAzLUQgZWxlbWVudHMgdGhhdCBhcHBlYXIgMy1EIGR1ZSB0byB0d28gY29uY2VudHJpYyBsYXllcnMgb2Ygc3Vycm91bmRpbmcgYm9yZGVyLlwiLFxyXG4gICAgdGhyZWVkZmFjZSAgICAgICAgICA6XCJUaGUgZmFjZSBiYWNrZ3JvdW5kIGNvbG9yIGZvciAzLUQgZWxlbWVudHMgdGhhdCBhcHBlYXIgMy1EIGR1ZSB0byB0d28gY29uY2VudHJpYyBsYXllcnMgb2Ygc3Vycm91bmRpbmcgYm9yZGVyLlwiLFxyXG4gICAgdGhyZWVkaGlnaGxpZ2h0ICAgICA6XCJUaGUgY29sb3Igb2YgdGhlIGxpZ2h0ZXIgKGdlbmVyYWxseSBvdXRlcikgb2YgdGhlIHR3byBib3JkZXJzIGZhY2luZyB0aGUgbGlnaHQgc291cmNlIGZvciAzLUQgZWxlbWVudHMgdGhhdCBhcHBlYXIgMy1EIGR1ZSB0byB0d28gY29uY2VudHJpYyBsYXllcnMgb2Ygc3Vycm91bmRpbmcgYm9yZGVyLlwiLFxyXG4gICAgdGhyZWVkbGlnaHRzaGFkb3cgICA6XCJUaGUgY29sb3Igb2YgdGhlIGRhcmtlciAoZ2VuZXJhbGx5IGlubmVyKSBvZiB0aGUgdHdvIGJvcmRlcnMgZmFjaW5nIHRoZSBsaWdodCBzb3VyY2UgZm9yIDMtRCBlbGVtZW50cyB0aGF0IGFwcGVhciAzLUQgZHVlIHRvIHR3byBjb25jZW50cmljIGxheWVycyBvZiBzdXJyb3VuZGluZyBib3JkZXIuXCIsXHJcbiAgICB0aHJlZWRzaGFkb3cgICAgICAgIDpcIlRoZSBjb2xvciBvZiB0aGUgbGlnaHRlciAoZ2VuZXJhbGx5IGlubmVyKSBvZiB0aGUgdHdvIGJvcmRlcnMgYXdheSBmcm9tIHRoZSBsaWdodCBzb3VyY2UgZm9yIDMtRCBlbGVtZW50cyB0aGF0IGFwcGVhciAzLUQgZHVlIHRvIHR3byBjb25jZW50cmljIGxheWVycyBvZiBzdXJyb3VuZGluZyBib3JkZXIuXCIsXHJcbiAgICB3aW5kb3cgICAgICAgICAgICAgIDpcIldpbmRvdyBiYWNrZ3JvdW5kLlwiLFxyXG4gICAgd2luZG93ZnJhbWUgICAgICAgICA6XCJXaW5kb3cgZnJhbWUuXCIsXHJcbiAgICB3aW5kb3d0ZXh0ICAgICAgICAgIDpcIlRleHQgaW4gd2luZG93cy5cIlxyXG59O1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHNlbGVjdG9yIGNvbWJpbmF0b3IgKHdoaXRlc3BhY2UsICssID4pLlxyXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi5jc3NcclxuICogQGNsYXNzIENvbWJpbmF0b3JcclxuICogQGV4dGVuZHMgcGFyc2VybGliLnV0aWwuU3ludGF4VW5pdFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuaXQuXHJcbiAqIEBwYXJhbSB7aW50fSBsaW5lIFRoZSBsaW5lIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cclxuICogQHBhcmFtIHtpbnR9IGNvbCBUaGUgY29sdW1uIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cclxuICovXHJcbmZ1bmN0aW9uIENvbWJpbmF0b3IodGV4dCwgbGluZSwgY29sKXtcclxuXHJcbiAgICBTeW50YXhVbml0LmNhbGwodGhpcywgdGV4dCwgbGluZSwgY29sLCBQYXJzZXIuQ09NQklOQVRPUl9UWVBFKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0eXBlIG9mIG1vZGlmaWVyLlxyXG4gICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgKiBAcHJvcGVydHkgdHlwZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnR5cGUgPSBcInVua25vd25cIjtcclxuXHJcbiAgICAvL3ByZXR0eSBzaW1wbGVcclxuICAgIGlmICgvXlxccyskLy50ZXN0KHRleHQpKXtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcImRlc2NlbmRhbnRcIjtcclxuICAgIH0gZWxzZSBpZiAodGV4dCA9PT0gXCI+XCIpe1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiY2hpbGRcIjtcclxuICAgIH0gZWxzZSBpZiAodGV4dCA9PT0gXCIrXCIpe1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiYWRqYWNlbnQtc2libGluZ1wiO1xyXG4gICAgfSBlbHNlIGlmICh0ZXh0ID09PSBcIn5cIil7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJzaWJsaW5nXCI7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5Db21iaW5hdG9yLnByb3RvdHlwZSA9IG5ldyBTeW50YXhVbml0KCk7XHJcbkNvbWJpbmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tYmluYXRvcjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgbWVkaWEgZmVhdHVyZSwgc3VjaCBhcyBtYXgtd2lkdGg6NTAwLlxyXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi5jc3NcclxuICogQGNsYXNzIE1lZGlhRmVhdHVyZVxyXG4gKiBAZXh0ZW5kcyBwYXJzZXJsaWIudXRpbC5TeW50YXhVbml0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1N5bnRheFVuaXR9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZlYXR1cmUuXHJcbiAqIEBwYXJhbSB7U3ludGF4VW5pdH0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBmZWF0dXJlIG9yIG51bGwgaWYgbm9uZS5cclxuICovXHJcbmZ1bmN0aW9uIE1lZGlhRmVhdHVyZShuYW1lLCB2YWx1ZSl7XHJcblxyXG4gICAgU3ludGF4VW5pdC5jYWxsKHRoaXMsIFwiKFwiICsgbmFtZSArICh2YWx1ZSAhPT0gbnVsbCA/IFwiOlwiICsgdmFsdWUgOiBcIlwiKSArIFwiKVwiLCBuYW1lLnN0YXJ0TGluZSwgbmFtZS5zdGFydENvbCwgUGFyc2VyLk1FRElBX0ZFQVRVUkVfVFlQRSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgbWVkaWEgZmVhdHVyZVxyXG4gICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgKiBAcHJvcGVydHkgbmFtZVxyXG4gICAgICovXHJcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgZmVhdHVyZSBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUuXHJcbiAgICAgKiBAdHlwZSBTeW50YXhVbml0XHJcbiAgICAgKiBAcHJvcGVydHkgdmFsdWVcclxuICAgICAqL1xyXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG59XHJcblxyXG5NZWRpYUZlYXR1cmUucHJvdG90eXBlID0gbmV3IFN5bnRheFVuaXQoKTtcclxuTWVkaWFGZWF0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lZGlhRmVhdHVyZTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIGluZGl2aWR1YWwgbWVkaWEgcXVlcnkuXHJcbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLmNzc1xyXG4gKiBAY2xhc3MgTWVkaWFRdWVyeVxyXG4gKiBAZXh0ZW5kcyBwYXJzZXJsaWIudXRpbC5TeW50YXhVbml0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXIgVGhlIG1vZGlmaWVyIFwibm90XCIgb3IgXCJvbmx5XCIgKG9yIG51bGwpLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVkaWFUeXBlIFRoZSB0eXBlIG9mIG1lZGlhIChpLmUuLCBcInByaW50XCIpLlxyXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJ0cyBBcnJheSBvZiBzZWxlY3RvcnMgcGFydHMgbWFraW5nIHVwIHRoaXMgc2VsZWN0b3IuXHJcbiAqIEBwYXJhbSB7aW50fSBsaW5lIFRoZSBsaW5lIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cclxuICogQHBhcmFtIHtpbnR9IGNvbCBUaGUgY29sdW1uIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cclxuICovXHJcbmZ1bmN0aW9uIE1lZGlhUXVlcnkobW9kaWZpZXIsIG1lZGlhVHlwZSwgZmVhdHVyZXMsIGxpbmUsIGNvbCl7XHJcblxyXG4gICAgU3ludGF4VW5pdC5jYWxsKHRoaXMsIChtb2RpZmllciA/IG1vZGlmaWVyICsgXCIgXCI6IFwiXCIpICsgKG1lZGlhVHlwZSA/IG1lZGlhVHlwZSA6IFwiXCIpICsgKG1lZGlhVHlwZSAmJiBmZWF0dXJlcy5sZW5ndGggPiAwID8gXCIgYW5kIFwiIDogXCJcIikgKyBmZWF0dXJlcy5qb2luKFwiIGFuZCBcIiksIGxpbmUsIGNvbCwgUGFyc2VyLk1FRElBX1FVRVJZX1RZUEUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1lZGlhIG1vZGlmaWVyIChcIm5vdFwiIG9yIFwib25seVwiKVxyXG4gICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgKiBAcHJvcGVydHkgbW9kaWZpZXJcclxuICAgICAqL1xyXG4gICAgdGhpcy5tb2RpZmllciA9IG1vZGlmaWVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1lZGlhVHlwZSAoaS5lLiwgXCJwcmludFwiKVxyXG4gICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgKiBAcHJvcGVydHkgbWVkaWFUeXBlXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWVkaWFUeXBlID0gbWVkaWFUeXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBhcnRzIHRoYXQgbWFrZSB1cCB0aGUgc2VsZWN0b3IuXHJcbiAgICAgKiBAdHlwZSBBcnJheVxyXG4gICAgICogQHByb3BlcnR5IGZlYXR1cmVzXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcztcclxuXHJcbn1cclxuXHJcbk1lZGlhUXVlcnkucHJvdG90eXBlID0gbmV3IFN5bnRheFVuaXQoKTtcclxuTWVkaWFRdWVyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZWRpYVF1ZXJ5O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBIENTUzMgcGFyc2VyLlxyXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi5jc3NcclxuICogQGNsYXNzIFBhcnNlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgKE9wdGlvbmFsKSBWYXJpb3VzIG9wdGlvbnMgZm9yIHRoZSBwYXJzZXI6XHJcbiAqICAgICAgc3RhckhhY2sgKHRydWV8ZmFsc2UpIHRvIGFsbG93IElFNiBzdGFyIGhhY2sgYXMgdmFsaWQsXHJcbiAqICAgICAgdW5kZXJzY29yZUhhY2sgKHRydWV8ZmFsc2UpIHRvIGludGVycHJldCBsZWFkaW5nIHVuZGVyc2NvcmVzXHJcbiAqICAgICAgYXMgSUU2LTcgdGFyZ2V0aW5nIGZvciBrbm93biBwcm9wZXJ0aWVzLCBpZUZpbHRlcnMgKHRydWV8ZmFsc2UpXHJcbiAqICAgICAgdG8gaW5kaWNhdGUgdGhhdCBJRSA8IDggZmlsdGVycyBzaG91bGQgYmUgYWNjZXB0ZWQgYW5kIG5vdCB0aHJvd1xyXG4gKiAgICAgIHN5bnRheCBlcnJvcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBQYXJzZXIob3B0aW9ucyl7XHJcblxyXG4gICAgLy9pbmhlcml0IGV2ZW50IGZ1bmN0aW9uYWxpdHlcclxuICAgIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XHJcblxyXG5cclxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgdGhpcy5fdG9rZW5TdHJlYW0gPSBudWxsO1xyXG59XHJcblxyXG4vL1N0YXRpYyBjb25zdGFudHNcclxuUGFyc2VyLkRFRkFVTFRfVFlQRSA9IDA7XHJcblBhcnNlci5DT01CSU5BVE9SX1RZUEUgPSAxO1xyXG5QYXJzZXIuTUVESUFfRkVBVFVSRV9UWVBFID0gMjtcclxuUGFyc2VyLk1FRElBX1FVRVJZX1RZUEUgPSAzO1xyXG5QYXJzZXIuUFJPUEVSVFlfTkFNRV9UWVBFID0gNDtcclxuUGFyc2VyLlBST1BFUlRZX1ZBTFVFX1RZUEUgPSA1O1xyXG5QYXJzZXIuUFJPUEVSVFlfVkFMVUVfUEFSVF9UWVBFID0gNjtcclxuUGFyc2VyLlNFTEVDVE9SX1RZUEUgPSA3O1xyXG5QYXJzZXIuU0VMRUNUT1JfUEFSVF9UWVBFID0gODtcclxuUGFyc2VyLlNFTEVDVE9SX1NVQl9QQVJUX1RZUEUgPSA5O1xyXG5cclxuUGFyc2VyLnByb3RvdHlwZSA9IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgdmFyIHByb3RvID0gbmV3IEV2ZW50VGFyZ2V0KCksICAvL25ldyBwcm90b3R5cGVcclxuICAgICAgICBwcm9wLFxyXG4gICAgICAgIGFkZGl0aW9ucyA9ICB7XHJcbiAgICAgICAgICAgIF9fcHJvdG9fXzogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8vcmVzdG9yZSBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcjogUGFyc2VyLFxyXG5cclxuICAgICAgICAgICAgLy9pbnN0YW5jZSBjb25zdGFudHMgLSB5dWNrXHJcbiAgICAgICAgICAgIERFRkFVTFRfVFlQRSA6IDAsXHJcbiAgICAgICAgICAgIENPTUJJTkFUT1JfVFlQRSA6IDEsXHJcbiAgICAgICAgICAgIE1FRElBX0ZFQVRVUkVfVFlQRSA6IDIsXHJcbiAgICAgICAgICAgIE1FRElBX1FVRVJZX1RZUEUgOiAzLFxyXG4gICAgICAgICAgICBQUk9QRVJUWV9OQU1FX1RZUEUgOiA0LFxyXG4gICAgICAgICAgICBQUk9QRVJUWV9WQUxVRV9UWVBFIDogNSxcclxuICAgICAgICAgICAgUFJPUEVSVFlfVkFMVUVfUEFSVF9UWVBFIDogNixcclxuICAgICAgICAgICAgU0VMRUNUT1JfVFlQRSA6IDcsXHJcbiAgICAgICAgICAgIFNFTEVDVE9SX1BBUlRfVFlQRSA6IDgsXHJcbiAgICAgICAgICAgIFNFTEVDVE9SX1NVQl9QQVJUX1RZUEUgOiA5LFxyXG5cclxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAgICAvLyBHcmFtbWFyXHJcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICAgICAgICAgIF9zdHlsZXNoZWV0OiBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBzdHlsZXNoZWV0XHJcbiAgICAgICAgICAgICAgICAgKiAgOiBbIENIQVJTRVRfU1lNIFMqIFNUUklORyBTKiAnOycgXT9cclxuICAgICAgICAgICAgICAgICAqICAgIFtTfENET3xDRENdKiBbIGltcG9ydCBbU3xDRE98Q0RDXSogXSpcclxuICAgICAgICAgICAgICAgICAqICAgIFsgbmFtZXNwYWNlIFtTfENET3xDRENdKiBdKlxyXG4gICAgICAgICAgICAgICAgICogICAgWyBbIHJ1bGVzZXQgfCBtZWRpYSB8IHBhZ2UgfCBmb250X2ZhY2UgfCBrZXlmcmFtZXMgXSBbU3xDRE98Q0RDXSogXSpcclxuICAgICAgICAgICAgICAgICAqICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICBjb3VudCxcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbixcclxuICAgICAgICAgICAgICAgICAgICB0dDtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoXCJzdGFydHN0eWxlc2hlZXRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy90cnkgdG8gcmVhZCBjaGFyYWN0ZXIgc2V0XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFyc2V0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2tpcENydWZ0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy90cnkgdG8gcmVhZCBpbXBvcnRzIC0gbWF5IGJlIG1vcmUgdGhhbiBvbmVcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5JTVBPUlRfU1lNKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbXBvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9za2lwQ3J1ZnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL3RyeSB0byByZWFkIG5hbWVzcGFjZXMgLSBtYXkgYmUgbW9yZSB0aGFuIG9uZVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLk5BTUVTUEFDRV9TWU0pe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25hbWVzcGFjZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NraXBDcnVmdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBuZXh0IHRva2VuXHJcbiAgICAgICAgICAgICAgICB0dCA9IHRva2VuU3RyZWFtLnBlZWsoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3RyeSB0byByZWFkIHRoZSByZXN0XHJcbiAgICAgICAgICAgICAgICB3aGlsZSh0dCA+IFRva2Vucy5FT0Ype1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKHR0KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVG9rZW5zLk1FRElBX1NZTTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NraXBDcnVmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbnMuUEFHRV9TWU06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NraXBDcnVmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbnMuRk9OVF9GQUNFX1NZTTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb250X2ZhY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9za2lwQ3J1ZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVG9rZW5zLktFWUZSQU1FU19TWU06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5ZnJhbWVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2tpcENydWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRva2Vucy5WSUVXUE9SVF9TWU06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlld3BvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9za2lwQ3J1ZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVG9rZW5zLkRPQ1VNRU5UX1NZTTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb2N1bWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NraXBDcnVmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbnMuVU5LTk9XTl9TWU06ICAvL3Vua25vd24gQCBydWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0uZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc3RyaWN0KXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZmlyZSBlcnJvciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJlcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICAgIFwiVW5rbm93biBAIHJ1bGU6IFwiICsgdG9rZW5TdHJlYW0uTFQoMCkudmFsdWUgKyBcIi5cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgICAgIHRva2VuU3RyZWFtLkxUKDApLnN0YXJ0TGluZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogICAgICAgIHRva2VuU3RyZWFtLkxUKDApLnN0YXJ0Q29sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9za2lwIGJyYWNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudD0wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodG9rZW5TdHJlYW0uYWR2YW5jZShbVG9rZW5zLkxCUkFDRSwgVG9rZW5zLlJCUkFDRV0pID09PSBUb2tlbnMuTEJSQUNFKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7ICAgIC8va2VlcCB0cmFjayBvZiBuZXN0aW5nIGRlcHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGNvdW50KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLmFkdmFuY2UoW1Rva2Vucy5SQlJBQ0VdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ub3QgYSBzeW50YXggZXJyb3IsIHJldGhyb3cgaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5rbm93biBAIHJ1bGUuXCIsIHRva2VuU3RyZWFtLkxUKDApLnN0YXJ0TGluZSwgdG9rZW5TdHJlYW0uTFQoMCkuc3RhcnRDb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVG9rZW5zLlM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMuX3J1bGVzZXQoKSl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Vycm9yIGhhbmRsaW5nIGZvciBrbm93biBpc3N1ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKHR0KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVG9rZW5zLkNIQVJTRVRfU1lNOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0uTFQoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhcnNldChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQGNoYXJzZXQgbm90IGFsbG93ZWQgaGVyZS5cIiwgdG9rZW4uc3RhcnRMaW5lLCB0b2tlbi5zdGFydENvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRva2Vucy5JTVBPUlRfU1lNOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0uTFQoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW1wb3J0KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJAaW1wb3J0IG5vdCBhbGxvd2VkIGhlcmUuXCIsIHRva2VuLnN0YXJ0TGluZSwgdG9rZW4uc3RhcnRDb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbnMuTkFNRVNQQUNFX1NZTTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLkxUKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25hbWVzcGFjZShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQG5hbWVzcGFjZSBub3QgYWxsb3dlZCBoZXJlLlwiLCB0b2tlbi5zdGFydExpbmUsIHRva2VuLnN0YXJ0Q29sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0uZ2V0KCk7ICAvL2dldCB0aGUgbGFzdCB0b2tlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VuZXhwZWN0ZWRUb2tlbih0b2tlblN0cmVhbS50b2tlbigpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleCBpbnN0YW5jZW9mIFN5bnRheEVycm9yICYmICF0aGlzLm9wdGlvbnMuc3RyaWN0KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJlcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAgICAgIGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICAgIGV4Lm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICAgICAgZXgubGluZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2w6ICAgICAgICBleC5jb2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHR0ID0gdG9rZW5TdHJlYW0ucGVlaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0dCAhPT0gVG9rZW5zLkVPRil7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5leHBlY3RlZFRva2VuKHRva2VuU3RyZWFtLnRva2VuKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZShcImVuZHN0eWxlc2hlZXRcIik7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBfY2hhcnNldDogZnVuY3Rpb24oZW1pdCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuQ0hBUlNFVF9TWU0pKXtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLlNUUklORyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0udG9rZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gdG9rZW4udmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5TRU1JQ09MT04pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW1pdCAhPT0gZmFsc2Upe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcImNoYXJzZXRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJzZXQ6Y2hhcnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgbGluZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogICAgY29sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIF9pbXBvcnQ6IGZ1bmN0aW9uKGVtaXQpe1xyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIGltcG9ydFxyXG4gICAgICAgICAgICAgICAgICogICA6IElNUE9SVF9TWU0gUypcclxuICAgICAgICAgICAgICAgICAqICAgIFtTVFJJTkd8VVJJXSBTKiBtZWRpYV9xdWVyeV9saXN0PyAnOycgUypcclxuICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxyXG4gICAgICAgICAgICAgICAgICAgIHVyaSxcclxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRUb2tlbixcclxuICAgICAgICAgICAgICAgICAgICBtZWRpYUxpc3QgICA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vcmVhZCBpbXBvcnQgc3ltYm9sXHJcbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLklNUE9SVF9TWU0pO1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0VG9rZW4gPSB0b2tlblN0cmVhbS50b2tlbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goW1Rva2Vucy5TVFJJTkcsIFRva2Vucy5VUkldKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2dyYWIgdGhlIFVSSSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgdXJpID0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZS5yZXBsYWNlKC9eKD86dXJsXFwoKT9bXCInXT8oW15cIiddKz8pW1wiJ10/XFwpPyQvLCBcIiQxXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgbWVkaWFMaXN0ID0gdGhpcy5fbWVkaWFfcXVlcnlfbGlzdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vbXVzdCBlbmQgd2l0aCBhIHNlbWljb2xvblxyXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5TRU1JQ09MT04pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZW1pdCAhPT0gZmFsc2Upe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgXCJpbXBvcnRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJpOiAgICB1cmksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhOiAgbWVkaWFMaXN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGltcG9ydFRva2VuLnN0YXJ0TGluZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiAgICBpbXBvcnRUb2tlbi5zdGFydENvbFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIF9uYW1lc3BhY2U6IGZ1bmN0aW9uKGVtaXQpe1xyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIG5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICogICA6IE5BTUVTUEFDRV9TWU0gUyogW25hbWVzcGFjZV9wcmVmaXggUypdPyBbU1RSSU5HfFVSSV0gUyogJzsnIFMqXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbCxcclxuICAgICAgICAgICAgICAgICAgICBwcmVmaXgsXHJcbiAgICAgICAgICAgICAgICAgICAgdXJpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vcmVhZCBpbXBvcnQgc3ltYm9sXHJcbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLk5BTUVTUEFDRV9TWU0pO1xyXG4gICAgICAgICAgICAgICAgbGluZSA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRMaW5lO1xyXG4gICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9pdCdzIGEgbmFtZXNwYWNlIHByZWZpeCAtIG5vIF9uYW1lc3BhY2VfcHJlZml4KCkgbWV0aG9kIGJlY2F1c2UgaXQncyBqdXN0IGFuIElERU5UXHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLklERU5UKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChbVG9rZW5zLlNUUklORywgVG9rZW5zLlVSSV0pO1xyXG4gICAgICAgICAgICAgICAgLyppZiAoIXRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5TVFJJTkcpKXtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLlVSSSk7XHJcbiAgICAgICAgICAgICAgICB9Ki9cclxuXHJcbiAgICAgICAgICAgICAgICAvL2dyYWIgdGhlIFVSSSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgdXJpID0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZS5yZXBsYWNlKC8oPzp1cmxcXCgpP1tcIiddKFteXCInXSspW1wiJ11cXCk/LywgXCIkMVwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vbXVzdCBlbmQgd2l0aCBhIHNlbWljb2xvblxyXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5TRU1JQ09MT04pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZW1pdCAhPT0gZmFsc2Upe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgXCJuYW1lc3BhY2VcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVyaTogICAgdXJpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogICAgY29sXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgX21lZGlhOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIG1lZGlhXHJcbiAgICAgICAgICAgICAgICAgKiAgIDogTUVESUFfU1lNIFMqIG1lZGlhX3F1ZXJ5X2xpc3QgUyogJ3snIFMqIHJ1bGVzZXQqICd9JyBTKlxyXG4gICAgICAgICAgICAgICAgICogICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSAgICAgPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbCxcclxuICAgICAgICAgICAgICAgICAgICBtZWRpYUxpc3Q7Ly8gICAgICAgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2xvb2sgZm9yIEBtZWRpYVxyXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5NRURJQV9TWU0pO1xyXG4gICAgICAgICAgICAgICAgbGluZSA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRMaW5lO1xyXG4gICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbDtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIG1lZGlhTGlzdCA9IHRoaXMuX21lZGlhX3F1ZXJ5X2xpc3QoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLkxCUkFDRSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcInN0YXJ0bWVkaWFcIixcclxuICAgICAgICAgICAgICAgICAgICBtZWRpYTogIG1lZGlhTGlzdCxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sOiAgICBjb2xcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuUEFHRV9TWU0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5GT05UX0ZBQ0VfU1lNKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9udF9mYWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5WSUVXUE9SVF9TWU0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92aWV3cG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuRE9DVU1FTlRfU1lNKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9ydWxlc2V0KCkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5SQlJBQ0UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgXCJlbmRtZWRpYVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhOiAgbWVkaWFMaXN0LFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgbGluZSxcclxuICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIGNvbFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgLy9DU1MzIE1lZGlhIFF1ZXJpZXNcclxuICAgICAgICAgICAgX21lZGlhX3F1ZXJ5X2xpc3Q6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogbWVkaWFfcXVlcnlfbGlzdFxyXG4gICAgICAgICAgICAgICAgICogICA6IFMqIFttZWRpYV9xdWVyeSBbICcsJyBTKiBtZWRpYV9xdWVyeSBdKiBdP1xyXG4gICAgICAgICAgICAgICAgICogICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhTGlzdCAgID0gW107XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLklERU5UIHx8IHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLkxQQVJFTil7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVkaWFMaXN0LnB1c2godGhpcy5fbWVkaWFfcXVlcnkoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkNPTU1BKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBtZWRpYUxpc3QucHVzaCh0aGlzLl9tZWRpYV9xdWVyeSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVkaWFMaXN0O1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICogTm90ZTogXCJleHByZXNzaW9uXCIgaW4gdGhlIGdyYW1tYXIgbWFwcyB0byB0aGUgX21lZGlhX2V4cHJlc3Npb25cclxuICAgICAgICAgICAgICogbWV0aG9kLlxyXG5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF9tZWRpYV9xdWVyeTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBtZWRpYV9xdWVyeVxyXG4gICAgICAgICAgICAgICAgICogICA6IFtPTkxZIHwgTk9UXT8gUyogbWVkaWFfdHlwZSBTKiBbIEFORCBTKiBleHByZXNzaW9uIF0qXHJcbiAgICAgICAgICAgICAgICAgKiAgIHwgZXhwcmVzc2lvbiBbIEFORCBTKiBleHByZXNzaW9uIF0qXHJcbiAgICAgICAgICAgICAgICAgKiAgIDtcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSAgICAgICAgPSBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkZW50ICAgICAgID0gbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiAgICAgICA9IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLklERU5UKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWRlbnQgPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2luY2UgdGhlcmUncyBubyBjdXN0b20gdG9rZW5zIGZvciB0aGVzZSwgbmVlZCB0byBtYW51YWxseSBjaGVja1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZGVudCAhPT0gXCJvbmx5XCIgJiYgaWRlbnQgIT09IFwibm90XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS51bmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlblN0cmVhbS50b2tlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5JREVOVCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHRoaXMuX21lZGlhX3R5cGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5MUEFSRU4pe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0uTFQoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5fbWVkaWFfZXhwcmVzc2lvbigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gbnVsbCAmJiBleHByZXNzaW9ucy5sZW5ndGggPT09IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuSURFTlQpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWUudG9Mb3dlckNhc2UoKSAhPT0gXCJhbmRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91bmV4cGVjdGVkVG9rZW4odG9rZW5TdHJlYW0udG9rZW4oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5fbWVkaWFfZXhwcmVzc2lvbigpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNZWRpYVF1ZXJ5KGlkZW50LCB0eXBlLCBleHByZXNzaW9ucywgdG9rZW4uc3RhcnRMaW5lLCB0b2tlbi5zdGFydENvbCk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvL0NTUzMgTWVkaWEgUXVlcmllc1xyXG4gICAgICAgICAgICBfbWVkaWFfdHlwZTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBtZWRpYV90eXBlXHJcbiAgICAgICAgICAgICAgICAgKiAgIDogSURFTlRcclxuICAgICAgICAgICAgICAgICAqICAgO1xyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFfZmVhdHVyZSgpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5vdGU6IGluIENTUzMgTWVkaWEgUXVlcmllcywgdGhpcyBpcyBjYWxsZWQgXCJleHByZXNzaW9uXCIuXHJcbiAgICAgICAgICAgICAqIFJlbmFtZWQgaGVyZSB0byBhdm9pZCBjb25mbGljdCB3aXRoIENTUzMgU2VsZWN0b3JzXHJcbiAgICAgICAgICAgICAqIGRlZmluaXRpb24gb2YgXCJleHByZXNzaW9uXCIuIEFsc28gbm90ZSB0aGF0IFwiZXhwclwiIGluIHRoZVxyXG4gICAgICAgICAgICAgKiBncmFtbWFyIG5vdyBtYXBzIHRvIFwiZXhwcmVzc2lvblwiIGZyb20gQ1NTMyBzZWxlY3RvcnMuXHJcbiAgICAgICAgICAgICAqIEBtZXRob2QgX21lZGlhX2V4cHJlc3Npb25cclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF9tZWRpYV9leHByZXNzaW9uOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgICAgICAqICA6ICcoJyBTKiBtZWRpYV9mZWF0dXJlIFMqIFsgJzonIFMqIGV4cHIgXT8gJyknIFMqXHJcbiAgICAgICAgICAgICAgICAgKiAgO1xyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlICAgICA9IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiAgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuTFBBUkVOKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlID0gdGhpcy5fbWVkaWFfZmVhdHVyZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkNPTE9OKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLkxUKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLl9leHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5SUEFSRU4pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1lZGlhRmVhdHVyZShmZWF0dXJlLCAoZXhwcmVzc2lvbiA/IG5ldyBTeW50YXhVbml0KGV4cHJlc3Npb24sIHRva2VuLnN0YXJ0TGluZSwgdG9rZW4uc3RhcnRDb2wpIDogbnVsbCkpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy9DU1MzIE1lZGlhIFF1ZXJpZXNcclxuICAgICAgICAgICAgX21lZGlhX2ZlYXR1cmU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogbWVkaWFfZmVhdHVyZVxyXG4gICAgICAgICAgICAgICAgICogICA6IElERU5UXHJcbiAgICAgICAgICAgICAgICAgKiAgIDtcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW07XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLklERU5UKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3ludGF4VW5pdC5mcm9tVG9rZW4odG9rZW5TdHJlYW0udG9rZW4oKSk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvL0NTUzMgUGFnZWQgTWVkaWFcclxuICAgICAgICAgICAgX3BhZ2U6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogcGFnZTpcclxuICAgICAgICAgICAgICAgICAqICAgIFBBR0VfU1lNIFMqIElERU5UPyBwc2V1ZG9fcGFnZT8gUypcclxuICAgICAgICAgICAgICAgICAqICAgICd7JyBTKiBbIGRlY2xhcmF0aW9uIHwgbWFyZ2luIF0/IFsgJzsnIFMqIFsgZGVjbGFyYXRpb24gfCBtYXJnaW4gXT8gXSogJ30nIFMqXHJcbiAgICAgICAgICAgICAgICAgKiAgICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgID0gbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBwc2V1ZG9QYWdlICA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9sb29rIGZvciBAcGFnZVxyXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5QQUdFX1NZTSk7XHJcbiAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmU7XHJcbiAgICAgICAgICAgICAgICBjb2wgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0Q29sO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5JREVOVCkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1RoZSB2YWx1ZSAnYXV0bycgbWF5IG5vdCBiZSB1c2VkIGFzIGEgcGFnZSBuYW1lIGFuZCBNVVNUIGJlIHRyZWF0ZWQgYXMgYSBzeW50YXggZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkZW50aWZpZXIudG9Mb3dlckNhc2UoKSA9PT0gXCJhdXRvXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91bmV4cGVjdGVkVG9rZW4odG9rZW5TdHJlYW0udG9rZW4oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vc2VlIGlmIHRoZXJlJ3MgYSBjb2xvbiB1cGNvbWluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLkNPTE9OKXtcclxuICAgICAgICAgICAgICAgICAgICBwc2V1ZG9QYWdlID0gdGhpcy5fcHNldWRvX3BhZ2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcInN0YXJ0cGFnZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkOiAgICAgaWRlbnRpZmllcixcclxuICAgICAgICAgICAgICAgICAgICBwc2V1ZG86IHBzZXVkb1BhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZTogICBsaW5lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbDogICAgY29sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkRGVjbGFyYXRpb25zKHRydWUsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcImVuZHBhZ2VcIixcclxuICAgICAgICAgICAgICAgICAgICBpZDogICAgIGlkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgcHNldWRvOiBwc2V1ZG9QYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgbGluZSxcclxuICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIGNvbFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy9DU1MzIFBhZ2VkIE1lZGlhXHJcbiAgICAgICAgICAgIF9tYXJnaW46IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogbWFyZ2luIDpcclxuICAgICAgICAgICAgICAgICAqICAgIG1hcmdpbl9zeW0gUyogJ3snIGRlY2xhcmF0aW9uIFsgJzsnIFMqIGRlY2xhcmF0aW9uPyBdKiAnfScgUypcclxuICAgICAgICAgICAgICAgICAqICAgIDtcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcclxuICAgICAgICAgICAgICAgICAgICBjb2wsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luU3ltICAgPSB0aGlzLl9tYXJnaW5fc3ltKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1hcmdpblN5bSl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRMaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2w7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhcnRwYWdlbWFyZ2luXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogbWFyZ2luU3ltLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogICAgY29sXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWREZWNsYXJhdGlvbnModHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZW5kcGFnZW1hcmdpblwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IG1hcmdpblN5bSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICBsaW5lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIGNvbFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvL0NTUzMgUGFnZWQgTWVkaWFcclxuICAgICAgICAgICAgX21hcmdpbl9zeW06IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIG1hcmdpbl9zeW0gOlxyXG4gICAgICAgICAgICAgICAgICogICAgVE9QTEVGVENPUk5FUl9TWU0gfFxyXG4gICAgICAgICAgICAgICAgICogICAgVE9QTEVGVF9TWU0gfFxyXG4gICAgICAgICAgICAgICAgICogICAgVE9QQ0VOVEVSX1NZTSB8XHJcbiAgICAgICAgICAgICAgICAgKiAgICBUT1BSSUdIVF9TWU0gfFxyXG4gICAgICAgICAgICAgICAgICogICAgVE9QUklHSFRDT1JORVJfU1lNIHxcclxuICAgICAgICAgICAgICAgICAqICAgIEJPVFRPTUxFRlRDT1JORVJfU1lNIHxcclxuICAgICAgICAgICAgICAgICAqICAgIEJPVFRPTUxFRlRfU1lNIHxcclxuICAgICAgICAgICAgICAgICAqICAgIEJPVFRPTUNFTlRFUl9TWU0gfFxyXG4gICAgICAgICAgICAgICAgICogICAgQk9UVE9NUklHSFRfU1lNIHxcclxuICAgICAgICAgICAgICAgICAqICAgIEJPVFRPTVJJR0hUQ09STkVSX1NZTSB8XHJcbiAgICAgICAgICAgICAgICAgKiAgICBMRUZUVE9QX1NZTSB8XHJcbiAgICAgICAgICAgICAgICAgKiAgICBMRUZUTUlERExFX1NZTSB8XHJcbiAgICAgICAgICAgICAgICAgKiAgICBMRUZUQk9UVE9NX1NZTSB8XHJcbiAgICAgICAgICAgICAgICAgKiAgICBSSUdIVFRPUF9TWU0gfFxyXG4gICAgICAgICAgICAgICAgICogICAgUklHSFRNSURETEVfU1lNIHxcclxuICAgICAgICAgICAgICAgICAqICAgIFJJR0hUQk9UVE9NX1NZTVxyXG4gICAgICAgICAgICAgICAgICogICAgO1xyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5UT1BMRUZUQ09STkVSX1NZTSwgVG9rZW5zLlRPUExFRlRfU1lNLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBUb2tlbnMuVE9QQ0VOVEVSX1NZTSwgVG9rZW5zLlRPUFJJR0hUX1NZTSwgVG9rZW5zLlRPUFJJR0hUQ09STkVSX1NZTSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgVG9rZW5zLkJPVFRPTUxFRlRDT1JORVJfU1lNLCBUb2tlbnMuQk9UVE9NTEVGVF9TWU0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRva2Vucy5CT1RUT01DRU5URVJfU1lNLCBUb2tlbnMuQk9UVE9NUklHSFRfU1lNLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBUb2tlbnMuQk9UVE9NUklHSFRDT1JORVJfU1lNLCBUb2tlbnMuTEVGVFRPUF9TWU0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRva2Vucy5MRUZUTUlERExFX1NZTSwgVG9rZW5zLkxFRlRCT1RUT01fU1lNLCBUb2tlbnMuUklHSFRUT1BfU1lNLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBUb2tlbnMuUklHSFRNSURETEVfU1lNLCBUb2tlbnMuUklHSFRCT1RUT01fU1lNXSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bnRheFVuaXQuZnJvbVRva2VuKHRva2VuU3RyZWFtLnRva2VuKCkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBfcHNldWRvX3BhZ2U6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogcHNldWRvX3BhZ2VcclxuICAgICAgICAgICAgICAgICAqICAgOiAnOicgSURFTlRcclxuICAgICAgICAgICAgICAgICAqICAgO1xyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW07XHJcblxyXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5DT0xPTik7XHJcbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLklERU5UKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1RPRE86IENTUzMgUGFnZWQgTWVkaWEgc2F5cyBvbmx5IFwibGVmdFwiLCBcImNlbnRlclwiLCBhbmQgXCJyaWdodFwiIGFyZSBhbGxvd2VkXHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBfZm9udF9mYWNlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIGZvbnRfZmFjZVxyXG4gICAgICAgICAgICAgICAgICogICA6IEZPTlRfRkFDRV9TWU0gUypcclxuICAgICAgICAgICAgICAgICAqICAgICAneycgUyogZGVjbGFyYXRpb24gWyAnOycgUyogZGVjbGFyYXRpb24gXSogJ30nIFMqXHJcbiAgICAgICAgICAgICAgICAgKiAgIDtcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcclxuICAgICAgICAgICAgICAgICAgICBjb2w7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9sb29rIGZvciBAcGFnZVxyXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5GT05UX0ZBQ0VfU1lNKTtcclxuICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0TGluZTtcclxuICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2w7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgXCJzdGFydGZvbnRmYWNlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZTogICBsaW5lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbDogICAgY29sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkRGVjbGFyYXRpb25zKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcImVuZGZvbnRmYWNlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZTogICBsaW5lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbDogICAgY29sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIF92aWV3cG9ydDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiB2aWV3cG9ydFxyXG4gICAgICAgICAgICAgICAgICogICA6IFZJRVdQT1JUX1NZTSBTKlxyXG4gICAgICAgICAgICAgICAgICogICAgICd7JyBTKiBkZWNsYXJhdGlvbj8gWyAnOycgUyogZGVjbGFyYXRpb24/IF0qICd9JyBTKlxyXG4gICAgICAgICAgICAgICAgICogICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5WSUVXUE9SVF9TWU0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0TGluZTtcclxuICAgICAgICAgICAgICAgICAgICBjb2wgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0Q29sO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAgIFwic3RhcnR2aWV3cG9ydFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogICAgY29sXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWREZWNsYXJhdGlvbnModHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgXCJlbmR2aWV3cG9ydFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogICAgY29sXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgX2RvY3VtZW50OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIGRvY3VtZW50XHJcbiAgICAgICAgICAgICAgICAgKiAgIDogRE9DVU1FTlRfU1lNIFMqXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgX2RvY3VtZW50X2Z1bmN0aW9uIFsgJywnIFMqIF9kb2N1bWVudF9mdW5jdGlvbiBdKiBTKlxyXG4gICAgICAgICAgICAgICAgICogICAgICd7JyBTKiBydWxlc2V0KiAnfSdcclxuICAgICAgICAgICAgICAgICAqICAgO1xyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gXCJcIjtcclxuXHJcbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLkRPQ1VNRU5UX1NZTSk7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoL15AXFwtKFteXFwtXSspXFwtLy50ZXN0KHRva2VuLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IFJlZ0V4cC4kMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25zLnB1c2godGhpcy5fZG9jdW1lbnRfZnVuY3Rpb24oKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkNPTU1BKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zLnB1c2godGhpcy5fZG9jdW1lbnRfZnVuY3Rpb24oKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5MQlJBQ0UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgXCJzdGFydGRvY3VtZW50XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zOiBmdW5jdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiAgICBwcmVmaXgsXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZTogICAgICB0b2tlbi5zdGFydExpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sOiAgICAgICB0b2tlbi5zdGFydENvbFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5QQUdFX1NZTSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLkZPTlRfRkFDRV9TWU0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb250X2ZhY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLlZJRVdQT1JUX1NZTSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5NRURJQV9TWU0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3J1bGVzZXQoKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLlJCUkFDRSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICBcImVuZGRvY3VtZW50XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zOiBmdW5jdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiAgICBwcmVmaXgsXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZTogICAgICB0b2tlbi5zdGFydExpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sOiAgICAgICB0b2tlbi5zdGFydENvbFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBfZG9jdW1lbnRfZnVuY3Rpb246IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogZG9jdW1lbnRfZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqICAgOiBmdW5jdGlvbiB8IFVSSSBTKlxyXG4gICAgICAgICAgICAgICAgICogICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLlVSSSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9mdW5jdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIF9vcGVyYXRvcjogZnVuY3Rpb24oaW5GdW5jdGlvbil7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIG9wZXJhdG9yIChvdXRzaWRlIGZ1bmN0aW9uKVxyXG4gICAgICAgICAgICAgICAgICogIDogJy8nIFMqIHwgJywnIFMqIHwgLyggZW1wdHkgKS9cclxuICAgICAgICAgICAgICAgICAqIG9wZXJhdG9yIChpbnNpZGUgZnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgKiAgOiAnLycgUyogfCAnKycgUyogfCAnKicgUyogfCAnLScgUyogLyggZW1wdHkgKS9cclxuICAgICAgICAgICAgICAgICAqICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiAgICAgICA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFtUb2tlbnMuU0xBU0gsIFRva2Vucy5DT01NQV0pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGluRnVuY3Rpb24gJiYgdG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5QTFVTLCBUb2tlbnMuU1RBUiwgVG9rZW5zLk1JTlVTXSkpKXtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9ICB0b2tlblN0cmVhbS50b2tlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPyBQcm9wZXJ0eVZhbHVlUGFydC5mcm9tVG9rZW4odG9rZW4pIDogbnVsbDtcclxuXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBfY29tYmluYXRvcjogZnVuY3Rpb24oKXtcclxuXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogY29tYmluYXRvclxyXG4gICAgICAgICAgICAgICAgICogIDogUExVUyBTKiB8IEdSRUFURVIgUyogfCBUSUxERSBTKiB8IFMrXHJcbiAgICAgICAgICAgICAgICAgKiAgO1xyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgPSBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHRva2VuU3RyZWFtLm1hdGNoKFtUb2tlbnMuUExVUywgVG9rZW5zLkdSRUFURVIsIFRva2Vucy5USUxERV0pKXtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQ29tYmluYXRvcih0b2tlbi52YWx1ZSwgdG9rZW4uc3RhcnRMaW5lLCB0b2tlbi5zdGFydENvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBfdW5hcnlfb3BlcmF0b3I6IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIHVuYXJ5X29wZXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgKiAgOiAnLScgfCAnKydcclxuICAgICAgICAgICAgICAgICAqICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5NSU5VUywgVG9rZW5zLlBMVVNdKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgX3Byb3BlcnR5OiBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgICogICA6IElERU5UIFMqXHJcbiAgICAgICAgICAgICAgICAgKiAgIDtcclxuICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgICAgID0gbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBoYWNrICAgICAgICA9IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5WYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbixcclxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbDtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGZvciBzdGFyIGhhY2sgLSB0aHJvd3MgZXJyb3IgaWYgbm90IGFsbG93ZWRcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5TVEFSICYmIHRoaXMub3B0aW9ucy5zdGFySGFjayl7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0uZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlblN0cmVhbS50b2tlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhY2sgPSB0b2tlbi52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW4uc3RhcnRMaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuLnN0YXJ0Q29sO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5JREVOVCkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0udG9rZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlblZhbHVlID0gdG9rZW4udmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIHVuZGVyc2NvcmUgaGFjayAtIG5vIGVycm9yIGlmIG5vdCBhbGxvd2VkIGJlY2F1c2UgaXQncyB2YWxpZCBDU1Mgc3ludGF4XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuVmFsdWUuY2hhckF0KDApID09PSBcIl9cIiAmJiB0aGlzLm9wdGlvbnMudW5kZXJzY29yZUhhY2spe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYWNrID0gXCJfXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVmFsdWUgPSB0b2tlblZhbHVlLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IFByb3BlcnR5TmFtZSh0b2tlblZhbHVlLCBoYWNrLCAobGluZXx8dG9rZW4uc3RhcnRMaW5lKSwgKGNvbHx8dG9rZW4uc3RhcnRDb2wpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vQXVnbWVudGVkIHdpdGggQ1NTMyBTZWxlY3RvcnNcclxuICAgICAgICAgICAgX3J1bGVzZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogcnVsZXNldFxyXG4gICAgICAgICAgICAgICAgICogICA6IHNlbGVjdG9yc19ncm91cFxyXG4gICAgICAgICAgICAgICAgICogICAgICd7JyBTKiBkZWNsYXJhdGlvbj8gWyAnOycgUyogZGVjbGFyYXRpb24/IF0qICd9JyBTKlxyXG4gICAgICAgICAgICAgICAgICogICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICB0dCxcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnM7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBFcnJvciBSZWNvdmVyeTogSWYgZXZlbiBhIHNpbmdsZSBzZWxlY3RvciBmYWlscyB0byBwYXJzZSxcclxuICAgICAgICAgICAgICAgICAqIHRoZW4gdGhlIGVudGlyZSBydWxlc2V0IHNob3VsZCBiZSB0aHJvd24gYXdheS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSB0aGlzLl9zZWxlY3RvcnNfZ3JvdXAoKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KXtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiBTeW50YXhFcnJvciAmJiAhdGhpcy5vcHRpb25zLnN0cmljdCl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ZpcmUgZXJyb3IgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgIFwiZXJyb3JcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAgICAgIGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogICAgZXgubWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgICAgIGV4LmxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2w6ICAgICAgICBleC5jb2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NraXAgb3ZlciBldmVyeXRoaW5nIHVudGlsIGNsb3NpbmcgYnJhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHQgPSB0b2tlblN0cmVhbS5hZHZhbmNlKFtUb2tlbnMuUkJSQUNFXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0dCA9PT0gVG9rZW5zLlJCUkFDRSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZXJlJ3MgYSByaWdodCBicmFjZSwgdGhlIHJ1bGUgaXMgZmluaXNoZWQgc28gZG9uJ3QgZG8gYW55dGhpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlLCByZXRocm93IHRoZSBlcnJvciBiZWNhdXNlIGl0IHdhc24ndCBoYW5kbGVkIHByb3Blcmx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL25vdCBhIHN5bnRheCBlcnJvciwgcmV0aHJvdyBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vdHJpZ2dlciBwYXJzZXIgdG8gY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL2lmIGl0IGdvdCBoZXJlLCBhbGwgc2VsZWN0b3JzIHBhcnNlZFxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9ycyl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgIFwic3RhcnRydWxlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yczogIHNlbGVjdG9ycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICAgICAgc2VsZWN0b3JzWzBdLmxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogICAgICAgIHNlbGVjdG9yc1swXS5jb2xcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZERlY2xhcmF0aW9ucyh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJlbmRydWxlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yczogIHNlbGVjdG9ycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICAgICAgc2VsZWN0b3JzWzBdLmxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogICAgICAgIHNlbGVjdG9yc1swXS5jb2xcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9ycztcclxuXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvL0NTUzMgU2VsZWN0b3JzXHJcbiAgICAgICAgICAgIF9zZWxlY3RvcnNfZ3JvdXA6IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIHNlbGVjdG9yc19ncm91cFxyXG4gICAgICAgICAgICAgICAgICogICA6IHNlbGVjdG9yIFsgQ09NTUEgUyogc2VsZWN0b3IgXSpcclxuICAgICAgICAgICAgICAgICAqICAgO1xyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnMgICA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdGhpcy5fc2VsZWN0b3IoKTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciAhPT0gbnVsbCl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuQ09NTUEpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB0aGlzLl9zZWxlY3RvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzLnB1c2goc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5leHBlY3RlZFRva2VuKHRva2VuU3RyZWFtLkxUKDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0b3JzLmxlbmd0aCA/IHNlbGVjdG9ycyA6IG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvL0NTUzMgU2VsZWN0b3JzXHJcbiAgICAgICAgICAgIF9zZWxlY3RvcjogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBzZWxlY3RvclxyXG4gICAgICAgICAgICAgICAgICogICA6IHNpbXBsZV9zZWxlY3Rvcl9zZXF1ZW5jZSBbIGNvbWJpbmF0b3Igc2ltcGxlX3NlbGVjdG9yX3NlcXVlbmNlIF0qXHJcbiAgICAgICAgICAgICAgICAgKiAgIDtcclxuICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yICAgID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNlbGVjdG9yID0gbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBjb21iaW5hdG9yICA9IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgd3MgICAgICAgICAgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBubyBzaW1wbGUgc2VsZWN0b3IsIHRoZW4gdGhlcmUncyBubyBzZWxlY3RvclxyXG4gICAgICAgICAgICAgICAgbmV4dFNlbGVjdG9yID0gdGhpcy5fc2ltcGxlX3NlbGVjdG9yX3NlcXVlbmNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNlbGVjdG9yID09PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rvci5wdXNoKG5leHRTZWxlY3Rvcik7XHJcblxyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2xvb2sgZm9yIGEgY29tYmluYXRvclxyXG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmF0b3IgPSB0aGlzLl9jb21iaW5hdG9yKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21iaW5hdG9yICE9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IucHVzaChjb21iaW5hdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNlbGVjdG9yID0gdGhpcy5fc2ltcGxlX3NlbGVjdG9yX3NlcXVlbmNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoZXJlIG11c3QgYmUgYSBuZXh0IHNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U2VsZWN0b3IgPT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5leHBlY3RlZFRva2VuKHRva2VuU3RyZWFtLkxUKDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25leHRTZWxlY3RvciBpcyBhbiBpbnN0YW5jZSBvZiBTZWxlY3RvclBhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLnB1c2gobmV4dFNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZXJlJ3Mgbm90IHdoaXRlc3BhY2UsIHdlJ3JlIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCkpe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRkIHdoaXRlc3BhY2Ugc2VwYXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cyA9IG5ldyBDb21iaW5hdG9yKHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWUsIHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRMaW5lLCB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0Q29sKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbWJpbmF0b3IgaXMgbm90IHJlcXVpcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21iaW5hdG9yID0gdGhpcy5fY29tYmluYXRvcigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2VsZWN0b3IgaXMgcmVxdWlyZWQgaWYgdGhlcmUncyBhIGNvbWJpbmF0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTZWxlY3RvciA9IHRoaXMuX3NpbXBsZV9zZWxlY3Rvcl9zZXF1ZW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTZWxlY3RvciA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbWJpbmF0b3IgIT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91bmV4cGVjdGVkVG9rZW4odG9rZW5TdHJlYW0uTFQoMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21iaW5hdG9yICE9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IucHVzaChjb21iaW5hdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvci5wdXNoKHdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLnB1c2gobmV4dFNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gd2hpbGUodHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3RvcihzZWxlY3Rvciwgc2VsZWN0b3JbMF0ubGluZSwgc2VsZWN0b3JbMF0uY29sKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vQ1NTMyBTZWxlY3RvcnNcclxuICAgICAgICAgICAgX3NpbXBsZV9zZWxlY3Rvcl9zZXF1ZW5jZTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBzaW1wbGVfc2VsZWN0b3Jfc2VxdWVuY2VcclxuICAgICAgICAgICAgICAgICAqICAgOiBbIHR5cGVfc2VsZWN0b3IgfCB1bml2ZXJzYWwgXVxyXG4gICAgICAgICAgICAgICAgICogICAgIFsgSEFTSCB8IGNsYXNzIHwgYXR0cmliIHwgcHNldWRvIHwgbmVnYXRpb24gXSpcclxuICAgICAgICAgICAgICAgICAqICAgfCBbIEhBU0ggfCBjbGFzcyB8IGF0dHJpYiB8IHBzZXVkbyB8IG5lZ2F0aW9uIF0rXHJcbiAgICAgICAgICAgICAgICAgKiAgIDtcclxuICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3BhcnRzIG9mIGEgc2ltcGxlIHNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE5hbWUgPSBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVycyAgID0gW10sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29tcGxldGUgc2VsZWN0b3IgdGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yVGV4dD0gXCJcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgZGlmZmVyZW50IHBhcnRzIGFmdGVyIHRoZSBlbGVtZW50IG5hbWUgdG8gc2VhcmNoIGZvclxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMgID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0hBU0hcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuSEFTSCkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgU2VsZWN0b3JTdWJQYXJ0KHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWUsIFwiaWRcIiwgdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmUsIHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2wpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dHJpYixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHNldWRvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZWdhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgaSAgICAgICAgICAgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbiAgICAgICAgID0gY29tcG9uZW50cy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ICAgPSBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL2dldCBzdGFydGluZyBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoZSBzZWxlY3RvclxyXG4gICAgICAgICAgICAgICAgbGluZSA9IHRva2VuU3RyZWFtLkxUKDEpLnN0YXJ0TGluZTtcclxuICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLkxUKDEpLnN0YXJ0Q29sO1xyXG5cclxuICAgICAgICAgICAgICAgIGVsZW1lbnROYW1lID0gdGhpcy5fdHlwZV9zZWxlY3RvcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50TmFtZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE5hbWUgPSB0aGlzLl91bml2ZXJzYWwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudE5hbWUgIT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yVGV4dCArPSBlbGVtZW50TmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSh0cnVlKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy93aGl0ZXNwYWNlIG1lYW5zIHdlJ3JlIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuUyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgZWFjaCBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZShpIDwgbGVuICYmIGNvbXBvbmVudCA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaSsrXS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gbnVsbCl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3dlIGRvbid0IGhhdmUgYSBzZWxlY3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JUZXh0ID09PSBcIlwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goY29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JUZXh0ICs9IGNvbXBvbmVudC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yVGV4dCAhPT0gXCJcIiA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTZWxlY3RvclBhcnQoZWxlbWVudE5hbWUsIG1vZGlmaWVycywgc2VsZWN0b3JUZXh0LCBsaW5lLCBjb2wpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vQ1NTMyBTZWxlY3RvcnNcclxuICAgICAgICAgICAgX3R5cGVfc2VsZWN0b3I6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogdHlwZV9zZWxlY3RvclxyXG4gICAgICAgICAgICAgICAgICogICA6IFsgbmFtZXNwYWNlX3ByZWZpeCBdPyBlbGVtZW50X25hbWVcclxuICAgICAgICAgICAgICAgICAqICAgO1xyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgbnMgICAgICAgICAgPSB0aGlzLl9uYW1lc3BhY2VfcHJlZml4KCksXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE5hbWUgPSB0aGlzLl9lbGVtZW50X25hbWUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnROYW1lKXtcclxuICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIE5lZWQgdG8gYmFjayBvdXQgdGhlIG5hbWVzcGFjZSB0aGF0IHdhcyByZWFkIGR1ZSB0byBib3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICogdHlwZV9zZWxlY3RvciBhbmQgdW5pdmVyc2FsIHJlYWRpbmcgbmFtZXNwYWNlX3ByZWZpeFxyXG4gICAgICAgICAgICAgICAgICAgICAqIGZpcnN0LiBLaW5kIG9mIGhhY2t5LCBidXQgb25seSB3YXkgSSBjYW4gZmlndXJlIG91dFxyXG4gICAgICAgICAgICAgICAgICAgICAqIHJpZ2h0IG5vdyBob3cgdG8gbm90IGNoYW5nZSB0aGUgZ3JhbW1hci5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBpZiAobnMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS51bmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnMubGVuZ3RoID4gMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS51bmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5zKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudE5hbWUudGV4dCA9IG5zICsgZWxlbWVudE5hbWUudGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudE5hbWUuY29sIC09IG5zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnROYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy9DU1MzIFNlbGVjdG9yc1xyXG4gICAgICAgICAgICBfY2xhc3M6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogY2xhc3NcclxuICAgICAgICAgICAgICAgICAqICAgOiAnLicgSURFTlRcclxuICAgICAgICAgICAgICAgICAqICAgO1xyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW47XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5ET1QpKXtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLklERU5UKTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3RvclN1YlBhcnQoXCIuXCIgKyB0b2tlbi52YWx1ZSwgXCJjbGFzc1wiLCB0b2tlbi5zdGFydExpbmUsIHRva2VuLnN0YXJ0Q29sIC0gMSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vQ1NTMyBTZWxlY3RvcnNcclxuICAgICAgICAgICAgX2VsZW1lbnRfbmFtZTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBlbGVtZW50X25hbWVcclxuICAgICAgICAgICAgICAgICAqICAgOiBJREVOVFxyXG4gICAgICAgICAgICAgICAgICogICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLklERU5UKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlblN0cmVhbS50b2tlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2VsZWN0b3JTdWJQYXJ0KHRva2VuLnZhbHVlLCBcImVsZW1lbnROYW1lXCIsIHRva2VuLnN0YXJ0TGluZSwgdG9rZW4uc3RhcnRDb2wpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvL0NTUzMgU2VsZWN0b3JzXHJcbiAgICAgICAgICAgIF9uYW1lc3BhY2VfcHJlZml4OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIG5hbWVzcGFjZV9wcmVmaXhcclxuICAgICAgICAgICAgICAgICAqICAgOiBbIElERU5UIHwgJyonIF0/ICd8J1xyXG4gICAgICAgICAgICAgICAgICogICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgICAgID0gXCJcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3ZlcmlmeSB0aGF0IHRoaXMgaXMgYSBuYW1lc3BhY2UgcHJlZml4XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0uTEEoMSkgPT09IFRva2Vucy5QSVBFIHx8IHRva2VuU3RyZWFtLkxBKDIpID09PSBUb2tlbnMuUElQRSl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRva2VuU3RyZWFtLm1hdGNoKFtUb2tlbnMuSURFTlQsIFRva2Vucy5TVEFSXSkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5QSVBFKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBcInxcIjtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA/IHZhbHVlIDogbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vQ1NTMyBTZWxlY3RvcnNcclxuICAgICAgICAgICAgX3VuaXZlcnNhbDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiB1bml2ZXJzYWxcclxuICAgICAgICAgICAgICAgICAqICAgOiBbIG5hbWVzcGFjZV9wcmVmaXggXT8gJyonXHJcbiAgICAgICAgICAgICAgICAgKiAgIDtcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgPSBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIG5zO1xyXG5cclxuICAgICAgICAgICAgICAgIG5zID0gdGhpcy5fbmFtZXNwYWNlX3ByZWZpeCgpO1xyXG4gICAgICAgICAgICAgICAgaWYobnMpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IG5zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5TVEFSKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gXCIqXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA/IHZhbHVlIDogbnVsbDtcclxuXHJcbiAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vQ1NTMyBTZWxlY3RvcnNcclxuICAgICAgICAgICAgX2F0dHJpYjogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBhdHRyaWJcclxuICAgICAgICAgICAgICAgICAqICAgOiAnWycgUyogWyBuYW1lc3BhY2VfcHJlZml4IF0/IElERU5UIFMqXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgIFsgWyBQUkVGSVhNQVRDSCB8XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICBTVUZGSVhNQVRDSCB8XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICBTVUJTVFJJTkdNQVRDSCB8XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAnPScgfFxyXG4gICAgICAgICAgICAgICAgICogICAgICAgICAgICAgSU5DTFVERVMgfFxyXG4gICAgICAgICAgICAgICAgICogICAgICAgICAgICAgREFTSE1BVENIIF0gUyogWyBJREVOVCB8IFNUUklORyBdIFMqXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgIF0/ICddJ1xyXG4gICAgICAgICAgICAgICAgICogICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA9IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW47XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5MQlJBQ0tFVCkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0udG9rZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRva2VuLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG5zID0gdGhpcy5fbmFtZXNwYWNlX3ByZWZpeCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobnMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBucztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuSURFTlQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5QUkVGSVhNQVRDSCwgVG9rZW5zLlNVRkZJWE1BVENILCBUb2tlbnMuU1VCU1RSSU5HTUFUQ0gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUb2tlbnMuRVFVQUxTLCBUb2tlbnMuSU5DTFVERVMsIFRva2Vucy5EQVNITUFUQ0hdKSl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFtUb2tlbnMuSURFTlQsIFRva2Vucy5TVFJJTkddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuUkJSQUNLRVQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNlbGVjdG9yU3ViUGFydCh2YWx1ZSArIFwiXVwiLCBcImF0dHJpYnV0ZVwiLCB0b2tlbi5zdGFydExpbmUsIHRva2VuLnN0YXJ0Q29sKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvL0NTUzMgU2VsZWN0b3JzXHJcbiAgICAgICAgICAgIF9wc2V1ZG86IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIHBzZXVkb1xyXG4gICAgICAgICAgICAgICAgICogICA6ICc6JyAnOic/IFsgSURFTlQgfCBmdW5jdGlvbmFsX3BzZXVkbyBdXHJcbiAgICAgICAgICAgICAgICAgKiAgIDtcclxuICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxyXG4gICAgICAgICAgICAgICAgICAgIHBzZXVkbyAgICAgID0gbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBjb2xvbnMgICAgICA9IFwiOlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuQ09MT04pKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5DT0xPTikpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvbnMgKz0gXCI6XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLklERU5UKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzZXVkbyA9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0TGluZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbCAtIGNvbG9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5GVU5DVElPTil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS5MVCgxKS5zdGFydExpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLkxUKDEpLnN0YXJ0Q29sIC0gY29sb25zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHNldWRvID0gdGhpcy5fZnVuY3Rpb25hbF9wc2V1ZG8oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwc2V1ZG8pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwc2V1ZG8gPSBuZXcgU2VsZWN0b3JTdWJQYXJ0KGNvbG9ucyArIHBzZXVkbywgXCJwc2V1ZG9cIiwgbGluZSwgY29sKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBzZXVkbztcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vQ1NTMyBTZWxlY3RvcnNcclxuICAgICAgICAgICAgX2Z1bmN0aW9uYWxfcHNldWRvOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIGZ1bmN0aW9uYWxfcHNldWRvXHJcbiAgICAgICAgICAgICAgICAgKiAgIDogRlVOQ1RJT04gUyogZXhwcmVzc2lvbiAnKSdcclxuICAgICAgICAgICAgICAgICAqICAgO1xyXG4gICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkZVTkNUSU9OKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy5fZXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuUlBBUkVOKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBcIilcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvL0NTUzMgU2VsZWN0b3JzXHJcbiAgICAgICAgICAgIF9leHByZXNzaW9uOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgICAgICAqICAgOiBbIFsgUExVUyB8ICctJyB8IERJTUVOU0lPTiB8IE5VTUJFUiB8IFNUUklORyB8IElERU5UIF0gUyogXStcclxuICAgICAgICAgICAgICAgICAqICAgO1xyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgPSBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlKHRva2VuU3RyZWFtLm1hdGNoKFtUb2tlbnMuUExVUywgVG9rZW5zLk1JTlVTLCBUb2tlbnMuRElNRU5TSU9OLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBUb2tlbnMuTlVNQkVSLCBUb2tlbnMuU1RSSU5HLCBUb2tlbnMuSURFTlQsIFRva2Vucy5MRU5HVEgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRva2Vucy5GUkVRLCBUb2tlbnMuQU5HTEUsIFRva2Vucy5USU1FLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBUb2tlbnMuUkVTT0xVVElPTiwgVG9rZW5zLlNMQVNIXSkpe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA/IHZhbHVlIDogbnVsbDtcclxuXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvL0NTUzMgU2VsZWN0b3JzXHJcbiAgICAgICAgICAgIF9uZWdhdGlvbjogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBuZWdhdGlvblxyXG4gICAgICAgICAgICAgICAgICogICA6IE5PVCBTKiBuZWdhdGlvbl9hcmcgUyogJyknXHJcbiAgICAgICAgICAgICAgICAgKiAgIDtcclxuICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgICAgID0gXCJcIixcclxuICAgICAgICAgICAgICAgICAgICBhcmcsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VicGFydCAgICAgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuTk9UKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0TGluZTtcclxuICAgICAgICAgICAgICAgICAgICBjb2wgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0Q29sO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gdGhpcy5fbmVnYXRpb25fYXJnKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gYXJnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLlJQQVJFTik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3VicGFydCA9IG5ldyBTZWxlY3RvclN1YlBhcnQodmFsdWUsIFwibm90XCIsIGxpbmUsIGNvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VicGFydC5hcmdzLnB1c2goYXJnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VicGFydDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vQ1NTMyBTZWxlY3RvcnNcclxuICAgICAgICAgICAgX25lZ2F0aW9uX2FyZzogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBuZWdhdGlvbl9hcmdcclxuICAgICAgICAgICAgICAgICAqICAgOiB0eXBlX3NlbGVjdG9yIHwgdW5pdmVyc2FsIHwgSEFTSCB8IGNsYXNzIHwgYXR0cmliIHwgcHNldWRvXHJcbiAgICAgICAgICAgICAgICAgKiAgIDtcclxuICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgICAgICAgID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90eXBlX3NlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91bml2ZXJzYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkhBU0gpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFNlbGVjdG9yU3ViUGFydCh0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlLCBcImlkXCIsIHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRMaW5lLCB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0Q29sKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsYXNzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdHRyaWIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BzZXVkb1xyXG4gICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnICAgICAgICAgPSBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBsZW4gICAgICAgICA9IGFyZ3MubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgbGluZSA9IHRva2VuU3RyZWFtLkxUKDEpLnN0YXJ0TGluZTtcclxuICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLkxUKDEpLnN0YXJ0Q29sO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlKGkgPCBsZW4gJiYgYXJnID09PSBudWxsKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnc1tpXS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL211c3QgYmUgYSBuZWdhdGlvbiBhcmdcclxuICAgICAgICAgICAgICAgIGlmIChhcmcgPT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VuZXhwZWN0ZWRUb2tlbih0b2tlblN0cmVhbS5MVCgxKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9pdCdzIGFuIGVsZW1lbnQgbmFtZVxyXG4gICAgICAgICAgICAgICAgaWYgKGFyZy50eXBlID09PSBcImVsZW1lbnROYW1lXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnQgPSBuZXcgU2VsZWN0b3JQYXJ0KGFyZywgW10sIGFyZy50b1N0cmluZygpLCBsaW5lLCBjb2wpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gbmV3IFNlbGVjdG9yUGFydChudWxsLCBbYXJnXSwgYXJnLnRvU3RyaW5nKCksIGxpbmUsIGNvbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBfZGVjbGFyYXRpb246IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIGRlY2xhcmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiAgIDogcHJvcGVydHkgJzonIFMqIGV4cHIgcHJpbz9cclxuICAgICAgICAgICAgICAgICAqICAgfCAvKCBlbXB0eSApL1xyXG4gICAgICAgICAgICAgICAgICogICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSAgICA9IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwciAgICAgICAgPSBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHByaW8gICAgICAgID0gbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkICAgICA9IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lPSBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gdGhpcy5fcHJvcGVydHkoKTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eSAhPT0gbnVsbCl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuQ09MT04pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLl9leHByKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBubyBwYXJ0cyBmb3IgdGhlIHZhbHVlLCBpdCdzIGFuIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleHByIHx8IGV4cHIubGVuZ3RoID09PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5leHBlY3RlZFRva2VuKHRva2VuU3RyZWFtLkxUKDEpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHByaW8gPSB0aGlzLl9wcmlvKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgICogSWYgaGFja3Mgc2hvdWxkIGJlIGFsbG93ZWQsIHRoZW4gb25seSBjaGVjayB0aGUgcm9vdFxyXG4gICAgICAgICAgICAgICAgICAgICAqIHByb3BlcnR5LiBJZiBoYWNrcyBzaG91bGQgbm90IGJlIGFsbG93ZWQsIHRyZWF0XHJcbiAgICAgICAgICAgICAgICAgICAgICogX3Byb3BlcnR5IG9yICpwcm9wZXJ0eSBhcyBpbnZhbGlkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lID0gcHJvcGVydHkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YXJIYWNrICYmIHByb3BlcnR5LmhhY2sgPT09IFwiKlwiIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudW5kZXJzY29yZUhhY2sgJiYgcHJvcGVydHkuaGFjayA9PT0gXCJfXCIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5LnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgZXhwcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZCA9IGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJwcm9wZXJ0eVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogICBwcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICAgICAgZXhwcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50OiAgcHJpbyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICAgICAgcHJvcGVydHkubGluZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiAgICAgICAgcHJvcGVydHkuY29sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkOiAgICBpbnZhbGlkXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBfcHJpbzogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBwcmlvXHJcbiAgICAgICAgICAgICAgICAgKiAgIDogSU1QT1JUQU5UX1NZTSBTKlxyXG4gICAgICAgICAgICAgICAgICogICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgICAgICA9IHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5JTVBPUlRBTlRfU1lNKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIF9leHByOiBmdW5jdGlvbihpbkZ1bmN0aW9uKXtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBleHByXHJcbiAgICAgICAgICAgICAgICAgKiAgIDogdGVybSBbIG9wZXJhdG9yIHRlcm0gXSpcclxuICAgICAgICAgICAgICAgICAqICAgO1xyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyAgICAgID0gW10sXHJcblx0XHRcdFx0XHQvL3ZhbHVlUGFydHNcdD0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgPSBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yICAgID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3Rlcm0oaW5GdW5jdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPSB0aGlzLl9vcGVyYXRvcihpbkZ1bmN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBhbiBvcGVyYXRvciwga2VlcCBidWlsZGluZyB1cCB0aGUgdmFsdWUgcGFydHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKG9wZXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSAvKmVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGVyZSdzIG5vdCBhbiBvcGVyYXRvciwgeW91IGhhdmUgYSBmdWxsIHZhbHVlXHJcblx0XHRcdFx0XHRcdFx0dmFsdWVzLnB1c2gobmV3IFByb3BlcnR5VmFsdWUodmFsdWVQYXJ0cywgdmFsdWVQYXJ0c1swXS5saW5lLCB2YWx1ZVBhcnRzWzBdLmNvbCkpO1xyXG5cdFx0XHRcdFx0XHRcdHZhbHVlUGFydHMgPSBbXTtcclxuXHRcdFx0XHRcdFx0fSovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3Rlcm0oaW5GdW5jdGlvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHRcdFx0XHQvL2NsZWFudXBcclxuICAgICAgICAgICAgICAgIC8qaWYgKHZhbHVlUGFydHMubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChuZXcgUHJvcGVydHlWYWx1ZSh2YWx1ZVBhcnRzLCB2YWx1ZVBhcnRzWzBdLmxpbmUsIHZhbHVlUGFydHNbMF0uY29sKSk7XHJcbiAgICAgICAgICAgICAgICB9Ki9cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzLmxlbmd0aCA+IDAgPyBuZXcgUHJvcGVydHlWYWx1ZSh2YWx1ZXMsIHZhbHVlc1swXS5saW5lLCB2YWx1ZXNbMF0uY29sKSA6IG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBfdGVybTogZnVuY3Rpb24oaW5GdW5jdGlvbil7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIHRlcm1cclxuICAgICAgICAgICAgICAgICAqICAgOiB1bmFyeV9vcGVyYXRvcj9cclxuICAgICAgICAgICAgICAgICAqICAgICBbIE5VTUJFUiBTKiB8IFBFUkNFTlRBR0UgUyogfCBMRU5HVEggUyogfCBBTkdMRSBTKiB8XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICBUSU1FIFMqIHwgRlJFUSBTKiB8IGZ1bmN0aW9uIHwgaWVfZnVuY3Rpb24gXVxyXG4gICAgICAgICAgICAgICAgICogICB8IFNUUklORyBTKiB8IElERU5UIFMqIHwgVVJJIFMqIHwgVU5JQ09ERVJBTkdFIFMqIHwgaGV4Y29sb3JcclxuICAgICAgICAgICAgICAgICAqICAgO1xyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgdW5hcnkgICAgICAgPSBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgICAgID0gbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBlbmRDaGFyICAgICA9IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcclxuICAgICAgICAgICAgICAgICAgICBjb2w7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9yZXR1cm5zIHRoZSBvcGVyYXRvciBvciBudWxsXHJcbiAgICAgICAgICAgICAgICB1bmFyeSA9IHRoaXMuX3VuYXJ5X29wZXJhdG9yKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodW5hcnkgIT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0TGluZTtcclxuICAgICAgICAgICAgICAgICAgICBjb2wgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0Q29sO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZXhjZXB0aW9uIGZvciBJRSBmaWx0ZXJzXHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuSUVfRlVOQ1RJT04gJiYgdGhpcy5vcHRpb25zLmllRmlsdGVycyl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5faWVfZnVuY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodW5hcnkgPT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vc2VlIGlmIGl0J3MgYSBzaW1wbGUgYmxvY2tcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5GdW5jdGlvbiAmJiB0b2tlblN0cmVhbS5tYXRjaChbVG9rZW5zLkxQQVJFTiwgVG9rZW5zLkxCUkFDRSwgVG9rZW5zLkxCUkFDS0VUXSkpe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kQ2hhciA9IHRva2VuLmVuZENoYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0b2tlbi52YWx1ZSArIHRoaXMuX2V4cHIoaW5GdW5jdGlvbikudGV4dDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodW5hcnkgPT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMudHlwZShlbmRDaGFyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZW5kQ2hhcjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vc2VlIGlmIHRoZXJlJ3MgYSBzaW1wbGUgbWF0Y2hcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5OVU1CRVIsIFRva2Vucy5QRVJDRU5UQUdFLCBUb2tlbnMuTEVOR1RILFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBUb2tlbnMuQU5HTEUsIFRva2Vucy5USU1FLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBUb2tlbnMuRlJFUSwgVG9rZW5zLlNUUklORywgVG9rZW5zLklERU5ULCBUb2tlbnMuVVJJLCBUb2tlbnMuVU5JQ09ERV9SQU5HRV0pKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmFyeSA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0TGluZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2VlIGlmIGl0J3MgYSBjb2xvclxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5faGV4Y29sb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IG51bGwpe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGVyZSdzIG5vIHVuYXJ5LCBnZXQgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IHRva2VuIGZvciBsaW5lL2NvbCBpbmZvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmFyeSA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0uTFQoMSkuc3RhcnRMaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0uTFQoMSkuc3RhcnRDb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaGFzIHRvIGJlIGEgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhpcyBjaGVja3MgZm9yIGFscGhhKG9wYWNpdHk9MCkgc3R5bGUgb2YgSUVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGZ1bmN0aW9ucy4gSUVfRlVOQ1RJT04gb25seSBwcmVzZW50cyBwcm9naWQ6IHN0eWxlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0uTEEoMykgPT09IFRva2Vucy5FUVVBTFMgJiYgdGhpcy5vcHRpb25zLmllRmlsdGVycyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9pZV9mdW5jdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2Z1bmN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qaWYgKHZhbHVlID09PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBpZGVudGlmaWVyIGF0IGxpbmUgXCIgKyB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0TGluZSArIFwiLCBjaGFyYWN0ZXIgXCIgKyAgdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbCArIFwiLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9rZW4udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmFyeSA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW4uc3RhcnRMaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gdG9rZW4uc3RhcnRDb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQcm9wZXJ0eVZhbHVlUGFydCh1bmFyeSAhPT0gbnVsbCA/IHVuYXJ5ICsgdmFsdWUgOiB2YWx1ZSwgbGluZSwgY29sKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XHJcblxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgX2Z1bmN0aW9uOiBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogICA6IEZVTkNUSU9OIFMqIGV4cHIgJyknIFMqXHJcbiAgICAgICAgICAgICAgICAgKiAgIDtcclxuICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCA9IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwciAgICAgICAgPSBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGx0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuRlVOQ1RJT04pKXtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblRleHQgPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuX2V4cHIodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ICs9IGV4cHI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vU1RBUlQ6IEhvcnJpYmxlIGhhY2sgaW4gY2FzZSBpdCdzIGFuIElFIGZpbHRlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWVGaWx0ZXJzICYmIHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLkVRVUFMUyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVhZFdoaXRlc3BhY2UoKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ICs9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9taWdodCBiZSBzZWNvbmQgdGltZSBpbiB0aGUgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLkxBKDApID09PSBUb2tlbnMuQ09NTUEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5JREVOVCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblRleHQgKz0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuRVFVQUxTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZnVuY3Rpb25UZXh0ICs9IHRoaXMuX3Rlcm0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGx0ID0gdG9rZW5TdHJlYW0ucGVlaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUobHQgIT09IFRva2Vucy5DT01NQSAmJiBsdCAhPT0gVG9rZW5zLlMgJiYgbHQgIT09IFRva2Vucy5SUEFSRU4pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGx0ID0gdG9rZW5TdHJlYW0ucGVlaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlKHRva2VuU3RyZWFtLm1hdGNoKFtUb2tlbnMuQ09NTUEsIFRva2Vucy5TXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9FTkQ6IEhvcnJpYmxlIEhhY2tcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLlJQQVJFTik7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ICs9IFwiKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uVGV4dDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIF9pZV9mdW5jdGlvbjogZnVuY3Rpb24oKXtcclxuXHJcbiAgICAgICAgICAgICAgICAvKiAoTXkgb3duIGV4dGVuc2lvbilcclxuICAgICAgICAgICAgICAgICAqIGllX2Z1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiAgIDogSUVfRlVOQ1RJT04gUyogSURFTlQgJz0nIHRlcm0gW1MqICcsJz8gSURFTlQgJz0nIHRlcm1dKyAnKScgUypcclxuICAgICAgICAgICAgICAgICAqICAgO1xyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ID0gbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBsdDtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0lFIGZ1bmN0aW9uIGNhbiBiZWdpbiBsaWtlIGEgcmVndWxhciBmdW5jdGlvbiwgdG9vXHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5JRV9GVU5DVElPTiwgVG9rZW5zLkZVTkNUSU9OXSkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCA9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkV2hpdGVzcGFjZSgpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21pZ2h0IGJlIHNlY29uZCB0aW1lIGluIHRoZSBsb29wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5MQSgwKSA9PT0gVG9rZW5zLkNPTU1BKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuSURFTlQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblRleHQgKz0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5FUVVBTFMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblRleHQgKz0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZnVuY3Rpb25UZXh0ICs9IHRoaXMuX3Rlcm0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbHQgPSB0b2tlblN0cmVhbS5wZWVrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGx0ICE9PSBUb2tlbnMuQ09NTUEgJiYgbHQgIT09IFRva2Vucy5TICYmIGx0ICE9PSBUb2tlbnMuUlBBUkVOKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ICs9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsdCA9IHRva2VuU3RyZWFtLnBlZWsoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUodG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5DT01NQSwgVG9rZW5zLlNdKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5SUEFSRU4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCArPSBcIilcIjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvblRleHQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBfaGV4Y29sb3I6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogVGhlcmUgaXMgYSBjb25zdHJhaW50IG9uIHRoZSBjb2xvciB0aGF0IGl0IG11c3RcclxuICAgICAgICAgICAgICAgICAqIGhhdmUgZWl0aGVyIDMgb3IgNiBoZXgtZGlnaXRzIChpLmUuLCBbMC05YS1mQS1GXSlcclxuICAgICAgICAgICAgICAgICAqIGFmdGVyIHRoZSBcIiNcIjsgZS5nLiwgXCIjMDAwXCIgaXMgT0ssIGJ1dCBcIiNhYmNkXCIgaXMgbm90LlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIGhleGNvbG9yXHJcbiAgICAgICAgICAgICAgICAgKiAgIDogSEFTSCBTKlxyXG4gICAgICAgICAgICAgICAgICogICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkhBU0gpKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9uZWVkIHRvIGRvIHNvbWUgdmFsaWRhdGlvbiBoZXJlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0udG9rZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IHRva2VuLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghLyNbYS1mMC05XXszLDZ9L2kudGVzdChjb2xvcikpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJFeHBlY3RlZCBhIGhleCBjb2xvciBidXQgZm91bmQgJ1wiICsgY29sb3IgKyBcIicgYXQgbGluZSBcIiArIHRva2VuLnN0YXJ0TGluZSArIFwiLCBjb2wgXCIgKyB0b2tlbi5zdGFydENvbCArIFwiLlwiLCB0b2tlbi5zdGFydExpbmUsIHRva2VuLnN0YXJ0Q29sKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICAgIC8vIEFuaW1hdGlvbnMgbWV0aG9kc1xyXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgICAgICAgICBfa2V5ZnJhbWVzOiBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBrZXlmcmFtZXM6XHJcbiAgICAgICAgICAgICAgICAgKiAgIDogS0VZRlJBTUVTX1NZTSBTKiBrZXlmcmFtZV9uYW1lIFMqICd7JyBTKiBrZXlmcmFtZV9ydWxlKiAnfScge1xyXG4gICAgICAgICAgICAgICAgICogICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgIHR0LFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gXCJcIjtcclxuXHJcbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLktFWUZSQU1FU19TWU0pO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlblN0cmVhbS50b2tlbigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKC9eQFxcLShbXlxcLV0rKVxcLS8udGVzdCh0b2tlbi52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBSZWdFeHAuJDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLl9rZXlmcmFtZV9uYW1lKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuTEJSQUNFKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgXCJzdGFydGtleWZyYW1lc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICAgbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHByZWZpeCxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIHRva2VuLnN0YXJ0TGluZSxcclxuICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIHRva2VuLnN0YXJ0Q29sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG4gICAgICAgICAgICAgICAgdHQgPSB0b2tlblN0cmVhbS5wZWVrKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3Iga2V5XHJcbiAgICAgICAgICAgICAgICB3aGlsZSh0dCA9PT0gVG9rZW5zLklERU5UIHx8IHR0ID09PSBUb2tlbnMuUEVSQ0VOVEFHRSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleWZyYW1lX3J1bGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHR0ID0gdG9rZW5TdHJlYW0ucGVlaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcImVuZGtleWZyYW1lc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICAgbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHByZWZpeCxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIHRva2VuLnN0YXJ0TGluZSxcclxuICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIHRva2VuLnN0YXJ0Q29sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5SQlJBQ0UpO1xyXG5cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIF9rZXlmcmFtZV9uYW1lOiBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBrZXlmcmFtZV9uYW1lOlxyXG4gICAgICAgICAgICAgICAgICogICA6IElERU5UXHJcbiAgICAgICAgICAgICAgICAgKiAgIHwgU1RSSU5HXHJcbiAgICAgICAgICAgICAgICAgKiAgIDtcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW07XHJcblxyXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFtUb2tlbnMuSURFTlQsIFRva2Vucy5TVFJJTkddKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXhVbml0LmZyb21Ub2tlbih0b2tlblN0cmVhbS50b2tlbigpKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIF9rZXlmcmFtZV9ydWxlOiBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBrZXlmcmFtZV9ydWxlOlxyXG4gICAgICAgICAgICAgICAgICogICA6IGtleV9saXN0IFMqXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgJ3snIFMqIGRlY2xhcmF0aW9uIFsgJzsnIFMqIGRlY2xhcmF0aW9uIF0qICd9JyBTKlxyXG4gICAgICAgICAgICAgICAgICogICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciBrZXlMaXN0ID0gdGhpcy5fa2V5X2xpc3QoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgXCJzdGFydGtleWZyYW1lcnVsZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGtleXM6ICAga2V5TGlzdCxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGtleUxpc3RbMF0ubGluZSxcclxuICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIGtleUxpc3RbMF0uY29sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkRGVjbGFyYXRpb25zKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcImVuZGtleWZyYW1lcnVsZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGtleXM6ICAga2V5TGlzdCxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGtleUxpc3RbMF0ubGluZSxcclxuICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIGtleUxpc3RbMF0uY29sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBfa2V5X2xpc3Q6IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIGtleV9saXN0OlxyXG4gICAgICAgICAgICAgICAgICogICA6IGtleSBbIFMqICcsJyBTKiBrZXldKlxyXG4gICAgICAgICAgICAgICAgICogICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxyXG4gICAgICAgICAgICAgICAgICAgIGtleUxpc3QgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL211c3QgYmUgbGVhc3Qgb25lIGtleVxyXG4gICAgICAgICAgICAgICAga2V5TGlzdC5wdXNoKHRoaXMuX2tleSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5DT01NQSkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5TGlzdC5wdXNoKHRoaXMuX2tleSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlMaXN0O1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgX2tleTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBUaGVyZSBpcyBhIHJlc3RyaWN0aW9uIHRoYXQgSURFTlQgY2FuIGJlIG9ubHkgXCJmcm9tXCIgb3IgXCJ0b1wiLlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIGtleVxyXG4gICAgICAgICAgICAgICAgICogICA6IFBFUkNFTlRBR0VcclxuICAgICAgICAgICAgICAgICAqICAgfCBJREVOVFxyXG4gICAgICAgICAgICAgICAgICogICA7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLlBFUkNFTlRBR0UpKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3ludGF4VW5pdC5mcm9tVG9rZW4odG9rZW5TdHJlYW0udG9rZW4oKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5JREVOVCkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0udG9rZW4oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9mcm9tfHRvL2kudGVzdCh0b2tlbi52YWx1ZSkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3ludGF4VW5pdC5mcm9tVG9rZW4odG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0udW5nZXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL2lmIGl0IGdldHMgaGVyZSwgdGhlcmUgd2Fzbid0IGEgdmFsaWQgdG9rZW4sIHNvIHRpbWUgdG8gZXhwbG9kZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdW5leHBlY3RlZFRva2VuKHRva2VuU3RyZWFtLkxUKDEpKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgICAgLy8gSGVscGVyIG1ldGhvZHNcclxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5vdCBwYXJ0IG9mIENTUyBncmFtbWFyLCBidXQgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyXHJcbiAgICAgICAgICAgICAqIGNvbWJpbmF0aW9uIG9mIHdoaXRlIHNwYWNlIGFuZCBIVE1MLXN0eWxlIGNvbW1lbnRzLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9za2lwQ3J1ZnRcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF9za2lwQ3J1ZnQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSh0aGlzLl90b2tlblN0cmVhbS5tYXRjaChbVG9rZW5zLlMsIFRva2Vucy5DRE8sIFRva2Vucy5DRENdKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9ub29wXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTm90IHBhcnQgb2YgQ1NTIGdyYW1tYXIsIGJ1dCB0aGlzIHBhdHRlcm4gb2NjdXJzIGZyZXF1ZW50bHlcclxuICAgICAgICAgICAgICogaW4gdGhlIG9mZmljaWFsIENTUyBncmFtbWFyLiBTcGxpdCBvdXQgaGVyZSB0byBlbGltaW5hdGVcclxuICAgICAgICAgICAgICogZHVwbGljYXRlIGNvZGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2hlY2tTdGFydCBJbmRpY2F0ZXMgaWYgdGhlIHJ1bGUgc2hvdWxkIGNoZWNrXHJcbiAgICAgICAgICAgICAqICAgICAgZm9yIHRoZSBsZWZ0IGJyYWNlIGF0IHRoZSBiZWdpbm5pbmcuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVhZE1hcmdpbnMgSW5kaWNhdGVzIGlmIHRoZSBydWxlIHNob3VsZCBjaGVja1xyXG4gICAgICAgICAgICAgKiAgICAgIGZvciBtYXJnaW4gcGF0dGVybnMuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICAgICAgICAgICAqIEBtZXRob2QgX3JlYWREZWNsYXJhdGlvbnNcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF9yZWFkRGVjbGFyYXRpb25zOiBmdW5jdGlvbihjaGVja1N0YXJ0LCByZWFkTWFyZ2lucyl7XHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogUmVhZHMgdGhlIHBhdHRlcm5cclxuICAgICAgICAgICAgICAgICAqIFMqICd7JyBTKiBkZWNsYXJhdGlvbiBbICc7JyBTKiBkZWNsYXJhdGlvbiBdKiAnfScgUypcclxuICAgICAgICAgICAgICAgICAqIG9yXHJcbiAgICAgICAgICAgICAgICAgKiBTKiAneycgUyogWyBkZWNsYXJhdGlvbiB8IG1hcmdpbiBdPyBbICc7JyBTKiBbIGRlY2xhcmF0aW9uIHwgbWFyZ2luIF0/IF0qICd9JyBTKlxyXG4gICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgaXMgaG93IGl0IGlzIGRlc2NyaWJlZCBpbiBDU1MzIFBhZ2VkIE1lZGlhLCBidXQgaXMgYWN0dWFsbHkgaW5jb3JyZWN0LlxyXG4gICAgICAgICAgICAgICAgICogQSBzZW1pY29sb24gaXMgb25seSBuZWNlc3NhcnkgZm9sbG93aW5nIGEgZGVjbGFyYXRpb24gaWYgdGhlcmUncyBhbm90aGVyIGRlY2xhcmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBvciBtYXJnaW4gYWZ0ZXJ3YXJkcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgdHQ7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrU3RhcnQpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuTEJSQUNFKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHRydWUpe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5TRU1JQ09MT04pIHx8IChyZWFkTWFyZ2lucyAmJiB0aGlzLl9tYXJnaW4oKSkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ub29wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZGVjbGFyYXRpb24oKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5TRU1JQ09MT04pKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmICgoIXRoaXMuX21hcmdpbigpICYmICF0aGlzLl9kZWNsYXJhdGlvbigpKSB8fCAhdG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLlNFTUlDT0xPTikpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy99XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLlJCUkFDRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleCBpbnN0YW5jZW9mIFN5bnRheEVycm9yICYmICF0aGlzLm9wdGlvbnMuc3RyaWN0KXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmlyZSBlcnJvciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJlcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICAgICAgZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAgICBleC5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICAgICAgZXgubGluZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogICAgICAgIGV4LmNvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2VlIGlmIHRoZXJlJ3MgYW5vdGhlciBkZWNsYXJhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0dCA9IHRva2VuU3RyZWFtLmFkdmFuY2UoW1Rva2Vucy5TRU1JQ09MT04sIFRva2Vucy5SQlJBQ0VdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR0ID09PSBUb2tlbnMuU0VNSUNPTE9OKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBhIHNlbWljb2xvbiwgdGhlbiB0aGVyZSBtaWdodCBiZSBhbm90aGVyIGRlY2xhcmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkRGVjbGFyYXRpb25zKGZhbHNlLCByZWFkTWFyZ2lucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHQgIT09IFRva2Vucy5SQlJBQ0Upe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGVyZSdzIGEgcmlnaHQgYnJhY2UsIHRoZSBydWxlIGlzIGZpbmlzaGVkIHNvIGRvbid0IGRvIGFueXRoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL290aGVyd2lzZSwgcmV0aHJvdyB0aGUgZXJyb3IgYmVjYXVzZSBpdCB3YXNuJ3QgaGFuZGxlZCBwcm9wZXJseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9ub3QgYSBzeW50YXggZXJyb3IsIHJldGhyb3cgaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbiBzb21lIGNhc2VzLCB5b3UgY2FuIGVuZCB1cCB3aXRoIHR3byB3aGl0ZSBzcGFjZSB0b2tlbnMgaW4gYVxyXG4gICAgICAgICAgICAgKiByb3cuIEluc3RlYWQgb2YgbWFraW5nIGEgY2hhbmdlIGluIGV2ZXJ5IGZ1bmN0aW9uIHRoYXQgbG9va3MgZm9yXHJcbiAgICAgICAgICAgICAqIHdoaXRlIHNwYWNlLCB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gbWF0Y2ggYXMgbXVjaCB3aGl0ZSBzcGFjZVxyXG4gICAgICAgICAgICAgKiBhcyBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAqIEBtZXRob2QgX3JlYWRXaGl0ZXNwYWNlXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHdoaXRlIHNwYWNlIGlmIGZvdW5kLCBlbXB0eSBzdHJpbmcgaWYgbm90LlxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3JlYWRXaGl0ZXNwYWNlOiBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxyXG4gICAgICAgICAgICAgICAgICAgIHdzID0gXCJcIjtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuUykpe1xyXG4gICAgICAgICAgICAgICAgICAgIHdzICs9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdzO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaHJvd3MgYW4gZXJyb3Igd2hlbiBhbiB1bmV4cGVjdGVkIHRva2VuIGlzIGZvdW5kLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdG9rZW4gVGhlIHRva2VuIHRoYXQgd2FzIGZvdW5kLlxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF91bmV4cGVjdGVkVG9rZW5cclxuICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF91bmV4cGVjdGVkVG9rZW46IGZ1bmN0aW9uKHRva2VuKXtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gJ1wiICsgdG9rZW4udmFsdWUgKyBcIicgYXQgbGluZSBcIiArIHRva2VuLnN0YXJ0TGluZSArIFwiLCBjb2wgXCIgKyB0b2tlbi5zdGFydENvbCArIFwiLlwiLCB0b2tlbi5zdGFydExpbmUsIHRva2VuLnN0YXJ0Q29sKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIZWxwZXIgbWV0aG9kIHVzZWQgZm9yIHBhcnNpbmcgc3VicGFydHMgb2YgYSBzdHlsZSBzaGVldC5cclxuICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cclxuICAgICAgICAgICAgICogQG1ldGhvZCBfdmVyaWZ5RW5kXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdmVyaWZ5RW5kOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rva2VuU3RyZWFtLkxBKDEpICE9PSBUb2tlbnMuRU9GKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91bmV4cGVjdGVkVG9rZW4odGhpcy5fdG9rZW5TdHJlYW0uTFQoMSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAgICAvLyBWYWxpZGF0aW9uIG1ldGhvZHNcclxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAgICBfdmFsaWRhdGVQcm9wZXJ0eTogZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKXtcclxuICAgICAgICAgICAgICAgIFZhbGlkYXRpb24udmFsaWRhdGUocHJvcGVydHksIHZhbHVlKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgICAgLy8gUGFyc2luZyBtZXRob2RzXHJcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b2tlblN0cmVhbSA9IG5ldyBUb2tlblN0cmVhbShpbnB1dCwgVG9rZW5zKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlc2hlZXQoKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHBhcnNlU3R5bGVTaGVldDogZnVuY3Rpb24oaW5wdXQpe1xyXG4gICAgICAgICAgICAgICAgLy9qdXN0IHBhc3N0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBwYXJzZU1lZGlhUXVlcnk6IGZ1bmN0aW9uKGlucHV0KXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rva2VuU3RyZWFtID0gbmV3IFRva2VuU3RyZWFtKGlucHV0LCBUb2tlbnMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX21lZGlhX3F1ZXJ5KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9pZiB0aGVyZSdzIGFueXRoaW5nIG1vcmUsIHRoZW4gaXQncyBhbiBpbnZhbGlkIHNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICB0aGlzLl92ZXJpZnlFbmQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL290aGVyd2lzZSByZXR1cm4gcmVzdWx0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyBhIHByb3BlcnR5IHZhbHVlIChldmVyeXRoaW5nIGFmdGVyIHRoZSBzZW1pY29sb24pLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtwYXJzZXJsaWIuY3NzLlByb3BlcnR5VmFsdWV9IFRoZSBwcm9wZXJ0eSB2YWx1ZS5cclxuICAgICAgICAgICAgICogQHRocm93cyBwYXJzZXJsaWIudXRpbC5TeW50YXhFcnJvciBJZiBhbiB1bmV4cGVjdGVkIHRva2VuIGlzIGZvdW5kLlxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHBhcnNlclByb3BlcnR5VmFsdWVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHBhcnNlUHJvcGVydHlWYWx1ZTogZnVuY3Rpb24oaW5wdXQpe1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rva2VuU3RyZWFtID0gbmV3IFRva2VuU3RyZWFtKGlucHV0LCBUb2tlbnMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZXhwcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vb2theSB0byBoYXZlIGEgdHJhaWxpbmcgd2hpdGUgc3BhY2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9pZiB0aGVyZSdzIGFueXRoaW5nIG1vcmUsIHRoZW4gaXQncyBhbiBpbnZhbGlkIHNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICB0aGlzLl92ZXJpZnlFbmQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL290aGVyd2lzZSByZXR1cm4gcmVzdWx0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyBhIGNvbXBsZXRlIENTUyBydWxlLCBpbmNsdWRpbmcgc2VsZWN0b3JzIGFuZFxyXG4gICAgICAgICAgICAgKiBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHRleHQgdG8gcGFyc2VyLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXJzZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBpZiBub3QuXHJcbiAgICAgICAgICAgICAqIEBtZXRob2QgcGFyc2VSdWxlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBwYXJzZVJ1bGU6IGZ1bmN0aW9uKGlucHV0KXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rva2VuU3RyZWFtID0gbmV3IFRva2VuU3RyZWFtKGlucHV0LCBUb2tlbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vc2tpcCBhbnkgbGVhZGluZyB3aGl0ZSBzcGFjZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcnVsZXNldCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vc2tpcCBhbnkgdHJhaWxpbmcgd2hpdGUgc3BhY2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9pZiB0aGVyZSdzIGFueXRoaW5nIG1vcmUsIHRoZW4gaXQncyBhbiBpbnZhbGlkIHNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICB0aGlzLl92ZXJpZnlFbmQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL290aGVyd2lzZSByZXR1cm4gcmVzdWx0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyBhIHNpbmdsZSBDU1Mgc2VsZWN0b3IgKG5vIGNvbW1hKVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHRleHQgdG8gcGFyc2UgYXMgYSBDU1Mgc2VsZWN0b3IuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1NlbGVjdG9yfSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZWxlY3Rvci5cclxuICAgICAgICAgICAgICogQHRocm93cyBwYXJzZXJsaWIudXRpbC5TeW50YXhFcnJvciBJZiBhbiB1bmV4cGVjdGVkIHRva2VuIGlzIGZvdW5kLlxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHBhcnNlU2VsZWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHBhcnNlU2VsZWN0b3I6IGZ1bmN0aW9uKGlucHV0KXtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b2tlblN0cmVhbSA9IG5ldyBUb2tlblN0cmVhbShpbnB1dCwgVG9rZW5zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3NraXAgYW55IGxlYWRpbmcgd2hpdGUgc3BhY2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3NlbGVjdG9yKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9za2lwIGFueSB0cmFpbGluZyB3aGl0ZSBzcGFjZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2lmIHRoZXJlJ3MgYW55dGhpbmcgbW9yZSwgdGhlbiBpdCdzIGFuIGludmFsaWQgc2VsZWN0b3JcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZlcmlmeUVuZCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIHJldHVybiByZXN1bHRcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGFuIEhUTUwgc3R5bGUgYXR0cmlidXRlOiBhIHNldCBvZiBDU1MgZGVjbGFyYXRpb25zXHJcbiAgICAgICAgICAgICAqIHNlcGFyYXRlZCBieSBzZW1pY29sb25zLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHRleHQgdG8gcGFyc2UgYXMgYSBzdHlsZSBhdHRyaWJ1dGVcclxuICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cclxuICAgICAgICAgICAgICogQG1ldGhvZCBwYXJzZVN0eWxlQXR0cmlidXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBwYXJzZVN0eWxlQXR0cmlidXRlOiBmdW5jdGlvbihpbnB1dCl7XHJcbiAgICAgICAgICAgICAgICBpbnB1dCArPSBcIn1cIjsgLy8gZm9yIGVycm9yIHJlY292ZXJ5IGluIF9yZWFkRGVjbGFyYXRpb25zKClcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rva2VuU3RyZWFtID0gbmV3IFRva2VuU3RyZWFtKGlucHV0LCBUb2tlbnMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZERlY2xhcmF0aW9ucygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAvL2NvcHkgb3ZlciBvbnRvIHByb3RvdHlwZVxyXG4gICAgZm9yIChwcm9wIGluIGFkZGl0aW9ucyl7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhZGRpdGlvbnMsIHByb3ApKXtcclxuICAgICAgICAgICAgcHJvdG9bcHJvcF0gPSBhZGRpdGlvbnNbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwcm90bztcclxufSgpO1xyXG5cclxuXHJcbi8qXHJcbm50aFxyXG4gIDogUyogWyBbJy0nfCcrJ10/IElOVEVHRVI/IHtOfSBbIFMqIFsnLSd8JysnXSBTKiBJTlRFR0VSIF0/IHxcclxuICAgICAgICAgWyctJ3wnKyddPyBJTlRFR0VSIHwge099e0R9e0R9IHwge0V9e1Z9e0V9e059IF0gUypcclxuICA7XHJcbiovXHJcbnZhciBQcm9wZXJ0aWVzID0ge1xyXG4gICAgX19wcm90b19fOiBudWxsLFxyXG5cclxuICAgIC8vQVxyXG4gICAgXCJhbGlnbi1pdGVtc1wiICAgICAgICAgICAgICAgICAgIDogXCJmbGV4LXN0YXJ0IHwgZmxleC1lbmQgfCBjZW50ZXIgfCBiYXNlbGluZSB8IHN0cmV0Y2hcIixcclxuICAgIFwiYWxpZ24tY29udGVudFwiICAgICAgICAgICAgICAgICA6IFwiZmxleC1zdGFydCB8IGZsZXgtZW5kIHwgY2VudGVyIHwgc3BhY2UtYmV0d2VlbiB8IHNwYWNlLWFyb3VuZCB8IHN0cmV0Y2hcIixcclxuICAgIFwiYWxpZ24tc2VsZlwiICAgICAgICAgICAgICAgICAgICA6IFwiYXV0byB8IGZsZXgtc3RhcnQgfCBmbGV4LWVuZCB8IGNlbnRlciB8IGJhc2VsaW5lIHwgc3RyZXRjaFwiLFxyXG4gICAgXCItd2Via2l0LWFsaWduLWl0ZW1zXCIgICAgICAgICAgIDogXCJmbGV4LXN0YXJ0IHwgZmxleC1lbmQgfCBjZW50ZXIgfCBiYXNlbGluZSB8IHN0cmV0Y2hcIixcclxuICAgIFwiLXdlYmtpdC1hbGlnbi1jb250ZW50XCIgICAgICAgICA6IFwiZmxleC1zdGFydCB8IGZsZXgtZW5kIHwgY2VudGVyIHwgc3BhY2UtYmV0d2VlbiB8IHNwYWNlLWFyb3VuZCB8IHN0cmV0Y2hcIixcclxuICAgIFwiLXdlYmtpdC1hbGlnbi1zZWxmXCIgICAgICAgICAgICA6IFwiYXV0byB8IGZsZXgtc3RhcnQgfCBmbGV4LWVuZCB8IGNlbnRlciB8IGJhc2VsaW5lIHwgc3RyZXRjaFwiLFxyXG4gICAgXCJhbGlnbm1lbnQtYWRqdXN0XCIgICAgICAgICAgICAgIDogXCJhdXRvIHwgYmFzZWxpbmUgfCBiZWZvcmUtZWRnZSB8IHRleHQtYmVmb3JlLWVkZ2UgfCBtaWRkbGUgfCBjZW50cmFsIHwgYWZ0ZXItZWRnZSB8IHRleHQtYWZ0ZXItZWRnZSB8IGlkZW9ncmFwaGljIHwgYWxwaGFiZXRpYyB8IGhhbmdpbmcgfCBtYXRoZW1hdGljYWwgfCA8cGVyY2VudGFnZT4gfCA8bGVuZ3RoPlwiLFxyXG4gICAgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIiAgICAgICAgICAgIDogXCJiYXNlbGluZSB8IHVzZS1zY3JpcHQgfCBiZWZvcmUtZWRnZSB8IHRleHQtYmVmb3JlLWVkZ2UgfCBhZnRlci1lZGdlIHwgdGV4dC1hZnRlci1lZGdlIHwgY2VudHJhbCB8IG1pZGRsZSB8IGlkZW9ncmFwaGljIHwgYWxwaGFiZXRpYyB8IGhhbmdpbmcgfCBtYXRoZW1hdGljYWxcIixcclxuICAgIFwiYW5pbWF0aW9uXCIgICAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcImFuaW1hdGlvbi1kZWxheVwiICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjx0aW1lPlwiLCBjb21tYTogdHJ1ZSB9LFxyXG4gICAgXCJhbmltYXRpb24tZGlyZWN0aW9uXCIgICAgICAgICAgIDogeyBtdWx0aTogXCJub3JtYWwgfCBhbHRlcm5hdGVcIiwgY29tbWE6IHRydWUgfSxcclxuICAgIFwiYW5pbWF0aW9uLWR1cmF0aW9uXCIgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPHRpbWU+XCIsIGNvbW1hOiB0cnVlIH0sXHJcbiAgICBcImFuaW1hdGlvbi1maWxsLW1vZGVcIiAgICAgICAgICAgOiB7IG11bHRpOiBcIm5vbmUgfCBmb3J3YXJkcyB8IGJhY2t3YXJkcyB8IGJvdGhcIiwgY29tbWE6IHRydWUgfSxcclxuICAgIFwiYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudFwiICAgICA6IHsgbXVsdGk6IFwiPG51bWJlcj4gfCBpbmZpbml0ZVwiLCBjb21tYTogdHJ1ZSB9LFxyXG4gICAgXCJhbmltYXRpb24tbmFtZVwiICAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCJub25lIHwgPGlkZW50PlwiLCBjb21tYTogdHJ1ZSB9LFxyXG4gICAgXCJhbmltYXRpb24tcGxheS1zdGF0ZVwiICAgICAgICAgIDogeyBtdWx0aTogXCJydW5uaW5nIHwgcGF1c2VkXCIsIGNvbW1hOiB0cnVlIH0sXHJcbiAgICBcImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb25cIiAgICAgOiAxLFxyXG5cclxuICAgIC8vdmVuZG9yIHByZWZpeGVkXHJcbiAgICBcIi1tb3otYW5pbWF0aW9uLWRlbGF5XCIgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPHRpbWU+XCIsIGNvbW1hOiB0cnVlIH0sXHJcbiAgICBcIi1tb3otYW5pbWF0aW9uLWRpcmVjdGlvblwiICAgICAgICAgICA6IHsgbXVsdGk6IFwibm9ybWFsIHwgYWx0ZXJuYXRlXCIsIGNvbW1hOiB0cnVlIH0sXHJcbiAgICBcIi1tb3otYW5pbWF0aW9uLWR1cmF0aW9uXCIgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPHRpbWU+XCIsIGNvbW1hOiB0cnVlIH0sXHJcbiAgICBcIi1tb3otYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudFwiICAgICA6IHsgbXVsdGk6IFwiPG51bWJlcj4gfCBpbmZpbml0ZVwiLCBjb21tYTogdHJ1ZSB9LFxyXG4gICAgXCItbW96LWFuaW1hdGlvbi1uYW1lXCIgICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIm5vbmUgfCA8aWRlbnQ+XCIsIGNvbW1hOiB0cnVlIH0sXHJcbiAgICBcIi1tb3otYW5pbWF0aW9uLXBsYXktc3RhdGVcIiAgICAgICAgICA6IHsgbXVsdGk6IFwicnVubmluZyB8IHBhdXNlZFwiLCBjb21tYTogdHJ1ZSB9LFxyXG5cclxuICAgIFwiLW1zLWFuaW1hdGlvbi1kZWxheVwiICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjx0aW1lPlwiLCBjb21tYTogdHJ1ZSB9LFxyXG4gICAgXCItbXMtYW5pbWF0aW9uLWRpcmVjdGlvblwiICAgICAgICAgICA6IHsgbXVsdGk6IFwibm9ybWFsIHwgYWx0ZXJuYXRlXCIsIGNvbW1hOiB0cnVlIH0sXHJcbiAgICBcIi1tcy1hbmltYXRpb24tZHVyYXRpb25cIiAgICAgICAgICAgIDogeyBtdWx0aTogXCI8dGltZT5cIiwgY29tbWE6IHRydWUgfSxcclxuICAgIFwiLW1zLWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnRcIiAgICAgOiB7IG11bHRpOiBcIjxudW1iZXI+IHwgaW5maW5pdGVcIiwgY29tbWE6IHRydWUgfSxcclxuICAgIFwiLW1zLWFuaW1hdGlvbi1uYW1lXCIgICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIm5vbmUgfCA8aWRlbnQ+XCIsIGNvbW1hOiB0cnVlIH0sXHJcbiAgICBcIi1tcy1hbmltYXRpb24tcGxheS1zdGF0ZVwiICAgICAgICAgIDogeyBtdWx0aTogXCJydW5uaW5nIHwgcGF1c2VkXCIsIGNvbW1hOiB0cnVlIH0sXHJcblxyXG4gICAgXCItd2Via2l0LWFuaW1hdGlvbi1kZWxheVwiICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjx0aW1lPlwiLCBjb21tYTogdHJ1ZSB9LFxyXG4gICAgXCItd2Via2l0LWFuaW1hdGlvbi1kaXJlY3Rpb25cIiAgICAgICAgICAgOiB7IG11bHRpOiBcIm5vcm1hbCB8IGFsdGVybmF0ZVwiLCBjb21tYTogdHJ1ZSB9LFxyXG4gICAgXCItd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvblwiICAgICAgICAgICAgOiB7IG11bHRpOiBcIjx0aW1lPlwiLCBjb21tYTogdHJ1ZSB9LFxyXG4gICAgXCItd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGVcIiAgICAgICAgICAgOiB7IG11bHRpOiBcIm5vbmUgfCBmb3J3YXJkcyB8IGJhY2t3YXJkcyB8IGJvdGhcIiwgY29tbWE6IHRydWUgfSxcclxuICAgIFwiLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50XCIgICAgIDogeyBtdWx0aTogXCI8bnVtYmVyPiB8IGluZmluaXRlXCIsIGNvbW1hOiB0cnVlIH0sXHJcbiAgICBcIi13ZWJraXQtYW5pbWF0aW9uLW5hbWVcIiAgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwibm9uZSB8IDxpZGVudD5cIiwgY29tbWE6IHRydWUgfSxcclxuICAgIFwiLXdlYmtpdC1hbmltYXRpb24tcGxheS1zdGF0ZVwiICAgICAgICAgIDogeyBtdWx0aTogXCJydW5uaW5nIHwgcGF1c2VkXCIsIGNvbW1hOiB0cnVlIH0sXHJcblxyXG4gICAgXCItby1hbmltYXRpb24tZGVsYXlcIiAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8dGltZT5cIiwgY29tbWE6IHRydWUgfSxcclxuICAgIFwiLW8tYW5pbWF0aW9uLWRpcmVjdGlvblwiICAgICAgICAgICA6IHsgbXVsdGk6IFwibm9ybWFsIHwgYWx0ZXJuYXRlXCIsIGNvbW1hOiB0cnVlIH0sXHJcbiAgICBcIi1vLWFuaW1hdGlvbi1kdXJhdGlvblwiICAgICAgICAgICAgOiB7IG11bHRpOiBcIjx0aW1lPlwiLCBjb21tYTogdHJ1ZSB9LFxyXG4gICAgXCItby1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50XCIgICAgIDogeyBtdWx0aTogXCI8bnVtYmVyPiB8IGluZmluaXRlXCIsIGNvbW1hOiB0cnVlIH0sXHJcbiAgICBcIi1vLWFuaW1hdGlvbi1uYW1lXCIgICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIm5vbmUgfCA8aWRlbnQ+XCIsIGNvbW1hOiB0cnVlIH0sXHJcbiAgICBcIi1vLWFuaW1hdGlvbi1wbGF5LXN0YXRlXCIgICAgICAgICAgOiB7IG11bHRpOiBcInJ1bm5pbmcgfCBwYXVzZWRcIiwgY29tbWE6IHRydWUgfSxcclxuXHJcbiAgICBcImFwcGVhcmFuY2VcIiAgICAgICAgICAgICAgICAgICAgOiBcImljb24gfCB3aW5kb3cgfCBkZXNrdG9wIHwgd29ya3NwYWNlIHwgZG9jdW1lbnQgfCB0b29sdGlwIHwgZGlhbG9nIHwgYnV0dG9uIHwgcHVzaC1idXR0b24gfCBoeXBlcmxpbmsgfCByYWRpbyB8IHJhZGlvLWJ1dHRvbiB8IGNoZWNrYm94IHwgbWVudS1pdGVtIHwgdGFiIHwgbWVudSB8IG1lbnViYXIgfCBwdWxsLWRvd24tbWVudSB8IHBvcC11cC1tZW51IHwgbGlzdC1tZW51IHwgcmFkaW8tZ3JvdXAgfCBjaGVja2JveC1ncm91cCB8IG91dGxpbmUtdHJlZSB8IHJhbmdlIHwgZmllbGQgfCBjb21iby1ib3ggfCBzaWduYXR1cmUgfCBwYXNzd29yZCB8IG5vcm1hbCB8IG5vbmUgfCBpbmhlcml0XCIsXHJcbiAgICBcImF6aW11dGhcIiAgICAgICAgICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xyXG4gICAgICAgIHZhciBzaW1wbGUgICAgICA9IFwiPGFuZ2xlPiB8IGxlZnR3YXJkcyB8IHJpZ2h0d2FyZHMgfCBpbmhlcml0XCIsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiAgID0gXCJsZWZ0LXNpZGUgfCBmYXItbGVmdCB8IGxlZnQgfCBjZW50ZXItbGVmdCB8IGNlbnRlciB8IGNlbnRlci1yaWdodCB8IHJpZ2h0IHwgZmFyLXJpZ2h0IHwgcmlnaHQtc2lkZVwiLFxyXG4gICAgICAgICAgICBiZWhpbmQgICAgICA9IGZhbHNlLFxyXG4gICAgICAgICAgICB2YWxpZCAgICAgICA9IGZhbHNlLFxyXG4gICAgICAgICAgICBwYXJ0O1xyXG5cclxuICAgICAgICBpZiAoIVZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBzaW1wbGUpKSB7XHJcbiAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgXCJiZWhpbmRcIikpIHtcclxuICAgICAgICAgICAgICAgIGJlaGluZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgZGlyZWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFiZWhpbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgXCJiZWhpbmRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChleHByZXNzaW9uLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIGVuZCBvZiB2YWx1ZSBidXQgZm91bmQgJ1wiICsgcGFydCArIFwiJy5cIiwgcGFydC5saW5lLCBwYXJ0LmNvbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgKDwnYXppbXV0aCc+KSBidXQgZm91bmQgJ1wiICsgcGFydCArIFwiJy5cIiwgcGFydC5saW5lLCBwYXJ0LmNvbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vQlxyXG4gICAgXCJiYWNrZmFjZS12aXNpYmlsaXR5XCIgICAgICAgICAgIDogXCJ2aXNpYmxlIHwgaGlkZGVuXCIsXHJcbiAgICBcImJhY2tncm91bmRcIiAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJiYWNrZ3JvdW5kLWF0dGFjaG1lbnRcIiAgICAgICAgIDogeyBtdWx0aTogXCI8YXR0YWNobWVudD5cIiwgY29tbWE6IHRydWUgfSxcclxuICAgIFwiYmFja2dyb3VuZC1jbGlwXCIgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPGJveD5cIiwgY29tbWE6IHRydWUgfSxcclxuICAgIFwiYmFja2dyb3VuZC1jb2xvclwiICAgICAgICAgICAgICA6IFwiPGNvbG9yPiB8IGluaGVyaXRcIixcclxuICAgIFwiYmFja2dyb3VuZC1pbWFnZVwiICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPGJnLWltYWdlPlwiLCBjb21tYTogdHJ1ZSB9LFxyXG4gICAgXCJiYWNrZ3JvdW5kLW9yaWdpblwiICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8Ym94PlwiLCBjb21tYTogdHJ1ZSB9LFxyXG4gICAgXCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIgICAgICAgICAgIDogeyBtdWx0aTogXCI8YmctcG9zaXRpb24+XCIsIGNvbW1hOiB0cnVlIH0sXHJcbiAgICBcImJhY2tncm91bmQtcmVwZWF0XCIgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjxyZXBlYXQtc3R5bGU+XCIgfSxcclxuICAgIFwiYmFja2dyb3VuZC1zaXplXCIgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPGJnLXNpemU+XCIsIGNvbW1hOiB0cnVlIH0sXHJcbiAgICBcImJhc2VsaW5lLXNoaWZ0XCIgICAgICAgICAgICAgICAgOiBcImJhc2VsaW5lIHwgc3ViIHwgc3VwZXIgfCA8cGVyY2VudGFnZT4gfCA8bGVuZ3RoPlwiLFxyXG4gICAgXCJiZWhhdmlvclwiICAgICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwiYmluZGluZ1wiICAgICAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcImJsZWVkXCIgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjxsZW5ndGg+XCIsXHJcbiAgICBcImJvb2ttYXJrLWxhYmVsXCIgICAgICAgICAgICAgICAgOiBcIjxjb250ZW50PiB8IDxhdHRyPiB8IDxzdHJpbmc+XCIsXHJcbiAgICBcImJvb2ttYXJrLWxldmVsXCIgICAgICAgICAgICAgICAgOiBcIm5vbmUgfCA8aW50ZWdlcj5cIixcclxuICAgIFwiYm9va21hcmstc3RhdGVcIiAgICAgICAgICAgICAgICA6IFwib3BlbiB8IGNsb3NlZFwiLFxyXG4gICAgXCJib29rbWFyay10YXJnZXRcIiAgICAgICAgICAgICAgIDogXCJub25lIHwgPHVyaT4gfCA8YXR0cj5cIixcclxuICAgIFwiYm9yZGVyXCIgICAgICAgICAgICAgICAgICAgICAgICA6IFwiPGJvcmRlci13aWR0aD4gfHwgPGJvcmRlci1zdHlsZT4gfHwgPGNvbG9yPlwiLFxyXG4gICAgXCJib3JkZXItYm90dG9tXCIgICAgICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXdpZHRoPiB8fCA8Ym9yZGVyLXN0eWxlPiB8fCA8Y29sb3I+XCIsXHJcbiAgICBcImJvcmRlci1ib3R0b20tY29sb3JcIiAgICAgICAgICAgOiBcIjxjb2xvcj4gfCBpbmhlcml0XCIsXHJcbiAgICBcImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIiAgICAgOiAgXCI8eC1vbmUtcmFkaXVzPlwiLFxyXG4gICAgXCJib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1c1wiICAgIDogIFwiPHgtb25lLXJhZGl1cz5cIixcclxuICAgIFwiYm9yZGVyLWJvdHRvbS1zdHlsZVwiICAgICAgICAgICA6IFwiPGJvcmRlci1zdHlsZT5cIixcclxuICAgIFwiYm9yZGVyLWJvdHRvbS13aWR0aFwiICAgICAgICAgICA6IFwiPGJvcmRlci13aWR0aD5cIixcclxuICAgIFwiYm9yZGVyLWNvbGxhcHNlXCIgICAgICAgICAgICAgICA6IFwiY29sbGFwc2UgfCBzZXBhcmF0ZSB8IGluaGVyaXRcIixcclxuICAgIFwiYm9yZGVyLWNvbG9yXCIgICAgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPGNvbG9yPiB8IGluaGVyaXRcIiwgbWF4OiA0IH0sXHJcbiAgICBcImJvcmRlci1pbWFnZVwiICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJib3JkZXItaW1hZ2Utb3V0c2V0XCIgICAgICAgICAgIDogeyBtdWx0aTogXCI8bGVuZ3RoPiB8IDxudW1iZXI+XCIsIG1heDogNCB9LFxyXG4gICAgXCJib3JkZXItaW1hZ2UtcmVwZWF0XCIgICAgICAgICAgIDogeyBtdWx0aTogXCJzdHJldGNoIHwgcmVwZWF0IHwgcm91bmRcIiwgbWF4OiAyIH0sXHJcbiAgICBcImJvcmRlci1pbWFnZS1zbGljZVwiICAgICAgICAgICAgOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XHJcblxyXG4gICAgICAgIHZhciB2YWxpZCAgID0gZmFsc2UsXHJcbiAgICAgICAgICAgIG51bWVyaWMgPSBcIjxudW1iZXI+IHwgPHBlcmNlbnRhZ2U+XCIsXHJcbiAgICAgICAgICAgIGZpbGwgICAgPSBmYWxzZSxcclxuICAgICAgICAgICAgY291bnQgICA9IDAsXHJcbiAgICAgICAgICAgIG1heCAgICAgPSA0LFxyXG4gICAgICAgICAgICBwYXJ0O1xyXG5cclxuICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIFwiZmlsbFwiKSkge1xyXG4gICAgICAgICAgICBmaWxsID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hpbGUgKGV4cHJlc3Npb24uaGFzTmV4dCgpICYmIGNvdW50IDwgbWF4KSB7XHJcbiAgICAgICAgICAgIHZhbGlkID0gVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIG51bWVyaWMpO1xyXG4gICAgICAgICAgICBpZiAoIXZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGlmICghZmlsbCkge1xyXG4gICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgXCJmaWxsXCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChleHByZXNzaW9uLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIGVuZCBvZiB2YWx1ZSBidXQgZm91bmQgJ1wiICsgcGFydCArIFwiJy5cIiwgcGFydC5saW5lLCBwYXJ0LmNvbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgKFs8bnVtYmVyPiB8IDxwZXJjZW50YWdlPl17MSw0fSAmJiBmaWxsPykgYnV0IGZvdW5kICdcIiArIHBhcnQgKyBcIicuXCIsIHBhcnQubGluZSwgcGFydC5jb2wpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFwiYm9yZGVyLWltYWdlLXNvdXJjZVwiICAgICAgICAgICA6IFwiPGltYWdlPiB8IG5vbmVcIixcclxuICAgIFwiYm9yZGVyLWltYWdlLXdpZHRoXCIgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gfCA8bnVtYmVyPiB8IGF1dG9cIiwgbWF4OiA0IH0sXHJcbiAgICBcImJvcmRlci1sZWZ0XCIgICAgICAgICAgICAgICAgICAgOiBcIjxib3JkZXItd2lkdGg+IHx8IDxib3JkZXItc3R5bGU+IHx8IDxjb2xvcj5cIixcclxuICAgIFwiYm9yZGVyLWxlZnQtY29sb3JcIiAgICAgICAgICAgICA6IFwiPGNvbG9yPiB8IGluaGVyaXRcIixcclxuICAgIFwiYm9yZGVyLWxlZnQtc3R5bGVcIiAgICAgICAgICAgICA6IFwiPGJvcmRlci1zdHlsZT5cIixcclxuICAgIFwiYm9yZGVyLWxlZnQtd2lkdGhcIiAgICAgICAgICAgICA6IFwiPGJvcmRlci13aWR0aD5cIixcclxuICAgIFwiYm9yZGVyLXJhZGl1c1wiICAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcclxuXHJcbiAgICAgICAgdmFyIHZhbGlkICAgPSBmYWxzZSxcclxuICAgICAgICAgICAgc2ltcGxlID0gXCI8bGVuZ3RoPiB8IDxwZXJjZW50YWdlPiB8IGluaGVyaXRcIixcclxuICAgICAgICAgICAgc2xhc2ggICA9IGZhbHNlLFxyXG4gICAgICAgICAgICBjb3VudCAgID0gMCxcclxuICAgICAgICAgICAgbWF4ICAgICA9IDgsXHJcbiAgICAgICAgICAgIHBhcnQ7XHJcblxyXG4gICAgICAgIHdoaWxlIChleHByZXNzaW9uLmhhc05leHQoKSAmJiBjb3VudCA8IG1heCkge1xyXG4gICAgICAgICAgICB2YWxpZCA9IFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBzaW1wbGUpO1xyXG4gICAgICAgICAgICBpZiAoIXZhbGlkKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKFN0cmluZyhleHByZXNzaW9uLnBlZWsoKSkgPT09IFwiL1wiICYmIGNvdW50ID4gMCAmJiAhc2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBzbGFzaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY291bnQgKyA1O1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGV4cHJlc3Npb24uaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgIHBhcnQgPSBleHByZXNzaW9uLm5leHQoKTtcclxuICAgICAgICAgICAgaWYgKHZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgZW5kIG9mIHZhbHVlIGJ1dCBmb3VuZCAnXCIgKyBwYXJ0ICsgXCInLlwiLCBwYXJ0LmxpbmUsIHBhcnQuY29sKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJFeHBlY3RlZCAoPCdib3JkZXItcmFkaXVzJz4pIGJ1dCBmb3VuZCAnXCIgKyBwYXJ0ICsgXCInLlwiLCBwYXJ0LmxpbmUsIHBhcnQuY29sKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcImJvcmRlci1yaWdodFwiICAgICAgICAgICAgICAgICAgOiBcIjxib3JkZXItd2lkdGg+IHx8IDxib3JkZXItc3R5bGU+IHx8IDxjb2xvcj5cIixcclxuICAgIFwiYm9yZGVyLXJpZ2h0LWNvbG9yXCIgICAgICAgICAgICA6IFwiPGNvbG9yPiB8IGluaGVyaXRcIixcclxuICAgIFwiYm9yZGVyLXJpZ2h0LXN0eWxlXCIgICAgICAgICAgICA6IFwiPGJvcmRlci1zdHlsZT5cIixcclxuICAgIFwiYm9yZGVyLXJpZ2h0LXdpZHRoXCIgICAgICAgICAgICA6IFwiPGJvcmRlci13aWR0aD5cIixcclxuICAgIFwiYm9yZGVyLXNwYWNpbmdcIiAgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPGxlbmd0aD4gfCBpbmhlcml0XCIsIG1heDogMiB9LFxyXG4gICAgXCJib3JkZXItc3R5bGVcIiAgICAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8Ym9yZGVyLXN0eWxlPlwiLCBtYXg6IDQgfSxcclxuICAgIFwiYm9yZGVyLXRvcFwiICAgICAgICAgICAgICAgICAgICA6IFwiPGJvcmRlci13aWR0aD4gfHwgPGJvcmRlci1zdHlsZT4gfHwgPGNvbG9yPlwiLFxyXG4gICAgXCJib3JkZXItdG9wLWNvbG9yXCIgICAgICAgICAgICAgIDogXCI8Y29sb3I+IHwgaW5oZXJpdFwiLFxyXG4gICAgXCJib3JkZXItdG9wLWxlZnQtcmFkaXVzXCIgICAgICAgIDogXCI8eC1vbmUtcmFkaXVzPlwiLFxyXG4gICAgXCJib3JkZXItdG9wLXJpZ2h0LXJhZGl1c1wiICAgICAgIDogXCI8eC1vbmUtcmFkaXVzPlwiLFxyXG4gICAgXCJib3JkZXItdG9wLXN0eWxlXCIgICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXN0eWxlPlwiLFxyXG4gICAgXCJib3JkZXItdG9wLXdpZHRoXCIgICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXdpZHRoPlwiLFxyXG4gICAgXCJib3JkZXItd2lkdGhcIiAgICAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8Ym9yZGVyLXdpZHRoPlwiLCBtYXg6IDQgfSxcclxuICAgIFwiYm90dG9tXCIgICAgICAgICAgICAgICAgICAgICAgICA6IFwiPG1hcmdpbi13aWR0aD4gfCBpbmhlcml0XCIsXHJcbiAgICBcIi1tb3otYm94LWFsaWduXCIgICAgICAgICAgICAgICAgOiBcInN0YXJ0IHwgZW5kIHwgY2VudGVyIHwgYmFzZWxpbmUgfCBzdHJldGNoXCIsXHJcbiAgICBcIi1tb3otYm94LWRlY29yYXRpb24tYnJlYWtcIiAgICAgOiBcInNsaWNlIHxjbG9uZVwiLFxyXG4gICAgXCItbW96LWJveC1kaXJlY3Rpb25cIiAgICAgICAgICAgIDogXCJub3JtYWwgfCByZXZlcnNlIHwgaW5oZXJpdFwiLFxyXG4gICAgXCItbW96LWJveC1mbGV4XCIgICAgICAgICAgICAgICAgIDogXCI8bnVtYmVyPlwiLFxyXG4gICAgXCItbW96LWJveC1mbGV4LWdyb3VwXCIgICAgICAgICAgIDogXCI8aW50ZWdlcj5cIixcclxuICAgIFwiLW1vei1ib3gtbGluZXNcIiAgICAgICAgICAgICAgICA6IFwic2luZ2xlIHwgbXVsdGlwbGVcIixcclxuICAgIFwiLW1vei1ib3gtb3JkaW5hbC1ncm91cFwiICAgICAgICA6IFwiPGludGVnZXI+XCIsXHJcbiAgICBcIi1tb3otYm94LW9yaWVudFwiICAgICAgICAgICAgICAgOiBcImhvcml6b250YWwgfCB2ZXJ0aWNhbCB8IGlubGluZS1heGlzIHwgYmxvY2stYXhpcyB8IGluaGVyaXRcIixcclxuICAgIFwiLW1vei1ib3gtcGFja1wiICAgICAgICAgICAgICAgICA6IFwic3RhcnQgfCBlbmQgfCBjZW50ZXIgfCBqdXN0aWZ5XCIsXHJcbiAgICBcIi1vLWJveC1kZWNvcmF0aW9uLWJyZWFrXCIgICAgICAgOiBcInNsaWNlIHwgY2xvbmVcIixcclxuICAgIFwiLXdlYmtpdC1ib3gtYWxpZ25cIiAgICAgICAgICAgICA6IFwic3RhcnQgfCBlbmQgfCBjZW50ZXIgfCBiYXNlbGluZSB8IHN0cmV0Y2hcIixcclxuICAgIFwiLXdlYmtpdC1ib3gtZGVjb3JhdGlvbi1icmVha1wiICA6IFwic2xpY2UgfGNsb25lXCIsXHJcbiAgICBcIi13ZWJraXQtYm94LWRpcmVjdGlvblwiICAgICAgICAgOiBcIm5vcm1hbCB8IHJldmVyc2UgfCBpbmhlcml0XCIsXHJcbiAgICBcIi13ZWJraXQtYm94LWZsZXhcIiAgICAgICAgICAgICAgOiBcIjxudW1iZXI+XCIsXHJcbiAgICBcIi13ZWJraXQtYm94LWZsZXgtZ3JvdXBcIiAgICAgICAgOiBcIjxpbnRlZ2VyPlwiLFxyXG4gICAgXCItd2Via2l0LWJveC1saW5lc1wiICAgICAgICAgICAgIDogXCJzaW5nbGUgfCBtdWx0aXBsZVwiLFxyXG4gICAgXCItd2Via2l0LWJveC1vcmRpbmFsLWdyb3VwXCIgICAgIDogXCI8aW50ZWdlcj5cIixcclxuICAgIFwiLXdlYmtpdC1ib3gtb3JpZW50XCIgICAgICAgICAgICA6IFwiaG9yaXpvbnRhbCB8IHZlcnRpY2FsIHwgaW5saW5lLWF4aXMgfCBibG9jay1heGlzIHwgaW5oZXJpdFwiLFxyXG4gICAgXCItd2Via2l0LWJveC1wYWNrXCIgICAgICAgICAgICAgIDogXCJzdGFydCB8IGVuZCB8IGNlbnRlciB8IGp1c3RpZnlcIixcclxuICAgIFwiYm94LWRlY29yYXRpb24tYnJlYWtcIiAgICAgICAgICA6IFwic2xpY2UgfCBjbG9uZVwiLFxyXG4gICAgXCJib3gtc2hhZG93XCIgICAgICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcclxuICAgICAgICB2YXIgcGFydDtcclxuXHJcbiAgICAgICAgaWYgKCFWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgXCJub25lXCIpKSB7XHJcbiAgICAgICAgICAgIFZhbGlkYXRpb24ubXVsdGlQcm9wZXJ0eShcIjxzaGFkb3c+XCIsIGV4cHJlc3Npb24sIHRydWUsIEluZmluaXR5KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHBhcnQgPSBleHByZXNzaW9uLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJFeHBlY3RlZCBlbmQgb2YgdmFsdWUgYnV0IGZvdW5kICdcIiArIHBhcnQgKyBcIicuXCIsIHBhcnQubGluZSwgcGFydC5jb2wpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFwiYm94LXNpemluZ1wiICAgICAgICAgICAgICAgICAgICA6IFwiY29udGVudC1ib3ggfCBib3JkZXItYm94IHwgaW5oZXJpdFwiLFxyXG4gICAgXCJicmVhay1hZnRlclwiICAgICAgICAgICAgICAgICAgIDogXCJhdXRvIHwgYWx3YXlzIHwgYXZvaWQgfCBsZWZ0IHwgcmlnaHQgfCBwYWdlIHwgY29sdW1uIHwgYXZvaWQtcGFnZSB8IGF2b2lkLWNvbHVtblwiLFxyXG4gICAgXCJicmVhay1iZWZvcmVcIiAgICAgICAgICAgICAgICAgIDogXCJhdXRvIHwgYWx3YXlzIHwgYXZvaWQgfCBsZWZ0IHwgcmlnaHQgfCBwYWdlIHwgY29sdW1uIHwgYXZvaWQtcGFnZSB8IGF2b2lkLWNvbHVtblwiLFxyXG4gICAgXCJicmVhay1pbnNpZGVcIiAgICAgICAgICAgICAgICAgIDogXCJhdXRvIHwgYXZvaWQgfCBhdm9pZC1wYWdlIHwgYXZvaWQtY29sdW1uXCIsXHJcblxyXG4gICAgLy9DXHJcbiAgICBcImNhcHRpb24tc2lkZVwiICAgICAgICAgICAgICAgICAgOiBcInRvcCB8IGJvdHRvbSB8IGluaGVyaXRcIixcclxuICAgIFwiY2xlYXJcIiAgICAgICAgICAgICAgICAgICAgICAgICA6IFwibm9uZSB8IHJpZ2h0IHwgbGVmdCB8IGJvdGggfCBpbmhlcml0XCIsXHJcbiAgICBcImNsaXBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJjb2xvclwiICAgICAgICAgICAgICAgICAgICAgICAgIDogXCI8Y29sb3I+IHwgaW5oZXJpdFwiLFxyXG4gICAgXCJjb2xvci1wcm9maWxlXCIgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwiY29sdW1uLWNvdW50XCIgICAgICAgICAgICAgICAgICA6IFwiPGludGVnZXI+IHwgYXV0b1wiLCAgICAgICAgICAgICAgICAgICAgICAvL2h0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtbXVsdGljb2wvXHJcbiAgICBcImNvbHVtbi1maWxsXCIgICAgICAgICAgICAgICAgICAgOiBcImF1dG8gfCBiYWxhbmNlXCIsXHJcbiAgICBcImNvbHVtbi1nYXBcIiAgICAgICAgICAgICAgICAgICAgOiBcIjxsZW5ndGg+IHwgbm9ybWFsXCIsXHJcbiAgICBcImNvbHVtbi1ydWxlXCIgICAgICAgICAgICAgICAgICAgOiBcIjxib3JkZXItd2lkdGg+IHx8IDxib3JkZXItc3R5bGU+IHx8IDxjb2xvcj5cIixcclxuICAgIFwiY29sdW1uLXJ1bGUtY29sb3JcIiAgICAgICAgICAgICA6IFwiPGNvbG9yPlwiLFxyXG4gICAgXCJjb2x1bW4tcnVsZS1zdHlsZVwiICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXN0eWxlPlwiLFxyXG4gICAgXCJjb2x1bW4tcnVsZS13aWR0aFwiICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXdpZHRoPlwiLFxyXG4gICAgXCJjb2x1bW4tc3BhblwiICAgICAgICAgICAgICAgICAgIDogXCJub25lIHwgYWxsXCIsXHJcbiAgICBcImNvbHVtbi13aWR0aFwiICAgICAgICAgICAgICAgICAgOiBcIjxsZW5ndGg+IHwgYXV0b1wiLFxyXG4gICAgXCJjb2x1bW5zXCIgICAgICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwiY29udGVudFwiICAgICAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcImNvdW50ZXItaW5jcmVtZW50XCIgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJjb3VudGVyLXJlc2V0XCIgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwiY3JvcFwiICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiPHNoYXBlPiB8IGF1dG9cIixcclxuICAgIFwiY3VlXCIgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiY3VlLWFmdGVyIHwgY3VlLWJlZm9yZSB8IGluaGVyaXRcIixcclxuICAgIFwiY3VlLWFmdGVyXCIgICAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcImN1ZS1iZWZvcmVcIiAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJjdXJzb3JcIiAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcclxuXHJcbiAgICAvL0RcclxuICAgIFwiZGlyZWN0aW9uXCIgICAgICAgICAgICAgICAgICAgICA6IFwibHRyIHwgcnRsIHwgaW5oZXJpdFwiLFxyXG4gICAgXCJkaXNwbGF5XCIgICAgICAgICAgICAgICAgICAgICAgIDogXCJpbmxpbmUgfCBibG9jayB8IGxpc3QtaXRlbSB8IGlubGluZS1ibG9jayB8IHRhYmxlIHwgaW5saW5lLXRhYmxlIHwgdGFibGUtcm93LWdyb3VwIHwgdGFibGUtaGVhZGVyLWdyb3VwIHwgdGFibGUtZm9vdGVyLWdyb3VwIHwgdGFibGUtcm93IHwgdGFibGUtY29sdW1uLWdyb3VwIHwgdGFibGUtY29sdW1uIHwgdGFibGUtY2VsbCB8IHRhYmxlLWNhcHRpb24gfCBncmlkIHwgaW5saW5lLWdyaWQgfCBydW4taW4gfCBydWJ5IHwgcnVieS1iYXNlIHwgcnVieS10ZXh0IHwgcnVieS1iYXNlLWNvbnRhaW5lciB8IHJ1YnktdGV4dC1jb250YWluZXIgfCBjb250ZW50cyB8IG5vbmUgfCBpbmhlcml0IHwgLW1vei1ib3ggfCAtbW96LWlubGluZS1ibG9jayB8IC1tb3otaW5saW5lLWJveCB8IC1tb3otaW5saW5lLWdyaWQgfCAtbW96LWlubGluZS1zdGFjayB8IC1tb3otaW5saW5lLXRhYmxlIHwgLW1vei1ncmlkIHwgLW1vei1ncmlkLWdyb3VwIHwgLW1vei1ncmlkLWxpbmUgfCAtbW96LWdyb3VwYm94IHwgLW1vei1kZWNrIHwgLW1vei1wb3B1cCB8IC1tb3otc3RhY2sgfCAtbW96LW1hcmtlciB8IC13ZWJraXQtYm94IHwgLXdlYmtpdC1pbmxpbmUtYm94IHwgLW1zLWZsZXhib3ggfCAtbXMtaW5saW5lLWZsZXhib3ggfCBmbGV4IHwgLXdlYmtpdC1mbGV4IHwgaW5saW5lLWZsZXggfCAtd2Via2l0LWlubGluZS1mbGV4XCIsXHJcbiAgICBcImRvbWluYW50LWJhc2VsaW5lXCIgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJkcm9wLWluaXRpYWwtYWZ0ZXItYWRqdXN0XCIgICAgIDogXCJjZW50cmFsIHwgbWlkZGxlIHwgYWZ0ZXItZWRnZSB8IHRleHQtYWZ0ZXItZWRnZSB8IGlkZW9ncmFwaGljIHwgYWxwaGFiZXRpYyB8IG1hdGhlbWF0aWNhbCB8IDxwZXJjZW50YWdlPiB8IDxsZW5ndGg+XCIsXHJcbiAgICBcImRyb3AtaW5pdGlhbC1hZnRlci1hbGlnblwiICAgICAgOiBcImJhc2VsaW5lIHwgdXNlLXNjcmlwdCB8IGJlZm9yZS1lZGdlIHwgdGV4dC1iZWZvcmUtZWRnZSB8IGFmdGVyLWVkZ2UgfCB0ZXh0LWFmdGVyLWVkZ2UgfCBjZW50cmFsIHwgbWlkZGxlIHwgaWRlb2dyYXBoaWMgfCBhbHBoYWJldGljIHwgaGFuZ2luZyB8IG1hdGhlbWF0aWNhbFwiLFxyXG4gICAgXCJkcm9wLWluaXRpYWwtYmVmb3JlLWFkanVzdFwiICAgIDogXCJiZWZvcmUtZWRnZSB8IHRleHQtYmVmb3JlLWVkZ2UgfCBjZW50cmFsIHwgbWlkZGxlIHwgaGFuZ2luZyB8IG1hdGhlbWF0aWNhbCB8IDxwZXJjZW50YWdlPiB8IDxsZW5ndGg+XCIsXHJcbiAgICBcImRyb3AtaW5pdGlhbC1iZWZvcmUtYWxpZ25cIiAgICAgOiBcImNhcHMtaGVpZ2h0IHwgYmFzZWxpbmUgfCB1c2Utc2NyaXB0IHwgYmVmb3JlLWVkZ2UgfCB0ZXh0LWJlZm9yZS1lZGdlIHwgYWZ0ZXItZWRnZSB8IHRleHQtYWZ0ZXItZWRnZSB8IGNlbnRyYWwgfCBtaWRkbGUgfCBpZGVvZ3JhcGhpYyB8IGFscGhhYmV0aWMgfCBoYW5naW5nIHwgbWF0aGVtYXRpY2FsXCIsXHJcbiAgICBcImRyb3AtaW5pdGlhbC1zaXplXCIgICAgICAgICAgICAgOiBcImF1dG8gfCBsaW5lIHwgPGxlbmd0aD4gfCA8cGVyY2VudGFnZT5cIixcclxuICAgIFwiZHJvcC1pbml0aWFsLXZhbHVlXCIgICAgICAgICAgICA6IFwiaW5pdGlhbCB8IDxpbnRlZ2VyPlwiLFxyXG5cclxuICAgIC8vRVxyXG4gICAgXCJlbGV2YXRpb25cIiAgICAgICAgICAgICAgICAgICAgIDogXCI8YW5nbGU+IHwgYmVsb3cgfCBsZXZlbCB8IGFib3ZlIHwgaGlnaGVyIHwgbG93ZXIgfCBpbmhlcml0XCIsXHJcbiAgICBcImVtcHR5LWNlbGxzXCIgICAgICAgICAgICAgICAgICAgOiBcInNob3cgfCBoaWRlIHwgaW5oZXJpdFwiLFxyXG5cclxuICAgIC8vRlxyXG4gICAgXCJmaWx0ZXJcIiAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwiZml0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiZmlsbCB8IGhpZGRlbiB8IG1lZXQgfCBzbGljZVwiLFxyXG4gICAgXCJmaXQtcG9zaXRpb25cIiAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwiZmxleFwiICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiPGZsZXg+XCIsXHJcbiAgICBcImZsZXgtYmFzaXNcIiAgICAgICAgICAgICAgICAgICAgOiBcIjx3aWR0aD5cIixcclxuICAgIFwiZmxleC1kaXJlY3Rpb25cIiAgICAgICAgICAgICAgICA6IFwicm93IHwgcm93LXJldmVyc2UgfCBjb2x1bW4gfCBjb2x1bW4tcmV2ZXJzZVwiLFxyXG4gICAgXCJmbGV4LWZsb3dcIiAgICAgICAgICAgICAgICAgICAgIDogXCI8ZmxleC1kaXJlY3Rpb24+IHx8IDxmbGV4LXdyYXA+XCIsXHJcbiAgICBcImZsZXgtZ3Jvd1wiICAgICAgICAgICAgICAgICAgICAgOiBcIjxudW1iZXI+XCIsXHJcbiAgICBcImZsZXgtc2hyaW5rXCIgICAgICAgICAgICAgICAgICAgOiBcIjxudW1iZXI+XCIsXHJcbiAgICBcImZsZXgtd3JhcFwiICAgICAgICAgICAgICAgICAgICAgOiBcIm5vd3JhcCB8IHdyYXAgfCB3cmFwLXJldmVyc2VcIixcclxuICAgIFwiLXdlYmtpdC1mbGV4XCIgICAgICAgICAgICAgICAgICA6IFwiPGZsZXg+XCIsXHJcbiAgICBcIi13ZWJraXQtZmxleC1iYXNpc1wiICAgICAgICAgICAgOiBcIjx3aWR0aD5cIixcclxuICAgIFwiLXdlYmtpdC1mbGV4LWRpcmVjdGlvblwiICAgICAgICA6IFwicm93IHwgcm93LXJldmVyc2UgfCBjb2x1bW4gfCBjb2x1bW4tcmV2ZXJzZVwiLFxyXG4gICAgXCItd2Via2l0LWZsZXgtZmxvd1wiICAgICAgICAgICAgIDogXCI8ZmxleC1kaXJlY3Rpb24+IHx8IDxmbGV4LXdyYXA+XCIsXHJcbiAgICBcIi13ZWJraXQtZmxleC1ncm93XCIgICAgICAgICAgICAgOiBcIjxudW1iZXI+XCIsXHJcbiAgICBcIi13ZWJraXQtZmxleC1zaHJpbmtcIiAgICAgICAgICAgOiBcIjxudW1iZXI+XCIsXHJcbiAgICBcIi13ZWJraXQtZmxleC13cmFwXCIgICAgICAgICAgICAgOiBcIm5vd3JhcCB8IHdyYXAgfCB3cmFwLXJldmVyc2VcIixcclxuICAgIFwiLW1zLWZsZXhcIiAgICAgICAgICAgICAgICAgICAgICA6IFwiPGZsZXg+XCIsXHJcbiAgICBcIi1tcy1mbGV4LWFsaWduXCIgICAgICAgICAgICAgICAgOiBcInN0YXJ0IHwgZW5kIHwgY2VudGVyIHwgc3RyZXRjaCB8IGJhc2VsaW5lXCIsXHJcbiAgICBcIi1tcy1mbGV4LWRpcmVjdGlvblwiICAgICAgICAgICAgOiBcInJvdyB8IHJvdy1yZXZlcnNlIHwgY29sdW1uIHwgY29sdW1uLXJldmVyc2UgfCBpbmhlcml0XCIsXHJcbiAgICBcIi1tcy1mbGV4LW9yZGVyXCIgICAgICAgICAgICAgICAgOiBcIjxudW1iZXI+XCIsXHJcbiAgICBcIi1tcy1mbGV4LXBhY2tcIiAgICAgICAgICAgICAgICAgOiBcInN0YXJ0IHwgZW5kIHwgY2VudGVyIHwganVzdGlmeVwiLFxyXG4gICAgXCItbXMtZmxleC13cmFwXCIgICAgICAgICAgICAgICAgIDogXCJub3dyYXAgfCB3cmFwIHwgd3JhcC1yZXZlcnNlXCIsXHJcbiAgICBcImZsb2F0XCIgICAgICAgICAgICAgICAgICAgICAgICAgOiBcImxlZnQgfCByaWdodCB8IG5vbmUgfCBpbmhlcml0XCIsXHJcbiAgICBcImZsb2F0LW9mZnNldFwiICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJmb250XCIgICAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwiZm9udC1mYW1pbHlcIiAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcImZvbnQtZmVhdHVyZS1zZXR0aW5nc1wiICAgICAgICAgOiBcIjxmZWF0dXJlLXRhZy12YWx1ZT4gfCBub3JtYWwgfCBpbmhlcml0XCIsXHJcbiAgICBcImZvbnQta2VybmluZ1wiICAgICAgICAgICAgICAgICAgOiBcImF1dG8gfCBub3JtYWwgfCBub25lIHwgaW5pdGlhbCB8IGluaGVyaXQgfCB1bnNldFwiLFxyXG4gICAgXCJmb250LXNpemVcIiAgICAgICAgICAgICAgICAgICAgIDogXCI8YWJzb2x1dGUtc2l6ZT4gfCA8cmVsYXRpdmUtc2l6ZT4gfCA8bGVuZ3RoPiB8IDxwZXJjZW50YWdlPiB8IGluaGVyaXRcIixcclxuICAgIFwiZm9udC1zaXplLWFkanVzdFwiICAgICAgICAgICAgICA6IFwiPG51bWJlcj4gfCBub25lIHwgaW5oZXJpdFwiLFxyXG4gICAgXCJmb250LXN0cmV0Y2hcIiAgICAgICAgICAgICAgICAgIDogXCJub3JtYWwgfCB1bHRyYS1jb25kZW5zZWQgfCBleHRyYS1jb25kZW5zZWQgfCBjb25kZW5zZWQgfCBzZW1pLWNvbmRlbnNlZCB8IHNlbWktZXhwYW5kZWQgfCBleHBhbmRlZCB8IGV4dHJhLWV4cGFuZGVkIHwgdWx0cmEtZXhwYW5kZWQgfCBpbmhlcml0XCIsXHJcbiAgICBcImZvbnQtc3R5bGVcIiAgICAgICAgICAgICAgICAgICAgOiBcIm5vcm1hbCB8IGl0YWxpYyB8IG9ibGlxdWUgfCBpbmhlcml0XCIsXHJcbiAgICBcImZvbnQtdmFyaWFudFwiICAgICAgICAgICAgICAgICAgOiBcIm5vcm1hbCB8IHNtYWxsLWNhcHMgfCBpbmhlcml0XCIsXHJcbiAgICBcImZvbnQtdmFyaWFudC1jYXBzXCIgICAgICAgICAgICAgOiBcIm5vcm1hbCB8IHNtYWxsLWNhcHMgfCBhbGwtc21hbGwtY2FwcyB8IHBldGl0ZS1jYXBzIHwgYWxsLXBldGl0ZS1jYXBzIHwgdW5pY2FzZSB8IHRpdGxpbmctY2Fwc1wiLFxyXG4gICAgXCJmb250LXZhcmlhbnQtcG9zaXRpb25cIiAgICAgICAgIDogXCJub3JtYWwgfCBzdWIgfCBzdXBlciB8IGluaGVyaXQgfCBpbml0aWFsIHwgdW5zZXRcIixcclxuICAgIFwiZm9udC13ZWlnaHRcIiAgICAgICAgICAgICAgICAgICA6IFwibm9ybWFsIHwgYm9sZCB8IGJvbGRlciB8IGxpZ2h0ZXIgfCAxMDAgfCAyMDAgfCAzMDAgfCA0MDAgfCA1MDAgfCA2MDAgfCA3MDAgfCA4MDAgfCA5MDAgfCBpbmhlcml0XCIsXHJcblxyXG4gICAgLy9HXHJcbiAgICBcImdyaWRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJncmlkLWFyZWFcIiAgICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwiZ3JpZC1hdXRvLWNvbHVtbnNcIiAgICAgICAgICAgICA6IDEsXHJcbiAgICBcImdyaWQtYXV0by1mbG93XCIgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJncmlkLWF1dG8tcG9zaXRpb25cIiAgICAgICAgICAgIDogMSxcclxuICAgIFwiZ3JpZC1hdXRvLXJvd3NcIiAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcImdyaWQtY2VsbC1zdGFja2luZ1wiICAgICAgICAgICAgOiBcImNvbHVtbnMgfCByb3dzIHwgbGF5ZXJcIixcclxuICAgIFwiZ3JpZC1jb2x1bW5cIiAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcImdyaWQtY29sdW1uc1wiICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJncmlkLWNvbHVtbi1hbGlnblwiICAgICAgICAgICAgIDogXCJzdGFydCB8IGVuZCB8IGNlbnRlciB8IHN0cmV0Y2hcIixcclxuICAgIFwiZ3JpZC1jb2x1bW4tc2l6aW5nXCIgICAgICAgICAgICA6IDEsXHJcbiAgICBcImdyaWQtY29sdW1uLXN0YXJ0XCIgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJncmlkLWNvbHVtbi1lbmRcIiAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwiZ3JpZC1jb2x1bW4tc3BhblwiICAgICAgICAgICAgICA6IFwiPGludGVnZXI+XCIsXHJcbiAgICBcImdyaWQtZmxvd1wiICAgICAgICAgICAgICAgICAgICAgOiBcIm5vbmUgfCByb3dzIHwgY29sdW1uc1wiLFxyXG4gICAgXCJncmlkLWxheWVyXCIgICAgICAgICAgICAgICAgICAgIDogXCI8aW50ZWdlcj5cIixcclxuICAgIFwiZ3JpZC1yb3dcIiAgICAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcImdyaWQtcm93c1wiICAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJncmlkLXJvdy1hbGlnblwiICAgICAgICAgICAgICAgIDogXCJzdGFydCB8IGVuZCB8IGNlbnRlciB8IHN0cmV0Y2hcIixcclxuICAgIFwiZ3JpZC1yb3ctc3RhcnRcIiAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcImdyaWQtcm93LWVuZFwiICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJncmlkLXJvdy1zcGFuXCIgICAgICAgICAgICAgICAgIDogXCI8aW50ZWdlcj5cIixcclxuICAgIFwiZ3JpZC1yb3ctc2l6aW5nXCIgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcImdyaWQtdGVtcGxhdGVcIiAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJncmlkLXRlbXBsYXRlLWFyZWFzXCIgICAgICAgICAgIDogMSxcclxuICAgIFwiZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zXCIgICAgICAgICA6IDEsXHJcbiAgICBcImdyaWQtdGVtcGxhdGUtcm93c1wiICAgICAgICAgICAgOiAxLFxyXG5cclxuICAgIC8vSFxyXG4gICAgXCJoYW5naW5nLXB1bmN0dWF0aW9uXCIgICAgICAgICAgIDogMSxcclxuICAgIFwiaGVpZ2h0XCIgICAgICAgICAgICAgICAgICAgICAgICA6IFwiPG1hcmdpbi13aWR0aD4gfCA8Y29udGVudC1zaXppbmc+IHwgaW5oZXJpdFwiLFxyXG4gICAgXCJoeXBoZW5hdGUtYWZ0ZXJcIiAgICAgICAgICAgICAgIDogXCI8aW50ZWdlcj4gfCBhdXRvXCIsXHJcbiAgICBcImh5cGhlbmF0ZS1iZWZvcmVcIiAgICAgICAgICAgICAgOiBcIjxpbnRlZ2VyPiB8IGF1dG9cIixcclxuICAgIFwiaHlwaGVuYXRlLWNoYXJhY3RlclwiICAgICAgICAgICA6IFwiPHN0cmluZz4gfCBhdXRvXCIsXHJcbiAgICBcImh5cGhlbmF0ZS1saW5lc1wiICAgICAgICAgICAgICAgOiBcIm5vLWxpbWl0IHwgPGludGVnZXI+XCIsXHJcbiAgICBcImh5cGhlbmF0ZS1yZXNvdXJjZVwiICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJoeXBoZW5zXCIgICAgICAgICAgICAgICAgICAgICAgIDogXCJub25lIHwgbWFudWFsIHwgYXV0b1wiLFxyXG5cclxuICAgIC8vSVxyXG4gICAgXCJpY29uXCIgICAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwiaW1hZ2Utb3JpZW50YXRpb25cIiAgICAgICAgICAgICA6IFwiYW5nbGUgfCBhdXRvXCIsXHJcbiAgICBcImltYWdlLXJlbmRlcmluZ1wiICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJpbWFnZS1yZXNvbHV0aW9uXCIgICAgICAgICAgICAgIDogMSxcclxuICAgIFwiaW1lLW1vZGVcIiAgICAgICAgICAgICAgICAgICAgICA6IFwiYXV0byB8IG5vcm1hbCB8IGFjdGl2ZSB8IGluYWN0aXZlIHwgZGlzYWJsZWQgfCBpbmhlcml0XCIsXHJcbiAgICBcImlubGluZS1ib3gtYWxpZ25cIiAgICAgICAgICAgICAgOiBcImluaXRpYWwgfCBsYXN0IHwgPGludGVnZXI+XCIsXHJcblxyXG4gICAgLy9KXHJcbiAgICBcImp1c3RpZnktY29udGVudFwiICAgICAgICAgICAgICAgOiBcImZsZXgtc3RhcnQgfCBmbGV4LWVuZCB8IGNlbnRlciB8IHNwYWNlLWJldHdlZW4gfCBzcGFjZS1hcm91bmRcIixcclxuICAgIFwiLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnRcIiAgICAgICA6IFwiZmxleC1zdGFydCB8IGZsZXgtZW5kIHwgY2VudGVyIHwgc3BhY2UtYmV0d2VlbiB8IHNwYWNlLWFyb3VuZFwiLFxyXG5cclxuICAgIC8vTFxyXG4gICAgXCJsZWZ0XCIgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCI8bWFyZ2luLXdpZHRoPiB8IGluaGVyaXRcIixcclxuICAgIFwibGV0dGVyLXNwYWNpbmdcIiAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD4gfCBub3JtYWwgfCBpbmhlcml0XCIsXHJcbiAgICBcImxpbmUtaGVpZ2h0XCIgICAgICAgICAgICAgICAgICAgOiBcIjxudW1iZXI+IHwgPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gfCBub3JtYWwgfCBpbmhlcml0XCIsXHJcbiAgICBcImxpbmUtYnJlYWtcIiAgICAgICAgICAgICAgICAgICAgOiBcImF1dG8gfCBsb29zZSB8IG5vcm1hbCB8IHN0cmljdFwiLFxyXG4gICAgXCJsaW5lLXN0YWNraW5nXCIgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwibGluZS1zdGFja2luZy1ydWJ5XCIgICAgICAgICAgICA6IFwiZXhjbHVkZS1ydWJ5IHwgaW5jbHVkZS1ydWJ5XCIsXHJcbiAgICBcImxpbmUtc3RhY2tpbmctc2hpZnRcIiAgICAgICAgICAgOiBcImNvbnNpZGVyLXNoaWZ0cyB8IGRpc3JlZ2FyZC1zaGlmdHNcIixcclxuICAgIFwibGluZS1zdGFja2luZy1zdHJhdGVneVwiICAgICAgICA6IFwiaW5saW5lLWxpbmUtaGVpZ2h0IHwgYmxvY2stbGluZS1oZWlnaHQgfCBtYXgtaGVpZ2h0IHwgZ3JpZC1oZWlnaHRcIixcclxuICAgIFwibGlzdC1zdHlsZVwiICAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcImxpc3Qtc3R5bGUtaW1hZ2VcIiAgICAgICAgICAgICAgOiBcIjx1cmk+IHwgbm9uZSB8IGluaGVyaXRcIixcclxuICAgIFwibGlzdC1zdHlsZS1wb3NpdGlvblwiICAgICAgICAgICA6IFwiaW5zaWRlIHwgb3V0c2lkZSB8IGluaGVyaXRcIixcclxuICAgIFwibGlzdC1zdHlsZS10eXBlXCIgICAgICAgICAgICAgICA6IFwiZGlzYyB8IGNpcmNsZSB8IHNxdWFyZSB8IGRlY2ltYWwgfCBkZWNpbWFsLWxlYWRpbmctemVybyB8IGxvd2VyLXJvbWFuIHwgdXBwZXItcm9tYW4gfCBsb3dlci1ncmVlayB8IGxvd2VyLWxhdGluIHwgdXBwZXItbGF0aW4gfCBhcm1lbmlhbiB8IGdlb3JnaWFuIHwgbG93ZXItYWxwaGEgfCB1cHBlci1hbHBoYSB8IG5vbmUgfCBpbmhlcml0XCIsXHJcblxyXG4gICAgLy9NXHJcbiAgICBcIm1hcmdpblwiICAgICAgICAgICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjxtYXJnaW4td2lkdGg+IHwgaW5oZXJpdFwiLCBtYXg6IDQgfSxcclxuICAgIFwibWFyZ2luLWJvdHRvbVwiICAgICAgICAgICAgICAgICA6IFwiPG1hcmdpbi13aWR0aD4gfCBpbmhlcml0XCIsXHJcbiAgICBcIm1hcmdpbi1sZWZ0XCIgICAgICAgICAgICAgICAgICAgOiBcIjxtYXJnaW4td2lkdGg+IHwgaW5oZXJpdFwiLFxyXG4gICAgXCJtYXJnaW4tcmlnaHRcIiAgICAgICAgICAgICAgICAgIDogXCI8bWFyZ2luLXdpZHRoPiB8IGluaGVyaXRcIixcclxuICAgIFwibWFyZ2luLXRvcFwiICAgICAgICAgICAgICAgICAgICA6IFwiPG1hcmdpbi13aWR0aD4gfCBpbmhlcml0XCIsXHJcbiAgICBcIm1hcmtcIiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJtYXJrLWFmdGVyXCIgICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwibWFyay1iZWZvcmVcIiAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcIm1hcmtzXCIgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJtYXJxdWVlLWRpcmVjdGlvblwiICAgICAgICAgICAgIDogMSxcclxuICAgIFwibWFycXVlZS1wbGF5LWNvdW50XCIgICAgICAgICAgICA6IDEsXHJcbiAgICBcIm1hcnF1ZWUtc3BlZWRcIiAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJtYXJxdWVlLXN0eWxlXCIgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwibWF4LWhlaWdodFwiICAgICAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gfCA8Y29udGVudC1zaXppbmc+IHwgbm9uZSB8IGluaGVyaXRcIixcclxuICAgIFwibWF4LXdpZHRoXCIgICAgICAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gfCA8Y29udGVudC1zaXppbmc+IHwgbm9uZSB8IGluaGVyaXRcIixcclxuICAgIFwibWluLWhlaWdodFwiICAgICAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gfCA8Y29udGVudC1zaXppbmc+IHwgY29udGFpbi1mbG9hdHMgfCAtbW96LWNvbnRhaW4tZmxvYXRzIHwgLXdlYmtpdC1jb250YWluLWZsb2F0cyB8IGluaGVyaXRcIixcclxuICAgIFwibWluLXdpZHRoXCIgICAgICAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gfCA8Y29udGVudC1zaXppbmc+IHwgY29udGFpbi1mbG9hdHMgfCAtbW96LWNvbnRhaW4tZmxvYXRzIHwgLXdlYmtpdC1jb250YWluLWZsb2F0cyB8IGluaGVyaXRcIixcclxuICAgIFwibW92ZS10b1wiICAgICAgICAgICAgICAgICAgICAgICA6IDEsXHJcblxyXG4gICAgLy9OXHJcbiAgICBcIm5hdi1kb3duXCIgICAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJuYXYtaW5kZXhcIiAgICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwibmF2LWxlZnRcIiAgICAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcIm5hdi1yaWdodFwiICAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJuYXYtdXBcIiAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcclxuXHJcbiAgICAvL09cclxuICAgIFwib2JqZWN0LWZpdFwiICAgICAgICAgICAgICAgICAgICA6IFwiZmlsbCB8IGNvbnRhaW4gfCBjb3ZlciB8IG5vbmUgfCBzY2FsZS1kb3duXCIsXHJcbiAgICBcIm9iamVjdC1wb3NpdGlvblwiICAgICAgICAgICAgICAgOiBcIjxiZy1wb3NpdGlvbj5cIixcclxuICAgIFwib3BhY2l0eVwiICAgICAgICAgICAgICAgICAgICAgICA6IFwiPG51bWJlcj4gfCBpbmhlcml0XCIsXHJcbiAgICBcIm9yZGVyXCIgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjxpbnRlZ2VyPlwiLFxyXG4gICAgXCItd2Via2l0LW9yZGVyXCIgICAgICAgICAgICAgICAgIDogXCI8aW50ZWdlcj5cIixcclxuICAgIFwib3JwaGFuc1wiICAgICAgICAgICAgICAgICAgICAgICA6IFwiPGludGVnZXI+IHwgaW5oZXJpdFwiLFxyXG4gICAgXCJvdXRsaW5lXCIgICAgICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwib3V0bGluZS1jb2xvclwiICAgICAgICAgICAgICAgICA6IFwiPGNvbG9yPiB8IGludmVydCB8IGluaGVyaXRcIixcclxuICAgIFwib3V0bGluZS1vZmZzZXRcIiAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcIm91dGxpbmUtc3R5bGVcIiAgICAgICAgICAgICAgICAgOiBcIjxib3JkZXItc3R5bGU+IHwgaW5oZXJpdFwiLFxyXG4gICAgXCJvdXRsaW5lLXdpZHRoXCIgICAgICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXdpZHRoPiB8IGluaGVyaXRcIixcclxuICAgIFwib3ZlcmZsb3dcIiAgICAgICAgICAgICAgICAgICAgICA6IFwidmlzaWJsZSB8IGhpZGRlbiB8IHNjcm9sbCB8IGF1dG8gfCBpbmhlcml0XCIsXHJcbiAgICBcIm92ZXJmbG93LXN0eWxlXCIgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJvdmVyZmxvdy13cmFwXCIgICAgICAgICAgICAgICAgIDogXCJub3JtYWwgfCBicmVhay13b3JkXCIsXHJcbiAgICBcIm92ZXJmbG93LXhcIiAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJvdmVyZmxvdy15XCIgICAgICAgICAgICAgICAgICAgIDogMSxcclxuXHJcbiAgICAvL1BcclxuICAgIFwicGFkZGluZ1wiICAgICAgICAgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPHBhZGRpbmctd2lkdGg+IHwgaW5oZXJpdFwiLCBtYXg6IDQgfSxcclxuICAgIFwicGFkZGluZy1ib3R0b21cIiAgICAgICAgICAgICAgICA6IFwiPHBhZGRpbmctd2lkdGg+IHwgaW5oZXJpdFwiLFxyXG4gICAgXCJwYWRkaW5nLWxlZnRcIiAgICAgICAgICAgICAgICAgIDogXCI8cGFkZGluZy13aWR0aD4gfCBpbmhlcml0XCIsXHJcbiAgICBcInBhZGRpbmctcmlnaHRcIiAgICAgICAgICAgICAgICAgOiBcIjxwYWRkaW5nLXdpZHRoPiB8IGluaGVyaXRcIixcclxuICAgIFwicGFkZGluZy10b3BcIiAgICAgICAgICAgICAgICAgICA6IFwiPHBhZGRpbmctd2lkdGg+IHwgaW5oZXJpdFwiLFxyXG4gICAgXCJwYWdlXCIgICAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwicGFnZS1icmVhay1hZnRlclwiICAgICAgICAgICAgICA6IFwiYXV0byB8IGFsd2F5cyB8IGF2b2lkIHwgbGVmdCB8IHJpZ2h0IHwgaW5oZXJpdFwiLFxyXG4gICAgXCJwYWdlLWJyZWFrLWJlZm9yZVwiICAgICAgICAgICAgIDogXCJhdXRvIHwgYWx3YXlzIHwgYXZvaWQgfCBsZWZ0IHwgcmlnaHQgfCBpbmhlcml0XCIsXHJcbiAgICBcInBhZ2UtYnJlYWstaW5zaWRlXCIgICAgICAgICAgICAgOiBcImF1dG8gfCBhdm9pZCB8IGluaGVyaXRcIixcclxuICAgIFwicGFnZS1wb2xpY3lcIiAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcInBhdXNlXCIgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJwYXVzZS1hZnRlclwiICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwicGF1c2UtYmVmb3JlXCIgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcInBlcnNwZWN0aXZlXCIgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJwZXJzcGVjdGl2ZS1vcmlnaW5cIiAgICAgICAgICAgIDogMSxcclxuICAgIFwicGhvbmVtZXNcIiAgICAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcInBpdGNoXCIgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJwaXRjaC1yYW5nZVwiICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwicGxheS1kdXJpbmdcIiAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcInBvaW50ZXItZXZlbnRzXCIgICAgICAgICAgICAgICAgOiBcImF1dG8gfCBub25lIHwgdmlzaWJsZVBhaW50ZWQgfCB2aXNpYmxlRmlsbCB8IHZpc2libGVTdHJva2UgfCB2aXNpYmxlIHwgcGFpbnRlZCB8IGZpbGwgfCBzdHJva2UgfCBhbGwgfCBpbmhlcml0XCIsXHJcbiAgICBcInBvc2l0aW9uXCIgICAgICAgICAgICAgICAgICAgICAgOiBcInN0YXRpYyB8IHJlbGF0aXZlIHwgYWJzb2x1dGUgfCBmaXhlZCB8IGluaGVyaXRcIixcclxuICAgIFwicHJlc2VudGF0aW9uLWxldmVsXCIgICAgICAgICAgICA6IDEsXHJcbiAgICBcInB1bmN0dWF0aW9uLXRyaW1cIiAgICAgICAgICAgICAgOiAxLFxyXG5cclxuICAgIC8vUVxyXG4gICAgXCJxdW90ZXNcIiAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcclxuXHJcbiAgICAvL1JcclxuICAgIFwicmVuZGVyaW5nLWludGVudFwiICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcInJlc2l6ZVwiICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJyZXN0XCIgICAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwicmVzdC1hZnRlclwiICAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcInJlc3QtYmVmb3JlXCIgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJyaWNobmVzc1wiICAgICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwicmlnaHRcIiAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiPG1hcmdpbi13aWR0aD4gfCBpbmhlcml0XCIsXHJcbiAgICBcInJvdGF0aW9uXCIgICAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJyb3RhdGlvbi1wb2ludFwiICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwicnVieS1hbGlnblwiICAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcInJ1Ynktb3ZlcmhhbmdcIiAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJydWJ5LXBvc2l0aW9uXCIgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwicnVieS1zcGFuXCIgICAgICAgICAgICAgICAgICAgICA6IDEsXHJcblxyXG4gICAgLy9TXHJcbiAgICBcInNpemVcIiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJzcGVha1wiICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJub3JtYWwgfCBub25lIHwgc3BlbGwtb3V0IHwgaW5oZXJpdFwiLFxyXG4gICAgXCJzcGVhay1oZWFkZXJcIiAgICAgICAgICAgICAgICAgIDogXCJvbmNlIHwgYWx3YXlzIHwgaW5oZXJpdFwiLFxyXG4gICAgXCJzcGVhay1udW1lcmFsXCIgICAgICAgICAgICAgICAgIDogXCJkaWdpdHMgfCBjb250aW51b3VzIHwgaW5oZXJpdFwiLFxyXG4gICAgXCJzcGVhay1wdW5jdHVhdGlvblwiICAgICAgICAgICAgIDogXCJjb2RlIHwgbm9uZSB8IGluaGVyaXRcIixcclxuICAgIFwic3BlZWNoLXJhdGVcIiAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcInNyY1wiICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJzdHJlc3NcIiAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwic3RyaW5nLXNldFwiICAgICAgICAgICAgICAgICAgICA6IDEsXHJcblxyXG4gICAgXCJ0YWJsZS1sYXlvdXRcIiAgICAgICAgICAgICAgICAgIDogXCJhdXRvIHwgZml4ZWQgfCBpbmhlcml0XCIsXHJcbiAgICBcInRhYi1zaXplXCIgICAgICAgICAgICAgICAgICAgICAgOiBcIjxpbnRlZ2VyPiB8IDxsZW5ndGg+XCIsXHJcbiAgICBcInRhcmdldFwiICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJ0YXJnZXQtbmFtZVwiICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwidGFyZ2V0LW5ld1wiICAgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcInRhcmdldC1wb3NpdGlvblwiICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJ0ZXh0LWFsaWduXCIgICAgICAgICAgICAgICAgICAgIDogXCJsZWZ0IHwgcmlnaHQgfCBjZW50ZXIgfCBqdXN0aWZ5IHwgbWF0Y2gtcGFyZW50IHwgc3RhcnQgfCBlbmQgfCBpbmhlcml0XCIgLFxyXG4gICAgXCJ0ZXh0LWFsaWduLWxhc3RcIiAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwidGV4dC1kZWNvcmF0aW9uXCIgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcInRleHQtZW1waGFzaXNcIiAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJ0ZXh0LWhlaWdodFwiICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwidGV4dC1pbmRlbnRcIiAgICAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gfCBpbmhlcml0XCIsXHJcbiAgICBcInRleHQtanVzdGlmeVwiICAgICAgICAgICAgICAgICAgOiBcImF1dG8gfCBub25lIHwgaW50ZXItd29yZCB8IGludGVyLWlkZW9ncmFwaCB8IGludGVyLWNsdXN0ZXIgfCBkaXN0cmlidXRlIHwga2FzaGlkYVwiLFxyXG4gICAgXCJ0ZXh0LW91dGxpbmVcIiAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwidGV4dC1vdmVyZmxvd1wiICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcInRleHQtcmVuZGVyaW5nXCIgICAgICAgICAgICAgICAgOiBcImF1dG8gfCBvcHRpbWl6ZVNwZWVkIHwgb3B0aW1pemVMZWdpYmlsaXR5IHwgZ2VvbWV0cmljUHJlY2lzaW9uIHwgaW5oZXJpdFwiLFxyXG4gICAgXCJ0ZXh0LXNoYWRvd1wiICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwidGV4dC10cmFuc2Zvcm1cIiAgICAgICAgICAgICAgICA6IFwiY2FwaXRhbGl6ZSB8IHVwcGVyY2FzZSB8IGxvd2VyY2FzZSB8IG5vbmUgfCBpbmhlcml0XCIsXHJcbiAgICBcInRleHQtd3JhcFwiICAgICAgICAgICAgICAgICAgICAgOiBcIm5vcm1hbCB8IG5vbmUgfCBhdm9pZFwiLFxyXG4gICAgXCJ0b3BcIiAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCI8bWFyZ2luLXdpZHRoPiB8IGluaGVyaXRcIixcclxuICAgIFwiLW1zLXRvdWNoLWFjdGlvblwiICAgICAgICAgICAgICA6IFwiYXV0byB8IG5vbmUgfCBwYW4teCB8IHBhbi15IHwgcGFuLWxlZnQgfCBwYW4tcmlnaHQgfCBwYW4tdXAgfCBwYW4tZG93biB8IG1hbmlwdWxhdGlvblwiLFxyXG4gICAgXCJ0b3VjaC1hY3Rpb25cIiAgICAgICAgICAgICAgICAgIDogXCJhdXRvIHwgbm9uZSB8IHBhbi14IHwgcGFuLXkgfCBwYW4tbGVmdCB8IHBhbi1yaWdodCB8IHBhbi11cCB8IHBhbi1kb3duIHwgbWFuaXB1bGF0aW9uXCIsXHJcbiAgICBcInRyYW5zZm9ybVwiICAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCIgICAgICAgICAgICAgIDogMSxcclxuICAgIFwidHJhbnNmb3JtLXN0eWxlXCIgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcInRyYW5zaXRpb25cIiAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJ0cmFuc2l0aW9uLWRlbGF5XCIgICAgICAgICAgICAgIDogMSxcclxuICAgIFwidHJhbnNpdGlvbi1kdXJhdGlvblwiICAgICAgICAgICA6IDEsXHJcbiAgICBcInRyYW5zaXRpb24tcHJvcGVydHlcIiAgICAgICAgICAgOiAxLFxyXG4gICAgXCJ0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblwiICAgIDogMSxcclxuXHJcbiAgICAvL1VcclxuICAgIFwidW5pY29kZS1iaWRpXCIgICAgICAgICAgICAgICAgICA6IFwibm9ybWFsIHwgZW1iZWQgfCBpc29sYXRlIHwgYmlkaS1vdmVycmlkZSB8IGlzb2xhdGUtb3ZlcnJpZGUgfCBwbGFpbnRleHQgfCBpbmhlcml0XCIsXHJcbiAgICBcInVzZXItbW9kaWZ5XCIgICAgICAgICAgICAgICAgICAgOiBcInJlYWQtb25seSB8IHJlYWQtd3JpdGUgfCB3cml0ZS1vbmx5IHwgaW5oZXJpdFwiLFxyXG4gICAgXCJ1c2VyLXNlbGVjdFwiICAgICAgICAgICAgICAgICAgIDogXCJub25lIHwgdGV4dCB8IHRvZ2dsZSB8IGVsZW1lbnQgfCBlbGVtZW50cyB8IGFsbCB8IGluaGVyaXRcIixcclxuXHJcbiAgICAvL1ZcclxuICAgIFwidmVydGljYWwtYWxpZ25cIiAgICAgICAgICAgICAgICA6IFwiYXV0byB8IHVzZS1zY3JpcHQgfCBiYXNlbGluZSB8IHN1YiB8IHN1cGVyIHwgdG9wIHwgdGV4dC10b3AgfCBjZW50cmFsIHwgbWlkZGxlIHwgYm90dG9tIHwgdGV4dC1ib3R0b20gfCA8cGVyY2VudGFnZT4gfCA8bGVuZ3RoPiB8IGluaGVyaXRcIixcclxuICAgIFwidmlzaWJpbGl0eVwiICAgICAgICAgICAgICAgICAgICA6IFwidmlzaWJsZSB8IGhpZGRlbiB8IGNvbGxhcHNlIHwgaW5oZXJpdFwiLFxyXG4gICAgXCJ2b2ljZS1iYWxhbmNlXCIgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwidm9pY2UtZHVyYXRpb25cIiAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcInZvaWNlLWZhbWlseVwiICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJ2b2ljZS1waXRjaFwiICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwidm9pY2UtcGl0Y2gtcmFuZ2VcIiAgICAgICAgICAgICA6IDEsXHJcbiAgICBcInZvaWNlLXJhdGVcIiAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgXCJ2b2ljZS1zdHJlc3NcIiAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgIFwidm9pY2Utdm9sdW1lXCIgICAgICAgICAgICAgICAgICA6IDEsXHJcbiAgICBcInZvbHVtZVwiICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxyXG5cclxuICAgIC8vV1xyXG4gICAgXCJ3aGl0ZS1zcGFjZVwiICAgICAgICAgICAgICAgICAgIDogXCJub3JtYWwgfCBwcmUgfCBub3dyYXAgfCBwcmUtd3JhcCB8IHByZS1saW5lIHwgaW5oZXJpdCB8IC1wcmUtd3JhcCB8IC1vLXByZS13cmFwIHwgLW1vei1wcmUtd3JhcCB8IC1ocC1wcmUtd3JhcFwiLCAvL2h0dHA6Ly9wZXJpc2hhYmxlcHJlc3MuY29tL3dyYXBwaW5nLWNvbnRlbnQvXHJcbiAgICBcIndoaXRlLXNwYWNlLWNvbGxhcHNlXCIgICAgICAgICAgOiAxLFxyXG4gICAgXCJ3aWRvd3NcIiAgICAgICAgICAgICAgICAgICAgICAgIDogXCI8aW50ZWdlcj4gfCBpbmhlcml0XCIsXHJcbiAgICBcIndpZHRoXCIgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjxsZW5ndGg+IHwgPHBlcmNlbnRhZ2U+IHwgPGNvbnRlbnQtc2l6aW5nPiB8IGF1dG8gfCBpbmhlcml0XCIsXHJcbiAgICBcIndpbGwtY2hhbmdlXCIgICAgICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjxpZGVudD5cIiwgY29tbWE6IHRydWUgfSxcclxuICAgIFwid29yZC1icmVha1wiICAgICAgICAgICAgICAgICAgICA6IFwibm9ybWFsIHwga2VlcC1hbGwgfCBicmVhay1hbGxcIixcclxuICAgIFwid29yZC1zcGFjaW5nXCIgICAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD4gfCBub3JtYWwgfCBpbmhlcml0XCIsXHJcbiAgICBcIndvcmQtd3JhcFwiICAgICAgICAgICAgICAgICAgICAgOiBcIm5vcm1hbCB8IGJyZWFrLXdvcmRcIixcclxuICAgIFwid3JpdGluZy1tb2RlXCIgICAgICAgICAgICAgICAgICA6IFwiaG9yaXpvbnRhbC10YiB8IHZlcnRpY2FsLXJsIHwgdmVydGljYWwtbHIgfCBsci10YiB8IHJsLXRiIHwgdGItcmwgfCBidC1ybCB8IHRiLWxyIHwgYnQtbHIgfCBsci1idCB8IHJsLWJ0IHwgbHIgfCBybCB8IHRiIHwgaW5oZXJpdFwiLFxyXG5cclxuICAgIC8vWlxyXG4gICAgXCJ6LWluZGV4XCIgICAgICAgICAgICAgICAgICAgICAgIDogXCI8aW50ZWdlcj4gfCBhdXRvIHwgaW5oZXJpdFwiLFxyXG4gICAgXCJ6b29tXCIgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCI8bnVtYmVyPiB8IDxwZXJjZW50YWdlPiB8IG5vcm1hbFwiXHJcbn07XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgc2VsZWN0b3IgY29tYmluYXRvciAod2hpdGVzcGFjZSwgKywgPikuXHJcbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLmNzc1xyXG4gKiBAY2xhc3MgUHJvcGVydHlOYW1lXHJcbiAqIEBleHRlbmRzIHBhcnNlcmxpYi51dGlsLlN5bnRheFVuaXRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bml0LlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaGFjayBUaGUgdHlwZSBvZiBJRSBoYWNrIGFwcGxpZWQgKFwiKlwiLCBcIl9cIiwgb3IgbnVsbCkuXHJcbiAqIEBwYXJhbSB7aW50fSBsaW5lIFRoZSBsaW5lIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cclxuICogQHBhcmFtIHtpbnR9IGNvbCBUaGUgY29sdW1uIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cclxuICovXHJcbmZ1bmN0aW9uIFByb3BlcnR5TmFtZSh0ZXh0LCBoYWNrLCBsaW5lLCBjb2wpe1xyXG5cclxuICAgIFN5bnRheFVuaXQuY2FsbCh0aGlzLCB0ZXh0LCBsaW5lLCBjb2wsIFBhcnNlci5QUk9QRVJUWV9OQU1FX1RZUEUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHR5cGUgb2YgSUUgaGFjayBhcHBsaWVkIChcIipcIiwgXCJfXCIsIG9yIG51bGwpLlxyXG4gICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgKiBAcHJvcGVydHkgaGFja1xyXG4gICAgICovXHJcbiAgICB0aGlzLmhhY2sgPSBoYWNrO1xyXG5cclxufVxyXG5cclxuUHJvcGVydHlOYW1lLnByb3RvdHlwZSA9IG5ldyBTeW50YXhVbml0KCk7XHJcblByb3BlcnR5TmFtZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQcm9wZXJ0eU5hbWU7XHJcblByb3BlcnR5TmFtZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuICh0aGlzLmhhY2sgPyB0aGlzLmhhY2sgOiBcIlwiKSArIHRoaXMudGV4dDtcclxufTtcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBzaW5nbGUgcGFydCBvZiBhIENTUyBwcm9wZXJ0eSB2YWx1ZSwgbWVhbmluZyB0aGF0IGl0IHJlcHJlc2VudHNcclxuICoganVzdCBldmVyeXRoaW5nIHNpbmdsZSBwYXJ0IGJldHdlZW4gXCI6XCIgYW5kIFwiO1wiLiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgdmFsdWVzXHJcbiAqIHNlcGFyYXRlZCBieSBjb21tYXMsIHRoaXMgdHlwZSByZXByZXNlbnRzIGp1c3Qgb25lIG9mIHRoZSB2YWx1ZXMuXHJcbiAqIEBwYXJhbSB7U3RyaW5nW119IHBhcnRzIEFuIGFycmF5IG9mIHZhbHVlIHBhcnRzIG1ha2luZyB1cCB0aGlzIHZhbHVlLlxyXG4gKiBAcGFyYW0ge2ludH0gbGluZSBUaGUgbGluZSBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXHJcbiAqIEBwYXJhbSB7aW50fSBjb2wgVGhlIGNvbHVtbiBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXHJcbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLmNzc1xyXG4gKiBAY2xhc3MgUHJvcGVydHlWYWx1ZVxyXG4gKiBAZXh0ZW5kcyBwYXJzZXJsaWIudXRpbC5TeW50YXhVbml0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gUHJvcGVydHlWYWx1ZShwYXJ0cywgbGluZSwgY29sKXtcclxuXHJcbiAgICBTeW50YXhVbml0LmNhbGwodGhpcywgcGFydHMuam9pbihcIiBcIiksIGxpbmUsIGNvbCwgUGFyc2VyLlBST1BFUlRZX1ZBTFVFX1RZUEUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBhcnRzIHRoYXQgbWFrZSB1cCB0aGUgc2VsZWN0b3IuXHJcbiAgICAgKiBAdHlwZSBBcnJheVxyXG4gICAgICogQHByb3BlcnR5IHBhcnRzXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFydHMgPSBwYXJ0cztcclxuXHJcbn1cclxuXHJcblByb3BlcnR5VmFsdWUucHJvdG90eXBlID0gbmV3IFN5bnRheFVuaXQoKTtcclxuUHJvcGVydHlWYWx1ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQcm9wZXJ0eVZhbHVlO1xyXG5cclxuLyoqXHJcbiAqIEEgdXRpbGl0eSBjbGFzcyB0aGF0IGFsbG93cyBmb3IgZWFzeSBpdGVyYXRpb24gb3ZlciB0aGUgdmFyaW91cyBwYXJ0cyBvZiBhXHJcbiAqIHByb3BlcnR5IHZhbHVlLlxyXG4gKiBAcGFyYW0ge3BhcnNlcmxpYi5jc3MuUHJvcGVydHlWYWx1ZX0gdmFsdWUgVGhlIHByb3BlcnR5IHZhbHVlIHRvIGl0ZXJhdGUgb3Zlci5cclxuICogQG5hbWVzcGFjZSBwYXJzZXJsaWIuY3NzXHJcbiAqIEBjbGFzcyBQcm9wZXJ0eVZhbHVlSXRlcmF0b3JcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBQcm9wZXJ0eVZhbHVlSXRlcmF0b3IodmFsdWUpe1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0b3IgdmFsdWVcclxuICAgICAqIEB0eXBlIGludFxyXG4gICAgICogQHByb3BlcnR5IF9pXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9pID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwYXJ0cyB0aGF0IG1ha2UgdXAgdGhlIHZhbHVlLlxyXG4gICAgICogQHR5cGUgQXJyYXlcclxuICAgICAqIEBwcm9wZXJ0eSBfcGFydHNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3BhcnRzID0gdmFsdWUucGFydHM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBLZWVwcyB0cmFjayBvZiBib29rbWFya3MgYWxvbmcgdGhlIHdheS5cclxuICAgICAqIEB0eXBlIEFycmF5XHJcbiAgICAgKiBAcHJvcGVydHkgX21hcmtzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9tYXJrcyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSG9sZHMgdGhlIG9yaWdpbmFsIHByb3BlcnR5IHZhbHVlLlxyXG4gICAgICogQHR5cGUgcGFyc2VybGliLmNzcy5Qcm9wZXJ0eVZhbHVlXHJcbiAgICAgKiBAcHJvcGVydHkgdmFsdWVcclxuICAgICAqL1xyXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBwYXJ0cyBpbiB0aGUgdmFsdWUuXHJcbiAqIEByZXR1cm4ge2ludH0gVGhlIHRvdGFsIG51bWJlciBvZiBwYXJ0cyBpbiB0aGUgdmFsdWUuXHJcbiAqIEBtZXRob2QgY291bnRcclxuICovXHJcblByb3BlcnR5VmFsdWVJdGVyYXRvci5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhcnRzLmxlbmd0aDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbmRpY2F0ZXMgaWYgdGhlIGl0ZXJhdG9yIGlzIHBvc2l0aW9uZWQgYXQgdGhlIGZpcnN0IGl0ZW0uXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgcG9zaXRpb25lZCBhdCBmaXJzdCBpdGVtLCBmYWxzZSBpZiBub3QuXHJcbiAqIEBtZXRob2QgaXNGaXJzdFxyXG4gKi9cclxuUHJvcGVydHlWYWx1ZUl0ZXJhdG9yLnByb3RvdHlwZS5pc0ZpcnN0ID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLl9pID09PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluZGljYXRlcyBpZiB0aGVyZSBhcmUgbW9yZSBwYXJ0cyBvZiB0aGUgcHJvcGVydHkgdmFsdWUuXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlcmUgYXJlIG1vcmUgcGFydHMsIGZhbHNlIGlmIG5vdC5cclxuICogQG1ldGhvZCBoYXNOZXh0XHJcbiAqL1xyXG5Qcm9wZXJ0eVZhbHVlSXRlcmF0b3IucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuICh0aGlzLl9pIDwgdGhpcy5fcGFydHMubGVuZ3RoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYXJrcyB0aGUgY3VycmVudCBzcG90IGluIHRoZSBpdGVyYXRpb24gc28gaXQgY2FuIGJlIHJlc3RvcmVkIHRvXHJcbiAqIGxhdGVyIG9uLlxyXG4gKiBAcmV0dXJuIHt2b2lkfVxyXG4gKiBAbWV0aG9kIG1hcmtcclxuICovXHJcblByb3BlcnR5VmFsdWVJdGVyYXRvci5wcm90b3R5cGUubWFyayA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLl9tYXJrcy5wdXNoKHRoaXMuX2kpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG5leHQgcGFydCBvZiB0aGUgcHJvcGVydHkgdmFsdWUgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBuZXh0XHJcbiAqIHBhcnQuIERvZXMgbm90IG1vdmUgdGhlIGludGVybmFsIGNvdW50ZXIgZm9yd2FyZC5cclxuICogQHJldHVybiB7cGFyc2VybGliLmNzcy5Qcm9wZXJ0eVZhbHVlUGFydH0gVGhlIG5leHQgcGFydCBvZiB0aGUgcHJvcGVydHkgdmFsdWUgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBuZXh0XHJcbiAqIHBhcnQuXHJcbiAqIEBtZXRob2QgcGVla1xyXG4gKi9cclxuUHJvcGVydHlWYWx1ZUl0ZXJhdG9yLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oY291bnQpe1xyXG4gICAgcmV0dXJuIHRoaXMuaGFzTmV4dCgpID8gdGhpcy5fcGFydHNbdGhpcy5faSArIChjb3VudCB8fCAwKV0gOiBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG5leHQgcGFydCBvZiB0aGUgcHJvcGVydHkgdmFsdWUgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBuZXh0XHJcbiAqIHBhcnQuXHJcbiAqIEByZXR1cm4ge3BhcnNlcmxpYi5jc3MuUHJvcGVydHlWYWx1ZVBhcnR9IFRoZSBuZXh0IHBhcnQgb2YgdGhlIHByb3BlcnR5IHZhbHVlIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gbmV4dFxyXG4gKiBwYXJ0LlxyXG4gKiBAbWV0aG9kIG5leHRcclxuICovXHJcblByb3BlcnR5VmFsdWVJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5oYXNOZXh0KCkgPyB0aGlzLl9wYXJ0c1t0aGlzLl9pKytdIDogbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwcmV2aW91cyBwYXJ0IG9mIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvciBudWxsIGlmIHRoZXJlIGlzIG5vXHJcbiAqIHByZXZpb3VzIHBhcnQuXHJcbiAqIEByZXR1cm4ge3BhcnNlcmxpYi5jc3MuUHJvcGVydHlWYWx1ZVBhcnR9IFRoZSBwcmV2aW91cyBwYXJ0IG9mIHRoZVxyXG4gKiBwcm9wZXJ0eSB2YWx1ZSBvciBudWxsIGlmIHRoZXJlIGlzIG5vIHByZXZpb3VzIHBhcnQuXHJcbiAqIEBtZXRob2QgcHJldmlvdXNcclxuICovXHJcblByb3BlcnR5VmFsdWVJdGVyYXRvci5wcm90b3R5cGUucHJldmlvdXMgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuX2kgPiAwID8gdGhpcy5fcGFydHNbLS10aGlzLl9pXSA6IG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVzdG9yZXMgdGhlIGxhc3Qgc2F2ZWQgYm9va21hcmsuXHJcbiAqIEByZXR1cm4ge3ZvaWR9XHJcbiAqIEBtZXRob2QgcmVzdG9yZVxyXG4gKi9cclxuUHJvcGVydHlWYWx1ZUl0ZXJhdG9yLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24oKXtcclxuICAgIGlmICh0aGlzLl9tYXJrcy5sZW5ndGgpe1xyXG4gICAgICAgIHRoaXMuX2kgPSB0aGlzLl9tYXJrcy5wb3AoKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgc2luZ2xlIHBhcnQgb2YgYSBDU1MgcHJvcGVydHkgdmFsdWUsIG1lYW5pbmcgdGhhdCBpdCByZXByZXNlbnRzXHJcbiAqIGp1c3Qgb25lIHBhcnQgb2YgdGhlIGRhdGEgYmV0d2VlbiBcIjpcIiBhbmQgXCI7XCIuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bml0LlxyXG4gKiBAcGFyYW0ge2ludH0gbGluZSBUaGUgbGluZSBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXHJcbiAqIEBwYXJhbSB7aW50fSBjb2wgVGhlIGNvbHVtbiBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXHJcbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLmNzc1xyXG4gKiBAY2xhc3MgUHJvcGVydHlWYWx1ZVBhcnRcclxuICogQGV4dGVuZHMgcGFyc2VybGliLnV0aWwuU3ludGF4VW5pdFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIFByb3BlcnR5VmFsdWVQYXJ0KHRleHQsIGxpbmUsIGNvbCl7XHJcblxyXG4gICAgU3ludGF4VW5pdC5jYWxsKHRoaXMsIHRleHQsIGxpbmUsIGNvbCwgUGFyc2VyLlBST1BFUlRZX1ZBTFVFX1BBUlRfVFlQRSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIHR5cGUgb2YgdmFsdWUgdW5pdC5cclxuICAgICAqIEB0eXBlIFN0cmluZ1xyXG4gICAgICogQHByb3BlcnR5IHR5cGVcclxuICAgICAqL1xyXG4gICAgdGhpcy50eXBlID0gXCJ1bmtub3duXCI7XHJcblxyXG4gICAgLy9maWd1cmUgb3V0IHdoYXQgdHlwZSBvZiBkYXRhIGl0IGlzXHJcblxyXG4gICAgdmFyIHRlbXA7XHJcblxyXG4gICAgLy9pdCBpcyBhIG1lYXN1cmVtZW50P1xyXG4gICAgaWYgKC9eKFsrXFwtXT9bXFxkXFwuXSspKFthLXpdKykkL2kudGVzdCh0ZXh0KSl7ICAvL2RpbWVuc2lvblxyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiZGltZW5zaW9uXCI7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9ICtSZWdFeHAuJDE7XHJcbiAgICAgICAgdGhpcy51bml0cyA9IFJlZ0V4cC4kMjtcclxuXHJcbiAgICAgICAgLy90cnkgdG8gbmFycm93IGRvd25cclxuICAgICAgICBzd2l0Y2godGhpcy51bml0cy50b0xvd2VyQ2FzZSgpKXtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgXCJlbVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwicmVtXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJleFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwicHhcIjpcclxuICAgICAgICAgICAgY2FzZSBcImNtXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJtbVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiaW5cIjpcclxuICAgICAgICAgICAgY2FzZSBcInB0XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJwY1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiY2hcIjpcclxuICAgICAgICAgICAgY2FzZSBcInZoXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJ2d1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwidm1heFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwidm1pblwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJsZW5ndGhcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgXCJmclwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJncmlkXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgXCJkZWdcIjpcclxuICAgICAgICAgICAgY2FzZSBcInJhZFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZ3JhZFwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJhbmdsZVwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwibXNcIjpcclxuICAgICAgICAgICAgY2FzZSBcInNcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwidGltZVwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwiaHpcIjpcclxuICAgICAgICAgICAgY2FzZSBcImtoelwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJmcmVxdWVuY3lcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBcImRwaVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZHBjbVwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJyZXNvbHV0aW9uXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vZGVmYXVsdFxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSBlbHNlIGlmICgvXihbK1xcLV0/W1xcZFxcLl0rKSUkL2kudGVzdCh0ZXh0KSl7ICAvL3BlcmNlbnRhZ2VcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInBlcmNlbnRhZ2VcIjtcclxuICAgICAgICB0aGlzLnZhbHVlID0gK1JlZ0V4cC4kMTtcclxuICAgIH0gZWxzZSBpZiAoL14oWytcXC1dP1xcZCspJC9pLnRlc3QodGV4dCkpeyAgLy9pbnRlZ2VyXHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJpbnRlZ2VyXCI7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9ICtSZWdFeHAuJDE7XHJcbiAgICB9IGVsc2UgaWYgKC9eKFsrXFwtXT9bXFxkXFwuXSspJC9pLnRlc3QodGV4dCkpeyAgLy9udW1iZXJcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIm51bWJlclwiO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSArUmVnRXhwLiQxO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoL14jKFthLWYwLTldezMsNn0pL2kudGVzdCh0ZXh0KSl7ICAvL2hleGNvbG9yXHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJjb2xvclwiO1xyXG4gICAgICAgIHRlbXAgPSBSZWdFeHAuJDE7XHJcbiAgICAgICAgaWYgKHRlbXAubGVuZ3RoID09PSAzKXtcclxuICAgICAgICAgICAgdGhpcy5yZWQgICAgPSBwYXJzZUludCh0ZW1wLmNoYXJBdCgwKSt0ZW1wLmNoYXJBdCgwKSwxNik7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JlZW4gID0gcGFyc2VJbnQodGVtcC5jaGFyQXQoMSkrdGVtcC5jaGFyQXQoMSksMTYpO1xyXG4gICAgICAgICAgICB0aGlzLmJsdWUgICA9IHBhcnNlSW50KHRlbXAuY2hhckF0KDIpK3RlbXAuY2hhckF0KDIpLDE2KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlZCAgICA9IHBhcnNlSW50KHRlbXAuc3Vic3RyaW5nKDAsMiksMTYpO1xyXG4gICAgICAgICAgICB0aGlzLmdyZWVuICA9IHBhcnNlSW50KHRlbXAuc3Vic3RyaW5nKDIsNCksMTYpO1xyXG4gICAgICAgICAgICB0aGlzLmJsdWUgICA9IHBhcnNlSW50KHRlbXAuc3Vic3RyaW5nKDQsNiksMTYpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoL15yZ2JcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKlxcKS9pLnRlc3QodGV4dCkpeyAvL3JnYigpIGNvbG9yIHdpdGggYWJzb2x1dGUgbnVtYmVyc1xyXG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJjb2xvclwiO1xyXG4gICAgICAgIHRoaXMucmVkICAgID0gK1JlZ0V4cC4kMTtcclxuICAgICAgICB0aGlzLmdyZWVuICA9ICtSZWdFeHAuJDI7XHJcbiAgICAgICAgdGhpcy5ibHVlICAgPSArUmVnRXhwLiQzO1xyXG4gICAgfSBlbHNlIGlmICgvXnJnYlxcKFxccyooXFxkKyklXFxzKixcXHMqKFxcZCspJVxccyosXFxzKihcXGQrKSVcXHMqXFwpL2kudGVzdCh0ZXh0KSl7IC8vcmdiKCkgY29sb3Igd2l0aCBwZXJjZW50YWdlc1xyXG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJjb2xvclwiO1xyXG4gICAgICAgIHRoaXMucmVkICAgID0gK1JlZ0V4cC4kMSAqIDI1NSAvIDEwMDtcclxuICAgICAgICB0aGlzLmdyZWVuICA9ICtSZWdFeHAuJDIgKiAyNTUgLyAxMDA7XHJcbiAgICAgICAgdGhpcy5ibHVlICAgPSArUmVnRXhwLiQzICogMjU1IC8gMTAwO1xyXG4gICAgfSBlbHNlIGlmICgvXnJnYmFcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFtcXGRcXC5dKylcXHMqXFwpL2kudGVzdCh0ZXh0KSl7IC8vcmdiYSgpIGNvbG9yIHdpdGggYWJzb2x1dGUgbnVtYmVyc1xyXG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJjb2xvclwiO1xyXG4gICAgICAgIHRoaXMucmVkICAgID0gK1JlZ0V4cC4kMTtcclxuICAgICAgICB0aGlzLmdyZWVuICA9ICtSZWdFeHAuJDI7XHJcbiAgICAgICAgdGhpcy5ibHVlICAgPSArUmVnRXhwLiQzO1xyXG4gICAgICAgIHRoaXMuYWxwaGEgID0gK1JlZ0V4cC4kNDtcclxuICAgIH0gZWxzZSBpZiAoL15yZ2JhXFwoXFxzKihcXGQrKSVcXHMqLFxccyooXFxkKyklXFxzKixcXHMqKFxcZCspJVxccyosXFxzKihbXFxkXFwuXSspXFxzKlxcKS9pLnRlc3QodGV4dCkpeyAvL3JnYmEoKSBjb2xvciB3aXRoIHBlcmNlbnRhZ2VzXHJcbiAgICAgICAgdGhpcy50eXBlICAgPSBcImNvbG9yXCI7XHJcbiAgICAgICAgdGhpcy5yZWQgICAgPSArUmVnRXhwLiQxICogMjU1IC8gMTAwO1xyXG4gICAgICAgIHRoaXMuZ3JlZW4gID0gK1JlZ0V4cC4kMiAqIDI1NSAvIDEwMDtcclxuICAgICAgICB0aGlzLmJsdWUgICA9ICtSZWdFeHAuJDMgKiAyNTUgLyAxMDA7XHJcbiAgICAgICAgdGhpcy5hbHBoYSAgPSArUmVnRXhwLiQ0O1xyXG4gICAgfSBlbHNlIGlmICgvXmhzbFxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKyklXFxzKixcXHMqKFxcZCspJVxccypcXCkvaS50ZXN0KHRleHQpKXsgLy9oc2woKVxyXG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJjb2xvclwiO1xyXG4gICAgICAgIHRoaXMuaHVlICAgID0gK1JlZ0V4cC4kMTtcclxuICAgICAgICB0aGlzLnNhdHVyYXRpb24gPSArUmVnRXhwLiQyIC8gMTAwO1xyXG4gICAgICAgIHRoaXMubGlnaHRuZXNzICA9ICtSZWdFeHAuJDMgLyAxMDA7XHJcbiAgICB9IGVsc2UgaWYgKC9eaHNsYVxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKyklXFxzKixcXHMqKFxcZCspJVxccyosXFxzKihbXFxkXFwuXSspXFxzKlxcKS9pLnRlc3QodGV4dCkpeyAvL2hzbGEoKSBjb2xvciB3aXRoIHBlcmNlbnRhZ2VzXHJcbiAgICAgICAgdGhpcy50eXBlICAgPSBcImNvbG9yXCI7XHJcbiAgICAgICAgdGhpcy5odWUgICAgPSArUmVnRXhwLiQxO1xyXG4gICAgICAgIHRoaXMuc2F0dXJhdGlvbiA9ICtSZWdFeHAuJDIgLyAxMDA7XHJcbiAgICAgICAgdGhpcy5saWdodG5lc3MgID0gK1JlZ0V4cC4kMyAvIDEwMDtcclxuICAgICAgICB0aGlzLmFscGhhICA9ICtSZWdFeHAuJDQ7XHJcbiAgICB9IGVsc2UgaWYgKC9edXJsXFwoW1wiJ10/KFteXFwpXCInXSspW1wiJ10/XFwpL2kudGVzdCh0ZXh0KSl7IC8vVVJJXHJcbiAgICAgICAgdGhpcy50eXBlICAgPSBcInVyaVwiO1xyXG4gICAgICAgIHRoaXMudXJpICAgID0gUmVnRXhwLiQxO1xyXG4gICAgfSBlbHNlIGlmICgvXihbXlxcKF0rKVxcKC9pLnRlc3QodGV4dCkpe1xyXG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJmdW5jdGlvblwiO1xyXG4gICAgICAgIHRoaXMubmFtZSAgID0gUmVnRXhwLiQxO1xyXG4gICAgICAgIHRoaXMudmFsdWUgID0gdGV4dDtcclxuICAgIH0gZWxzZSBpZiAoL15cIihbXlxcblxcclxcZlxcXFxcIl18XFxcXFxcclxcbnxcXFxcW15cXHIwLTlhLWZdfFxcXFxbMC05YS1mXXsxLDZ9KFxcclxcbnxbIFxcblxcclxcdFxcZl0pPykqXCIvaS50ZXN0KHRleHQpKXsgICAgLy9kb3VibGUtcXVvdGVkIHN0cmluZ1xyXG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJzdHJpbmdcIjtcclxuICAgICAgICB0aGlzLnZhbHVlICA9IFByb3BlcnR5VmFsdWVQYXJ0LnBhcnNlU3RyaW5nKHRleHQpO1xyXG4gICAgfSBlbHNlIGlmICgvXicoW15cXG5cXHJcXGZcXFxcJ118XFxcXFxcclxcbnxcXFxcW15cXHIwLTlhLWZdfFxcXFxbMC05YS1mXXsxLDZ9KFxcclxcbnxbIFxcblxcclxcdFxcZl0pPykqJy9pLnRlc3QodGV4dCkpeyAgICAvL3NpbmdsZS1xdW90ZWQgc3RyaW5nXHJcbiAgICAgICAgdGhpcy50eXBlICAgPSBcInN0cmluZ1wiO1xyXG4gICAgICAgIHRoaXMudmFsdWUgID0gUHJvcGVydHlWYWx1ZVBhcnQucGFyc2VTdHJpbmcodGV4dCk7XHJcbiAgICB9IGVsc2UgaWYgKENvbG9yc1t0ZXh0LnRvTG93ZXJDYXNlKCldKXsgIC8vbmFtZWQgY29sb3JcclxuICAgICAgICB0aGlzLnR5cGUgICA9IFwiY29sb3JcIjtcclxuICAgICAgICB0ZW1wICAgICAgICA9IENvbG9yc1t0ZXh0LnRvTG93ZXJDYXNlKCldLnN1YnN0cmluZygxKTtcclxuICAgICAgICB0aGlzLnJlZCAgICA9IHBhcnNlSW50KHRlbXAuc3Vic3RyaW5nKDAsMiksMTYpO1xyXG4gICAgICAgIHRoaXMuZ3JlZW4gID0gcGFyc2VJbnQodGVtcC5zdWJzdHJpbmcoMiw0KSwxNik7XHJcbiAgICAgICAgdGhpcy5ibHVlICAgPSBwYXJzZUludCh0ZW1wLnN1YnN0cmluZyg0LDYpLDE2KTtcclxuICAgIH0gZWxzZSBpZiAoL15bXFwsXFwvXSQvLnRlc3QodGV4dCkpe1xyXG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJvcGVyYXRvclwiO1xyXG4gICAgICAgIHRoaXMudmFsdWUgID0gdGV4dDtcclxuICAgIH0gZWxzZSBpZiAoL15bYS16XFwtX1xcdTAwODAtXFx1RkZGRl1bYS16MC05XFwtX1xcdTAwODAtXFx1RkZGRl0qJC9pLnRlc3QodGV4dCkpe1xyXG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJpZGVudGlmaWVyXCI7XHJcbiAgICAgICAgdGhpcy52YWx1ZSAgPSB0ZXh0O1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuUHJvcGVydHlWYWx1ZVBhcnQucHJvdG90eXBlID0gbmV3IFN5bnRheFVuaXQoKTtcclxuUHJvcGVydHlWYWx1ZVBhcnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHJvcGVydHlWYWx1ZVBhcnQ7XHJcblxyXG4vKipcclxuICogSGVscGVyIG1ldGhvZCB0byBwYXJzZSBhIENTUyBzdHJpbmcuXHJcbiAqL1xyXG5Qcm9wZXJ0eVZhbHVlUGFydC5wYXJzZVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgc3RyID0gc3RyLnNsaWNlKDEsIC0xKTsgLy8gU3RyaXAgc3Vycm91bmRpbmcgc2luZ2xlL2RvdWJsZSBxdW90ZXNcclxuICAgIHZhciByZXBsYWNlciA9IGZ1bmN0aW9uKG1hdGNoLCBlc2MpIHtcclxuICAgICAgICBpZiAoL14oXFxufFxcclxcbnxcXHJ8XFxmKSQvLnRlc3QoZXNjKSkgeyByZXR1cm4gJyc7IH1cclxuICAgICAgICB2YXIgbSA9IC9eWzAtOWEtZl17MSw2fS9pLmV4ZWMoZXNjKTtcclxuICAgICAgICBpZiAobSkge1xyXG4gICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gcGFyc2VJbnQobVswXSwgMTYpO1xyXG4gICAgICAgICAgICBpZiAoU3RyaW5nLmZyb21Db2RlUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlUG9pbnQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gWFhYIE5vIHN1cHBvcnQgZm9yIHN1cnJvZ2F0ZXMgb24gb2xkIEphdmFTY3JpcHQgZW5naW5lcy5cclxuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVzYztcclxuICAgIH07XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwoXFxyXFxufFteXFxyMC05YS1mXXxbMC05YS1mXXsxLDZ9KFxcclxcbnxbIFxcblxcclxcdFxcZl0pPykvaWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBtZXRob2QgdG8gc2VyaWFsaXplIGEgQ1NTIHN0cmluZy5cclxuICovXHJcblByb3BlcnR5VmFsdWVQYXJ0LnNlcmlhbGl6ZVN0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICB2YXIgcmVwbGFjZXIgPSBmdW5jdGlvbihtYXRjaCwgYykge1xyXG4gICAgICAgIGlmIChjID09PSAnXCInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFxcIiArIGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjcCA9IFN0cmluZy5jb2RlUG9pbnRBdCA/IFN0cmluZy5jb2RlUG9pbnRBdCgwKSA6XHJcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgZXNjYXBlIG5vbi1zdXJyb2dhdGUgY2hhcnMsIHNvIHVzaW5nIGNoYXJDb2RlQXRcclxuICAgICAgICAgICAgLy8gaXMgaGFybWxlc3MgaGVyZS5cclxuICAgICAgICAgICAgU3RyaW5nLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgY3AudG9TdHJpbmcoMTYpICsgXCIgXCI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuICdcIicgKyB2YWx1ZS5yZXBsYWNlKC9bXCJcXHJcXG5cXGZdL2csIHJlcGxhY2VyKSArICdcIic7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgbmV3IHN5bnRheCB1bml0IGJhc2VkIHNvbGVseSBvbiB0aGUgZ2l2ZW4gdG9rZW4uXHJcbiAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBuZXcgc3ludGF4IHVuaXQgd2hlblxyXG4gKiBpdCByZXByZXNlbnRzIGEgc2luZ2xlIHRva2VuIGluc3RlYWQgb2YgbXVsdGlwbGUuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbiBUaGUgdG9rZW4gb2JqZWN0IHRvIHJlcHJlc2VudC5cclxuICogQHJldHVybiB7cGFyc2VybGliLmNzcy5Qcm9wZXJ0eVZhbHVlUGFydH0gVGhlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHRva2VuLlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgZnJvbVRva2VuXHJcbiAqL1xyXG5Qcm9wZXJ0eVZhbHVlUGFydC5mcm9tVG9rZW4gPSBmdW5jdGlvbih0b2tlbil7XHJcbiAgICByZXR1cm4gbmV3IFByb3BlcnR5VmFsdWVQYXJ0KHRva2VuLnZhbHVlLCB0b2tlbi5zdGFydExpbmUsIHRva2VuLnN0YXJ0Q29sKTtcclxufTtcclxudmFyIFBzZXVkb3MgPSB7XHJcbiAgICBfX3Byb3RvX186ICAgICAgIG51bGwsXHJcbiAgICBcIjpmaXJzdC1sZXR0ZXJcIjogMSxcclxuICAgIFwiOmZpcnN0LWxpbmVcIjogICAxLFxyXG4gICAgXCI6YmVmb3JlXCI6ICAgICAgIDEsXHJcbiAgICBcIjphZnRlclwiOiAgICAgICAgMVxyXG59O1xyXG5cclxuUHNldWRvcy5FTEVNRU5UID0gMTtcclxuUHNldWRvcy5DTEFTUyA9IDI7XHJcblxyXG5Qc2V1ZG9zLmlzRWxlbWVudCA9IGZ1bmN0aW9uKHBzZXVkbyl7XHJcbiAgICByZXR1cm4gcHNldWRvLmluZGV4T2YoXCI6OlwiKSA9PT0gMCB8fCBQc2V1ZG9zW3BzZXVkby50b0xvd2VyQ2FzZSgpXSA9PT0gUHNldWRvcy5FTEVNRU5UO1xyXG59O1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBlbnRpcmUgc2luZ2xlIHNlbGVjdG9yLCBpbmNsdWRpbmcgYWxsIHBhcnRzIGJ1dCBub3RcclxuICogaW5jbHVkaW5nIG11bHRpcGxlIHNlbGVjdG9ycyAodGhvc2Ugc2VwYXJhdGVkIGJ5IGNvbW1hcykuXHJcbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLmNzc1xyXG4gKiBAY2xhc3MgU2VsZWN0b3JcclxuICogQGV4dGVuZHMgcGFyc2VybGliLnV0aWwuU3ludGF4VW5pdFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtBcnJheX0gcGFydHMgQXJyYXkgb2Ygc2VsZWN0b3JzIHBhcnRzIG1ha2luZyB1cCB0aGlzIHNlbGVjdG9yLlxyXG4gKiBAcGFyYW0ge2ludH0gbGluZSBUaGUgbGluZSBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXHJcbiAqIEBwYXJhbSB7aW50fSBjb2wgVGhlIGNvbHVtbiBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBTZWxlY3RvcihwYXJ0cywgbGluZSwgY29sKXtcclxuXHJcbiAgICBTeW50YXhVbml0LmNhbGwodGhpcywgcGFydHMuam9pbihcIiBcIiksIGxpbmUsIGNvbCwgUGFyc2VyLlNFTEVDVE9SX1RZUEUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBhcnRzIHRoYXQgbWFrZSB1cCB0aGUgc2VsZWN0b3IuXHJcbiAgICAgKiBAdHlwZSBBcnJheVxyXG4gICAgICogQHByb3BlcnR5IHBhcnRzXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFydHMgPSBwYXJ0cztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzcGVjaWZpY2l0eSBvZiB0aGUgc2VsZWN0b3IuXHJcbiAgICAgKiBAdHlwZSBwYXJzZXJsaWIuY3NzLlNwZWNpZmljaXR5XHJcbiAgICAgKiBAcHJvcGVydHkgc3BlY2lmaWNpdHlcclxuICAgICAqL1xyXG4gICAgdGhpcy5zcGVjaWZpY2l0eSA9IFNwZWNpZmljaXR5LmNhbGN1bGF0ZSh0aGlzKTtcclxuXHJcbn1cclxuXHJcblNlbGVjdG9yLnByb3RvdHlwZSA9IG5ldyBTeW50YXhVbml0KCk7XHJcblNlbGVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNlbGVjdG9yO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBzaW5nbGUgcGFydCBvZiBhIHNlbGVjdG9yIHN0cmluZywgbWVhbmluZyBhIHNpbmdsZSBzZXQgb2ZcclxuICogZWxlbWVudCBuYW1lIGFuZCBtb2RpZmllcnMuIFRoaXMgZG9lcyBub3QgaW5jbHVkZSBjb21iaW5hdG9ycyBzdWNoIGFzXHJcbiAqIHNwYWNlcywgKywgPiwgZXRjLlxyXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi5jc3NcclxuICogQGNsYXNzIFNlbGVjdG9yUGFydFxyXG4gKiBAZXh0ZW5kcyBwYXJzZXJsaWIudXRpbC5TeW50YXhVbml0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZWxlbWVudE5hbWUgVGhlIGVsZW1lbnQgbmFtZSBpbiB0aGUgc2VsZWN0b3Igb3IgbnVsbFxyXG4gKiAgICAgIGlmIHRoZXJlIGlzIG5vIGVsZW1lbnQgbmFtZS5cclxuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzIEFycmF5IG9mIGluZGl2aWR1YWwgbW9kaWZpZXJzIGZvciB0aGUgZWxlbWVudC5cclxuICogICAgICBNYXkgYmUgZW1wdHkgaWYgdGhlcmUgYXJlIG5vbmUuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bml0LlxyXG4gKiBAcGFyYW0ge2ludH0gbGluZSBUaGUgbGluZSBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXHJcbiAqIEBwYXJhbSB7aW50fSBjb2wgVGhlIGNvbHVtbiBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBTZWxlY3RvclBhcnQoZWxlbWVudE5hbWUsIG1vZGlmaWVycywgdGV4dCwgbGluZSwgY29sKXtcclxuXHJcbiAgICBTeW50YXhVbml0LmNhbGwodGhpcywgdGV4dCwgbGluZSwgY29sLCBQYXJzZXIuU0VMRUNUT1JfUEFSVF9UWVBFKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0YWcgbmFtZSBvZiB0aGUgZWxlbWVudCB0byB3aGljaCB0aGlzIHBhcnRcclxuICAgICAqIG9mIHRoZSBzZWxlY3RvciBhZmZlY3RzLlxyXG4gICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgKiBAcHJvcGVydHkgZWxlbWVudE5hbWVcclxuICAgICAqL1xyXG4gICAgdGhpcy5lbGVtZW50TmFtZSA9IGVsZW1lbnROYW1lO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBhcnRzIHRoYXQgY29tZSBhZnRlciB0aGUgZWxlbWVudCBuYW1lLCBzdWNoIGFzIGNsYXNzIG5hbWVzLCBJRHMsXHJcbiAgICAgKiBwc2V1ZG8gY2xhc3Nlcy9lbGVtZW50cywgZXRjLlxyXG4gICAgICogQHR5cGUgQXJyYXlcclxuICAgICAqIEBwcm9wZXJ0eSBtb2RpZmllcnNcclxuICAgICAqL1xyXG4gICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XHJcblxyXG59XHJcblxyXG5TZWxlY3RvclBhcnQucHJvdG90eXBlID0gbmV3IFN5bnRheFVuaXQoKTtcclxuU2VsZWN0b3JQYXJ0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNlbGVjdG9yUGFydDtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgc2VsZWN0b3IgbW9kaWZpZXIgc3RyaW5nLCBtZWFuaW5nIGEgY2xhc3MgbmFtZSwgZWxlbWVudCBuYW1lLFxyXG4gKiBlbGVtZW50IElELCBwc2V1ZG8gcnVsZSwgZXRjLlxyXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi5jc3NcclxuICogQGNsYXNzIFNlbGVjdG9yU3ViUGFydFxyXG4gKiBAZXh0ZW5kcyBwYXJzZXJsaWIudXRpbC5TeW50YXhVbml0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5pdC5cclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2Ygc2VsZWN0b3IgbW9kaWZpZXIuXHJcbiAqIEBwYXJhbSB7aW50fSBsaW5lIFRoZSBsaW5lIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cclxuICogQHBhcmFtIHtpbnR9IGNvbCBUaGUgY29sdW1uIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cclxuICovXHJcbmZ1bmN0aW9uIFNlbGVjdG9yU3ViUGFydCh0ZXh0LCB0eXBlLCBsaW5lLCBjb2wpe1xyXG5cclxuICAgIFN5bnRheFVuaXQuY2FsbCh0aGlzLCB0ZXh0LCBsaW5lLCBjb2wsIFBhcnNlci5TRUxFQ1RPUl9TVUJfUEFSVF9UWVBFKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0eXBlIG9mIG1vZGlmaWVyLlxyXG4gICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgKiBAcHJvcGVydHkgdHlwZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU29tZSBzdWJwYXJ0cyBoYXZlIGFyZ3VtZW50cywgdGhpcyByZXByZXNlbnRzIHRoZW0uXHJcbiAgICAgKiBAdHlwZSBBcnJheVxyXG4gICAgICogQHByb3BlcnR5IGFyZ3NcclxuICAgICAqL1xyXG4gICAgdGhpcy5hcmdzID0gW107XHJcblxyXG59XHJcblxyXG5TZWxlY3RvclN1YlBhcnQucHJvdG90eXBlID0gbmV3IFN5bnRheFVuaXQoKTtcclxuU2VsZWN0b3JTdWJQYXJ0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNlbGVjdG9yU3ViUGFydDtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgc2VsZWN0b3IncyBzcGVjaWZpY2l0eS5cclxuICogQG5hbWVzcGFjZSBwYXJzZXJsaWIuY3NzXHJcbiAqIEBjbGFzcyBTcGVjaWZpY2l0eVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtpbnR9IGEgU2hvdWxkIGJlIDEgZm9yIGlubGluZSBzdHlsZXMsIHplcm8gZm9yIHN0eWxlc2hlZXQgc3R5bGVzXHJcbiAqIEBwYXJhbSB7aW50fSBiIE51bWJlciBvZiBJRCBzZWxlY3RvcnNcclxuICogQHBhcmFtIHtpbnR9IGMgTnVtYmVyIG9mIGNsYXNzZXMgYW5kIHBzZXVkbyBjbGFzc2VzXHJcbiAqIEBwYXJhbSB7aW50fSBkIE51bWJlciBvZiBlbGVtZW50IG5hbWVzIGFuZCBwc2V1ZG8gZWxlbWVudHNcclxuICovXHJcbmZ1bmN0aW9uIFNwZWNpZmljaXR5KGEsIGIsIGMsIGQpe1xyXG4gICAgdGhpcy5hID0gYTtcclxuICAgIHRoaXMuYiA9IGI7XHJcbiAgICB0aGlzLmMgPSBjO1xyXG4gICAgdGhpcy5kID0gZDtcclxufVxyXG5cclxuU3BlY2lmaWNpdHkucHJvdG90eXBlID0ge1xyXG4gICAgY29uc3RydWN0b3I6IFNwZWNpZmljaXR5LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyZSB0aGlzIHNwZWNpZmljaXR5IHRvIGFub3RoZXIuXHJcbiAgICAgKiBAcGFyYW0ge1NwZWNpZmljaXR5fSBvdGhlciBUaGUgb3RoZXIgc3BlY2lmaWNpdHkgdG8gY29tcGFyZSB0by5cclxuICAgICAqIEByZXR1cm4ge2ludH0gLTEgaWYgdGhlIG90aGVyIHNwZWNpZmljaXR5IGlzIGxhcmdlciwgMSBpZiBzbWFsbGVyLCAwIGlmIGVxdWFsLlxyXG4gICAgICogQG1ldGhvZCBjb21wYXJlXHJcbiAgICAgKi9cclxuICAgIGNvbXBhcmU6IGZ1bmN0aW9uKG90aGVyKXtcclxuICAgICAgICB2YXIgY29tcHMgPSBbXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCJdLFxyXG4gICAgICAgICAgICBpLCBsZW47XHJcblxyXG4gICAgICAgIGZvciAoaT0wLCBsZW49Y29tcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xyXG4gICAgICAgICAgICBpZiAodGhpc1tjb21wc1tpXV0gPCBvdGhlcltjb21wc1tpXV0pe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXNbY29tcHNbaV1dID4gb3RoZXJbY29tcHNbaV1dKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbnVtZXJpYyB2YWx1ZSBmb3IgdGhlIHNwZWNpZmljaXR5LlxyXG4gICAgICogQHJldHVybiB7aW50fSBUaGUgbnVtZXJpYyB2YWx1ZSBmb3IgdGhlIHNwZWNpZmljaXR5LlxyXG4gICAgICogQG1ldGhvZCB2YWx1ZU9mXHJcbiAgICAgKi9cclxuICAgIHZhbHVlT2Y6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmEgKiAxMDAwKSArICh0aGlzLmIgKiAxMDApICsgKHRoaXMuYyAqIDEwKSArIHRoaXMuZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBzcGVjaWZpY2l0eS5cclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBzcGVjaWZpY2l0eS5cclxuICAgICAqIEBtZXRob2QgdG9TdHJpbmdcclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYSArIFwiLFwiICsgdGhpcy5iICsgXCIsXCIgKyB0aGlzLmMgKyBcIixcIiArIHRoaXMuZDtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3BlY2lmaWNpdHkgb2YgdGhlIGdpdmVuIHNlbGVjdG9yLlxyXG4gKiBAcGFyYW0ge3BhcnNlcmxpYi5jc3MuU2VsZWN0b3J9IFRoZSBzZWxlY3RvciB0byBjYWxjdWxhdGUgc3BlY2lmaWNpdHkgZm9yLlxyXG4gKiBAcmV0dXJuIHtwYXJzZXJsaWIuY3NzLlNwZWNpZmljaXR5fSBUaGUgc3BlY2lmaWNpdHkgb2YgdGhlIHNlbGVjdG9yLlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgY2FsY3VsYXRlXHJcbiAqL1xyXG5TcGVjaWZpY2l0eS5jYWxjdWxhdGUgPSBmdW5jdGlvbihzZWxlY3Rvcil7XHJcblxyXG4gICAgdmFyIGksIGxlbixcclxuICAgICAgICBwYXJ0LFxyXG4gICAgICAgIGI9MCwgYz0wLCBkPTA7XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlVmFsdWVzKHBhcnQpe1xyXG5cclxuICAgICAgICB2YXIgaSwgaiwgbGVuLCBudW0sXHJcbiAgICAgICAgICAgIGVsZW1lbnROYW1lID0gcGFydC5lbGVtZW50TmFtZSA/IHBhcnQuZWxlbWVudE5hbWUudGV4dCA6IFwiXCIsXHJcbiAgICAgICAgICAgIG1vZGlmaWVyO1xyXG5cclxuICAgICAgICBpZiAoZWxlbWVudE5hbWUgJiYgZWxlbWVudE5hbWUuY2hhckF0KGVsZW1lbnROYW1lLmxlbmd0aC0xKSAhPT0gXCIqXCIpIHtcclxuICAgICAgICAgICAgZCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpPTAsIGxlbj1wYXJ0Lm1vZGlmaWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XHJcbiAgICAgICAgICAgIG1vZGlmaWVyID0gcGFydC5tb2RpZmllcnNbaV07XHJcbiAgICAgICAgICAgIHN3aXRjaChtb2RpZmllci50eXBlKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJjbGFzc1wiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImF0dHJpYnV0ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGMrKztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiaWRcIjpcclxuICAgICAgICAgICAgICAgICAgICBiKys7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInBzZXVkb1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChQc2V1ZG9zLmlzRWxlbWVudChtb2RpZmllci50ZXh0KSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQrKztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgXCJub3RcIjpcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGo9MCwgbnVtPW1vZGlmaWVyLmFyZ3MubGVuZ3RoOyBqIDwgbnVtOyBqKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZXMobW9kaWZpZXIuYXJnc1tqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGk9MCwgbGVuPXNlbGVjdG9yLnBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcclxuICAgICAgICBwYXJ0ID0gc2VsZWN0b3IucGFydHNbaV07XHJcblxyXG4gICAgICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgU2VsZWN0b3JQYXJ0KXtcclxuICAgICAgICAgICAgdXBkYXRlVmFsdWVzKHBhcnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFNwZWNpZmljaXR5KDAsIGIsIGMsIGQpO1xyXG59O1xyXG5cclxudmFyIGggPSAvXlswLTlhLWZBLUZdJC8sXHJcbiAgICAvL25vbmFzY2lpID0gL15bXFx1MDA4MC1cXHVGRkZGXSQvLFxyXG4gICAgbmwgPSAvXFxufFxcclxcbnxcXHJ8XFxmLztcclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gSGVscGVyIGZ1bmN0aW9uc1xyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuZnVuY3Rpb24gaXNIZXhEaWdpdChjKXtcclxuICAgIHJldHVybiBjICE9PSBudWxsICYmIGgudGVzdChjKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNEaWdpdChjKXtcclxuICAgIHJldHVybiBjICE9PSBudWxsICYmIC9cXGQvLnRlc3QoYyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjKXtcclxuICAgIHJldHVybiBjICE9PSBudWxsICYmIC9cXHMvLnRlc3QoYyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTmV3TGluZShjKXtcclxuICAgIHJldHVybiBjICE9PSBudWxsICYmIG5sLnRlc3QoYyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTmFtZVN0YXJ0KGMpe1xyXG4gICAgcmV0dXJuIGMgIT09IG51bGwgJiYgKC9bYS16X1xcdTAwODAtXFx1RkZGRlxcXFxdL2kudGVzdChjKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTmFtZUNoYXIoYyl7XHJcbiAgICByZXR1cm4gYyAhPT0gbnVsbCAmJiAoaXNOYW1lU3RhcnQoYykgfHwgL1swLTlcXC1cXFxcXS8udGVzdChjKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzSWRlbnRTdGFydChjKXtcclxuICAgIHJldHVybiBjICE9PSBudWxsICYmIChpc05hbWVTdGFydChjKSB8fCAvXFwtXFxcXC8udGVzdChjKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1peChyZWNlaXZlciwgc3VwcGxpZXIpe1xyXG5cdGZvciAodmFyIHByb3AgaW4gc3VwcGxpZXIpe1xyXG5cdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdXBwbGllciwgcHJvcCkpe1xyXG5cdFx0XHRyZWNlaXZlcltwcm9wXSA9IHN1cHBsaWVyW3Byb3BdO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmVjZWl2ZXI7XHJcbn1cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gQ1NTIFRva2VuIFN0cmVhbVxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuLyoqXHJcbiAqIEEgdG9rZW4gc3RyZWFtIHRoYXQgcHJvZHVjZXMgQ1NTIHRva2Vucy5cclxuICogQHBhcmFtIHtTdHJpbmd8UmVhZGVyfSBpbnB1dCBUaGUgc291cmNlIG9mIHRleHQgdG8gdG9rZW5pemUuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAY2xhc3MgVG9rZW5TdHJlYW1cclxuICogQG5hbWVzcGFjZSBwYXJzZXJsaWIuY3NzXHJcbiAqL1xyXG5mdW5jdGlvbiBUb2tlblN0cmVhbShpbnB1dCl7XHJcblx0VG9rZW5TdHJlYW1CYXNlLmNhbGwodGhpcywgaW5wdXQsIFRva2Vucyk7XHJcbn1cclxuXHJcblRva2VuU3RyZWFtLnByb3RvdHlwZSA9IG1peChuZXcgVG9rZW5TdHJlYW1CYXNlKCksIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgVG9rZW5TdHJlYW1CYXNlIG1ldGhvZCBvZiB0aGUgc2FtZSBuYW1lXHJcbiAgICAgKiB0byBwcm9kdWNlIENTUyB0b2tlbnMuXHJcbiAgICAgKiBAcGFyYW0ge3ZhcmlhbnR9IGNoYW5uZWwgVGhlIG5hbWUgb2YgdGhlIGNoYW5uZWwgdG8gdXNlXHJcbiAgICAgKiAgICAgIGZvciB0aGUgbmV4dCB0b2tlbi5cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBuZXh0IHRva2VuLlxyXG4gICAgICogQG1ldGhvZCBfZ2V0VG9rZW5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9nZXRUb2tlbjogZnVuY3Rpb24oY2hhbm5lbCl7XHJcblxyXG4gICAgICAgIHZhciBjLFxyXG4gICAgICAgICAgICByZWFkZXIgPSB0aGlzLl9yZWFkZXIsXHJcbiAgICAgICAgICAgIHRva2VuICAgPSBudWxsLFxyXG4gICAgICAgICAgICBzdGFydExpbmUgICA9IHJlYWRlci5nZXRMaW5lKCksXHJcbiAgICAgICAgICAgIHN0YXJ0Q29sICAgID0gcmVhZGVyLmdldENvbCgpO1xyXG5cclxuICAgICAgICBjID0gcmVhZGVyLnJlYWQoKTtcclxuXHJcblxyXG4gICAgICAgIHdoaWxlKGMpe1xyXG4gICAgICAgICAgICBzd2l0Y2goYyl7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIFBvdGVudGlhbCB0b2tlbnM6XHJcbiAgICAgICAgICAgICAgICAgKiAtIENPTU1FTlRcclxuICAgICAgICAgICAgICAgICAqIC0gU0xBU0hcclxuICAgICAgICAgICAgICAgICAqIC0gQ0hBUlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiL1wiOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihyZWFkZXIucGVlaygpID09PSBcIipcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5jb21tZW50VG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmNoYXJUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIFBvdGVudGlhbCB0b2tlbnM6XHJcbiAgICAgICAgICAgICAgICAgKiAtIERBU0hNQVRDSFxyXG4gICAgICAgICAgICAgICAgICogLSBJTkNMVURFU1xyXG4gICAgICAgICAgICAgICAgICogLSBQUkVGSVhNQVRDSFxyXG4gICAgICAgICAgICAgICAgICogLSBTVUZGSVhNQVRDSFxyXG4gICAgICAgICAgICAgICAgICogLSBTVUJTVFJJTkdNQVRDSFxyXG4gICAgICAgICAgICAgICAgICogLSBDSEFSXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ8XCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiflwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIl5cIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCIkXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiKlwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHJlYWRlci5wZWVrKCkgPT09IFwiPVwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmNvbXBhcmlzb25Ub2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuY2hhclRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcclxuICAgICAgICAgICAgICAgICAqIC0gU1RSSU5HXHJcbiAgICAgICAgICAgICAgICAgKiAtIElOVkFMSURcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcXCJcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCInXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnN0cmluZ1Rva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBQb3RlbnRpYWwgdG9rZW5zOlxyXG4gICAgICAgICAgICAgICAgICogLSBIQVNIXHJcbiAgICAgICAgICAgICAgICAgKiAtIENIQVJcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIiNcIjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYW1lQ2hhcihyZWFkZXIucGVlaygpKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5oYXNoVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmNoYXJUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIFBvdGVudGlhbCB0b2tlbnM6XHJcbiAgICAgICAgICAgICAgICAgKiAtIERPVFxyXG4gICAgICAgICAgICAgICAgICogLSBOVU1CRVJcclxuICAgICAgICAgICAgICAgICAqIC0gRElNRU5TSU9OXHJcbiAgICAgICAgICAgICAgICAgKiAtIFBFUkNFTlRBR0VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIi5cIjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEaWdpdChyZWFkZXIucGVlaygpKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5udW1iZXJUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuY2hhclRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcclxuICAgICAgICAgICAgICAgICAqIC0gQ0RDXHJcbiAgICAgICAgICAgICAgICAgKiAtIE1JTlVTXHJcbiAgICAgICAgICAgICAgICAgKiAtIE5VTUJFUlxyXG4gICAgICAgICAgICAgICAgICogLSBESU1FTlNJT05cclxuICAgICAgICAgICAgICAgICAqIC0gUEVSQ0VOVEFHRVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiLVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFkZXIucGVlaygpID09PSBcIi1cIil7ICAvL2NvdWxkIGJlIGNsb3NpbmcgSFRNTC1zdHlsZSBjb21tZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5odG1sQ29tbWVudEVuZFRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYW1lU3RhcnQocmVhZGVyLnBlZWsoKSkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuaWRlbnRPckZ1bmN0aW9uVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmNoYXJUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIFBvdGVudGlhbCB0b2tlbnM6XHJcbiAgICAgICAgICAgICAgICAgKiAtIElNUE9SVEFOVF9TWU1cclxuICAgICAgICAgICAgICAgICAqIC0gQ0hBUlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiIVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5pbXBvcnRhbnRUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogQW55IGF0LWtleXdvcmQgb3IgQ0hBUlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiQFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5hdFJ1bGVUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcclxuICAgICAgICAgICAgICAgICAqIC0gTk9UXHJcbiAgICAgICAgICAgICAgICAgKiAtIENIQVJcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIjpcIjpcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubm90VG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIFBvdGVudGlhbCB0b2tlbnM6XHJcbiAgICAgICAgICAgICAgICAgKiAtIENET1xyXG4gICAgICAgICAgICAgICAgICogLSBDSEFSXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGNhc2UgXCI8XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmh0bWxDb21tZW50U3RhcnRUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcclxuICAgICAgICAgICAgICAgICAqIC0gVU5JQ09ERV9SQU5HRVxyXG4gICAgICAgICAgICAgICAgICogLSBVUkxcclxuICAgICAgICAgICAgICAgICAqIC0gQ0hBUlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiVVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInVcIjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZGVyLnBlZWsoKSA9PT0gXCIrXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudW5pY29kZVJhbmdlVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFBvdGVudGlhbCB0b2tlbnM6XHJcbiAgICAgICAgICAgICAgICAgICAgICogLSBOVU1CRVJcclxuICAgICAgICAgICAgICAgICAgICAgKiAtIERJTUVOU0lPTlxyXG4gICAgICAgICAgICAgICAgICAgICAqIC0gTEVOR1RIXHJcbiAgICAgICAgICAgICAgICAgICAgICogLSBGUkVRXHJcbiAgICAgICAgICAgICAgICAgICAgICogLSBUSU1FXHJcbiAgICAgICAgICAgICAgICAgICAgICogLSBFTVNcclxuICAgICAgICAgICAgICAgICAgICAgKiAtIEVYU1xyXG4gICAgICAgICAgICAgICAgICAgICAqIC0gQU5HTEVcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEaWdpdChjKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5udW1iZXJUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgKiBQb3RlbnRpYWwgdG9rZW5zOlxyXG4gICAgICAgICAgICAgICAgICAgICAqIC0gU1xyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMud2hpdGVzcGFjZVRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFBvdGVudGlhbCB0b2tlbnM6XHJcbiAgICAgICAgICAgICAgICAgICAgICogLSBJREVOVFxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0lkZW50U3RhcnQoYykpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuaWRlbnRPckZ1bmN0aW9uVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcclxuICAgICAgICAgICAgICAgICAgICAgKiAtIENIQVJcclxuICAgICAgICAgICAgICAgICAgICAgKiAtIFBMVVNcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5jaGFyVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL21ha2Ugc3VyZSB0aGlzIHRva2VuIGlzIHdhbnRlZFxyXG4gICAgICAgICAgICAvL1RPRE86IGNoZWNrIGNoYW5uZWxcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRva2VuICYmIGMgPT09IG51bGwpe1xyXG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMuY3JlYXRlVG9rZW4oVG9rZW5zLkVPRixudWxsLHN0YXJ0TGluZSxzdGFydENvbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICB9LFxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gTWV0aG9kcyB0byBjcmVhdGUgdG9rZW5zXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2R1Y2VzIGEgdG9rZW4gYmFzZWQgb24gYXZhaWxhYmxlIGRhdGEgYW5kIHRoZSBjdXJyZW50XHJcbiAgICAgKiByZWFkZXIgcG9zaXRpb24gaW5mb3JtYXRpb24uIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBvdGhlclxyXG4gICAgICogcHJpdmF0ZSBtZXRob2RzIHRvIGNyZWF0ZSB0b2tlbnMgYW5kIGlzIG5ldmVyIGNhbGxlZCBkaXJlY3RseS5cclxuICAgICAqIEBwYXJhbSB7aW50fSB0dCBUaGUgdG9rZW4gdHlwZS5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgdGV4dCB2YWx1ZSBvZiB0aGUgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRMaW5lIFRoZSBiZWdpbm5pbmcgbGluZSBmb3IgdGhlIGNoYXJhY3Rlci5cclxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydENvbCBUaGUgYmVnaW5uaW5nIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3Rlci5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIChPcHRpb25hbCkgU3BlY2lmaWVzIGEgY2hhbm5lbCBwcm9wZXJ0eVxyXG4gICAgICogICAgICB0byBpbmRpY2F0ZSB0aGF0IGEgZGlmZmVyZW50IGNoYW5uZWwgc2hvdWxkIGJlIHNjYW5uZWRcclxuICAgICAqICAgICAgYW5kL29yIGEgaGlkZSBwcm9wZXJ0eSBpbmRpY2F0aW5nIHRoYXQgdGhlIHRva2VuIHNob3VsZFxyXG4gICAgICogICAgICBiZSBoaWRkZW4uXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgdG9rZW4gb2JqZWN0LlxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVUb2tlblxyXG4gICAgICovXHJcbiAgICBjcmVhdGVUb2tlbjogZnVuY3Rpb24odHQsIHZhbHVlLCBzdGFydExpbmUsIHN0YXJ0Q29sLCBvcHRpb25zKXtcclxuICAgICAgICB2YXIgcmVhZGVyID0gdGhpcy5fcmVhZGVyO1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2YWx1ZTogICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgdHlwZTogICAgICAgdHQsXHJcbiAgICAgICAgICAgIGNoYW5uZWw6ICAgIG9wdGlvbnMuY2hhbm5lbCxcclxuICAgICAgICAgICAgZW5kQ2hhcjogICAgb3B0aW9ucy5lbmRDaGFyLFxyXG4gICAgICAgICAgICBoaWRlOiAgICAgICBvcHRpb25zLmhpZGUgfHwgZmFsc2UsXHJcbiAgICAgICAgICAgIHN0YXJ0TGluZTogIHN0YXJ0TGluZSxcclxuICAgICAgICAgICAgc3RhcnRDb2w6ICAgc3RhcnRDb2wsXHJcbiAgICAgICAgICAgIGVuZExpbmU6ICAgIHJlYWRlci5nZXRMaW5lKCksXHJcbiAgICAgICAgICAgIGVuZENvbDogICAgIHJlYWRlci5nZXRDb2woKVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gTWV0aG9kcyB0byBjcmVhdGUgc3BlY2lmaWMgdG9rZW5zXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2R1Y2VzIGEgdG9rZW4gZm9yIGFueSBhdC1ydWxlLiBJZiB0aGUgYXQtcnVsZSBpcyB1bmtub3duLCB0aGVuXHJcbiAgICAgKiB0aGUgdG9rZW4gaXMgZm9yIGEgc2luZ2xlIFwiQFwiIGNoYXJhY3Rlci5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaXJzdCBUaGUgZmlyc3QgY2hhcmFjdGVyIGZvciB0aGUgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRMaW5lIFRoZSBiZWdpbm5pbmcgbGluZSBmb3IgdGhlIGNoYXJhY3Rlci5cclxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydENvbCBUaGUgYmVnaW5uaW5nIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3Rlci5cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXHJcbiAgICAgKiBAbWV0aG9kIGF0UnVsZVRva2VuXHJcbiAgICAgKi9cclxuICAgIGF0UnVsZVRva2VuOiBmdW5jdGlvbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCl7XHJcbiAgICAgICAgdmFyIHJ1bGUgICAgPSBmaXJzdCxcclxuICAgICAgICAgICAgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcclxuICAgICAgICAgICAgdHQgICAgICA9IFRva2Vucy5DSEFSLFxyXG4gICAgICAgICAgICBpZGVudDtcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBGaXJzdCwgbWFyayB3aGVyZSB3ZSBhcmUuIFRoZXJlIGFyZSBvbmx5IGZvdXIgQCBydWxlcyxcclxuICAgICAgICAgKiBzbyBhbnl0aGluZyBlbHNlIGlzIHJlYWxseSBqdXN0IGFuIGludmFsaWQgdG9rZW4uXHJcbiAgICAgICAgICogQmFzaWNhbGx5LCBpZiB0aGlzIGRvZXNuJ3QgbWF0Y2ggb25lIG9mIHRoZSBrbm93biBAXHJcbiAgICAgICAgICogcnVsZXMsIGp1c3QgcmV0dXJuICdAJyBhcyBhbiB1bmtub3duIHRva2VuIGFuZCBhbGxvd1xyXG4gICAgICAgICAqIHBhcnNpbmcgdG8gY29udGludWUgYWZ0ZXIgdGhhdCBwb2ludC5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZWFkZXIubWFyaygpO1xyXG5cclxuICAgICAgICAvL3RyeSB0byBmaW5kIHRoZSBhdC1rZXl3b3JkXHJcbiAgICAgICAgaWRlbnQgPSB0aGlzLnJlYWROYW1lKCk7XHJcbiAgICAgICAgcnVsZSA9IGZpcnN0ICsgaWRlbnQ7XHJcbiAgICAgICAgdHQgPSBUb2tlbnMudHlwZShydWxlLnRvTG93ZXJDYXNlKCkpO1xyXG5cclxuICAgICAgICAvL2lmIGl0J3Mgbm90IHZhbGlkLCB1c2UgdGhlIGZpcnN0IGNoYXJhY3RlciBvbmx5IGFuZCByZXNldCB0aGUgcmVhZGVyXHJcbiAgICAgICAgaWYgKHR0ID09PSBUb2tlbnMuQ0hBUiB8fCB0dCA9PT0gVG9rZW5zLlVOS05PV04pe1xyXG4gICAgICAgICAgICBpZiAocnVsZS5sZW5ndGggPiAxKXtcclxuICAgICAgICAgICAgICAgIHR0ID0gVG9rZW5zLlVOS05PV05fU1lNO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHQgPSBUb2tlbnMuQ0hBUjtcclxuICAgICAgICAgICAgICAgIHJ1bGUgPSBmaXJzdDtcclxuICAgICAgICAgICAgICAgIHJlYWRlci5yZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbih0dCwgcnVsZSwgc3RhcnRMaW5lLCBzdGFydENvbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvZHVjZXMgYSBjaGFyYWN0ZXIgdG9rZW4gYmFzZWQgb24gdGhlIGdpdmVuIGNoYXJhY3RlclxyXG4gICAgICogYW5kIGxvY2F0aW9uIGluIHRoZSBzdHJlYW0uIElmIHRoZXJlJ3MgYSBzcGVjaWFsIChub24tc3RhbmRhcmQpXHJcbiAgICAgKiB0b2tlbiBuYW1lLCB0aGlzIGlzIHVzZWQ7IG90aGVyd2lzZSBDSEFSIGlzIHVzZWQuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYyBUaGUgY2hhcmFjdGVyIGZvciB0aGUgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRMaW5lIFRoZSBiZWdpbm5pbmcgbGluZSBmb3IgdGhlIGNoYXJhY3Rlci5cclxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydENvbCBUaGUgYmVnaW5uaW5nIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3Rlci5cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXHJcbiAgICAgKiBAbWV0aG9kIGNoYXJUb2tlblxyXG4gICAgICovXHJcbiAgICBjaGFyVG9rZW46IGZ1bmN0aW9uKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpe1xyXG4gICAgICAgIHZhciB0dCA9IFRva2Vucy50eXBlKGMpO1xyXG4gICAgICAgIHZhciBvcHRzID0ge307XHJcblxyXG4gICAgICAgIGlmICh0dCA9PT0gLTEpe1xyXG4gICAgICAgICAgICB0dCA9IFRva2Vucy5DSEFSO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdHMuZW5kQ2hhciA9IFRva2Vuc1t0dF0uZW5kQ2hhcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKHR0LCBjLCBzdGFydExpbmUsIHN0YXJ0Q29sLCBvcHRzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9kdWNlcyBhIGNoYXJhY3RlciB0b2tlbiBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2hhcmFjdGVyXHJcbiAgICAgKiBhbmQgbG9jYXRpb24gaW4gdGhlIHN0cmVhbS4gSWYgdGhlcmUncyBhIHNwZWNpYWwgKG5vbi1zdGFuZGFyZClcclxuICAgICAqIHRva2VuIG5hbWUsIHRoaXMgaXMgdXNlZDsgb3RoZXJ3aXNlIENIQVIgaXMgdXNlZC5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaXJzdCBUaGUgZmlyc3QgY2hhcmFjdGVyIGZvciB0aGUgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRMaW5lIFRoZSBiZWdpbm5pbmcgbGluZSBmb3IgdGhlIGNoYXJhY3Rlci5cclxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydENvbCBUaGUgYmVnaW5uaW5nIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3Rlci5cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXHJcbiAgICAgKiBAbWV0aG9kIGNvbW1lbnRUb2tlblxyXG4gICAgICovXHJcbiAgICBjb21tZW50VG9rZW46IGZ1bmN0aW9uKGZpcnN0LCBzdGFydExpbmUsIHN0YXJ0Q29sKXtcclxuICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMucmVhZENvbW1lbnQoZmlyc3QpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbihUb2tlbnMuQ09NTUVOVCwgY29tbWVudCwgc3RhcnRMaW5lLCBzdGFydENvbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvZHVjZXMgYSBjb21wYXJpc29uIHRva2VuIGJhc2VkIG9uIHRoZSBnaXZlbiBjaGFyYWN0ZXJcclxuICAgICAqIGFuZCBsb2NhdGlvbiBpbiB0aGUgc3RyZWFtLiBUaGUgbmV4dCBjaGFyYWN0ZXIgbXVzdCBiZVxyXG4gICAgICogcmVhZCBhbmQgaXMgYWxyZWFkeSBrbm93biB0byBiZSBhbiBlcXVhbHMgc2lnbi5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjIFRoZSBjaGFyYWN0ZXIgZm9yIHRoZSB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydExpbmUgVGhlIGJlZ2lubmluZyBsaW5lIGZvciB0aGUgY2hhcmFjdGVyLlxyXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHRva2VuIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgY29tcGFyaXNvblRva2VuXHJcbiAgICAgKi9cclxuICAgIGNvbXBhcmlzb25Ub2tlbjogZnVuY3Rpb24oYywgc3RhcnRMaW5lLCBzdGFydENvbCl7XHJcbiAgICAgICAgdmFyIHJlYWRlciAgPSB0aGlzLl9yZWFkZXIsXHJcbiAgICAgICAgICAgIGNvbXBhcmlzb24gID0gYyArIHJlYWRlci5yZWFkKCksXHJcbiAgICAgICAgICAgIHR0ICAgICAgPSBUb2tlbnMudHlwZShjb21wYXJpc29uKSB8fCBUb2tlbnMuQ0hBUjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVG9rZW4odHQsIGNvbXBhcmlzb24sIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2R1Y2VzIGEgaGFzaCB0b2tlbiBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGluZm9ybWF0aW9uLiBUaGVcclxuICAgICAqIGZpcnN0IGNoYXJhY3RlciBwcm92aWRlZCBpcyB0aGUgcG91bmQgc2lnbiAoIykgYW5kIHRoZW4gdGhpc1xyXG4gICAgICogbWV0aG9kIHJlYWRzIGEgbmFtZSBhZnRlcndhcmQuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlyc3QgVGhlIGZpcnN0IGNoYXJhY3RlciAoIykgaW4gdGhlIGhhc2ggbmFtZS5cclxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydExpbmUgVGhlIGJlZ2lubmluZyBsaW5lIGZvciB0aGUgY2hhcmFjdGVyLlxyXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHRva2VuIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgaGFzaFRva2VuXHJcbiAgICAgKi9cclxuICAgIGhhc2hUb2tlbjogZnVuY3Rpb24oZmlyc3QsIHN0YXJ0TGluZSwgc3RhcnRDb2wpe1xyXG4gICAgICAgIHZhciBuYW1lICAgID0gdGhpcy5yZWFkTmFtZShmaXJzdCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKFRva2Vucy5IQVNILCBuYW1lLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9kdWNlcyBhIENETyBvciBDSEFSIHRva2VuIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgaW5mb3JtYXRpb24uIFRoZVxyXG4gICAgICogZmlyc3QgY2hhcmFjdGVyIGlzIHByb3ZpZGVkIGFuZCB0aGUgcmVzdCBpcyByZWFkIGJ5IHRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmVcclxuICAgICAqIHRoZSBjb3JyZWN0IHRva2VuIHRvIGNyZWF0ZS5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaXJzdCBUaGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydExpbmUgVGhlIGJlZ2lubmluZyBsaW5lIGZvciB0aGUgY2hhcmFjdGVyLlxyXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHRva2VuIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgaHRtbENvbW1lbnRTdGFydFRva2VuXHJcbiAgICAgKi9cclxuICAgIGh0bWxDb21tZW50U3RhcnRUb2tlbjogZnVuY3Rpb24oZmlyc3QsIHN0YXJ0TGluZSwgc3RhcnRDb2wpe1xyXG4gICAgICAgIHZhciByZWFkZXIgICAgICA9IHRoaXMuX3JlYWRlcixcclxuICAgICAgICAgICAgdGV4dCAgICAgICAgPSBmaXJzdDtcclxuXHJcbiAgICAgICAgcmVhZGVyLm1hcmsoKTtcclxuICAgICAgICB0ZXh0ICs9IHJlYWRlci5yZWFkQ291bnQoMyk7XHJcblxyXG4gICAgICAgIGlmICh0ZXh0ID09PSBcIjwhLS1cIil7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKFRva2Vucy5DRE8sIHRleHQsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlYWRlci5yZXNldCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFyVG9rZW4oZmlyc3QsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9kdWNlcyBhIENEQyBvciBDSEFSIHRva2VuIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgaW5mb3JtYXRpb24uIFRoZVxyXG4gICAgICogZmlyc3QgY2hhcmFjdGVyIGlzIHByb3ZpZGVkIGFuZCB0aGUgcmVzdCBpcyByZWFkIGJ5IHRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmVcclxuICAgICAqIHRoZSBjb3JyZWN0IHRva2VuIHRvIGNyZWF0ZS5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaXJzdCBUaGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydExpbmUgVGhlIGJlZ2lubmluZyBsaW5lIGZvciB0aGUgY2hhcmFjdGVyLlxyXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHRva2VuIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgaHRtbENvbW1lbnRFbmRUb2tlblxyXG4gICAgICovXHJcbiAgICBodG1sQ29tbWVudEVuZFRva2VuOiBmdW5jdGlvbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCl7XHJcbiAgICAgICAgdmFyIHJlYWRlciAgICAgID0gdGhpcy5fcmVhZGVyLFxyXG4gICAgICAgICAgICB0ZXh0ICAgICAgICA9IGZpcnN0O1xyXG5cclxuICAgICAgICByZWFkZXIubWFyaygpO1xyXG4gICAgICAgIHRleHQgKz0gcmVhZGVyLnJlYWRDb3VudCgyKTtcclxuXHJcbiAgICAgICAgaWYgKHRleHQgPT09IFwiLS0+XCIpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbihUb2tlbnMuQ0RDLCB0ZXh0LCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZWFkZXIucmVzZXQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhclRva2VuKGZpcnN0LCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvZHVjZXMgYW4gSURFTlQgb3IgRlVOQ1RJT04gdG9rZW4gYmFzZWQgb24gdGhlIHNwZWNpZmllZCBpbmZvcm1hdGlvbi4gVGhlXHJcbiAgICAgKiBmaXJzdCBjaGFyYWN0ZXIgaXMgcHJvdmlkZWQgYW5kIHRoZSByZXN0IGlzIHJlYWQgYnkgdGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZVxyXG4gICAgICogdGhlIGNvcnJlY3QgdG9rZW4gdG8gY3JlYXRlLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpcnN0IFRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIGlkZW50aWZpZXIuXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRMaW5lIFRoZSBiZWdpbm5pbmcgbGluZSBmb3IgdGhlIGNoYXJhY3Rlci5cclxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydENvbCBUaGUgYmVnaW5uaW5nIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3Rlci5cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXHJcbiAgICAgKiBAbWV0aG9kIGlkZW50T3JGdW5jdGlvblRva2VuXHJcbiAgICAgKi9cclxuICAgIGlkZW50T3JGdW5jdGlvblRva2VuOiBmdW5jdGlvbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCl7XHJcbiAgICAgICAgdmFyIHJlYWRlciAgPSB0aGlzLl9yZWFkZXIsXHJcbiAgICAgICAgICAgIGlkZW50ICAgPSB0aGlzLnJlYWROYW1lKGZpcnN0KSxcclxuICAgICAgICAgICAgdHQgICAgICA9IFRva2Vucy5JREVOVCxcclxuICAgICAgICAgICAgdXJpRm5zICA9IFtcInVybChcIiwgXCJ1cmwtcHJlZml4KFwiLCBcImRvbWFpbihcIl07XHJcblxyXG4gICAgICAgIC8vaWYgdGhlcmUncyBhIGxlZnQgcGFyZW4gaW1tZWRpYXRlbHkgYWZ0ZXIsIGl0J3MgYSBVUkkgb3IgZnVuY3Rpb25cclxuICAgICAgICBpZiAocmVhZGVyLnBlZWsoKSA9PT0gXCIoXCIpe1xyXG4gICAgICAgICAgICBpZGVudCArPSByZWFkZXIucmVhZCgpO1xyXG4gICAgICAgICAgICBpZiAodXJpRm5zLmluZGV4T2YoaWRlbnQudG9Mb3dlckNhc2UoKSkgPiAtMSl7XHJcbiAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5VUkk7XHJcbiAgICAgICAgICAgICAgICBpZGVudCA9IHRoaXMucmVhZFVSSShpZGVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9kaWRuJ3QgZmluZCBhIHZhbGlkIFVSTCBvciB0aGVyZSdzIG5vIGNsb3NpbmcgcGFyZW5cclxuICAgICAgICAgICAgICAgIGlmICh1cmlGbnMuaW5kZXhPZihpZGVudC50b0xvd2VyQ2FzZSgpKSA+IC0xKXtcclxuICAgICAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5GVU5DVElPTjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHR0ID0gVG9rZW5zLkZVTkNUSU9OO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChyZWFkZXIucGVlaygpID09PSBcIjpcIil7ICAvL21pZ2h0IGJlIGFuIElFIGZ1bmN0aW9uXHJcblxyXG4gICAgICAgICAgICAvL0lFLXNwZWNpZmljIGZ1bmN0aW9ucyBhbHdheXMgYmVpbmcgd2l0aCBwcm9naWQ6XHJcbiAgICAgICAgICAgIGlmIChpZGVudC50b0xvd2VyQ2FzZSgpID09PSBcInByb2dpZFwiKXtcclxuICAgICAgICAgICAgICAgIGlkZW50ICs9IHJlYWRlci5yZWFkVG8oXCIoXCIpO1xyXG4gICAgICAgICAgICAgICAgdHQgPSBUb2tlbnMuSUVfRlVOQ1RJT047XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKHR0LCBpZGVudCwgc3RhcnRMaW5lLCBzdGFydENvbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvZHVjZXMgYW4gSU1QT1JUQU5UX1NZTSBvciBDSEFSIHRva2VuIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgaW5mb3JtYXRpb24uIFRoZVxyXG4gICAgICogZmlyc3QgY2hhcmFjdGVyIGlzIHByb3ZpZGVkIGFuZCB0aGUgcmVzdCBpcyByZWFkIGJ5IHRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmVcclxuICAgICAqIHRoZSBjb3JyZWN0IHRva2VuIHRvIGNyZWF0ZS5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaXJzdCBUaGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydExpbmUgVGhlIGJlZ2lubmluZyBsaW5lIGZvciB0aGUgY2hhcmFjdGVyLlxyXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHRva2VuIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgaW1wb3J0YW50VG9rZW5cclxuICAgICAqL1xyXG4gICAgaW1wb3J0YW50VG9rZW46IGZ1bmN0aW9uKGZpcnN0LCBzdGFydExpbmUsIHN0YXJ0Q29sKXtcclxuICAgICAgICB2YXIgcmVhZGVyICAgICAgPSB0aGlzLl9yZWFkZXIsXHJcbiAgICAgICAgICAgIGltcG9ydGFudCAgID0gZmlyc3QsXHJcbiAgICAgICAgICAgIHR0ICAgICAgICAgID0gVG9rZW5zLkNIQVIsXHJcbiAgICAgICAgICAgIHRlbXAsXHJcbiAgICAgICAgICAgIGM7XHJcblxyXG4gICAgICAgIHJlYWRlci5tYXJrKCk7XHJcbiAgICAgICAgYyA9IHJlYWRlci5yZWFkKCk7XHJcblxyXG4gICAgICAgIHdoaWxlKGMpe1xyXG5cclxuICAgICAgICAgICAgLy90aGVyZSBjYW4gYmUgYSBjb21tZW50IGluIGhlcmVcclxuICAgICAgICAgICAgaWYgKGMgPT09IFwiL1wiKXtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2lmIHRoZSBuZXh0IGNoYXJhY3RlciBpc24ndCBhIHN0YXIsIHRoZW4gdGhpcyBpc24ndCBhIHZhbGlkICFpbXBvcnRhbnQgdG9rZW5cclxuICAgICAgICAgICAgICAgIGlmIChyZWFkZXIucGVlaygpICE9PSBcIipcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSB0aGlzLnJlYWRDb21tZW50KGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wID09PSBcIlwiKXsgICAgLy9icm9rZW4hXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpe1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0YW50ICs9IGMgKyB0aGlzLnJlYWRXaGl0ZXNwYWNlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL2kvaS50ZXN0KGMpKXtcclxuICAgICAgICAgICAgICAgIHRlbXAgPSByZWFkZXIucmVhZENvdW50KDgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKC9tcG9ydGFudC9pLnRlc3QodGVtcCkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGFudCArPSBjICsgdGVtcDtcclxuICAgICAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5JTVBPUlRBTlRfU1lNO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrOyAgLy93ZSdyZSBkb25lXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYyA9IHJlYWRlci5yZWFkKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHQgPT09IFRva2Vucy5DSEFSKXtcclxuICAgICAgICAgICAgcmVhZGVyLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJUb2tlbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVG9rZW4odHQsIGltcG9ydGFudCwgc3RhcnRMaW5lLCBzdGFydENvbCk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvZHVjZXMgYSBOT1Qgb3IgQ0hBUiB0b2tlbiBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGluZm9ybWF0aW9uLiBUaGVcclxuICAgICAqIGZpcnN0IGNoYXJhY3RlciBpcyBwcm92aWRlZCBhbmQgdGhlIHJlc3QgaXMgcmVhZCBieSB0aGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lXHJcbiAgICAgKiB0aGUgY29ycmVjdCB0b2tlbiB0byBjcmVhdGUuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlyc3QgVGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRMaW5lIFRoZSBiZWdpbm5pbmcgbGluZSBmb3IgdGhlIGNoYXJhY3Rlci5cclxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydENvbCBUaGUgYmVnaW5uaW5nIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3Rlci5cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXHJcbiAgICAgKiBAbWV0aG9kIG5vdFRva2VuXHJcbiAgICAgKi9cclxuICAgIG5vdFRva2VuOiBmdW5jdGlvbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCl7XHJcbiAgICAgICAgdmFyIHJlYWRlciAgICAgID0gdGhpcy5fcmVhZGVyLFxyXG4gICAgICAgICAgICB0ZXh0ICAgICAgICA9IGZpcnN0O1xyXG5cclxuICAgICAgICByZWFkZXIubWFyaygpO1xyXG4gICAgICAgIHRleHQgKz0gcmVhZGVyLnJlYWRDb3VudCg0KTtcclxuXHJcbiAgICAgICAgaWYgKHRleHQudG9Mb3dlckNhc2UoKSA9PT0gXCI6bm90KFwiKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVG9rZW4oVG9rZW5zLk5PVCwgdGV4dCwgc3RhcnRMaW5lLCBzdGFydENvbCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVhZGVyLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJUb2tlbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2R1Y2VzIGEgbnVtYmVyIHRva2VuIGJhc2VkIG9uIHRoZSBnaXZlbiBjaGFyYWN0ZXJcclxuICAgICAqIGFuZCBsb2NhdGlvbiBpbiB0aGUgc3RyZWFtLiBUaGlzIG1heSByZXR1cm4gYSB0b2tlbiBvZlxyXG4gICAgICogTlVNQkVSLCBFTVMsIEVYUywgTEVOR1RILCBBTkdMRSwgVElNRSwgRlJFUSwgRElNRU5TSU9OLFxyXG4gICAgICogb3IgUEVSQ0VOVEFHRS5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaXJzdCBUaGUgZmlyc3QgY2hhcmFjdGVyIGZvciB0aGUgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRMaW5lIFRoZSBiZWdpbm5pbmcgbGluZSBmb3IgdGhlIGNoYXJhY3Rlci5cclxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydENvbCBUaGUgYmVnaW5uaW5nIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3Rlci5cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXHJcbiAgICAgKiBAbWV0aG9kIG51bWJlclRva2VuXHJcbiAgICAgKi9cclxuICAgIG51bWJlclRva2VuOiBmdW5jdGlvbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCl7XHJcbiAgICAgICAgdmFyIHJlYWRlciAgPSB0aGlzLl9yZWFkZXIsXHJcbiAgICAgICAgICAgIHZhbHVlICAgPSB0aGlzLnJlYWROdW1iZXIoZmlyc3QpLFxyXG4gICAgICAgICAgICBpZGVudCxcclxuICAgICAgICAgICAgdHQgICAgICA9IFRva2Vucy5OVU1CRVIsXHJcbiAgICAgICAgICAgIGMgICAgICAgPSByZWFkZXIucGVlaygpO1xyXG5cclxuICAgICAgICBpZiAoaXNJZGVudFN0YXJ0KGMpKXtcclxuICAgICAgICAgICAgaWRlbnQgPSB0aGlzLnJlYWROYW1lKHJlYWRlci5yZWFkKCkpO1xyXG4gICAgICAgICAgICB2YWx1ZSArPSBpZGVudDtcclxuXHJcbiAgICAgICAgICAgIGlmICgvXmVtJHxeZXgkfF5weCR8XmdkJHxecmVtJHxednckfF52aCR8XnZtYXgkfF52bWluJHxeY2gkfF5jbSR8Xm1tJHxeaW4kfF5wdCR8XnBjJC9pLnRlc3QoaWRlbnQpKXtcclxuICAgICAgICAgICAgICAgIHR0ID0gVG9rZW5zLkxFTkdUSDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICgvXmRlZ3xecmFkJHxeZ3JhZCQvaS50ZXN0KGlkZW50KSl7XHJcbiAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5BTkdMRTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICgvXm1zJHxecyQvaS50ZXN0KGlkZW50KSl7XHJcbiAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5USU1FO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9eaHokfF5raHokL2kudGVzdChpZGVudCkpe1xyXG4gICAgICAgICAgICAgICAgdHQgPSBUb2tlbnMuRlJFUTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICgvXmRwaSR8XmRwY20kL2kudGVzdChpZGVudCkpe1xyXG4gICAgICAgICAgICAgICAgdHQgPSBUb2tlbnMuUkVTT0xVVElPTjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHR0ID0gVG9rZW5zLkRJTUVOU0lPTjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKGMgPT09IFwiJVwiKXtcclxuICAgICAgICAgICAgdmFsdWUgKz0gcmVhZGVyLnJlYWQoKTtcclxuICAgICAgICAgICAgdHQgPSBUb2tlbnMuUEVSQ0VOVEFHRTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKHR0LCB2YWx1ZSwgc3RhcnRMaW5lLCBzdGFydENvbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvZHVjZXMgYSBzdHJpbmcgdG9rZW4gYmFzZWQgb24gdGhlIGdpdmVuIGNoYXJhY3RlclxyXG4gICAgICogYW5kIGxvY2F0aW9uIGluIHRoZSBzdHJlYW0uIFNpbmNlIHN0cmluZ3MgbWF5IGJlIGluZGljYXRlZFxyXG4gICAgICogYnkgc2luZ2xlIG9yIGRvdWJsZSBxdW90ZXMsIGEgZmFpbHVyZSB0byBtYXRjaCBzdGFydGluZ1xyXG4gICAgICogYW5kIGVuZGluZyBxdW90ZXMgcmVzdWx0cyBpbiBhbiBJTlZBTElEIHRva2VuIGJlaW5nIGdlbmVyYXRlZC5cclxuICAgICAqIFRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZyBpcyBwYXNzZWQgaW4gYW5kIHRoZW5cclxuICAgICAqIHRoZSByZXN0IGFyZSByZWFkIHVwIHRvIGFuZCBpbmNsdWRpbmcgdGhlIGZpbmFsIHF1b3RhdGlvbiBtYXJrLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpcnN0IFRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydExpbmUgVGhlIGJlZ2lubmluZyBsaW5lIGZvciB0aGUgY2hhcmFjdGVyLlxyXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHRva2VuIG9iamVjdC5cclxuICAgICAqIEBtZXRob2Qgc3RyaW5nVG9rZW5cclxuICAgICAqL1xyXG4gICAgc3RyaW5nVG9rZW46IGZ1bmN0aW9uKGZpcnN0LCBzdGFydExpbmUsIHN0YXJ0Q29sKXtcclxuICAgICAgICB2YXIgZGVsaW0gICA9IGZpcnN0LFxyXG4gICAgICAgICAgICBzdHJpbmcgID0gZmlyc3QsXHJcbiAgICAgICAgICAgIHJlYWRlciAgPSB0aGlzLl9yZWFkZXIsXHJcbiAgICAgICAgICAgIHByZXYgICAgPSBmaXJzdCxcclxuICAgICAgICAgICAgdHQgICAgICA9IFRva2Vucy5TVFJJTkcsXHJcbiAgICAgICAgICAgIGMgICAgICAgPSByZWFkZXIucmVhZCgpO1xyXG5cclxuICAgICAgICB3aGlsZShjKXtcclxuICAgICAgICAgICAgc3RyaW5nICs9IGM7XHJcblxyXG4gICAgICAgICAgICAvL2lmIHRoZSBkZWxpbWl0ZXIgaXMgZm91bmQgd2l0aCBhbiBlc2NhcGVtZW50LCB3ZSdyZSBkb25lLlxyXG4gICAgICAgICAgICBpZiAoYyA9PT0gZGVsaW0gJiYgcHJldiAhPT0gXCJcXFxcXCIpe1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vaWYgdGhlcmUncyBhIG5ld2xpbmUgd2l0aG91dCBhbiBlc2NhcGVtZW50LCBpdCdzIGFuIGludmFsaWQgc3RyaW5nXHJcbiAgICAgICAgICAgIGlmIChpc05ld0xpbmUocmVhZGVyLnBlZWsoKSkgJiYgYyAhPT0gXCJcXFxcXCIpe1xyXG4gICAgICAgICAgICAgICAgdHQgPSBUb2tlbnMuSU5WQUxJRDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL3NhdmUgcHJldmlvdXMgYW5kIGdldCBuZXh0XHJcbiAgICAgICAgICAgIHByZXYgPSBjO1xyXG4gICAgICAgICAgICBjID0gcmVhZGVyLnJlYWQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vaWYgYyBpcyBudWxsLCB0aGF0IG1lYW5zIHdlJ3JlIG91dCBvZiBpbnB1dCBhbmQgdGhlIHN0cmluZyB3YXMgbmV2ZXIgY2xvc2VkXHJcbiAgICAgICAgaWYgKGMgPT09IG51bGwpe1xyXG4gICAgICAgICAgICB0dCA9IFRva2Vucy5JTlZBTElEO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVG9rZW4odHQsIHN0cmluZywgc3RhcnRMaW5lLCBzdGFydENvbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVuaWNvZGVSYW5nZVRva2VuOiBmdW5jdGlvbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCl7XHJcbiAgICAgICAgdmFyIHJlYWRlciAgPSB0aGlzLl9yZWFkZXIsXHJcbiAgICAgICAgICAgIHZhbHVlICAgPSBmaXJzdCxcclxuICAgICAgICAgICAgdGVtcCxcclxuICAgICAgICAgICAgdHQgICAgICA9IFRva2Vucy5DSEFSO1xyXG5cclxuICAgICAgICAvL3RoZW4gaXQgc2hvdWxkIGJlIGEgdW5pY29kZSByYW5nZVxyXG4gICAgICAgIGlmIChyZWFkZXIucGVlaygpID09PSBcIitcIil7XHJcbiAgICAgICAgICAgIHJlYWRlci5tYXJrKCk7XHJcbiAgICAgICAgICAgIHZhbHVlICs9IHJlYWRlci5yZWFkKCk7XHJcbiAgICAgICAgICAgIHZhbHVlICs9IHRoaXMucmVhZFVuaWNvZGVSYW5nZVBhcnQodHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAvL2Vuc3VyZSB0aGVyZSdzIGFuIGFjdHVhbCB1bmljb2RlIHJhbmdlIGhlcmVcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMil7XHJcbiAgICAgICAgICAgICAgICByZWFkZXIucmVzZXQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5VTklDT0RFX1JBTkdFO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBhID8gaW4gdGhlIGZpcnN0IHBhcnQsIHRoZXJlIGNhbid0IGJlIGEgc2Vjb25kIHBhcnRcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKFwiP1wiKSA9PT0gLTEpe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZGVyLnBlZWsoKSA9PT0gXCItXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIubWFyaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gcmVhZGVyLnJlYWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCArPSB0aGlzLnJlYWRVbmljb2RlUmFuZ2VQYXJ0KGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBub3QgYW5vdGhlciB2YWx1ZSwgYmFjayB1cCBhbmQganVzdCB0YWtlIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcC5sZW5ndGggPT09IDEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVG9rZW4odHQsIHZhbHVlLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9kdWNlcyBhIFMgdG9rZW4gYmFzZWQgb24gdGhlIHNwZWNpZmllZCBpbmZvcm1hdGlvbi4gU2luY2Ugd2hpdGVzcGFjZVxyXG4gICAgICogbWF5IGhhdmUgbXVsdGlwbGUgY2hhcmFjdGVycywgdGhpcyBjb25zdW1lcyBhbGwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXHJcbiAgICAgKiBpbnRvIGEgc2luZ2xlIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpcnN0IFRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0TGluZSBUaGUgYmVnaW5uaW5nIGxpbmUgZm9yIHRoZSBjaGFyYWN0ZXIuXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRDb2wgVGhlIGJlZ2lubmluZyBjb2x1bW4gZm9yIHRoZSBjaGFyYWN0ZXIuXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgdG9rZW4gb2JqZWN0LlxyXG4gICAgICogQG1ldGhvZCB3aGl0ZXNwYWNlVG9rZW5cclxuICAgICAqL1xyXG4gICAgd2hpdGVzcGFjZVRva2VuOiBmdW5jdGlvbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCl7XHJcbiAgICAgICAgdmFyIHZhbHVlICAgPSBmaXJzdCArIHRoaXMucmVhZFdoaXRlc3BhY2UoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbihUb2tlbnMuUywgdmFsdWUsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xyXG4gICAgfSxcclxuXHJcblxyXG5cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIE1ldGhvZHMgdG8gcmVhZCB2YWx1ZXMgZnJvbSB0aGUgc3RyaW5nIHN0cmVhbVxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgcmVhZFVuaWNvZGVSYW5nZVBhcnQ6IGZ1bmN0aW9uKGFsbG93UXVlc3Rpb25NYXJrKXtcclxuICAgICAgICB2YXIgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcclxuICAgICAgICAgICAgcGFydCA9IFwiXCIsXHJcbiAgICAgICAgICAgIGMgICAgICAgPSByZWFkZXIucGVlaygpO1xyXG5cclxuICAgICAgICAvL2ZpcnN0IHJlYWQgaGV4IGRpZ2l0c1xyXG4gICAgICAgIHdoaWxlKGlzSGV4RGlnaXQoYykgJiYgcGFydC5sZW5ndGggPCA2KXtcclxuICAgICAgICAgICAgcmVhZGVyLnJlYWQoKTtcclxuICAgICAgICAgICAgcGFydCArPSBjO1xyXG4gICAgICAgICAgICBjID0gcmVhZGVyLnBlZWsoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdGhlbiByZWFkIHF1ZXN0aW9uIG1hcmtzIGlmIGFsbG93ZWRcclxuICAgICAgICBpZiAoYWxsb3dRdWVzdGlvbk1hcmspe1xyXG4gICAgICAgICAgICB3aGlsZShjID09PSBcIj9cIiAmJiBwYXJ0Lmxlbmd0aCA8IDYpe1xyXG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWQoKTtcclxuICAgICAgICAgICAgICAgIHBhcnQgKz0gYztcclxuICAgICAgICAgICAgICAgIGMgPSByZWFkZXIucGVlaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3RoZXJlIGNhbid0IGJlIGFueSBvdGhlciBjaGFyYWN0ZXJzIGFmdGVyIHRoaXMgcG9pbnRcclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcnQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlYWRXaGl0ZXNwYWNlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciByZWFkZXIgID0gdGhpcy5fcmVhZGVyLFxyXG4gICAgICAgICAgICB3aGl0ZXNwYWNlID0gXCJcIixcclxuICAgICAgICAgICAgYyAgICAgICA9IHJlYWRlci5wZWVrKCk7XHJcblxyXG4gICAgICAgIHdoaWxlKGlzV2hpdGVzcGFjZShjKSl7XHJcbiAgICAgICAgICAgIHJlYWRlci5yZWFkKCk7XHJcbiAgICAgICAgICAgIHdoaXRlc3BhY2UgKz0gYztcclxuICAgICAgICAgICAgYyA9IHJlYWRlci5wZWVrKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gd2hpdGVzcGFjZTtcclxuICAgIH0sXHJcbiAgICByZWFkTnVtYmVyOiBmdW5jdGlvbihmaXJzdCl7XHJcbiAgICAgICAgdmFyIHJlYWRlciAgPSB0aGlzLl9yZWFkZXIsXHJcbiAgICAgICAgICAgIG51bWJlciAgPSBmaXJzdCxcclxuICAgICAgICAgICAgaGFzRG90ICA9IChmaXJzdCA9PT0gXCIuXCIpLFxyXG4gICAgICAgICAgICBjICAgICAgID0gcmVhZGVyLnBlZWsoKTtcclxuXHJcblxyXG4gICAgICAgIHdoaWxlKGMpe1xyXG4gICAgICAgICAgICBpZiAoaXNEaWdpdChjKSl7XHJcbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gcmVhZGVyLnJlYWQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBcIi5cIil7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRG90KXtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzRG90ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gcmVhZGVyLnJlYWQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjID0gcmVhZGVyLnBlZWsoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudW1iZXI7XHJcbiAgICB9LFxyXG4gICAgcmVhZFN0cmluZzogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcclxuICAgICAgICAgICAgZGVsaW0gICA9IHJlYWRlci5yZWFkKCksXHJcbiAgICAgICAgICAgIHN0cmluZyAgPSBkZWxpbSxcclxuICAgICAgICAgICAgcHJldiAgICA9IGRlbGltLFxyXG4gICAgICAgICAgICBjICAgICAgID0gcmVhZGVyLnBlZWsoKTtcclxuXHJcbiAgICAgICAgd2hpbGUoYyl7XHJcbiAgICAgICAgICAgIGMgPSByZWFkZXIucmVhZCgpO1xyXG4gICAgICAgICAgICBzdHJpbmcgKz0gYztcclxuXHJcbiAgICAgICAgICAgIC8vaWYgdGhlIGRlbGltaXRlciBpcyBmb3VuZCB3aXRoIGFuIGVzY2FwZW1lbnQsIHdlJ3JlIGRvbmUuXHJcbiAgICAgICAgICAgIGlmIChjID09PSBkZWxpbSAmJiBwcmV2ICE9PSBcIlxcXFxcIil7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9pZiB0aGVyZSdzIGEgbmV3bGluZSB3aXRob3V0IGFuIGVzY2FwZW1lbnQsIGl0J3MgYW4gaW52YWxpZCBzdHJpbmdcclxuICAgICAgICAgICAgaWYgKGlzTmV3TGluZShyZWFkZXIucGVlaygpKSAmJiBjICE9PSBcIlxcXFxcIil7XHJcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vc2F2ZSBwcmV2aW91cyBhbmQgZ2V0IG5leHRcclxuICAgICAgICAgICAgcHJldiA9IGM7XHJcbiAgICAgICAgICAgIGMgPSByZWFkZXIucGVlaygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9pZiBjIGlzIG51bGwsIHRoYXQgbWVhbnMgd2UncmUgb3V0IG9mIGlucHV0IGFuZCB0aGUgc3RyaW5nIHdhcyBuZXZlciBjbG9zZWRcclxuICAgICAgICBpZiAoYyA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3RyaW5nO1xyXG4gICAgfSxcclxuICAgIHJlYWRVUkk6IGZ1bmN0aW9uKGZpcnN0KXtcclxuICAgICAgICB2YXIgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcclxuICAgICAgICAgICAgdXJpICAgICA9IGZpcnN0LFxyXG4gICAgICAgICAgICBpbm5lciAgID0gXCJcIixcclxuICAgICAgICAgICAgYyAgICAgICA9IHJlYWRlci5wZWVrKCk7XHJcblxyXG4gICAgICAgIHJlYWRlci5tYXJrKCk7XHJcblxyXG4gICAgICAgIC8vc2tpcCB3aGl0ZXNwYWNlIGJlZm9yZVxyXG4gICAgICAgIHdoaWxlKGMgJiYgaXNXaGl0ZXNwYWNlKGMpKXtcclxuICAgICAgICAgICAgcmVhZGVyLnJlYWQoKTtcclxuICAgICAgICAgICAgYyA9IHJlYWRlci5wZWVrKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2l0J3MgYSBzdHJpbmdcclxuICAgICAgICBpZiAoYyA9PT0gXCInXCIgfHwgYyA9PT0gXCJcXFwiXCIpe1xyXG4gICAgICAgICAgICBpbm5lciA9IHRoaXMucmVhZFN0cmluZygpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlubmVyID0gdGhpcy5yZWFkVVJMKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjID0gcmVhZGVyLnBlZWsoKTtcclxuXHJcbiAgICAgICAgLy9za2lwIHdoaXRlc3BhY2UgYWZ0ZXJcclxuICAgICAgICB3aGlsZShjICYmIGlzV2hpdGVzcGFjZShjKSl7XHJcbiAgICAgICAgICAgIHJlYWRlci5yZWFkKCk7XHJcbiAgICAgICAgICAgIGMgPSByZWFkZXIucGVlaygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9pZiB0aGVyZSB3YXMgbm8gaW5uZXIgdmFsdWUgb3IgdGhlIG5leHQgY2hhcmFjdGVyIGlzbid0IGNsb3NpbmcgcGFyZW4sIGl0J3Mgbm90IGEgVVJJXHJcbiAgICAgICAgaWYgKGlubmVyID09PSBcIlwiIHx8IGMgIT09IFwiKVwiKXtcclxuICAgICAgICAgICAgdXJpID0gZmlyc3Q7XHJcbiAgICAgICAgICAgIHJlYWRlci5yZXNldCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHVyaSArPSBpbm5lciArIHJlYWRlci5yZWFkKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdXJpO1xyXG4gICAgfSxcclxuICAgIHJlYWRVUkw6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHJlYWRlciAgPSB0aGlzLl9yZWFkZXIsXHJcbiAgICAgICAgICAgIHVybCAgICAgPSBcIlwiLFxyXG4gICAgICAgICAgICBjICAgICAgID0gcmVhZGVyLnBlZWsoKTtcclxuXHJcbiAgICAgICAgLy9UT0RPOiBDaGVjayBmb3IgZXNjYXBlIGFuZCBub25hc2NpaVxyXG4gICAgICAgIHdoaWxlICgvXlshIyQlJlxcXFwqLX5dJC8udGVzdChjKSl7XHJcbiAgICAgICAgICAgIHVybCArPSByZWFkZXIucmVhZCgpO1xyXG4gICAgICAgICAgICBjID0gcmVhZGVyLnBlZWsoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB1cmw7XHJcblxyXG4gICAgfSxcclxuICAgIHJlYWROYW1lOiBmdW5jdGlvbihmaXJzdCl7XHJcbiAgICAgICAgdmFyIHJlYWRlciAgPSB0aGlzLl9yZWFkZXIsXHJcbiAgICAgICAgICAgIGlkZW50ICAgPSBmaXJzdCB8fCBcIlwiLFxyXG4gICAgICAgICAgICBjICAgICAgID0gcmVhZGVyLnBlZWsoKTtcclxuXHJcbiAgICAgICAgd2hpbGUodHJ1ZSl7XHJcbiAgICAgICAgICAgIGlmIChjID09PSBcIlxcXFxcIil7XHJcbiAgICAgICAgICAgICAgICBpZGVudCArPSB0aGlzLnJlYWRFc2NhcGUocmVhZGVyLnJlYWQoKSk7XHJcbiAgICAgICAgICAgICAgICBjID0gcmVhZGVyLnBlZWsoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKGMgJiYgaXNOYW1lQ2hhcihjKSl7XHJcbiAgICAgICAgICAgICAgICBpZGVudCArPSByZWFkZXIucmVhZCgpO1xyXG4gICAgICAgICAgICAgICAgYyA9IHJlYWRlci5wZWVrKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGlkZW50O1xyXG4gICAgfSxcclxuXHJcbiAgICByZWFkRXNjYXBlOiBmdW5jdGlvbihmaXJzdCl7XHJcbiAgICAgICAgdmFyIHJlYWRlciAgPSB0aGlzLl9yZWFkZXIsXHJcbiAgICAgICAgICAgIGNzc0VzY2FwZSA9IGZpcnN0IHx8IFwiXCIsXHJcbiAgICAgICAgICAgIGkgICAgICAgPSAwLFxyXG4gICAgICAgICAgICBjICAgICAgID0gcmVhZGVyLnBlZWsoKTtcclxuXHJcbiAgICAgICAgaWYgKGlzSGV4RGlnaXQoYykpe1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBjc3NFc2NhcGUgKz0gcmVhZGVyLnJlYWQoKTtcclxuICAgICAgICAgICAgICAgIGMgPSByZWFkZXIucGVlaygpO1xyXG4gICAgICAgICAgICB9IHdoaWxlKGMgJiYgaXNIZXhEaWdpdChjKSAmJiArK2kgPCA2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjc3NFc2NhcGUubGVuZ3RoID09PSAzICYmIC9cXHMvLnRlc3QoYykgfHxcclxuICAgICAgICAgICAgY3NzRXNjYXBlLmxlbmd0aCA9PT0gNyB8fCBjc3NFc2NhcGUubGVuZ3RoID09PSAxKXtcclxuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYyA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY3NzRXNjYXBlICsgYztcclxuICAgIH0sXHJcblxyXG4gICAgcmVhZENvbW1lbnQ6IGZ1bmN0aW9uKGZpcnN0KXtcclxuICAgICAgICB2YXIgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcclxuICAgICAgICAgICAgY29tbWVudCA9IGZpcnN0IHx8IFwiXCIsXHJcbiAgICAgICAgICAgIGMgICAgICAgPSByZWFkZXIucmVhZCgpO1xyXG5cclxuICAgICAgICBpZiAoYyA9PT0gXCIqXCIpe1xyXG4gICAgICAgICAgICB3aGlsZShjKXtcclxuICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gYztcclxuXHJcbiAgICAgICAgICAgICAgICAvL2xvb2sgZm9yIGVuZCBvZiBjb21tZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5sZW5ndGggPiAyICYmIGMgPT09IFwiKlwiICYmIHJlYWRlci5wZWVrKCkgPT09IFwiL1wiKXtcclxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IHJlYWRlci5yZWFkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYyA9IHJlYWRlci5yZWFkKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjb21tZW50O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxudmFyIFRva2VucyAgPSBbXHJcblxyXG4gICAgLypcclxuICAgICAqIFRoZSBmb2xsb3dpbmcgdG9rZW4gbmFtZXMgYXJlIGRlZmluZWQgaW4gQ1NTMyBHcmFtbWFyOiBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC8jbGV4aWNhbFxyXG4gICAgICovXHJcblxyXG4gICAgLy9IVE1MLXN0eWxlIGNvbW1lbnRzXHJcbiAgICB7IG5hbWU6IFwiQ0RPXCJ9LFxyXG4gICAgeyBuYW1lOiBcIkNEQ1wifSxcclxuXHJcbiAgICAvL2lnbm9yYWJsZXNcclxuICAgIHsgbmFtZTogXCJTXCIsIHdoaXRlc3BhY2U6IHRydWUvKiwgY2hhbm5lbDogXCJ3c1wiKi99LFxyXG4gICAgeyBuYW1lOiBcIkNPTU1FTlRcIiwgY29tbWVudDogdHJ1ZSwgaGlkZTogdHJ1ZSwgY2hhbm5lbDogXCJjb21tZW50XCIgfSxcclxuXHJcbiAgICAvL2F0dHJpYnV0ZSBlcXVhbGl0eVxyXG4gICAgeyBuYW1lOiBcIklOQ0xVREVTXCIsIHRleHQ6IFwifj1cIn0sXHJcbiAgICB7IG5hbWU6IFwiREFTSE1BVENIXCIsIHRleHQ6IFwifD1cIn0sXHJcbiAgICB7IG5hbWU6IFwiUFJFRklYTUFUQ0hcIiwgdGV4dDogXCJePVwifSxcclxuICAgIHsgbmFtZTogXCJTVUZGSVhNQVRDSFwiLCB0ZXh0OiBcIiQ9XCJ9LFxyXG4gICAgeyBuYW1lOiBcIlNVQlNUUklOR01BVENIXCIsIHRleHQ6IFwiKj1cIn0sXHJcblxyXG4gICAgLy9pZGVudGlmaWVyIHR5cGVzXHJcbiAgICB7IG5hbWU6IFwiU1RSSU5HXCJ9LFxyXG4gICAgeyBuYW1lOiBcIklERU5UXCJ9LFxyXG4gICAgeyBuYW1lOiBcIkhBU0hcIn0sXHJcblxyXG4gICAgLy9hdC1rZXl3b3Jkc1xyXG4gICAgeyBuYW1lOiBcIklNUE9SVF9TWU1cIiwgdGV4dDogXCJAaW1wb3J0XCJ9LFxyXG4gICAgeyBuYW1lOiBcIlBBR0VfU1lNXCIsIHRleHQ6IFwiQHBhZ2VcIn0sXHJcbiAgICB7IG5hbWU6IFwiTUVESUFfU1lNXCIsIHRleHQ6IFwiQG1lZGlhXCJ9LFxyXG4gICAgeyBuYW1lOiBcIkZPTlRfRkFDRV9TWU1cIiwgdGV4dDogXCJAZm9udC1mYWNlXCJ9LFxyXG4gICAgeyBuYW1lOiBcIkNIQVJTRVRfU1lNXCIsIHRleHQ6IFwiQGNoYXJzZXRcIn0sXHJcbiAgICB7IG5hbWU6IFwiTkFNRVNQQUNFX1NZTVwiLCB0ZXh0OiBcIkBuYW1lc3BhY2VcIn0sXHJcbiAgICB7IG5hbWU6IFwiVklFV1BPUlRfU1lNXCIsIHRleHQ6IFtcIkB2aWV3cG9ydFwiLCBcIkAtbXMtdmlld3BvcnRcIiwgXCJALW8tdmlld3BvcnRcIl19LFxyXG4gICAgeyBuYW1lOiBcIkRPQ1VNRU5UX1NZTVwiLCB0ZXh0OiBbXCJAZG9jdW1lbnRcIiwgXCJALW1vei1kb2N1bWVudFwiXX0sXHJcbiAgICB7IG5hbWU6IFwiVU5LTk9XTl9TWU1cIiB9LFxyXG4gICAgLy97IG5hbWU6IFwiQVRLRVlXT1JEXCJ9LFxyXG5cclxuICAgIC8vQ1NTMyBhbmltYXRpb25zXHJcbiAgICB7IG5hbWU6IFwiS0VZRlJBTUVTX1NZTVwiLCB0ZXh0OiBbIFwiQGtleWZyYW1lc1wiLCBcIkAtd2Via2l0LWtleWZyYW1lc1wiLCBcIkAtbW96LWtleWZyYW1lc1wiLCBcIkAtby1rZXlmcmFtZXNcIiBdIH0sXHJcblxyXG4gICAgLy9pbXBvcnRhbnQgc3ltYm9sXHJcbiAgICB7IG5hbWU6IFwiSU1QT1JUQU5UX1NZTVwifSxcclxuXHJcbiAgICAvL21lYXN1cmVtZW50c1xyXG4gICAgeyBuYW1lOiBcIkxFTkdUSFwifSxcclxuICAgIHsgbmFtZTogXCJBTkdMRVwifSxcclxuICAgIHsgbmFtZTogXCJUSU1FXCJ9LFxyXG4gICAgeyBuYW1lOiBcIkZSRVFcIn0sXHJcbiAgICB7IG5hbWU6IFwiRElNRU5TSU9OXCJ9LFxyXG4gICAgeyBuYW1lOiBcIlBFUkNFTlRBR0VcIn0sXHJcbiAgICB7IG5hbWU6IFwiTlVNQkVSXCJ9LFxyXG5cclxuICAgIC8vZnVuY3Rpb25zXHJcbiAgICB7IG5hbWU6IFwiVVJJXCJ9LFxyXG4gICAgeyBuYW1lOiBcIkZVTkNUSU9OXCJ9LFxyXG5cclxuICAgIC8vVW5pY29kZSByYW5nZXNcclxuICAgIHsgbmFtZTogXCJVTklDT0RFX1JBTkdFXCJ9LFxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgZm9sbG93aW5nIHRva2VuIG5hbWVzIGFyZSBkZWZpbmVkIGluIENTUzMgU2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jc2VsZWN0b3Itc3ludGF4XHJcbiAgICAgKi9cclxuXHJcbiAgICAvL2ludmFsaWQgc3RyaW5nXHJcbiAgICB7IG5hbWU6IFwiSU5WQUxJRFwifSxcclxuXHJcbiAgICAvL2NvbWJpbmF0b3JzXHJcbiAgICB7IG5hbWU6IFwiUExVU1wiLCB0ZXh0OiBcIitcIiB9LFxyXG4gICAgeyBuYW1lOiBcIkdSRUFURVJcIiwgdGV4dDogXCI+XCJ9LFxyXG4gICAgeyBuYW1lOiBcIkNPTU1BXCIsIHRleHQ6IFwiLFwifSxcclxuICAgIHsgbmFtZTogXCJUSUxERVwiLCB0ZXh0OiBcIn5cIn0sXHJcblxyXG4gICAgLy9tb2RpZmllclxyXG4gICAgeyBuYW1lOiBcIk5PVFwifSxcclxuXHJcbiAgICAvKlxyXG4gICAgICogRGVmaW5lZCBpbiBDU1MzIFBhZ2VkIE1lZGlhXHJcbiAgICAgKi9cclxuICAgIHsgbmFtZTogXCJUT1BMRUZUQ09STkVSX1NZTVwiLCB0ZXh0OiBcIkB0b3AtbGVmdC1jb3JuZXJcIn0sXHJcbiAgICB7IG5hbWU6IFwiVE9QTEVGVF9TWU1cIiwgdGV4dDogXCJAdG9wLWxlZnRcIn0sXHJcbiAgICB7IG5hbWU6IFwiVE9QQ0VOVEVSX1NZTVwiLCB0ZXh0OiBcIkB0b3AtY2VudGVyXCJ9LFxyXG4gICAgeyBuYW1lOiBcIlRPUFJJR0hUX1NZTVwiLCB0ZXh0OiBcIkB0b3AtcmlnaHRcIn0sXHJcbiAgICB7IG5hbWU6IFwiVE9QUklHSFRDT1JORVJfU1lNXCIsIHRleHQ6IFwiQHRvcC1yaWdodC1jb3JuZXJcIn0sXHJcbiAgICB7IG5hbWU6IFwiQk9UVE9NTEVGVENPUk5FUl9TWU1cIiwgdGV4dDogXCJAYm90dG9tLWxlZnQtY29ybmVyXCJ9LFxyXG4gICAgeyBuYW1lOiBcIkJPVFRPTUxFRlRfU1lNXCIsIHRleHQ6IFwiQGJvdHRvbS1sZWZ0XCJ9LFxyXG4gICAgeyBuYW1lOiBcIkJPVFRPTUNFTlRFUl9TWU1cIiwgdGV4dDogXCJAYm90dG9tLWNlbnRlclwifSxcclxuICAgIHsgbmFtZTogXCJCT1RUT01SSUdIVF9TWU1cIiwgdGV4dDogXCJAYm90dG9tLXJpZ2h0XCJ9LFxyXG4gICAgeyBuYW1lOiBcIkJPVFRPTVJJR0hUQ09STkVSX1NZTVwiLCB0ZXh0OiBcIkBib3R0b20tcmlnaHQtY29ybmVyXCJ9LFxyXG4gICAgeyBuYW1lOiBcIkxFRlRUT1BfU1lNXCIsIHRleHQ6IFwiQGxlZnQtdG9wXCJ9LFxyXG4gICAgeyBuYW1lOiBcIkxFRlRNSURETEVfU1lNXCIsIHRleHQ6IFwiQGxlZnQtbWlkZGxlXCJ9LFxyXG4gICAgeyBuYW1lOiBcIkxFRlRCT1RUT01fU1lNXCIsIHRleHQ6IFwiQGxlZnQtYm90dG9tXCJ9LFxyXG4gICAgeyBuYW1lOiBcIlJJR0hUVE9QX1NZTVwiLCB0ZXh0OiBcIkByaWdodC10b3BcIn0sXHJcbiAgICB7IG5hbWU6IFwiUklHSFRNSURETEVfU1lNXCIsIHRleHQ6IFwiQHJpZ2h0LW1pZGRsZVwifSxcclxuICAgIHsgbmFtZTogXCJSSUdIVEJPVFRPTV9TWU1cIiwgdGV4dDogXCJAcmlnaHQtYm90dG9tXCJ9LFxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgZm9sbG93aW5nIHRva2VuIG5hbWVzIGFyZSBkZWZpbmVkIGluIENTUzMgTWVkaWEgUXVlcmllczogaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1tZWRpYXF1ZXJpZXMvI3N5bnRheFxyXG4gICAgICovXHJcbiAgICAvKnsgbmFtZTogXCJNRURJQV9PTkxZXCIsIHN0YXRlOiBcIm1lZGlhXCJ9LFxyXG4gICAgeyBuYW1lOiBcIk1FRElBX05PVFwiLCBzdGF0ZTogXCJtZWRpYVwifSxcclxuICAgIHsgbmFtZTogXCJNRURJQV9BTkRcIiwgc3RhdGU6IFwibWVkaWFcIn0sKi9cclxuICAgIHsgbmFtZTogXCJSRVNPTFVUSU9OXCIsIHN0YXRlOiBcIm1lZGlhXCJ9LFxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgZm9sbG93aW5nIHRva2VuIG5hbWVzIGFyZSBub3QgZGVmaW5lZCBpbiBhbnkgQ1NTIHNwZWNpZmljYXRpb24gYnV0IGFyZSB1c2VkIGJ5IHRoZSBsZXhlci5cclxuICAgICAqL1xyXG5cclxuICAgIC8vbm90IGEgcmVhbCB0b2tlbiwgYnV0IHVzZWZ1bCBmb3Igc3R1cGlkIElFIGZpbHRlcnNcclxuICAgIHsgbmFtZTogXCJJRV9GVU5DVElPTlwiIH0sXHJcblxyXG4gICAgLy9wYXJ0IG9mIENTUzMgZ3JhbW1hciBidXQgbm90IHRoZSBGbGV4IGNvZGVcclxuICAgIHsgbmFtZTogXCJDSEFSXCIgfSxcclxuXHJcbiAgICAvL1RPRE86IE5lZWRlZD9cclxuICAgIC8vTm90IGRlZmluZWQgYXMgdG9rZW5zLCBidXQgbWlnaHQgYXMgd2VsbCBiZVxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6IFwiUElQRVwiLFxyXG4gICAgICAgIHRleHQ6IFwifFwiXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6IFwiU0xBU0hcIixcclxuICAgICAgICB0ZXh0OiBcIi9cIlxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiBcIk1JTlVTXCIsXHJcbiAgICAgICAgdGV4dDogXCItXCJcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogXCJTVEFSXCIsXHJcbiAgICAgICAgdGV4dDogXCIqXCJcclxuICAgIH0sXHJcblxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6IFwiTEJSQUNFXCIsXHJcbiAgICAgICAgZW5kQ2hhcjogXCJ9XCIsXHJcbiAgICAgICAgdGV4dDogXCJ7XCJcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogXCJSQlJBQ0VcIixcclxuICAgICAgICB0ZXh0OiBcIn1cIlxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiBcIkxCUkFDS0VUXCIsXHJcbiAgICAgICAgZW5kQ2hhcjogXCJdXCIsXHJcbiAgICAgICAgdGV4dDogXCJbXCJcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogXCJSQlJBQ0tFVFwiLFxyXG4gICAgICAgIHRleHQ6IFwiXVwiXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6IFwiRVFVQUxTXCIsXHJcbiAgICAgICAgdGV4dDogXCI9XCJcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogXCJDT0xPTlwiLFxyXG4gICAgICAgIHRleHQ6IFwiOlwiXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6IFwiU0VNSUNPTE9OXCIsXHJcbiAgICAgICAgdGV4dDogXCI7XCJcclxuICAgIH0sXHJcblxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6IFwiTFBBUkVOXCIsXHJcbiAgICAgICAgZW5kQ2hhcjogXCIpXCIsXHJcbiAgICAgICAgdGV4dDogXCIoXCJcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogXCJSUEFSRU5cIixcclxuICAgICAgICB0ZXh0OiBcIilcIlxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiBcIkRPVFwiLFxyXG4gICAgICAgIHRleHQ6IFwiLlwiXHJcbiAgICB9XHJcbl07XHJcblxyXG4oZnVuY3Rpb24oKXtcclxuXHJcbiAgICB2YXIgbmFtZU1hcCA9IFtdLFxyXG4gICAgICAgIHR5cGVNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuICAgIFRva2Vucy5VTktOT1dOID0gLTE7XHJcbiAgICBUb2tlbnMudW5zaGlmdCh7bmFtZTpcIkVPRlwifSk7XHJcbiAgICBmb3IgKHZhciBpPTAsIGxlbiA9IFRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XHJcbiAgICAgICAgbmFtZU1hcC5wdXNoKFRva2Vuc1tpXS5uYW1lKTtcclxuICAgICAgICBUb2tlbnNbVG9rZW5zW2ldLm5hbWVdID0gaTtcclxuICAgICAgICBpZiAoVG9rZW5zW2ldLnRleHQpe1xyXG4gICAgICAgICAgICBpZiAoVG9rZW5zW2ldLnRleHQgaW5zdGFuY2VvZiBBcnJheSl7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGogPCBUb2tlbnNbaV0udGV4dC5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZU1hcFtUb2tlbnNbaV0udGV4dFtqXV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHlwZU1hcFtUb2tlbnNbaV0udGV4dF0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIFRva2Vucy5uYW1lID0gZnVuY3Rpb24odHQpe1xyXG4gICAgICAgIHJldHVybiBuYW1lTWFwW3R0XTtcclxuICAgIH07XHJcblxyXG4gICAgVG9rZW5zLnR5cGUgPSBmdW5jdGlvbihjKXtcclxuICAgICAgICByZXR1cm4gdHlwZU1hcFtjXSB8fCAtMTtcclxuICAgIH07XHJcblxyXG59KSgpO1xyXG5cclxuXHJcblxyXG4vL1RoaXMgZmlsZSB3aWxsIGxpa2VseSBjaGFuZ2UgYSBsb3QhIFZlcnkgZXhwZXJpbWVudGFsIVxyXG52YXIgVmFsaWRhdGlvbiA9IHtcclxuXHJcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKXtcclxuXHJcbiAgICAgICAgLy9ub3JtYWxpemUgbmFtZVxyXG4gICAgICAgIHZhciBuYW1lICAgICAgICA9IHByb3BlcnR5LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSxcclxuICAgICAgICAgICAgZXhwcmVzc2lvbiAgPSBuZXcgUHJvcGVydHlWYWx1ZUl0ZXJhdG9yKHZhbHVlKSxcclxuICAgICAgICAgICAgc3BlYyAgICAgICAgPSBQcm9wZXJ0aWVzW25hbWVdO1xyXG5cclxuICAgICAgICBpZiAoIXNwZWMpIHtcclxuICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZihcIi1cIikgIT09IDApeyAgICAvL3ZlbmRvciBwcmVmaXhlZCBhcmUgb2tcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJVbmtub3duIHByb3BlcnR5ICdcIiArIHByb3BlcnR5ICsgXCInLlwiLCBwcm9wZXJ0eS5saW5lLCBwcm9wZXJ0eS5jb2wpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyAhPT0gXCJudW1iZXJcIil7XHJcblxyXG4gICAgICAgICAgICAvL2luaXRpYWxpemF0aW9uXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BlYyA9PT0gXCJzdHJpbmdcIil7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5pbmRleE9mKFwifHxcIikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBQcm9wZXJ0eShzcGVjLCBleHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaW5nbGVQcm9wZXJ0eShzcGVjLCBleHByZXNzaW9uLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BlYy5tdWx0aSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aVByb3BlcnR5KHNwZWMubXVsdGksIGV4cHJlc3Npb24sIHNwZWMuY29tbWEsIHNwZWMubWF4IHx8IEluZmluaXR5KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBzcGVjKGV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNpbmdsZVByb3BlcnR5OiBmdW5jdGlvbih0eXBlcywgZXhwcmVzc2lvbiwgbWF4LCBwYXJ0aWFsKSB7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgICAgICA9IGZhbHNlLFxyXG4gICAgICAgICAgICB2YWx1ZSAgICAgICA9IGV4cHJlc3Npb24udmFsdWUsXHJcbiAgICAgICAgICAgIGNvdW50ICAgICAgID0gMCxcclxuICAgICAgICAgICAgcGFydDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGV4cHJlc3Npb24uaGFzTmV4dCgpICYmIGNvdW50IDwgbWF4KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCB0eXBlcyk7XHJcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24uaGFzTmV4dCgpICYmICFleHByZXNzaW9uLmlzRmlyc3QoKSkge1xyXG4gICAgICAgICAgICAgICAgcGFydCA9IGV4cHJlc3Npb24ucGVlaygpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIGVuZCBvZiB2YWx1ZSBidXQgZm91bmQgJ1wiICsgcGFydCArIFwiJy5cIiwgcGFydC5saW5lLCBwYXJ0LmNvbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIChcIiArIHR5cGVzICsgXCIpIGJ1dCBmb3VuZCAnXCIgKyB2YWx1ZSArIFwiJy5cIiwgdmFsdWUubGluZSwgdmFsdWUuY29sKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbi5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgcGFydCA9IGV4cHJlc3Npb24ubmV4dCgpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgZW5kIG9mIHZhbHVlIGJ1dCBmb3VuZCAnXCIgKyBwYXJ0ICsgXCInLlwiLCBwYXJ0LmxpbmUsIHBhcnQuY29sKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aVByb3BlcnR5OiBmdW5jdGlvbiAodHlwZXMsIGV4cHJlc3Npb24sIGNvbW1hLCBtYXgpIHtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCAgICAgID0gZmFsc2UsXHJcbiAgICAgICAgICAgIHZhbHVlICAgICAgID0gZXhwcmVzc2lvbi52YWx1ZSxcclxuICAgICAgICAgICAgY291bnQgICAgICAgPSAwLFxyXG4gICAgICAgICAgICBwYXJ0O1xyXG5cclxuICAgICAgICB3aGlsZShleHByZXNzaW9uLmhhc05leHQoKSAmJiAhcmVzdWx0ICYmIGNvdW50IDwgbWF4KSB7XHJcbiAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgdHlwZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFleHByZXNzaW9uLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChTdHJpbmcoZXhwcmVzc2lvbi5wZWVrKCkpID09PSBcIixcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5oYXNOZXh0KCkgJiYgIWV4cHJlc3Npb24uaXNGaXJzdCgpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5wZWVrKCk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgZW5kIG9mIHZhbHVlIGJ1dCBmb3VuZCAnXCIgKyBwYXJ0ICsgXCInLlwiLCBwYXJ0LmxpbmUsIHBhcnQuY29sKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcnQgPSBleHByZXNzaW9uLnByZXZpb3VzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tbWEgJiYgU3RyaW5nKHBhcnQpID09PSBcIixcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJFeHBlY3RlZCBlbmQgb2YgdmFsdWUgYnV0IGZvdW5kICdcIiArIHBhcnQgKyBcIicuXCIsIHBhcnQubGluZSwgcGFydC5jb2wpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgKFwiICsgdHlwZXMgKyBcIikgYnV0IGZvdW5kICdcIiArIHZhbHVlICsgXCInLlwiLCB2YWx1ZS5saW5lLCB2YWx1ZS5jb2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbi5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgcGFydCA9IGV4cHJlc3Npb24ubmV4dCgpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgZW5kIG9mIHZhbHVlIGJ1dCBmb3VuZCAnXCIgKyBwYXJ0ICsgXCInLlwiLCBwYXJ0LmxpbmUsIHBhcnQuY29sKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBncm91cFByb3BlcnR5OiBmdW5jdGlvbiAodHlwZXMsIGV4cHJlc3Npb24sIGNvbW1hKSB7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgICAgICA9IGZhbHNlLFxyXG4gICAgICAgICAgICB2YWx1ZSAgICAgICA9IGV4cHJlc3Npb24udmFsdWUsXHJcbiAgICAgICAgICAgIHR5cGVDb3VudCAgID0gdHlwZXMuc3BsaXQoXCJ8fFwiKS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGdyb3VwcyAgICAgID0geyBjb3VudDogMCB9LFxyXG4gICAgICAgICAgICBwYXJ0aWFsICAgICA9IGZhbHNlLFxyXG4gICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICBwYXJ0O1xyXG5cclxuICAgICAgICB3aGlsZShleHByZXNzaW9uLmhhc05leHQoKSAmJiAhcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBWYWxpZGF0aW9uVHlwZXMuaXNBbnlPZkdyb3VwKGV4cHJlc3Npb24sIHR5cGVzKTtcclxuICAgICAgICAgICAgaWYgKG5hbWUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvL25vIGR1cGVzXHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBzW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwc1tuYW1lXSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzLmNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cHMuY291bnQgPT09IHR5cGVDb3VudCB8fCAhZXhwcmVzc2lvbi5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgaWYgKHBhcnRpYWwgJiYgZXhwcmVzc2lvbi5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5wZWVrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIGVuZCBvZiB2YWx1ZSBidXQgZm91bmQgJ1wiICsgcGFydCArIFwiJy5cIiwgcGFydC5saW5lLCBwYXJ0LmNvbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgKFwiICsgdHlwZXMgKyBcIikgYnV0IGZvdW5kICdcIiArIHZhbHVlICsgXCInLlwiLCB2YWx1ZS5saW5lLCB2YWx1ZS5jb2wpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChleHByZXNzaW9uLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5uZXh0KCk7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJFeHBlY3RlZCBlbmQgb2YgdmFsdWUgYnV0IGZvdW5kICdcIiArIHBhcnQgKyBcIicuXCIsIHBhcnQubGluZSwgcGFydC5jb2wpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxufTtcclxuLyoqXHJcbiAqIFR5cGUgdG8gdXNlIHdoZW4gYSB2YWxpZGF0aW9uIGVycm9yIG9jY3Vycy5cclxuICogQGNsYXNzIFZhbGlkYXRpb25FcnJvclxyXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi51dGlsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cclxuICogQHBhcmFtIHtpbnR9IGxpbmUgVGhlIGxpbmUgYXQgd2hpY2ggdGhlIGVycm9yIG9jY3VycmVkLlxyXG4gKiBAcGFyYW0ge2ludH0gY29sIFRoZSBjb2x1bW4gYXQgd2hpY2ggdGhlIGVycm9yIG9jY3VycmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9yKG1lc3NhZ2UsIGxpbmUsIGNvbCl7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29sdW1uIGF0IHdoaWNoIHRoZSBlcnJvciBvY2N1cnJlZC5cclxuICAgICAqIEB0eXBlIGludFxyXG4gICAgICogQHByb3BlcnR5IGNvbFxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbCA9IGNvbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsaW5lIGF0IHdoaWNoIHRoZSBlcnJvciBvY2N1cnJlZC5cclxuICAgICAqIEB0eXBlIGludFxyXG4gICAgICogQHByb3BlcnR5IGxpbmVcclxuICAgICAqL1xyXG4gICAgdGhpcy5saW5lID0gbGluZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bml0LlxyXG4gICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgKiBAcHJvcGVydHkgdGV4dFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG5cclxufVxyXG5cclxuLy9pbmhlcml0IGZyb20gRXJyb3JcclxuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xyXG4vL1RoaXMgZmlsZSB3aWxsIGxpa2VseSBjaGFuZ2UgYSBsb3QhIFZlcnkgZXhwZXJpbWVudGFsIVxyXG52YXIgVmFsaWRhdGlvblR5cGVzID0ge1xyXG5cclxuICAgIGlzTGl0ZXJhbDogZnVuY3Rpb24gKHBhcnQsIGxpdGVyYWxzKSB7XHJcbiAgICAgICAgdmFyIHRleHQgPSBwYXJ0LnRleHQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgICAgICBhcmdzID0gbGl0ZXJhbHMuc3BsaXQoXCIgfCBcIiksXHJcbiAgICAgICAgICAgIGksIGxlbiwgZm91bmQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZm9yIChpPTAsbGVuPWFyZ3MubGVuZ3RoOyBpIDwgbGVuICYmICFmb3VuZDsgaSsrKXtcclxuICAgICAgICAgICAgaWYgKHRleHQgPT09IGFyZ3NbaV0udG9Mb3dlckNhc2UoKSl7XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmb3VuZDtcclxuICAgIH0sXHJcblxyXG4gICAgaXNTaW1wbGU6IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLnNpbXBsZVt0eXBlXTtcclxuICAgIH0sXHJcblxyXG4gICAgaXNDb21wbGV4OiBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jb21wbGV4W3R5cGVdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgaWYgdGhlIG5leHQgcGFydChzKSBvZiB0aGUgZ2l2ZW4gZXhwcmVzc2lvblxyXG4gICAgICogYXJlIGFueSBvZiB0aGUgZ2l2ZW4gdHlwZXMuXHJcbiAgICAgKi9cclxuICAgIGlzQW55OiBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgdHlwZXMpIHtcclxuICAgICAgICB2YXIgYXJncyA9IHR5cGVzLnNwbGl0KFwiIHwgXCIpLFxyXG4gICAgICAgICAgICBpLCBsZW4sIGZvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvciAoaT0wLGxlbj1hcmdzLmxlbmd0aDsgaSA8IGxlbiAmJiAhZm91bmQgJiYgZXhwcmVzc2lvbi5oYXNOZXh0KCk7IGkrKyl7XHJcbiAgICAgICAgICAgIGZvdW5kID0gdGhpcy5pc1R5cGUoZXhwcmVzc2lvbiwgYXJnc1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgbmV4dCBwYXJ0KHMpIG9mIHRoZSBnaXZlbiBleHByZXNzaW9uXHJcbiAgICAgKiBhcmUgb25lIG9mIGEgZ3JvdXAuXHJcbiAgICAgKi9cclxuICAgIGlzQW55T2ZHcm91cDogZnVuY3Rpb24oZXhwcmVzc2lvbiwgdHlwZXMpIHtcclxuICAgICAgICB2YXIgYXJncyA9IHR5cGVzLnNwbGl0KFwiIHx8IFwiKSxcclxuICAgICAgICAgICAgaSwgbGVuLCBmb3VuZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmb3IgKGk9MCxsZW49YXJncy5sZW5ndGg7IGkgPCBsZW4gJiYgIWZvdW5kOyBpKyspe1xyXG4gICAgICAgICAgICBmb3VuZCA9IHRoaXMuaXNUeXBlKGV4cHJlc3Npb24sIGFyZ3NbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZvdW5kID8gYXJnc1tpLTFdIDogZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgbmV4dCBwYXJ0KHMpIG9mIHRoZSBnaXZlbiBleHByZXNzaW9uXHJcbiAgICAgKiBhcmUgb2YgYSBnaXZlbiB0eXBlLlxyXG4gICAgICovXHJcbiAgICBpc1R5cGU6IGZ1bmN0aW9uIChleHByZXNzaW9uLCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIHBhcnQgPSBleHByZXNzaW9uLnBlZWsoKSxcclxuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICh0eXBlLmNoYXJBdCgwKSAhPT0gXCI8XCIpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5pc0xpdGVyYWwocGFydCwgdHlwZSk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24ubmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNpbXBsZVt0eXBlXSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnNpbXBsZVt0eXBlXShwYXJ0KTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5uZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNvbXBsZXhbdHlwZV0oZXhwcmVzc2lvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuXHJcblxyXG5cclxuICAgIHNpbXBsZToge1xyXG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcclxuXHJcbiAgICAgICAgXCI8YWJzb2x1dGUtc2l6ZT5cIjogZnVuY3Rpb24ocGFydCl7XHJcbiAgICAgICAgICAgIHJldHVybiBWYWxpZGF0aW9uVHlwZXMuaXNMaXRlcmFsKHBhcnQsIFwieHgtc21hbGwgfCB4LXNtYWxsIHwgc21hbGwgfCBtZWRpdW0gfCBsYXJnZSB8IHgtbGFyZ2UgfCB4eC1sYXJnZVwiKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIjxhdHRhY2htZW50PlwiOiBmdW5jdGlvbihwYXJ0KXtcclxuICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRpb25UeXBlcy5pc0xpdGVyYWwocGFydCwgXCJzY3JvbGwgfCBmaXhlZCB8IGxvY2FsXCIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiPGF0dHI+XCI6IGZ1bmN0aW9uKHBhcnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgcGFydC5uYW1lID09PSBcImF0dHJcIjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIjxiZy1pbWFnZT5cIjogZnVuY3Rpb24ocGFydCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiPGltYWdlPlwiXShwYXJ0KSB8fCB0aGlzW1wiPGdyYWRpZW50PlwiXShwYXJ0KSB8fCAgU3RyaW5nKHBhcnQpID09PSBcIm5vbmVcIjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIjxncmFkaWVudD5cIjogZnVuY3Rpb24ocGFydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgL14oPzpcXC0oPzptc3xtb3p8b3x3ZWJraXQpXFwtKT8oPzpyZXBlYXRpbmdcXC0pPyg/OnJhZGlhbFxcLXxsaW5lYXJcXC0pP2dyYWRpZW50L2kudGVzdChwYXJ0KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIjxib3g+XCI6IGZ1bmN0aW9uKHBhcnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdGlvblR5cGVzLmlzTGl0ZXJhbChwYXJ0LCBcInBhZGRpbmctYm94IHwgYm9yZGVyLWJveCB8IGNvbnRlbnQtYm94XCIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiPGNvbnRlbnQ+XCI6IGZ1bmN0aW9uKHBhcnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgcGFydC5uYW1lID09PSBcImNvbnRlbnRcIjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIjxyZWxhdGl2ZS1zaXplPlwiOiBmdW5jdGlvbihwYXJ0KXtcclxuICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRpb25UeXBlcy5pc0xpdGVyYWwocGFydCwgXCJzbWFsbGVyIHwgbGFyZ2VyXCIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vYW55IGlkZW50aWZpZXJcclxuICAgICAgICBcIjxpZGVudD5cIjogZnVuY3Rpb24ocGFydCl7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwiaWRlbnRpZmllclwiO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiPGxlbmd0aD5cIjogZnVuY3Rpb24ocGFydCl7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiAvXig/OlxcLSg/Om1zfG1venxvfHdlYmtpdClcXC0pP2NhbGMvaS50ZXN0KHBhcnQpKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwibGVuZ3RoXCIgfHwgcGFydC50eXBlID09PSBcIm51bWJlclwiIHx8IHBhcnQudHlwZSA9PT0gXCJpbnRlZ2VyXCIgfHwgU3RyaW5nKHBhcnQpID09PSBcIjBcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiPGNvbG9yPlwiOiBmdW5jdGlvbihwYXJ0KXtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJjb2xvclwiIHx8IFN0cmluZyhwYXJ0KSA9PT0gXCJ0cmFuc3BhcmVudFwiIHx8IFN0cmluZyhwYXJ0KSA9PT0gXCJjdXJyZW50Q29sb3JcIjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIjxudW1iZXI+XCI6IGZ1bmN0aW9uKHBhcnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09PSBcIm51bWJlclwiIHx8IHRoaXNbXCI8aW50ZWdlcj5cIl0ocGFydCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCI8aW50ZWdlcj5cIjogZnVuY3Rpb24ocGFydCl7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwiaW50ZWdlclwiO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiPGxpbmU+XCI6IGZ1bmN0aW9uKHBhcnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09PSBcImludGVnZXJcIjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIjxhbmdsZT5cIjogZnVuY3Rpb24ocGFydCl7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwiYW5nbGVcIjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIjx1cmk+XCI6IGZ1bmN0aW9uKHBhcnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09PSBcInVyaVwiO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiPGltYWdlPlwiOiBmdW5jdGlvbihwYXJ0KXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCI8dXJpPlwiXShwYXJ0KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIjxwZXJjZW50YWdlPlwiOiBmdW5jdGlvbihwYXJ0KXtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJwZXJjZW50YWdlXCIgfHwgU3RyaW5nKHBhcnQpID09PSBcIjBcIjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIjxib3JkZXItd2lkdGg+XCI6IGZ1bmN0aW9uKHBhcnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIjxsZW5ndGg+XCJdKHBhcnQpIHx8IFZhbGlkYXRpb25UeXBlcy5pc0xpdGVyYWwocGFydCwgXCJ0aGluIHwgbWVkaXVtIHwgdGhpY2tcIik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCI8Ym9yZGVyLXN0eWxlPlwiOiBmdW5jdGlvbihwYXJ0KXtcclxuICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRpb25UeXBlcy5pc0xpdGVyYWwocGFydCwgXCJub25lIHwgaGlkZGVuIHwgZG90dGVkIHwgZGFzaGVkIHwgc29saWQgfCBkb3VibGUgfCBncm9vdmUgfCByaWRnZSB8IGluc2V0IHwgb3V0c2V0XCIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiPGNvbnRlbnQtc2l6aW5nPlwiOiBmdW5jdGlvbihwYXJ0KXsgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zaXppbmcvI3dpZHRoLWhlaWdodC1rZXl3b3Jkc1xyXG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdGlvblR5cGVzLmlzTGl0ZXJhbChwYXJ0LCBcImZpbGwtYXZhaWxhYmxlIHwgLW1vei1hdmFpbGFibGUgfCAtd2Via2l0LWZpbGwtYXZhaWxhYmxlIHwgbWF4LWNvbnRlbnQgfCAtbW96LW1heC1jb250ZW50IHwgLXdlYmtpdC1tYXgtY29udGVudCB8IG1pbi1jb250ZW50IHwgLW1vei1taW4tY29udGVudCB8IC13ZWJraXQtbWluLWNvbnRlbnQgfCBmaXQtY29udGVudCB8IC1tb3otZml0LWNvbnRlbnQgfCAtd2Via2l0LWZpdC1jb250ZW50XCIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiPG1hcmdpbi13aWR0aD5cIjogZnVuY3Rpb24ocGFydCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiPGxlbmd0aD5cIl0ocGFydCkgfHwgdGhpc1tcIjxwZXJjZW50YWdlPlwiXShwYXJ0KSB8fCBWYWxpZGF0aW9uVHlwZXMuaXNMaXRlcmFsKHBhcnQsIFwiYXV0b1wiKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIjxwYWRkaW5nLXdpZHRoPlwiOiBmdW5jdGlvbihwYXJ0KXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCI8bGVuZ3RoPlwiXShwYXJ0KSB8fCB0aGlzW1wiPHBlcmNlbnRhZ2U+XCJdKHBhcnQpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiPHNoYXBlPlwiOiBmdW5jdGlvbihwYXJ0KXtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmIChwYXJ0Lm5hbWUgPT09IFwicmVjdFwiIHx8IHBhcnQubmFtZSA9PT0gXCJpbnNldC1yZWN0XCIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiPHRpbWU+XCI6IGZ1bmN0aW9uKHBhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJ0aW1lXCI7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCI8ZmxleC1ncm93PlwiOiBmdW5jdGlvbihwYXJ0KXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCI8bnVtYmVyPlwiXShwYXJ0KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIjxmbGV4LXNocmluaz5cIjogZnVuY3Rpb24ocGFydCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiPG51bWJlcj5cIl0ocGFydCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCI8d2lkdGg+XCI6IGZ1bmN0aW9uKHBhcnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIjxtYXJnaW4td2lkdGg+XCJdKHBhcnQpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiPGZsZXgtYmFzaXM+XCI6IGZ1bmN0aW9uKHBhcnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIjx3aWR0aD5cIl0ocGFydCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCI8ZmxleC1kaXJlY3Rpb24+XCI6IGZ1bmN0aW9uKHBhcnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdGlvblR5cGVzLmlzTGl0ZXJhbChwYXJ0LCBcInJvdyB8IHJvdy1yZXZlcnNlIHwgY29sdW1uIHwgY29sdW1uLXJldmVyc2VcIik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCI8ZmxleC13cmFwPlwiOiBmdW5jdGlvbihwYXJ0KXtcclxuICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRpb25UeXBlcy5pc0xpdGVyYWwocGFydCwgXCJub3dyYXAgfCB3cmFwIHwgd3JhcC1yZXZlcnNlXCIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiPGZlYXR1cmUtdGFnLXZhbHVlPlwiOiBmdW5jdGlvbihwYXJ0KXtcclxuICAgICAgICAgICAgcmV0dXJuIChwYXJ0LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiAvXltBLVowLTldezR9JC9pLnRlc3QocGFydCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgY29tcGxleDoge1xyXG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcclxuXHJcbiAgICAgICAgXCI8YmctcG9zaXRpb24+XCI6IGZ1bmN0aW9uKGV4cHJlc3Npb24pe1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ICA9IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbnVtZXJpYyA9IFwiPHBlcmNlbnRhZ2U+IHwgPGxlbmd0aD5cIixcclxuICAgICAgICAgICAgICAgIHhEaXIgICAgPSBcImxlZnQgfCByaWdodFwiLFxyXG4gICAgICAgICAgICAgICAgeURpciAgICA9IFwidG9wIHwgYm90dG9tXCIsXHJcbiAgICAgICAgICAgICAgICBjb3VudCA9IDA7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoZXhwcmVzc2lvbi5wZWVrKGNvdW50KSAmJiBleHByZXNzaW9uLnBlZWsoY291bnQpLnRleHQgIT09IFwiLFwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4vKlxyXG48cG9zaXRpb24+ID0gW1xyXG4gIFsgbGVmdCB8IGNlbnRlciB8IHJpZ2h0IHwgdG9wIHwgYm90dG9tIHwgPHBlcmNlbnRhZ2U+IHwgPGxlbmd0aD4gXVxyXG58XHJcbiAgWyBsZWZ0IHwgY2VudGVyIHwgcmlnaHQgfCA8cGVyY2VudGFnZT4gfCA8bGVuZ3RoPiBdXHJcbiAgWyB0b3AgfCBjZW50ZXIgfCBib3R0b20gfCA8cGVyY2VudGFnZT4gfCA8bGVuZ3RoPiBdXHJcbnxcclxuICBbIGNlbnRlciB8IFsgbGVmdCB8IHJpZ2h0IF0gWyA8cGVyY2VudGFnZT4gfCA8bGVuZ3RoPiBdPyBdICYmXHJcbiAgWyBjZW50ZXIgfCBbIHRvcCB8IGJvdHRvbSBdIFsgPHBlcmNlbnRhZ2U+IHwgPGxlbmd0aD4gXT8gXVxyXG5dXHJcbiovXHJcblxyXG4gICAgICAgICAgICBpZiAoY291bnQgPCAzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHhEaXIgKyBcIiB8IGNlbnRlciB8IFwiICsgbnVtZXJpYykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHlEaXIgKyBcIiB8IGNlbnRlciB8IFwiICsgbnVtZXJpYyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCB5RGlyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgeERpciArIFwiIHwgY2VudGVyXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCB4RGlyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgeURpcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIG51bWVyaWMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIG51bWVyaWMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgeURpcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgbnVtZXJpYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIFwiY2VudGVyXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgeURpcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHhEaXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBudW1lcmljKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBudW1lcmljKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHhEaXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgbnVtZXJpYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIFwiY2VudGVyXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgXCJjZW50ZXJcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHhEaXIgKyBcIiB8IFwiICsgeURpcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIG51bWVyaWMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIjxiZy1zaXplPlwiOiBmdW5jdGlvbihleHByZXNzaW9uKXtcclxuICAgICAgICAgICAgLy88Ymctc2l6ZT4gPSBbIDxsZW5ndGg+IHwgPHBlcmNlbnRhZ2U+IHwgYXV0byBdezEsMn0gfCBjb3ZlciB8IGNvbnRhaW5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCAgPSBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG51bWVyaWMgPSBcIjxwZXJjZW50YWdlPiB8IDxsZW5ndGg+IHwgYXV0b1wiO1xyXG5cclxuICAgICAgICAgICAgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBcImNvdmVyIHwgY29udGFpblwiKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgbnVtZXJpYykpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgbnVtZXJpYyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCI8cmVwZWF0LXN0eWxlPlwiOiBmdW5jdGlvbihleHByZXNzaW9uKXtcclxuICAgICAgICAgICAgLy9yZXBlYXQteCB8IHJlcGVhdC15IHwgW3JlcGVhdCB8IHNwYWNlIHwgcm91bmQgfCBuby1yZXBlYXRdezEsMn1cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCAgPSBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlcyAgPSBcInJlcGVhdCB8IHNwYWNlIHwgcm91bmQgfCBuby1yZXBlYXRcIixcclxuICAgICAgICAgICAgICAgIHBhcnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5oYXNOZXh0KCkpe1xyXG4gICAgICAgICAgICAgICAgcGFydCA9IGV4cHJlc3Npb24ubmV4dCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNMaXRlcmFsKHBhcnQsIFwicmVwZWF0LXggfCByZXBlYXQteVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0xpdGVyYWwocGFydCwgdmFsdWVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uLmhhc05leHQoKSAmJiBWYWxpZGF0aW9uVHlwZXMuaXNMaXRlcmFsKGV4cHJlc3Npb24ucGVlaygpLCB2YWx1ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCI8c2hhZG93PlwiOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIC8vaW5zZXQ/ICYmIFsgPGxlbmd0aD57Miw0fSAmJiA8Y29sb3I+PyBdXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgID0gZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb3VudCAgID0gMCxcclxuICAgICAgICAgICAgICAgIGluc2V0ICAgPSBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbG9yICAgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uLmhhc05leHQoKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgXCJpbnNldFwiKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgXCI8Y29sb3I+XCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgXCI8bGVuZ3RoPlwiKSAmJiBjb3VudCA8IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBcIjxjb2xvcj5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWluc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBcImluc2V0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKGNvdW50ID49IDIgJiYgY291bnQgPD0gNCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiPHgtb25lLXJhZGl1cz5cIjogZnVuY3Rpb24oZXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAvL1sgPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gXSBbIDxsZW5ndGg+IHwgPHBlcmNlbnRhZ2U+IF0/XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgID0gZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaW1wbGUgPSBcIjxsZW5ndGg+IHwgPHBlcmNlbnRhZ2U+IHwgaW5oZXJpdFwiO1xyXG5cclxuICAgICAgICAgICAgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBzaW1wbGUpKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgc2ltcGxlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIjxmbGV4PlwiOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTQvV0QtY3NzLWZsZXhib3gtMS0yMDE0MDMyNS8jZmxleC1wcm9wZXJ0eVxyXG4gICAgICAgICAgICAvLyBub25lIHwgWyA8ZmxleC1ncm93PiA8ZmxleC1zaHJpbms+PyB8fCA8ZmxleC1iYXNpcz4gXVxyXG4gICAgICAgICAgICAvLyBWYWxpZCBzeW50YXhlcywgYWNjb3JkaW5nIHRvIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mbGV4I1N5bnRheFxyXG4gICAgICAgICAgICAvLyAqIG5vbmVcclxuICAgICAgICAgICAgLy8gKiA8ZmxleC1ncm93PlxyXG4gICAgICAgICAgICAvLyAqIDxmbGV4LWJhc2lzPlxyXG4gICAgICAgICAgICAvLyAqIDxmbGV4LWdyb3c+IDxmbGV4LWJhc2lzPlxyXG4gICAgICAgICAgICAvLyAqIDxmbGV4LWdyb3c+IDxmbGV4LXNocmluaz5cclxuICAgICAgICAgICAgLy8gKiA8ZmxleC1ncm93PiA8ZmxleC1zaHJpbms+IDxmbGV4LWJhc2lzPlxyXG4gICAgICAgICAgICAvLyAqIGluaGVyaXRcclxuICAgICAgICAgICAgdmFyIHBhcnQsXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBcIm5vbmUgfCBpbmhlcml0XCIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKFZhbGlkYXRpb25UeXBlcy5pc1R5cGUoZXhwcmVzc2lvbiwgXCI8ZmxleC1ncm93PlwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uLnBlZWsoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzVHlwZShleHByZXNzaW9uLCBcIjxmbGV4LXNocmluaz5cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uLnBlZWsoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFZhbGlkYXRpb25UeXBlcy5pc1R5cGUoZXhwcmVzc2lvbiwgXCI8ZmxleC1iYXNpcz5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVmFsaWRhdGlvblR5cGVzLmlzVHlwZShleHByZXNzaW9uLCBcIjxmbGV4LWJhc2lzPlwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwcmVzc2lvbi5wZWVrKCkgPT09IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVmFsaWRhdGlvblR5cGVzLmlzVHlwZShleHByZXNzaW9uLCBcIjxmbGV4LWJhc2lzPlwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIG1vcmUgdmVyYm9zZSBlcnJvciB0aGFuIFwiRXhwZWN0ZWQgPGZsZXg+Li4uXCJcclxuICAgICAgICAgICAgICAgIHBhcnQgPSBleHByZXNzaW9uLnBlZWsoKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJFeHBlY3RlZCAobm9uZSB8IFsgPGZsZXgtZ3Jvdz4gPGZsZXgtc2hyaW5rPj8gfHwgPGZsZXgtYmFzaXM+IF0pIGJ1dCBmb3VuZCAnXCIgKyBleHByZXNzaW9uLnZhbHVlLnRleHQgKyBcIicuXCIsIHBhcnQubGluZSwgcGFydC5jb2wpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbnBhcnNlcmxpYi5jc3MgPSB7XHJcbl9fcHJvdG9fXyAgICAgICAgICAgOm51bGwsXHJcbkNvbG9ycyAgICAgICAgICAgICAgOkNvbG9ycyxcclxuQ29tYmluYXRvciAgICAgICAgICA6Q29tYmluYXRvcixcclxuUGFyc2VyICAgICAgICAgICAgICA6UGFyc2VyLFxyXG5Qcm9wZXJ0eU5hbWUgICAgICAgIDpQcm9wZXJ0eU5hbWUsXHJcblByb3BlcnR5VmFsdWUgICAgICAgOlByb3BlcnR5VmFsdWUsXHJcblByb3BlcnR5VmFsdWVQYXJ0ICAgOlByb3BlcnR5VmFsdWVQYXJ0LFxyXG5NZWRpYUZlYXR1cmUgICAgICAgIDpNZWRpYUZlYXR1cmUsXHJcbk1lZGlhUXVlcnkgICAgICAgICAgOk1lZGlhUXVlcnksXHJcblNlbGVjdG9yICAgICAgICAgICAgOlNlbGVjdG9yLFxyXG5TZWxlY3RvclBhcnQgICAgICAgIDpTZWxlY3RvclBhcnQsXHJcblNlbGVjdG9yU3ViUGFydCAgICAgOlNlbGVjdG9yU3ViUGFydCxcclxuU3BlY2lmaWNpdHkgICAgICAgICA6U3BlY2lmaWNpdHksXHJcblRva2VuU3RyZWFtICAgICAgICAgOlRva2VuU3RyZWFtLFxyXG5Ub2tlbnMgICAgICAgICAgICAgIDpUb2tlbnMsXHJcblZhbGlkYXRpb25FcnJvciAgICAgOlZhbGlkYXRpb25FcnJvclxyXG59O1xyXG59KSgpO1xyXG5cclxuKGZ1bmN0aW9uKCl7XHJcbi8qIGpzaGludCBmb3JpbjpmYWxzZSAqL1xyXG5mb3IodmFyIHByb3AgaW4gcGFyc2VybGliKXtcclxuZXhwb3J0c1twcm9wXSA9IHBhcnNlcmxpYltwcm9wXTtcclxufVxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZG9taW5vL2xpYi9jc3NwYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgRE9NSW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL0RPTUltcGxlbWVudGF0aW9uJyk7XHJcbnZhciBIVE1MUGFyc2VyID0gcmVxdWlyZSgnLi9IVE1MUGFyc2VyJyk7XHJcbnZhciBXaW5kb3cgPSByZXF1aXJlKCcuL1dpbmRvdycpO1xyXG5cclxuZXhwb3J0cy5jcmVhdGVET01JbXBsZW1lbnRhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiBuZXcgRE9NSW1wbGVtZW50YXRpb24oKTtcclxufTtcclxuXHJcbmV4cG9ydHMuY3JlYXRlRG9jdW1lbnQgPSBmdW5jdGlvbihodG1sLCBmb3JjZSkge1xyXG4gIC8vIFByZXZpb3VzIEFQSSBjb3VsZG4ndCBsZXQgeW91IHBhc3MgJycgYXMgYSBkb2N1bWVudCwgYW5kIHRoYXRcclxuICAvLyB5aWVsZHMgYSBzbGlnaHRseSBkaWZmZXJlbnQgZG9jdW1lbnQgdGhhbiBjcmVhdGVIVE1MRG9jdW1lbnQoJycpXHJcbiAgLy8gZG9lcy4gIFRoZSBuZXcgYGZvcmNlYCBwYXJhbWV0ZXIgbGV0cyB5b3UgcGFzcyAnJyBpZiB5b3Ugd2FudCB0by5cclxuICBpZiAoaHRtbCB8fCBmb3JjZSkge1xyXG4gICAgdmFyIHBhcnNlciA9IG5ldyBIVE1MUGFyc2VyKCk7XHJcbiAgICBwYXJzZXIucGFyc2UoaHRtbCB8fCAnJywgdHJ1ZSk7XHJcbiAgICByZXR1cm4gcGFyc2VyLmRvY3VtZW50KCk7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgRE9NSW1wbGVtZW50YXRpb24oKS5jcmVhdGVIVE1MRG9jdW1lbnQoXCJcIik7XHJcbn07XHJcblxyXG5leHBvcnRzLmNyZWF0ZVdpbmRvdyA9IGZ1bmN0aW9uKGh0bWwsIGFkZHJlc3MpIHtcclxuICB2YXIgZG9jdW1lbnQgPSBleHBvcnRzLmNyZWF0ZURvY3VtZW50KGh0bWwpO1xyXG4gIGlmIChhZGRyZXNzICE9PSB1bmRlZmluZWQpIHsgZG9jdW1lbnQuX2FkZHJlc3MgPSBhZGRyZXNzOyB9XHJcbiAgcmV0dXJuIG5ldyBXaW5kb3coZG9jdW1lbnQpO1xyXG59O1xyXG5cclxuZXhwb3J0cy5pbXBsID0gcmVxdWlyZSgnLi9pbXBsJyk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kb21pbm8vbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz0nY29udGFpbmVyLWZsdWlkJz5cXHJcXG4gICAgPGRpdiBjbGFzcz0ncm93Jz5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9J2NvbC1zbS0zJz5cXHJcXG4gICAgICAgICAgICA8bmF2LW1lbnU+PC9uYXYtbWVudT5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz0nY29sLXNtLTkgYm9keS1jb250ZW50Jz5cXHJcXG4gICAgICAgICAgICA8cm91dGVyLW91dGxldD48L3JvdXRlci1vdXRsZXQ+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvYXBwL2FwcC5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxoMT5Db3VudGVyPC9oMT5cXHJcXG5cXHJcXG48cD5UaGlzIGlzIGEgc2ltcGxlIGV4YW1wbGUgb2YgYW4gQW5ndWxhciBjb21wb25lbnQuPC9wPlxcclxcblxcclxcbjxwPkN1cnJlbnQgY291bnQ6IDxzdHJvbmc+e3sgY3VycmVudENvdW50IH19PC9zdHJvbmc+PC9wPlxcclxcblxcclxcbjxidXR0b24gbWF0LXJhaXNlZC1idXR0b24gY2xhc3M9XFxcIm15QnV0dG9uXFxcIiAoY2xpY2spPVxcXCJpbmNyZW1lbnRDb3VudGVyKClcXFwiIFtAaG92ZXJBbmltYXRpb25dPkluY3JlbWVudDwvYnV0dG9uPlxcclxcblxcclxcbjxtYXQtc2xpZGUtdG9nZ2xlIFsobmdNb2RlbCldPVxcXCJpc0VuYWJsZWRcXFwiPlRvZ2dsZTwvbWF0LXNsaWRlLXRvZ2dsZT5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9jb3VudGVyL2NvdW50ZXIuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDE+V2VhdGhlciBmb3JlY2FzdDwvaDE+XFxyXFxuXFxyXFxuPHA+VGhpcyBjb21wb25lbnQgZGVtb25zdHJhdGVzIGZldGNoaW5nIGRhdGEgZnJvbSB0aGUgc2VydmVyLjwvcD5cXHJcXG5cXHJcXG48cCAqbmdJZj1cXFwiIWZvcmVjYXN0c1xcXCI+PGVtPkxvYWRpbmcuLi48L2VtPjwvcD5cXHJcXG5cXHJcXG48dGFibGUgY2xhc3M9J3RhYmxlJyAqbmdJZj1cXFwiZm9yZWNhc3RzXFxcIj5cXHJcXG4gICAgPHRoZWFkPlxcclxcbiAgICAgICAgPHRyPlxcclxcbiAgICAgICAgICAgIDx0aD5EYXRlPC90aD5cXHJcXG4gICAgICAgICAgICA8dGg+VGVtcC4gKEMpPC90aD5cXHJcXG4gICAgICAgICAgICA8dGg+VGVtcC4gKEYpPC90aD5cXHJcXG4gICAgICAgICAgICA8dGg+U3VtbWFyeTwvdGg+XFxyXFxuICAgICAgICA8L3RyPlxcclxcbiAgICA8L3RoZWFkPlxcclxcbiAgICA8dGJvZHk+XFxyXFxuICAgICAgICA8dHIgKm5nRm9yPVxcXCJsZXQgZm9yZWNhc3Qgb2YgZm9yZWNhc3RzXFxcIj5cXHJcXG4gICAgICAgICAgICA8dGQ+e3sgZm9yZWNhc3QuZGF0ZUZvcm1hdHRlZCB9fTwvdGQ+XFxyXFxuICAgICAgICAgICAgPHRkPnt7IGZvcmVjYXN0LnRlbXBlcmF0dXJlQyB9fTwvdGQ+XFxyXFxuICAgICAgICAgICAgPHRkPnt7IGZvcmVjYXN0LnRlbXBlcmF0dXJlRiB9fTwvdGQ+XFxyXFxuICAgICAgICAgICAgPHRkPnt7IGZvcmVjYXN0LnN1bW1hcnkgfX08L3RkPlxcclxcbiAgICAgICAgPC90cj5cXHJcXG4gICAgPC90Ym9keT5cXHJcXG48L3RhYmxlPlxcclxcblwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2ZldGNoZGF0YS9mZXRjaGRhdGEuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDE+SGVsbG8sIHdvcmxkITwvaDE+XFxyXFxuPHA+V2VsY29tZSB0byB5b3VyIG5ldyBzaW5nbGUtcGFnZSBhcHBsaWNhdGlvbiwgYnVpbHQgd2l0aDo8L3A+XFxyXFxuPHVsPlxcclxcbiAgICA8bGk+PGEgaHJlZj0naHR0cHM6Ly9nZXQuYXNwLm5ldC8nPkFTUC5ORVQgQ29yZTwvYT4gYW5kIDxhIGhyZWY9J2h0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvNjdlZjhzYmQuYXNweCc+QyM8L2E+IGZvciBjcm9zcy1wbGF0Zm9ybSBzZXJ2ZXItc2lkZSBjb2RlPC9saT5cXHJcXG4gICAgPGxpPjxhIGhyZWY9J2h0dHBzOi8vYW5ndWxhci5pby8nPkFuZ3VsYXI8L2E+IGFuZCA8YSBocmVmPSdodHRwOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy8nPlR5cGVTY3JpcHQ8L2E+IGZvciBjbGllbnQtc2lkZSBjb2RlPC9saT5cXHJcXG4gICAgPGxpPjxhIGhyZWY9J2h0dHBzOi8vd2VicGFjay5naXRodWIuaW8vJz5XZWJwYWNrPC9hPiBmb3IgYnVpbGRpbmcgYW5kIGJ1bmRsaW5nIGNsaWVudC1zaWRlIHJlc291cmNlczwvbGk+XFxyXFxuICAgIDxsaT48YSBocmVmPSdodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS8nPkJvb3RzdHJhcDwvYT4gZm9yIGxheW91dCBhbmQgc3R5bGluZzwvbGk+XFxyXFxuPC91bD5cXHJcXG48cD5UbyBoZWxwIHlvdSBnZXQgc3RhcnRlZCwgd2UndmUgYWxzbyBzZXQgdXA6PC9wPlxcclxcbjx1bD5cXHJcXG4gICAgPGxpPjxzdHJvbmc+Q2xpZW50LXNpZGUgbmF2aWdhdGlvbjwvc3Ryb25nPi4gRm9yIGV4YW1wbGUsIGNsaWNrIDxlbT5Db3VudGVyPC9lbT4gdGhlbiA8ZW0+QmFjazwvZW0+IHRvIHJldHVybiBoZXJlLjwvbGk+XFxyXFxuICAgIDxsaT48c3Ryb25nPlNlcnZlci1zaWRlIHByZXJlbmRlcmluZzwvc3Ryb25nPi4gRm9yIGZhc3RlciBpbml0aWFsIGxvYWRpbmcgYW5kIGltcHJvdmVkIFNFTywgeW91ciBBbmd1bGFyIGFwcCBpcyBwcmVyZW5kZXJlZCBvbiB0aGUgc2VydmVyLiBUaGUgcmVzdWx0aW5nIEhUTUwgaXMgdGhlbiB0cmFuc2ZlcnJlZCB0byB0aGUgYnJvd3NlciB3aGVyZSBhIGNsaWVudC1zaWRlIGNvcHkgb2YgdGhlIGFwcCB0YWtlcyBvdmVyLjwvbGk+XFxyXFxuICAgIDxsaT48c3Ryb25nPldlYnBhY2sgZGV2IG1pZGRsZXdhcmU8L3N0cm9uZz4uIEluIGRldmVsb3BtZW50IG1vZGUsIHRoZXJlJ3Mgbm8gbmVlZCB0byBydW4gdGhlIDxjb2RlPndlYnBhY2s8L2NvZGU+IGJ1aWxkIHRvb2wuIFlvdXIgY2xpZW50LXNpZGUgcmVzb3VyY2VzIGFyZSBkeW5hbWljYWxseSBidWlsdCBvbiBkZW1hbmQuIFVwZGF0ZXMgYXJlIGF2YWlsYWJsZSBhcyBzb29uIGFzIHlvdSBtb2RpZnkgYW55IGZpbGUuPC9saT5cXHJcXG4gICAgPGxpPjxzdHJvbmc+SG90IG1vZHVsZSByZXBsYWNlbWVudDwvc3Ryb25nPi4gSW4gZGV2ZWxvcG1lbnQgbW9kZSwgeW91IGRvbid0IGV2ZW4gbmVlZCB0byByZWxvYWQgdGhlIHBhZ2UgYWZ0ZXIgbWFraW5nIG1vc3QgY2hhbmdlcy4gV2l0aGluIHNlY29uZHMgb2Ygc2F2aW5nIGNoYW5nZXMgdG8gZmlsZXMsIHlvdXIgQW5ndWxhciBhcHAgd2lsbCBiZSByZWJ1aWx0IGFuZCBhIG5ldyBpbnN0YW5jZSBpbmplY3RlZCBpbnRvIHRoZSBwYWdlLjwvbGk+XFxyXFxuICAgIDxsaT48c3Ryb25nPkVmZmljaWVudCBwcm9kdWN0aW9uIGJ1aWxkczwvc3Ryb25nPi4gSW4gcHJvZHVjdGlvbiBtb2RlLCBkZXZlbG9wbWVudC10aW1lIGZlYXR1cmVzIGFyZSBkaXNhYmxlZCwgYW5kIHRoZSA8Y29kZT53ZWJwYWNrPC9jb2RlPiBidWlsZCB0b29sIHByb2R1Y2VzIG1pbmlmaWVkIHN0YXRpYyBDU1MgYW5kIEphdmFTY3JpcHQgZmlsZXMuPC9saT5cXHJcXG48L3VsPlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2hvbWUvaG9tZS5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9J21haW4tbmF2Jz5cXHJcXG4gICAgPGRpdiBjbGFzcz0nbmF2YmFyIG5hdmJhci1pbnZlcnNlJz5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9J25hdmJhci1oZWFkZXInPlxcclxcbiAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nbmF2YmFyLXRvZ2dsZScgZGF0YS10b2dnbGU9J2NvbGxhcHNlJyBkYXRhLXRhcmdldD0nLm5hdmJhci1jb2xsYXBzZSc+XFxyXFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdzci1vbmx5Jz5Ub2dnbGUgbmF2aWdhdGlvbjwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ljb24tYmFyJz48L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdpY29uLWJhcic+PC9zcGFuPlxcclxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0naWNvbi1iYXInPjwvc3Bhbj5cXHJcXG4gICAgICAgICAgICA8L2J1dHRvbj5cXHJcXG4gICAgICAgICAgICA8YSBjbGFzcz0nbmF2YmFyLWJyYW5kJyBbcm91dGVyTGlua109XFxcIlsnL2hvbWUnXVxcXCI+UHJvY2Vzc0h1YjwvYT5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz0nY2xlYXJmaXgnPjwvZGl2PlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz0nbmF2YmFyLWNvbGxhcHNlIGNvbGxhcHNlJz5cXHJcXG4gICAgICAgICAgICA8dWwgY2xhc3M9J25hdiBuYXZiYXItbmF2Jz5cXHJcXG4gICAgICAgICAgICAgICAgPGxpIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydsaW5rLWFjdGl2ZSddXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxhIFtyb3V0ZXJMaW5rXT1cXFwiWycvaG9tZSddXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZ2x5cGhpY29uIGdseXBoaWNvbi1ob21lJz48L3NwYW4+IEhvbWVcXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXHJcXG4gICAgICAgICAgICAgICAgPC9saT5cXHJcXG4gICAgICAgICAgICAgICAgPGxpIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydsaW5rLWFjdGl2ZSddXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxhIFtyb3V0ZXJMaW5rXT1cXFwiWycvdmVoaWNsZXMvbmV3J11cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdnbHlwaGljb24gZ2x5cGhpY29uLXBsdXMnPjwvc3Bhbj4gdmVoaWNsZXMgTkVXXFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2E+XFxyXFxuICAgICAgICAgICAgICAgIDwvbGk+XFxyXFxuICAgICAgICAgICAgICAgIDxsaSBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnbGluay1hY3RpdmUnXVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8YSBbcm91dGVyTGlua109XFxcIlsnL2NvdW50ZXInXVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2dseXBoaWNvbiBnbHlwaGljb24tZWR1Y2F0aW9uJz48L3NwYW4+IENvdW50ZXJcXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXHJcXG4gICAgICAgICAgICAgICAgPC9saT5cXHJcXG4gICAgICAgICAgICAgICAgPGxpIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydsaW5rLWFjdGl2ZSddXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxhIFtyb3V0ZXJMaW5rXT1cXFwiWycvZmV0Y2gtZGF0YSddXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZ2x5cGhpY29uIGdseXBoaWNvbi10aC1saXN0Jz48L3NwYW4+IEZldGNoIGRhdGFcXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXHJcXG4gICAgICAgICAgICAgICAgPC9saT5cXHJcXG4gICAgICAgICAgICA8L3VsPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZGl2PlxcclxcblwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL25hdm1lbnUvbmF2bWVudS5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxwPlxcclxcbiAgdmVoaWNsZS1tb2R1bGUgYWN1YWxseSB3b3JrcyBcXHJcXG48L3A+XFxyXFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvdmVoaWNsZS1mb3JtL3ZlaGljbGUtZm9ybS5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XHJcbi8vIEhBQ0s6IHRoaXMgaXMgaGVyZSBmb3IgYmFja3dhcmQgY29tcGF0YWJpbGl0eVxyXG4vLyBUT0RPKGJlbmxlc2gpOiByZW1vdmUgdGhpcyBpbiB2Ni5cclxuZXhwb3J0cy50b1Byb21pc2UgPSBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudG9Qcm9taXNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b1Byb21pc2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYXBwLmNvbXBvbmVudC5jc3NcIik7XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2FwcC9hcHAuY29tcG9uZW50LmNzc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4gICAgICAgIHZhciByZXN1bHQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL25hdm1lbnUuY29tcG9uZW50LmNzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvbmF2bWVudS9uYXZtZW51LmNvbXBvbmVudC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi92ZWhpY2xlLWZvcm0uY29tcG9uZW50LmNzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvdmVoaWNsZS1mb3JtL3ZlaGljbGUtZm9ybS5jb21wb25lbnQuY3NzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuMlxyXG4oZnVuY3Rpb24oKSB7XHJcbiAgdmFyIEludmFsaWRTdGF0ZUVycm9yLCBOZXR3b3JrRXJyb3IsIFByb2dyZXNzRXZlbnQsIFNlY3VyaXR5RXJyb3IsIFN5bnRheEVycm9yLCBYTUxIdHRwUmVxdWVzdCwgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCwgWE1MSHR0cFJlcXVlc3RVcGxvYWQsIGh0dHAsIGh0dHBzLCBvcywgdXJsLFxyXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxyXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xyXG5cclxuICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0ID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgZnVuY3Rpb24gWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCgpIHtcclxuICAgICAgdGhpcy5vbmxvYWRzdGFydCA9IG51bGw7XHJcbiAgICAgIHRoaXMub25wcm9ncmVzcyA9IG51bGw7XHJcbiAgICAgIHRoaXMub25hYm9ydCA9IG51bGw7XHJcbiAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XHJcbiAgICAgIHRoaXMub25sb2FkID0gbnVsbDtcclxuICAgICAgdGhpcy5vbnRpbWVvdXQgPSBudWxsO1xyXG4gICAgICB0aGlzLm9ubG9hZGVuZCA9IG51bGw7XHJcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlLm9ubG9hZHN0YXJ0ID0gbnVsbDtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbnByb2dyZXNzID0gbnVsbDtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbmFib3J0ID0gbnVsbDtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbmVycm9yID0gbnVsbDtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbmxvYWQgPSBudWxsO1xyXG5cclxuICAgIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlLm9udGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldC5wcm90b3R5cGUub25sb2FkZW5kID0gbnVsbDtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xyXG4gICAgICB2YXIgYmFzZTtcclxuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIChiYXNlID0gdGhpcy5fbGlzdGVuZXJzKVtldmVudFR5cGVdIHx8IChiYXNlW2V2ZW50VHlwZV0gPSBbXSk7XHJcbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xyXG4gICAgICB2YXIgaW5kZXg7XHJcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICBpZiAodGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0pIHtcclxuICAgICAgICBpbmRleCA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICB9O1xyXG5cclxuICAgIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICB2YXIgZXZlbnRUeXBlLCBqLCBsZW4sIGxpc3RlbmVyLCBsaXN0ZW5lcnM7XHJcbiAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBldmVudC50YXJnZXQgPSB0aGlzO1xyXG4gICAgICBldmVudFR5cGUgPSBldmVudC50eXBlO1xyXG4gICAgICBpZiAobGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0pIHtcclxuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXJzW2pdO1xyXG4gICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChsaXN0ZW5lciA9IHRoaXNbXCJvblwiICsgZXZlbnRUeXBlXSkge1xyXG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0O1xyXG5cclxuICB9KSgpO1xyXG5cclxuICBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xyXG5cclxuICBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XHJcblxyXG4gIG9zID0gcmVxdWlyZSgnb3MnKTtcclxuXHJcbiAgdXJsID0gcmVxdWlyZSgndXJsJyk7XHJcblxyXG4gIFhNTEh0dHBSZXF1ZXN0ID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcclxuICAgIGV4dGVuZChYTUxIdHRwUmVxdWVzdCwgc3VwZXJDbGFzcyk7XHJcblxyXG4gICAgZnVuY3Rpb24gWE1MSHR0cFJlcXVlc3Qob3B0aW9ucykge1xyXG4gICAgICBYTUxIdHRwUmVxdWVzdC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcclxuICAgICAgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xyXG4gICAgICB0aGlzLl9hbm9ueW1vdXMgPSBvcHRpb25zICYmIG9wdGlvbnMuYW5vbjtcclxuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gWE1MSHR0cFJlcXVlc3QuVU5TRU5UO1xyXG4gICAgICB0aGlzLnJlc3BvbnNlID0gbnVsbDtcclxuICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSAnJztcclxuICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSAnJztcclxuICAgICAgdGhpcy5yZXNwb25zZVVSTCA9ICcnO1xyXG4gICAgICB0aGlzLnN0YXR1cyA9IDA7XHJcbiAgICAgIHRoaXMuc3RhdHVzVGV4dCA9ICcnO1xyXG4gICAgICB0aGlzLnRpbWVvdXQgPSAwO1xyXG4gICAgICB0aGlzLnVwbG9hZCA9IG5ldyBYTUxIdHRwUmVxdWVzdFVwbG9hZCh0aGlzKTtcclxuICAgICAgdGhpcy5fbWV0aG9kID0gbnVsbDtcclxuICAgICAgdGhpcy5fdXJsID0gbnVsbDtcclxuICAgICAgdGhpcy5fc3luYyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9oZWFkZXJzID0gbnVsbDtcclxuICAgICAgdGhpcy5fbG93ZXJlZEhlYWRlcnMgPSBudWxsO1xyXG4gICAgICB0aGlzLl9taW1lT3ZlcnJpZGUgPSBudWxsO1xyXG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcclxuICAgICAgdGhpcy5fcmVzcG9uc2UgPSBudWxsO1xyXG4gICAgICB0aGlzLl9yZXNwb25zZVBhcnRzID0gbnVsbDtcclxuICAgICAgdGhpcy5fcmVzcG9uc2VIZWFkZXJzID0gbnVsbDtcclxuICAgICAgdGhpcy5fYWJvcnRpbmcgPSBudWxsO1xyXG4gICAgICB0aGlzLl9lcnJvciA9IG51bGw7XHJcbiAgICAgIHRoaXMuX2xvYWRlZEJ5dGVzID0gMDtcclxuICAgICAgdGhpcy5fdG90YWxCeXRlcyA9IDA7XHJcbiAgICAgIHRoaXMuX2xlbmd0aENvbXB1dGFibGUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUucmVhZHlTdGF0ZSA9IG51bGw7XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnJlc3BvbnNlID0gbnVsbDtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUucmVzcG9uc2VUZXh0ID0gbnVsbDtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUucmVzcG9uc2VUeXBlID0gbnVsbDtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuc3RhdHVzID0gbnVsbDtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUudGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnVwbG9hZCA9IG51bGw7XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihtZXRob2QsIHVybCwgYXN5bmMsIHVzZXIsIHBhc3N3b3JkKSB7XHJcbiAgICAgIHZhciB4aHJVcmw7XHJcbiAgICAgIG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICBpZiAobWV0aG9kIGluIHRoaXMuX3Jlc3RyaWN0ZWRNZXRob2RzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFNlY3VyaXR5RXJyb3IoXCJIVFRQIG1ldGhvZCBcIiArIG1ldGhvZCArIFwiIGlzIG5vdCBhbGxvd2VkIGluIFhIUlwiKTtcclxuICAgICAgfVxyXG4gICAgICB4aHJVcmwgPSB0aGlzLl9wYXJzZVVybCh1cmwpO1xyXG4gICAgICBpZiAoYXN5bmMgPT09IHZvaWQgMCkge1xyXG4gICAgICAgIGFzeW5jID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2ggKHRoaXMucmVhZHlTdGF0ZSkge1xyXG4gICAgICAgIGNhc2UgWE1MSHR0cFJlcXVlc3QuVU5TRU5UOlxyXG4gICAgICAgIGNhc2UgWE1MSHR0cFJlcXVlc3QuT1BFTkVEOlxyXG4gICAgICAgIGNhc2UgWE1MSHR0cFJlcXVlc3QuRE9ORTpcclxuICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQ6XHJcbiAgICAgICAgY2FzZSBYTUxIdHRwUmVxdWVzdC5MT0FESU5HOlxyXG4gICAgICAgICAgbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9tZXRob2QgPSBtZXRob2Q7XHJcbiAgICAgIHRoaXMuX3VybCA9IHhoclVybDtcclxuICAgICAgdGhpcy5fc3luYyA9ICFhc3luYztcclxuICAgICAgdGhpcy5faGVhZGVycyA9IHt9O1xyXG4gICAgICB0aGlzLl9sb3dlcmVkSGVhZGVycyA9IHt9O1xyXG4gICAgICB0aGlzLl9taW1lT3ZlcnJpZGUgPSBudWxsO1xyXG4gICAgICB0aGlzLl9zZXRSZWFkeVN0YXRlKFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCk7XHJcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xyXG4gICAgICB0aGlzLl9yZXNwb25zZSA9IG51bGw7XHJcbiAgICAgIHRoaXMuc3RhdHVzID0gMDtcclxuICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gJyc7XHJcbiAgICAgIHRoaXMuX3Jlc3BvbnNlUGFydHMgPSBbXTtcclxuICAgICAgdGhpcy5fcmVzcG9uc2VIZWFkZXJzID0gbnVsbDtcclxuICAgICAgdGhpcy5fbG9hZGVkQnl0ZXMgPSAwO1xyXG4gICAgICB0aGlzLl90b3RhbEJ5dGVzID0gMDtcclxuICAgICAgdGhpcy5fbGVuZ3RoQ29tcHV0YWJsZSA9IGZhbHNlO1xyXG4gICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuc2V0UmVxdWVzdEhlYWRlciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgIHZhciBsb3dlcmVkTmFtZTtcclxuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuT1BFTkVEKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTdGF0ZUVycm9yKFwiWEhSIHJlYWR5U3RhdGUgbXVzdCBiZSBPUEVORURcIik7XHJcbiAgICAgIH1cclxuICAgICAgbG93ZXJlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIGlmICh0aGlzLl9yZXN0cmljdGVkSGVhZGVyc1tsb3dlcmVkTmFtZV0gfHwgL15zZWNcXC0vLnRlc3QobG93ZXJlZE5hbWUpIHx8IC9ecHJveHktLy50ZXN0KGxvd2VyZWROYW1lKSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlJlZnVzZWQgdG8gc2V0IHVuc2FmZSBoZWFkZXIgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKTtcclxuICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgICB9XHJcbiAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgaWYgKGxvd2VyZWROYW1lIGluIHRoaXMuX2xvd2VyZWRIZWFkZXJzKSB7XHJcbiAgICAgICAgbmFtZSA9IHRoaXMuX2xvd2VyZWRIZWFkZXJzW2xvd2VyZWROYW1lXTtcclxuICAgICAgICB0aGlzLl9oZWFkZXJzW25hbWVdID0gdGhpcy5faGVhZGVyc1tuYW1lXSArICcsICcgKyB2YWx1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9sb3dlcmVkSGVhZGVyc1tsb3dlcmVkTmFtZV0gPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuX2hlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuT1BFTkVEKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTdGF0ZUVycm9yKFwiWEhSIHJlYWR5U3RhdGUgbXVzdCBiZSBPUEVORURcIik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcclxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0YXRlRXJyb3IoXCJzZW5kKCkgYWxyZWFkeSBjYWxsZWRcIik7XHJcbiAgICAgIH1cclxuICAgICAgc3dpdGNoICh0aGlzLl91cmwucHJvdG9jb2wpIHtcclxuICAgICAgICBjYXNlICdmaWxlOic6XHJcbiAgICAgICAgICB0aGlzLl9zZW5kRmlsZShkYXRhKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2h0dHA6JzpcclxuICAgICAgICBjYXNlICdodHRwczonOlxyXG4gICAgICAgICAgdGhpcy5fc2VuZEh0dHAoZGF0YSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihcIlVuc3VwcG9ydGVkIHByb3RvY29sIFwiICsgdGhpcy5fdXJsLnByb3RvY29sKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX3JlcXVlc3QuYWJvcnQoKTtcclxuICAgICAgdGhpcy5fc2V0RXJyb3IoKTtcclxuICAgICAgdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnYWJvcnQnKTtcclxuICAgICAgdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnbG9hZGVuZCcpO1xyXG4gICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgIHZhciBsb3dlcmVkTmFtZTtcclxuICAgICAgaWYgKCF0aGlzLl9yZXNwb25zZUhlYWRlcnMpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBsb3dlcmVkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgaWYgKGxvd2VyZWROYW1lIGluIHRoaXMuX3Jlc3BvbnNlSGVhZGVycykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNwb25zZUhlYWRlcnNbbG93ZXJlZE5hbWVdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGxpbmVzLCBuYW1lLCB2YWx1ZTtcclxuICAgICAgaWYgKCF0aGlzLl9yZXNwb25zZUhlYWRlcnMpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgIH1cclxuICAgICAgbGluZXMgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHJlZiwgcmVzdWx0cztcclxuICAgICAgICByZWYgPSB0aGlzLl9yZXNwb25zZUhlYWRlcnM7XHJcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIGZvciAobmFtZSBpbiByZWYpIHtcclxuICAgICAgICAgIHZhbHVlID0gcmVmW25hbWVdO1xyXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG5hbWUgKyBcIjogXCIgKyB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICB9KS5jYWxsKHRoaXMpO1xyXG4gICAgICByZXR1cm4gbGluZXMuam9pbihcIlxcclxcblwiKTtcclxuICAgIH07XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLm92ZXJyaWRlTWltZVR5cGUgPSBmdW5jdGlvbihuZXdNaW1lVHlwZSkge1xyXG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBYTUxIdHRwUmVxdWVzdC5MT0FESU5HIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xyXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU3RhdGVFcnJvcihcIm92ZXJyaWRlTWltZVR5cGUoKSBub3QgYWxsb3dlZCBpbiBMT0FESU5HIG9yIERPTkVcIik7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fbWltZU92ZXJyaWRlID0gbmV3TWltZVR5cGUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIH07XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLm5vZGVqc1NldCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgdmFyIGJhc2VVcmwsIHBhcnNlZFVybDtcclxuICAgICAgaWYgKCdodHRwQWdlbnQnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLm5vZGVqc0h0dHBBZ2VudCA9IG9wdGlvbnMuaHR0cEFnZW50O1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgnaHR0cHNBZ2VudCcgaW4gb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMubm9kZWpzSHR0cHNBZ2VudCA9IG9wdGlvbnMuaHR0cHNBZ2VudDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoJ2Jhc2VVcmwnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICBiYXNlVXJsID0gb3B0aW9ucy5iYXNlVXJsO1xyXG4gICAgICAgIGlmIChiYXNlVXJsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBwYXJzZWRVcmwgPSB1cmwucGFyc2UoYmFzZVVybCwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgaWYgKCFwYXJzZWRVcmwucHJvdG9jb2wpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiYmFzZVVybCBtdXN0IGJlIGFuIGFic29sdXRlIFVSTFwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ub2RlanNCYXNlVXJsID0gYmFzZVVybDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5ub2RlanNTZXQgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5ub2RlanNTZXQob3B0aW9ucyk7XHJcbiAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICB9O1xyXG5cclxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5VTlNFTlQgPSAwO1xyXG5cclxuICAgIFhNTEh0dHBSZXF1ZXN0LlVOU0VOVCA9IDA7XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLk9QRU5FRCA9IDE7XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QuT1BFTkVEID0gMTtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuSEVBREVSU19SRUNFSVZFRCA9IDI7XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QuSEVBREVSU19SRUNFSVZFRCA9IDI7XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLkxPQURJTkcgPSAzO1xyXG5cclxuICAgIFhNTEh0dHBSZXF1ZXN0LkxPQURJTkcgPSAzO1xyXG5cclxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5ET05FID0gNDtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5ET05FID0gNDtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUubm9kZWpzSHR0cEFnZW50ID0gaHR0cC5nbG9iYWxBZ2VudDtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUubm9kZWpzSHR0cHNBZ2VudCA9IGh0dHBzLmdsb2JhbEFnZW50O1xyXG5cclxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5ub2RlanNCYXNlVXJsID0gbnVsbDtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3Jlc3RyaWN0ZWRNZXRob2RzID0ge1xyXG4gICAgICBDT05ORUNUOiB0cnVlLFxyXG4gICAgICBUUkFDRTogdHJ1ZSxcclxuICAgICAgVFJBQ0s6IHRydWVcclxuICAgIH07XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9yZXN0cmljdGVkSGVhZGVycyA9IHtcclxuICAgICAgJ2FjY2VwdC1jaGFyc2V0JzogdHJ1ZSxcclxuICAgICAgJ2FjY2VwdC1lbmNvZGluZyc6IHRydWUsXHJcbiAgICAgICdhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnMnOiB0cnVlLFxyXG4gICAgICAnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2QnOiB0cnVlLFxyXG4gICAgICBjb25uZWN0aW9uOiB0cnVlLFxyXG4gICAgICAnY29udGVudC1sZW5ndGgnOiB0cnVlLFxyXG4gICAgICBjb29raWU6IHRydWUsXHJcbiAgICAgIGNvb2tpZTI6IHRydWUsXHJcbiAgICAgIGRhdGU6IHRydWUsXHJcbiAgICAgIGRudDogdHJ1ZSxcclxuICAgICAgZXhwZWN0OiB0cnVlLFxyXG4gICAgICBob3N0OiB0cnVlLFxyXG4gICAgICAna2VlcC1hbGl2ZSc6IHRydWUsXHJcbiAgICAgIG9yaWdpbjogdHJ1ZSxcclxuICAgICAgcmVmZXJlcjogdHJ1ZSxcclxuICAgICAgdGU6IHRydWUsXHJcbiAgICAgIHRyYWlsZXI6IHRydWUsXHJcbiAgICAgICd0cmFuc2Zlci1lbmNvZGluZyc6IHRydWUsXHJcbiAgICAgIHVwZ3JhZGU6IHRydWUsXHJcbiAgICAgICd1c2VyLWFnZW50JzogdHJ1ZSxcclxuICAgICAgdmlhOiB0cnVlXHJcbiAgICB9O1xyXG5cclxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fcHJpdmF0ZUhlYWRlcnMgPSB7XHJcbiAgICAgICdzZXQtY29va2llJzogdHJ1ZSxcclxuICAgICAgJ3NldC1jb29raWUyJzogdHJ1ZVxyXG4gICAgfTtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3VzZXJBZ2VudCA9IChcIk1vemlsbGEvNS4wIChcIiArIChvcy50eXBlKCkpICsgXCIgXCIgKyAob3MuYXJjaCgpKSArIFwiKSBcIikgKyAoXCJub2RlLmpzL1wiICsgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICsgXCIgdjgvXCIgKyBwcm9jZXNzLnZlcnNpb25zLnY4KTtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3NldFJlYWR5U3RhdGUgPSBmdW5jdGlvbihuZXdSZWFkeVN0YXRlKSB7XHJcbiAgICAgIHZhciBldmVudDtcclxuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gbmV3UmVhZHlTdGF0ZTtcclxuICAgICAgZXZlbnQgPSBuZXcgUHJvZ3Jlc3NFdmVudCgncmVhZHlzdGF0ZWNoYW5nZScpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3NlbmRGaWxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICh0aGlzLl91cmwubWV0aG9kICE9PSAnR0VUJykge1xyXG4gICAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoJ1RoZSBmaWxlIHByb3RvY29sIG9ubHkgc3VwcG9ydHMgR0VUJyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdG9jb2wgZmlsZTogbm90IGltcGxlbWVudGVkXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3NlbmRIdHRwID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICBpZiAodGhpcy5fc3luYykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bmNocm9ub3VzIFhIUiBwcm9jZXNzaW5nIG5vdCBpbXBsZW1lbnRlZFwiKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKGRhdGEgIT0gbnVsbCkgJiYgKHRoaXMuX21ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5fbWV0aG9kID09PSAnSEVBRCcpKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiRGlzY2FyZGluZyBlbnRpdHkgYm9keSBmb3IgXCIgKyB0aGlzLl9tZXRob2QgKyBcIiByZXF1ZXN0c1wiKTtcclxuICAgICAgICBkYXRhID0gbnVsbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkYXRhIHx8IChkYXRhID0gJycpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudXBsb2FkLl9zZXREYXRhKGRhdGEpO1xyXG4gICAgICB0aGlzLl9maW5hbGl6ZUhlYWRlcnMoKTtcclxuICAgICAgdGhpcy5fc2VuZEh4eHBSZXF1ZXN0KCk7XHJcbiAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICB9O1xyXG5cclxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fc2VuZEh4eHBSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBhZ2VudCwgaHh4cCwgcmVxdWVzdDtcclxuICAgICAgaWYgKHRoaXMuX3VybC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xyXG4gICAgICAgIGh4eHAgPSBodHRwO1xyXG4gICAgICAgIGFnZW50ID0gdGhpcy5ub2RlanNIdHRwQWdlbnQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaHh4cCA9IGh0dHBzO1xyXG4gICAgICAgIGFnZW50ID0gdGhpcy5ub2RlanNIdHRwc0FnZW50O1xyXG4gICAgICB9XHJcbiAgICAgIHJlcXVlc3QgPSBoeHhwLnJlcXVlc3Qoe1xyXG4gICAgICAgIGhvc3RuYW1lOiB0aGlzLl91cmwuaG9zdG5hbWUsXHJcbiAgICAgICAgcG9ydDogdGhpcy5fdXJsLnBvcnQsXHJcbiAgICAgICAgcGF0aDogdGhpcy5fdXJsLnBhdGgsXHJcbiAgICAgICAgYXV0aDogdGhpcy5fdXJsLmF1dGgsXHJcbiAgICAgICAgbWV0aG9kOiB0aGlzLl9tZXRob2QsXHJcbiAgICAgICAgaGVhZGVyczogdGhpcy5faGVhZGVycyxcclxuICAgICAgICBhZ2VudDogYWdlbnRcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0O1xyXG4gICAgICBpZiAodGhpcy50aW1lb3V0KSB7XHJcbiAgICAgICAgcmVxdWVzdC5zZXRUaW1lb3V0KHRoaXMudGltZW91dCwgKGZ1bmN0aW9uKF90aGlzKSB7XHJcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fb25IdHRwVGltZW91dChyZXF1ZXN0KTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSkodGhpcykpO1xyXG4gICAgICB9XHJcbiAgICAgIHJlcXVlc3Qub24oJ3Jlc3BvbnNlJywgKGZ1bmN0aW9uKF90aGlzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX29uSHR0cFJlc3BvbnNlKHJlcXVlc3QsIHJlc3BvbnNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9KSh0aGlzKSk7XHJcbiAgICAgIHJlcXVlc3Qub24oJ2Vycm9yJywgKGZ1bmN0aW9uKF90aGlzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX29uSHR0cFJlcXVlc3RFcnJvcihyZXF1ZXN0LCBlcnJvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgfSkodGhpcykpO1xyXG4gICAgICB0aGlzLnVwbG9hZC5fc3RhcnRVcGxvYWQocmVxdWVzdCk7XHJcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ID09PSByZXF1ZXN0KSB7XHJcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnbG9hZHN0YXJ0Jyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIH07XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9maW5hbGl6ZUhlYWRlcnMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5faGVhZGVyc1snQ29ubmVjdGlvbiddID0gJ2tlZXAtYWxpdmUnO1xyXG4gICAgICB0aGlzLl9oZWFkZXJzWydIb3N0J10gPSB0aGlzLl91cmwuaG9zdDtcclxuICAgICAgaWYgKHRoaXMuX2Fub255bW91cykge1xyXG4gICAgICAgIHRoaXMuX2hlYWRlcnNbJ1JlZmVyZXInXSA9ICdhYm91dDpibGFuayc7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5faGVhZGVyc1snVXNlci1BZ2VudCddID0gdGhpcy5fdXNlckFnZW50O1xyXG4gICAgICB0aGlzLnVwbG9hZC5fZmluYWxpemVIZWFkZXJzKHRoaXMuX2hlYWRlcnMsIHRoaXMuX2xvd2VyZWRIZWFkZXJzKTtcclxuICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIH07XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9vbkh0dHBSZXNwb25zZSA9IGZ1bmN0aW9uKHJlcXVlc3QsIHJlc3BvbnNlKSB7XHJcbiAgICAgIHZhciBsZW5ndGhTdHJpbmc7XHJcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ICE9PSByZXF1ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHN3aXRjaCAocmVzcG9uc2Uuc3RhdHVzQ29kZSkge1xyXG4gICAgICAgIGNhc2UgMzAxOlxyXG4gICAgICAgIGNhc2UgMzAyOlxyXG4gICAgICAgIGNhc2UgMzAzOlxyXG4gICAgICAgIGNhc2UgMzA3OlxyXG4gICAgICAgIGNhc2UgMzA4OlxyXG4gICAgICAgICAgdGhpcy5fdXJsID0gdGhpcy5fcGFyc2VVcmwocmVzcG9uc2UuaGVhZGVyc1snbG9jYXRpb24nXSk7XHJcbiAgICAgICAgICB0aGlzLl9tZXRob2QgPSAnR0VUJztcclxuICAgICAgICAgIGlmICgnY29udGVudC10eXBlJyBpbiB0aGlzLl9sb3dlcmVkSGVhZGVycykge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZGVyc1t0aGlzLl9sb3dlcmVkSGVhZGVyc1snY29udGVudC10eXBlJ11dO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbG93ZXJlZEhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCdDb250ZW50LVR5cGUnIGluIHRoaXMuX2hlYWRlcnMpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ107XHJcbiAgICAgICAgICB0aGlzLnVwbG9hZC5fcmVzZXQoKTtcclxuICAgICAgICAgIHRoaXMuX2ZpbmFsaXplSGVhZGVycygpO1xyXG4gICAgICAgICAgdGhpcy5fc2VuZEh4eHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fcmVzcG9uc2UgPSByZXNwb25zZTtcclxuICAgICAgdGhpcy5fcmVzcG9uc2Uub24oJ2RhdGEnLCAoZnVuY3Rpb24oX3RoaXMpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9vbkh0dHBSZXNwb25zZURhdGEocmVzcG9uc2UsIGRhdGEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH0pKHRoaXMpKTtcclxuICAgICAgdGhpcy5fcmVzcG9uc2Uub24oJ2VuZCcsIChmdW5jdGlvbihfdGhpcykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiBfdGhpcy5fb25IdHRwUmVzcG9uc2VFbmQocmVzcG9uc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH0pKHRoaXMpKTtcclxuICAgICAgdGhpcy5fcmVzcG9uc2Uub24oJ2Nsb3NlJywgKGZ1bmN0aW9uKF90aGlzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9vbkh0dHBSZXNwb25zZUNsb3NlKHJlc3BvbnNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9KSh0aGlzKSk7XHJcbiAgICAgIHRoaXMucmVzcG9uc2VVUkwgPSB0aGlzLl91cmwuaHJlZi5zcGxpdCgnIycpWzBdO1xyXG4gICAgICB0aGlzLnN0YXR1cyA9IHRoaXMuX3Jlc3BvbnNlLnN0YXR1c0NvZGU7XHJcbiAgICAgIHRoaXMuc3RhdHVzVGV4dCA9IGh0dHAuU1RBVFVTX0NPREVTW3RoaXMuc3RhdHVzXTtcclxuICAgICAgdGhpcy5fcGFyc2VSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xyXG4gICAgICBpZiAobGVuZ3RoU3RyaW5nID0gdGhpcy5fcmVzcG9uc2VIZWFkZXJzWydjb250ZW50LWxlbmd0aCddKSB7XHJcbiAgICAgICAgdGhpcy5fdG90YWxCeXRlcyA9IHBhcnNlSW50KGxlbmd0aFN0cmluZyk7XHJcbiAgICAgICAgdGhpcy5fbGVuZ3RoQ29tcHV0YWJsZSA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fbGVuZ3RoQ29tcHV0YWJsZSA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLl9zZXRSZWFkeVN0YXRlKFhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX29uSHR0cFJlc3BvbnNlRGF0YSA9IGZ1bmN0aW9uKHJlc3BvbnNlLCBkYXRhKSB7XHJcbiAgICAgIGlmICh0aGlzLl9yZXNwb25zZSAhPT0gcmVzcG9uc2UpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fcmVzcG9uc2VQYXJ0cy5wdXNoKGRhdGEpO1xyXG4gICAgICB0aGlzLl9sb2FkZWRCeXRlcyArPSBkYXRhLmxlbmd0aDtcclxuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuTE9BRElORykge1xyXG4gICAgICAgIHRoaXMuX3NldFJlYWR5U3RhdGUoWE1MSHR0cFJlcXVlc3QuTE9BRElORyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ3Byb2dyZXNzJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fb25IdHRwUmVzcG9uc2VFbmQgPSBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICBpZiAodGhpcy5fcmVzcG9uc2UgIT09IHJlc3BvbnNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX3BhcnNlUmVzcG9uc2UoKTtcclxuICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XHJcbiAgICAgIHRoaXMuX3Jlc3BvbnNlID0gbnVsbDtcclxuICAgICAgdGhpcy5fc2V0UmVhZHlTdGF0ZShYTUxIdHRwUmVxdWVzdC5ET05FKTtcclxuICAgICAgdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnbG9hZCcpO1xyXG4gICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnbG9hZGVuZCcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX29uSHR0cFJlc3BvbnNlQ2xvc2UgPSBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICB2YXIgcmVxdWVzdDtcclxuICAgICAgaWYgKHRoaXMuX3Jlc3BvbnNlICE9PSByZXNwb25zZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICByZXF1ZXN0ID0gdGhpcy5fcmVxdWVzdDtcclxuICAgICAgdGhpcy5fc2V0RXJyb3IoKTtcclxuICAgICAgcmVxdWVzdC5hYm9ydCgpO1xyXG4gICAgICB0aGlzLl9zZXRSZWFkeVN0YXRlKFhNTEh0dHBSZXF1ZXN0LkRPTkUpO1xyXG4gICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdlcnJvcicpO1xyXG4gICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnbG9hZGVuZCcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX29uSHR0cFRpbWVvdXQgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XHJcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ICE9PSByZXF1ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX3NldEVycm9yKCk7XHJcbiAgICAgIHJlcXVlc3QuYWJvcnQoKTtcclxuICAgICAgdGhpcy5fc2V0UmVhZHlTdGF0ZShYTUxIdHRwUmVxdWVzdC5ET05FKTtcclxuICAgICAgdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygndGltZW91dCcpO1xyXG4gICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnbG9hZGVuZCcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX29uSHR0cFJlcXVlc3RFcnJvciA9IGZ1bmN0aW9uKHJlcXVlc3QsIGVycm9yKSB7XHJcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ICE9PSByZXF1ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX3NldEVycm9yKCk7XHJcbiAgICAgIHJlcXVlc3QuYWJvcnQoKTtcclxuICAgICAgdGhpcy5fc2V0UmVhZHlTdGF0ZShYTUxIdHRwUmVxdWVzdC5ET05FKTtcclxuICAgICAgdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnZXJyb3InKTtcclxuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2xvYWRlbmQnKTtcclxuICAgIH07XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9kaXNwYXRjaFByb2dyZXNzID0gZnVuY3Rpb24oZXZlbnRUeXBlKSB7XHJcbiAgICAgIHZhciBldmVudDtcclxuICAgICAgZXZlbnQgPSBuZXcgUHJvZ3Jlc3NFdmVudChldmVudFR5cGUpO1xyXG4gICAgICBldmVudC5sZW5ndGhDb21wdXRhYmxlID0gdGhpcy5fbGVuZ3RoQ29tcHV0YWJsZTtcclxuICAgICAgZXZlbnQubG9hZGVkID0gdGhpcy5fbG9hZGVkQnl0ZXM7XHJcbiAgICAgIGV2ZW50LnRvdGFsID0gdGhpcy5fdG90YWxCeXRlcztcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIH07XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9zZXRFcnJvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcclxuICAgICAgdGhpcy5fcmVzcG9uc2UgPSBudWxsO1xyXG4gICAgICB0aGlzLl9yZXNwb25zZUhlYWRlcnMgPSBudWxsO1xyXG4gICAgICB0aGlzLl9yZXNwb25zZVBhcnRzID0gbnVsbDtcclxuICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIH07XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9wYXJzZVVybCA9IGZ1bmN0aW9uKHVybFN0cmluZykge1xyXG4gICAgICB2YXIgYWJzb2x1dGVVcmxTdHJpbmcsIGluZGV4LCBwYXNzd29yZCwgdXNlciwgeGhyVXJsO1xyXG4gICAgICBpZiAodGhpcy5ub2RlanNCYXNlVXJsID09PSBudWxsKSB7XHJcbiAgICAgICAgYWJzb2x1dGVVcmxTdHJpbmcgPSB1cmxTdHJpbmc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWJzb2x1dGVVcmxTdHJpbmcgPSB1cmwucmVzb2x2ZSh0aGlzLm5vZGVqc0Jhc2VVcmwsIHVybFN0cmluZyk7XHJcbiAgICAgIH1cclxuICAgICAgeGhyVXJsID0gdXJsLnBhcnNlKGFic29sdXRlVXJsU3RyaW5nLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgIHhoclVybC5oYXNoID0gbnVsbDtcclxuICAgICAgaWYgKHhoclVybC5hdXRoICYmICgodHlwZW9mIHVzZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdXNlciAhPT0gbnVsbCkgfHwgKHR5cGVvZiBwYXNzd29yZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwYXNzd29yZCAhPT0gbnVsbCkpKSB7XHJcbiAgICAgICAgaW5kZXggPSB4aHJVcmwuYXV0aC5pbmRleE9mKCc6Jyk7XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgaWYgKCF1c2VyKSB7XHJcbiAgICAgICAgICAgIHVzZXIgPSB4aHJVcmwuYXV0aDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCF1c2VyKSB7XHJcbiAgICAgICAgICAgIHVzZXIgPSB4aHJVcmwuc3Vic3RyaW5nKDAsIGluZGV4KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghcGFzc3dvcmQpIHtcclxuICAgICAgICAgICAgcGFzc3dvcmQgPSB4aHJVcmwuc3Vic3RyaW5nKGluZGV4ICsgMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICh1c2VyIHx8IHBhc3N3b3JkKSB7XHJcbiAgICAgICAgeGhyVXJsLmF1dGggPSB1c2VyICsgXCI6XCIgKyBwYXNzd29yZDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4geGhyVXJsO1xyXG4gICAgfTtcclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3BhcnNlUmVzcG9uc2VIZWFkZXJzID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgdmFyIGxvd2VyZWROYW1lLCBuYW1lLCByZWYsIHZhbHVlO1xyXG4gICAgICB0aGlzLl9yZXNwb25zZUhlYWRlcnMgPSB7fTtcclxuICAgICAgcmVmID0gcmVzcG9uc2UuaGVhZGVycztcclxuICAgICAgZm9yIChuYW1lIGluIHJlZikge1xyXG4gICAgICAgIHZhbHVlID0gcmVmW25hbWVdO1xyXG4gICAgICAgIGxvd2VyZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlSGVhZGVyc1tsb3dlcmVkTmFtZV0pIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fbWltZU92ZXJyaWRlICE9PSBudWxsICYmIGxvd2VyZWROYW1lID09PSAnY29udGVudC10eXBlJykge1xyXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl9taW1lT3ZlcnJpZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlSGVhZGVyc1tsb3dlcmVkTmFtZV0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5fbWltZU92ZXJyaWRlICE9PSBudWxsICYmICEoJ2NvbnRlbnQtdHlwZScgaW4gdGhpcy5fcmVzcG9uc2VIZWFkZXJzKSkge1xyXG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlSGVhZGVyc1snY29udGVudC10eXBlJ10gPSB0aGlzLl9taW1lT3ZlcnJpZGU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIH07XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9wYXJzZVJlc3BvbnNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBhcnJheUJ1ZmZlciwgYnVmZmVyLCBpLCBqLCBqc29uRXJyb3IsIHJlZiwgdmlldztcclxuICAgICAgaWYgKEJ1ZmZlci5jb25jYXQpIHtcclxuICAgICAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KHRoaXMuX3Jlc3BvbnNlUGFydHMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJ1ZmZlciA9IHRoaXMuX2NvbmNhdEJ1ZmZlcnModGhpcy5fcmVzcG9uc2VQYXJ0cyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fcmVzcG9uc2VQYXJ0cyA9IG51bGw7XHJcbiAgICAgIHN3aXRjaCAodGhpcy5yZXNwb25zZVR5cGUpIHtcclxuICAgICAgICBjYXNlICd0ZXh0JzpcclxuICAgICAgICAgIHRoaXMuX3BhcnNlVGV4dFJlc3BvbnNlKGJ1ZmZlcik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdqc29uJzpcclxuICAgICAgICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gbnVsbDtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBKU09OLnBhcnNlKGJ1ZmZlci50b1N0cmluZygndXRmLTgnKSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcjEpIHtcclxuICAgICAgICAgICAganNvbkVycm9yID0gZXJyb3IxO1xyXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gbnVsbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2J1ZmZlcic6XHJcbiAgICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IG51bGw7XHJcbiAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gYnVmZmVyO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnYXJyYXlidWZmZXInOlxyXG4gICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSBudWxsO1xyXG4gICAgICAgICAgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmxlbmd0aCk7XHJcbiAgICAgICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xyXG4gICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGJ1ZmZlci5sZW5ndGg7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xyXG4gICAgICAgICAgICB2aWV3W2ldID0gYnVmZmVyW2ldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5yZXNwb25zZSA9IGFycmF5QnVmZmVyO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRoaXMuX3BhcnNlVGV4dFJlc3BvbnNlKGJ1ZmZlcik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIH07XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9wYXJzZVRleHRSZXNwb25zZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xyXG4gICAgICB2YXIgZTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IGJ1ZmZlci50b1N0cmluZyh0aGlzLl9wYXJzZVJlc3BvbnNlRW5jb2RpbmcoKSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yMSkge1xyXG4gICAgICAgIGUgPSBlcnJvcjE7XHJcbiAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSBidWZmZXIudG9TdHJpbmcoJ2JpbmFyeScpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucmVzcG9uc2UgPSB0aGlzLnJlc3BvbnNlVGV4dDtcclxuICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIH07XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9wYXJzZVJlc3BvbnNlRW5jb2RpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGNvbnRlbnRUeXBlLCBlbmNvZGluZywgbWF0Y2g7XHJcbiAgICAgIGVuY29kaW5nID0gbnVsbDtcclxuICAgICAgaWYgKGNvbnRlbnRUeXBlID0gdGhpcy5fcmVzcG9uc2VIZWFkZXJzWydjb250ZW50LXR5cGUnXSkge1xyXG4gICAgICAgIGlmIChtYXRjaCA9IC9cXDtcXHMqY2hhcnNldFxcPSguKikkLy5leGVjKGNvbnRlbnRUeXBlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIG1hdGNoWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gJ3V0Zi04JztcclxuICAgIH07XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9jb25jYXRCdWZmZXJzID0gZnVuY3Rpb24oYnVmZmVycykge1xyXG4gICAgICB2YXIgYnVmZmVyLCBqLCBrLCBsZW4sIGxlbjEsIGxlbmd0aCwgdGFyZ2V0O1xyXG4gICAgICBpZiAoYnVmZmVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYnVmZmVycy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gYnVmZmVyc1swXTtcclxuICAgICAgfVxyXG4gICAgICBsZW5ndGggPSAwO1xyXG4gICAgICBmb3IgKGogPSAwLCBsZW4gPSBidWZmZXJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XHJcbiAgICAgICAgYnVmZmVyID0gYnVmZmVyc1tqXTtcclxuICAgICAgICBsZW5ndGggKz0gYnVmZmVyLmxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgICB0YXJnZXQgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XHJcbiAgICAgIGxlbmd0aCA9IDA7XHJcbiAgICAgIGZvciAoayA9IDAsIGxlbjEgPSBidWZmZXJzLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xyXG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlcnNba107XHJcbiAgICAgICAgYnVmZmVyLmNvcHkodGFyZ2V0LCBsZW5ndGgpO1xyXG4gICAgICAgIGxlbmd0aCArPSBidWZmZXIubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBYTUxIdHRwUmVxdWVzdDtcclxuXHJcbiAgfSkoWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCk7XHJcblxyXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MSHR0cFJlcXVlc3Q7XHJcblxyXG4gIFhNTEh0dHBSZXF1ZXN0LlhNTEh0dHBSZXF1ZXN0ID0gWE1MSHR0cFJlcXVlc3Q7XHJcblxyXG4gIFNlY3VyaXR5RXJyb3IgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xyXG4gICAgZXh0ZW5kKFNlY3VyaXR5RXJyb3IsIHN1cGVyQ2xhc3MpO1xyXG5cclxuICAgIGZ1bmN0aW9uIFNlY3VyaXR5RXJyb3IoKSB7XHJcbiAgICAgIFNlY3VyaXR5RXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFNlY3VyaXR5RXJyb3I7XHJcblxyXG4gIH0pKEVycm9yKTtcclxuXHJcbiAgWE1MSHR0cFJlcXVlc3QuU2VjdXJpdHlFcnJvciA9IFNlY3VyaXR5RXJyb3I7XHJcblxyXG4gIEludmFsaWRTdGF0ZUVycm9yID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcclxuICAgIGV4dGVuZChJbnZhbGlkU3RhdGVFcnJvciwgc3VwZXJDbGFzcyk7XHJcblxyXG4gICAgZnVuY3Rpb24gSW52YWxpZFN0YXRlRXJyb3IoKSB7XHJcbiAgICAgIEludmFsaWRTdGF0ZUVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBJbnZhbGlkU3RhdGVFcnJvcjtcclxuXHJcbiAgfSkoRXJyb3IpO1xyXG5cclxuICBJbnZhbGlkU3RhdGVFcnJvciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XHJcbiAgICBleHRlbmQoSW52YWxpZFN0YXRlRXJyb3IsIHN1cGVyQ2xhc3MpO1xyXG5cclxuICAgIGZ1bmN0aW9uIEludmFsaWRTdGF0ZUVycm9yKCkge1xyXG4gICAgICByZXR1cm4gSW52YWxpZFN0YXRlRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEludmFsaWRTdGF0ZUVycm9yO1xyXG5cclxuICB9KShFcnJvcik7XHJcblxyXG4gIFhNTEh0dHBSZXF1ZXN0LkludmFsaWRTdGF0ZUVycm9yID0gSW52YWxpZFN0YXRlRXJyb3I7XHJcblxyXG4gIE5ldHdvcmtFcnJvciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XHJcbiAgICBleHRlbmQoTmV0d29ya0Vycm9yLCBzdXBlckNsYXNzKTtcclxuXHJcbiAgICBmdW5jdGlvbiBOZXR3b3JrRXJyb3IoKSB7XHJcbiAgICAgIE5ldHdvcmtFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTmV0d29ya0Vycm9yO1xyXG5cclxuICB9KShFcnJvcik7XHJcblxyXG4gIFhNTEh0dHBSZXF1ZXN0LlN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XHJcblxyXG4gIFN5bnRheEVycm9yID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcclxuICAgIGV4dGVuZChTeW50YXhFcnJvciwgc3VwZXJDbGFzcyk7XHJcblxyXG4gICAgZnVuY3Rpb24gU3ludGF4RXJyb3IoKSB7XHJcbiAgICAgIFN5bnRheEVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBTeW50YXhFcnJvcjtcclxuXHJcbiAgfSkoRXJyb3IpO1xyXG5cclxuICBQcm9ncmVzc0V2ZW50ID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgZnVuY3Rpb24gUHJvZ3Jlc3NFdmVudCh0eXBlKSB7XHJcbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcclxuICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcclxuICAgICAgdGhpcy5sZW5ndGhDb21wdXRhYmxlID0gZmFsc2U7XHJcbiAgICAgIHRoaXMubG9hZGVkID0gMDtcclxuICAgICAgdGhpcy50b3RhbCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgUHJvZ3Jlc3NFdmVudC5wcm90b3R5cGUuYnViYmxlcyA9IGZhbHNlO1xyXG5cclxuICAgIFByb2dyZXNzRXZlbnQucHJvdG90eXBlLmNhbmNlbGFibGUgPSBmYWxzZTtcclxuXHJcbiAgICBQcm9ncmVzc0V2ZW50LnByb3RvdHlwZS50YXJnZXQgPSBudWxsO1xyXG5cclxuICAgIFByb2dyZXNzRXZlbnQucHJvdG90eXBlLmxvYWRlZCA9IG51bGw7XHJcblxyXG4gICAgUHJvZ3Jlc3NFdmVudC5wcm90b3R5cGUubGVuZ3RoQ29tcHV0YWJsZSA9IG51bGw7XHJcblxyXG4gICAgUHJvZ3Jlc3NFdmVudC5wcm90b3R5cGUudG90YWwgPSBudWxsO1xyXG5cclxuICAgIHJldHVybiBQcm9ncmVzc0V2ZW50O1xyXG5cclxuICB9KSgpO1xyXG5cclxuICBYTUxIdHRwUmVxdWVzdC5Qcm9ncmVzc0V2ZW50ID0gUHJvZ3Jlc3NFdmVudDtcclxuXHJcbiAgWE1MSHR0cFJlcXVlc3RVcGxvYWQgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xyXG4gICAgZXh0ZW5kKFhNTEh0dHBSZXF1ZXN0VXBsb2FkLCBzdXBlckNsYXNzKTtcclxuXHJcbiAgICBmdW5jdGlvbiBYTUxIdHRwUmVxdWVzdFVwbG9hZChyZXF1ZXN0KSB7XHJcbiAgICAgIFhNTEh0dHBSZXF1ZXN0VXBsb2FkLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xyXG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdDtcclxuICAgICAgdGhpcy5fcmVzZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBYTUxIdHRwUmVxdWVzdFVwbG9hZC5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuX2NvbnRlbnRUeXBlID0gbnVsbDtcclxuICAgICAgdGhpcy5fYm9keSA9IG51bGw7XHJcbiAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICB9O1xyXG5cclxuICAgIFhNTEh0dHBSZXF1ZXN0VXBsb2FkLnByb3RvdHlwZS5fc2V0RGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgdmFyIGJvZHksIGksIGosIGssIG9mZnNldCwgcmVmLCByZWYxLCB2aWV3O1xyXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnIHx8IGRhdGEgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgdGhpcy5fY29udGVudFR5cGUgPSAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYm9keSA9IG5ldyBCdWZmZXIoZGF0YSwgJ3V0ZjgnKTtcclxuICAgICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcclxuICAgICAgICB0aGlzLl9ib2R5ID0gZGF0YTtcclxuICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICBib2R5ID0gbmV3IEJ1ZmZlcihkYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheShkYXRhKTtcclxuICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gZGF0YS5ieXRlTGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcclxuICAgICAgICAgIGJvZHlbaV0gPSB2aWV3W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ib2R5ID0gYm9keTtcclxuICAgICAgfSBlbHNlIGlmIChkYXRhLmJ1ZmZlciAmJiBkYXRhLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgYm9keSA9IG5ldyBCdWZmZXIoZGF0YS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICBvZmZzZXQgPSBkYXRhLmJ5dGVPZmZzZXQ7XHJcbiAgICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyKTtcclxuICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmMSA9IGRhdGEuYnl0ZUxlbmd0aDsgMCA8PSByZWYxID8gayA8IHJlZjEgOiBrID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsrayA6IC0taykge1xyXG4gICAgICAgICAgYm9keVtpXSA9IHZpZXdbaSArIG9mZnNldF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2JvZHkgPSBib2R5O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHNlbmQoKSBkYXRhIFwiICsgZGF0YSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIH07XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3RVcGxvYWQucHJvdG90eXBlLl9maW5hbGl6ZUhlYWRlcnMgPSBmdW5jdGlvbihoZWFkZXJzLCBsb3dlcmVkSGVhZGVycykge1xyXG4gICAgICBpZiAodGhpcy5fY29udGVudFR5cGUpIHtcclxuICAgICAgICBpZiAoISgnY29udGVudC10eXBlJyBpbiBsb3dlcmVkSGVhZGVycykpIHtcclxuICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdGhpcy5fY29udGVudFR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLl9ib2R5KSB7XHJcbiAgICAgICAgaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9IHRoaXMuX2JvZHkubGVuZ3RoLnRvU3RyaW5nKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIH07XHJcblxyXG4gICAgWE1MSHR0cFJlcXVlc3RVcGxvYWQucHJvdG90eXBlLl9zdGFydFVwbG9hZCA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcclxuICAgICAgaWYgKHRoaXMuX2JvZHkpIHtcclxuICAgICAgICByZXF1ZXN0LndyaXRlKHRoaXMuX2JvZHkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJlcXVlc3QuZW5kKCk7XHJcbiAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBYTUxIdHRwUmVxdWVzdFVwbG9hZDtcclxuXHJcbiAgfSkoWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCk7XHJcblxyXG4gIFhNTEh0dHBSZXF1ZXN0LlhNTEh0dHBSZXF1ZXN0VXBsb2FkID0gWE1MSHR0cFJlcXVlc3RVcGxvYWQ7XHJcblxyXG59KS5jYWxsKHRoaXMpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34veGhyMi9saWIveGhyMi5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoMjQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9mb3Jtcy9idW5kbGVzL2Zvcm1zLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL1N1YmplY3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg0NCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL2J1bmRsZXMvY29tcGlsZXIudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygwKSkoNTYpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2ZpbHRlci5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDc0KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvbWF0ZXJpYWwvYnVuZGxlcy9tYXRlcmlhbC51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg3NSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy9idW5kbGVzL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg3Nik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3JvdXRlci9idW5kbGVzL3JvdXRlci51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg5Mik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9idW5kbGVzL2NvbW1vbi1odHRwLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJodHRwXCJcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiaHR0cHNcIlxuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwib3NcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJvc1wiXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9